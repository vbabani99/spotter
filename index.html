
<!--
vics_Smart_Spotter_v0.3.28 - Vic Skin PRO (volumen, sombras, bordes 3D) -
v0.3.05: FIX TTS en primer plano (A+B) - start-guard menos agresivo (3.5s), auto-recupera sin pedir tap si ya se desbloqueo, reset de fallos al iniciar voz.
Fecha: 2026-01-31
Origen: Spotter_5.0.1.html

Changelog:
- v0.3.28: Q TABLA - Best Lap arreglado (usa valor del feed, fix segundos vs ms) + color/contraste en tabla.
- v0.3.27: Manual rehecho (Q TABLA: Mejor por piloto / Por Q + tips iPhone/PC + troubleshooting).
- v0.0.2.21: Q TABLA (FIX guardado) (clasificacin) - mejor resultado por piloto (best-per-pilot) guardado por da/evento. UI only.
- v0.0.2.23: Fix UX: VOZ responde al primer toque (iOS/Android), debounced LIVE (sin parpadeo), header altura estable (sin salto). UI/TTS only.
- v0.0.2.17: LapChart watermark restaurada (logo Vic) en fondo del canvas. UI only.
- v0.0.1.99: Logo header ajustado -5% (reduce height de 88px a 84px) manteniendo 'cover' para recorte del aire.
- v0.0.1.91: Limpieza editorial de textos del locutor (acentos y palabras recortadas) en RD_PHRASES y AUTO_PHRASES_PRO. Solo texto/UI.
- v0.0.1.87: TTS PRO (ms -> segundos/dcimas/centsimas/milsimas; +V como 'ms una vuelta'; correccin de recortes en normalizador).
- v0.0.1.79: LIVE como radio-button (solo punto verde) + MODO legible sin recortes y con color por estado.
- v0.0.1.86: Fix TTS (P# en espaol, +V como 'ms 1 vuelta', tildes, HobbyShop México, Italia, Messina).
- v0.0.1.38: Auto Locutor lifecycle: actividad robusta (tiempo sube o baja) + debug strip (solo ?debug=1).
- v0.0.1.02: Fix iPhone/pequenas pantallas - header responsivo (sin recortes) + safe-area top + logo always-fit.
- v0.0.1.08: Fix ReferenceError (miniGridExpanded/miniGridLimit + voiceToggleBtns). Mantiene Top grid expanded como rows estilo scoreboard con INT vs anterior.
- v0.0.1.11: Pulido Top20 expanded (rows): columnas mas compactas, mejor alineacion y truncado, INT mas legible.
- v0.0.1.10: Lap Chart meta (chips P1/P2/P3) ancho fijo 390px con scroll horizontal.
- v0.0.1.00: controls-section reducido 50% (tipografia/padding/botones) y oculto por defecto (solo visible en modo debug).
- v0.0.0.99: extras-section reducido 33% (zoom 0.67) para compactar controles.
- v0.0.0.98: Header-right a 200x123 px (centrado interno preservado).
- v0.0.0.97: Header-right centrado (logo, acciones y version) + header-version centrada (100% width).
- v0.0.0.92: UI header - fija header-left y header-right a 224x123 px (bloques simetricos).
- v0.0.0.94: Badge LIVE igualado a botones del header-actions-row (misma altura/tamano), texto corto OFF/LIVE, alineado.
- v0.0.0.89: UI header - reduce tamano de botones en header-actions-row (sin cambiar layout base v0.0.0.82) + raceTitleText contenedor 240x56 + raceSubtitle hasta 50px (2 lineas).
- v0.0.0.36: Fix TTS palabra 'Clasificacion' (sin acento en voz) en anuncio de carrera nueva.
- v0.0.0.37: Fix selector de piloto consistente (dark forms + no update mientras seleccionas) y mejora anti-parpadeo iOS/Android/Chrome/Safari.
- v0.0.0.38: Anuncio de carrera nueva: formato TTS "Clasificacion - Qx - Manga X - Serie X" y anuncios de Finales por A/B/C con frases PRO/divertidas.
- v0.0.0.39: Fix anuncio de carrera nueva (reintentos si falla TTS, sin bloquear 10 min por error) y estabilidad al reenviar mismo raceName.
- v0.0.0.42: Parsing de titulo de MANGA/Clasificacion desde raceName tipo "Q1.Manga B - Serie 1" => TTS "Clasificacion, Q1, Manga, B, Serie 1".
- v0.0.0.44: UI - oculta botones RD Sarca/Engineer/Hype (algoritmo decide en background).
- v0.0.0.49: UI header - mueve LiveIndicator al renglon de abajo junto a MANUAL, y appVersion al renglon inferior.
- v0.0.0.50: UI header - aumenta header-logo 50% (alto y max-width).
- v0.0.0.51: UI header - baja botones + version para alinear (logo arriba, acciones abajo).
- v0.0.0.57: UI header - aumenta header-logo 15% adicional.
- v0.0.0.58: Nuevo tema "Vic's Pulse" basado en colores del logo (rojo/blanco/negro), acentos y header ajustados.
- v0.0.0.71: Fix raceTitleText (wrap pro: evita guion al inicio de linea y evita el "1" huerfano).
- v0.0.0.72: raceTitleText 33% mas chico (evita cortes en header).
- v0.0.0.79: Bandera en raceTitleText (fix emoji font) + raceTitleText +2px.
- v0.0.0.79: Paquete de temas T1-T8 (orden A: VIC, CARB, BLUE, LIME, PURP, AMBR, ICE, OLED).
- v0.0.0.80: Detalles premium: header "vivo" solo en Live (breath + led sweep) y linea sutil tipo LED bajo botones.

- v0.0.0.59: Guard rails TTS: si falta dato (nombre/gap/tiempo), el spotter se calla (evita "undefined" y frases incompletas).
- v0.0.0.60: Auto Locutor: reintenta 1 vez (re-roll) si una frase queda incompleta; si el segundo intento falla, se calla.
- v0.0.0.62: Bandera azul: menciona nombre del lapeador en P1/P2/P3 (seguimiento y auto locutor).
- v7.5: Fix Auto Locutor: ya no depende de RD, usa POS para top3/peleas por defecto, umbral ajustado para evitar silencio, y no resetea tus voiceSettings.
- v7.4: Auto Locutor PRO narrativo: seguimiento de pelea (focus) con contexto, tendencia de gap, y modo MANGA mejorado (pole/best lap) con menos 'robot'.
- v7.3: Locutor mejorado: frases tipo shuffle-bag (anti repeticin real), manga batalla con nombres+gaps, y micro-variacin en Auto Locutor.
- v7.2: UI piloto + voz: pilotSelect 2x, color por posición, gapInfo blanco grande, extras ms compacto, y clon mini de botn de voz junto al piloto.
- v7.1: TTS (Web Speech API) reforzado: selector de voz visible, botn de prueba, carga de voces con reintentos, y respeto a la voz elegida en la cola.
- v7.0: Nuevo toggle "Modo background" (no pausa al quedar oculta la pestaña/ventana) + reenganche al volver (visibilitychange) + wake lock se reintenta al regresar.
Nota: En iPhone/iOS, el sistema puede pausar TTS cuando la app se va a background real (pantalla apagada o cambiar de app). En Windows/Chrome, si la ventana queda tapada, a veces hay throttling del navegador.-->

<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>vics_Smart_Spotter_v0.3.28</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  












<style id="appStyles">


/* ============================================================
   CONSOLIDATED CSS (v0.3.05)
   - Original style blocks merged in source order (no behavior change intended).
   ============================================================ */

html{ color-scheme: dark; -webkit-text-size-adjust: 100%; }
    body{ color-scheme: dark; }

    :root{
      --bg-dark: #040406;
      --card-dark: #080a0f;
      --card-dark-2: #05070c;
      --text-main: #f2f5ff;
      --text-muted: #a3adbd;

      --accent-red: #ff2b2b;
      --accent-red-soft: rgba(255,43,43,0.55);

      --accent-orange: #ff3b3b;
      --accent-orange-soft: rgba(255,59,59,0.55);

      --accent-blue: #cbd5e1;
      --accent-blue-soft: rgba(203,213,225,0.18);

      --accent-cyan: #ff2b2b;
      --border-soft: rgba(148,163,184,0.38);

      --radius-lg: 16px;
      --radius-pill: 999px;

      --shadow-strong: 0 0 18px rgba(255,43,43,0.46);
      --shadow-soft: 0 0 12px rgba(255,255,255,0.08);
      /* Header (app-header) theme */
      --hdr-grad-a: rgba(255,43,43,0.18);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #0b1220;
      --hdr-stripe-b: #05070d;
      --hdr-border: rgba(255,43,43,0.28);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(255,43,43,0.16);

      /* Badge MODO theme (auto por sesin) */
      --mode-bg-neutral: rgba(0,0,0,0.25);
      --mode-brd-neutral: rgba(255,255,255,0.14);
      --mode-bg-manga: linear-gradient(135deg, rgba(255,60,60,.86), rgba(120,0,0,.70));
      --mode-bg-final: linear-gradient(135deg, rgba(255,60,60,.95), rgba(255,255,255,.12));
      --mode-bg-finalA: linear-gradient(135deg, rgba(255,215,0,.96), rgba(255,140,0,.80));

    }

    /* === SKIN: Vic's Pulse Timing (logo palette) === */
    body.skin-vicpulse{
      /* Oscuros (carbon) */
      --bg-dark: #060507;
      --card-dark: #0b090c;
      --card-dark-2: #07060a;
      /* Texto (blanco suave del logo) */
      --text-main: #EAEAEC;
      --text-muted: #C7B3B3;

      /* Acentos (rojo + rojo secundario del logo) */
      --accent-red: #DD1413;
      --accent-red-soft: rgba(221,20,19,0.55);
      --accent-orange: #C14A46;
      --accent-orange-soft: rgba(193,74,70,0.45);

      /* Highlights neutrales */
      --accent-blue: #EAEAEC;
      --accent-blue-soft: rgba(234,234,236,0.18);
      --accent-cyan: #EAEAEC;
      --border-soft: rgba(234,234,236,0.28);

      /* Glow rojo (Pulse) */
      --shadow-strong: 0 0 18px rgba(221,20,19,0.46);
      --shadow-soft: 0 0 12px rgba(234,234,236,0.08);

      /* Header theme */
      --hdr-grad-a: rgba(221,20,19,0.22);
      --hdr-grad-b: rgba(234,234,236,0.06);
      --hdr-stripe-a: #120d10;
      --hdr-stripe-b: #07060a;
      --hdr-border: rgba(221,20,19,0.32);
      --hdr-border-2: rgba(234,234,236,0.10);
      --hdr-glow: 0 0 18px rgba(221,20,19,0.18);

      /* Badge MODO theme */
      --mode-bg-manga: linear-gradient(135deg, rgba(221,20,19,.86), rgba(90,26,31,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(221,20,19,.95), rgba(234,234,236,.10));
      /* finalA se queda dorado (bandera de campeón) */
    }

    

    /* === THEME PACK (T1-T8) - orden A === */
    /* Nota: todos los temas usan el mismo "Skin PRO" (volumen, sombras, bordes 3D) via .skin-pro */

    /* T2 - Carbon Redline */
    body.skin-carbon{
      --accent-rgb: 255, 45, 45;
      --accent2-rgb: 255, 255, 255;
      --bg-dark: #050506;
      --card-dark: #0a0b0f;
      --card-dark-2: #07080c;
      --text-main: #f4f6fb;
      --text-muted: rgba(244,246,251,0.72);
      --accent-red: #ff2d2d;
      --accent-red-soft: rgba(255,45,45,0.52);
      --accent-orange: #ffffff;
      --accent-orange-soft: rgba(255,255,255,0.18);
      --accent-blue: #d6dde8;
      --accent-blue-soft: rgba(214,221,232,0.18);
      --border-soft: rgba(244,246,251,0.16);
      --hdr-grad-a: rgba(255,45,45,0.22);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #0f0f12;
      --hdr-stripe-b: #07070b;
      --hdr-border: rgba(255,45,45,0.30);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(255,45,45,0.18);
      --mode-bg-manga: linear-gradient(135deg, rgba(255,45,45,.88), rgba(80,0,0,.74));
      --mode-bg-final: linear-gradient(135deg, rgba(255,45,45,.95), rgba(255,255,255,.10));
    }

    /* T3 - Stealth Blue */
    body.skin-blue{
      --accent-rgb: 47, 140, 255;
      --accent2-rgb: 140, 215, 255;
      --bg-dark: #05070e;
      --card-dark: #0a1020;
      --card-dark-2: #070c18;
      --text-main: #eef6ff;
      --text-muted: rgba(238,246,255,0.70);
      --accent-red: #2f8cff;
      --accent-red-soft: rgba(47,140,255,0.50);
      --accent-orange: #8cd7ff;
      --accent-orange-soft: rgba(140,215,255,0.22);
      --accent-blue: #d6e7ff;
      --accent-blue-soft: rgba(214,231,255,0.18);
      --border-soft: rgba(238,246,255,0.16);
      --hdr-grad-a: rgba(47,140,255,0.22);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #0b1428;
      --hdr-stripe-b: #070c18;
      --hdr-border: rgba(47,140,255,0.30);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(47,140,255,0.18);
      --mode-bg-manga: linear-gradient(135deg, rgba(47,140,255,.86), rgba(0,35,80,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(47,140,255,.94), rgba(255,255,255,.10));
    }

    /* T4 - Neon Lime */
    body.skin-lime{
      --accent-rgb: 167, 255, 59;
      --accent2-rgb: 220, 255, 190;
      --bg-dark: #050705;
      --card-dark: #0a140a;
      --card-dark-2: #071007;
      --text-main: #f3fff1;
      --text-muted: rgba(243,255,241,0.70);
      --accent-red: #a7ff3b;
      --accent-red-soft: rgba(167,255,59,0.46);
      --accent-orange: #dcffbe;
      --accent-orange-soft: rgba(220,255,190,0.20);
      --accent-blue: #e9ffe1;
      --accent-blue-soft: rgba(233,255,225,0.16);
      --border-soft: rgba(243,255,241,0.16);
      --hdr-grad-a: rgba(167,255,59,0.18);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #0b1a0b;
      --hdr-stripe-b: #071007;
      --hdr-border: rgba(167,255,59,0.28);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(167,255,59,0.16);
      --mode-bg-manga: linear-gradient(135deg, rgba(167,255,59,.82), rgba(10,60,10,.70));
      --mode-bg-final: linear-gradient(135deg, rgba(167,255,59,.90), rgba(255,255,255,.10));
    }

    /* T5 - Purple Night */
    body.skin-purple{
      --accent-rgb: 190, 74, 255;
      --accent2-rgb: 255, 105, 230;
      --bg-dark: #06050a;
      --card-dark: #110b1a;
      --card-dark-2: #0c0714;
      --text-main: #f6f0ff;
      --text-muted: rgba(246,240,255,0.70);
      --accent-red: #be4aff;
      --accent-red-soft: rgba(190,74,255,0.50);
      --accent-orange: #ff69e6;
      --accent-orange-soft: rgba(255,105,230,0.22);
      --accent-blue: #eadbff;
      --accent-blue-soft: rgba(234,219,255,0.18);
      --border-soft: rgba(246,240,255,0.16);
      --hdr-grad-a: rgba(190,74,255,0.20);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #1a0f2a;
      --hdr-stripe-b: #0c0714;
      --hdr-border: rgba(190,74,255,0.28);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(190,74,255,0.16);
      --mode-bg-manga: linear-gradient(135deg, rgba(190,74,255,.84), rgba(50,0,80,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(190,74,255,.92), rgba(255,255,255,.10));
    }

    /* T6 - Amber Heat */
    body.skin-amber{
      --accent-rgb: 255, 176, 0;
      --accent2-rgb: 255, 75, 75;
      --bg-dark: #070504;
      --card-dark: #120b07;
      --card-dark-2: #0c0705;
      --text-main: #fff6ea;
      --text-muted: rgba(255,246,234,0.72);
      --accent-red: #ffb000;
      --accent-red-soft: rgba(255,176,0,0.46);
      --accent-orange: #ff4b4b;
      --accent-orange-soft: rgba(255,75,75,0.22);
      --accent-blue: #ffe3bf;
      --accent-blue-soft: rgba(255,227,191,0.16);
      --border-soft: rgba(255,246,234,0.16);
      --hdr-grad-a: rgba(255,176,0,0.18);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #23110a;
      --hdr-stripe-b: #0c0705;
      --hdr-border: rgba(255,176,0,0.26);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(255,176,0,0.14);
      --mode-bg-manga: linear-gradient(135deg, rgba(255,176,0,.82), rgba(90,30,0,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(255,176,0,.90), rgba(255,255,255,.10));
    }

    /* T7 - Ice White */
    body.skin-ice{
      --accent-rgb: 140, 215, 255;
      --accent2-rgb: 255, 255, 255;
      --bg-dark: #06080b;
      --card-dark: #0c141c;
      --card-dark-2: #091019;
      --text-main: #f1fbff;
      --text-muted: rgba(241,251,255,0.70);
      --accent-red: #8cd7ff;
      --accent-red-soft: rgba(140,215,255,0.42);
      --accent-orange: #ffffff;
      --accent-orange-soft: rgba(255,255,255,0.18);
      --accent-blue: #dff6ff;
      --accent-blue-soft: rgba(223,246,255,0.18);
      --border-soft: rgba(241,251,255,0.16);
      --hdr-grad-a: rgba(140,215,255,0.18);
      --hdr-grad-b: rgba(255,255,255,0.08);
      --hdr-stripe-a: #0b1a24;
      --hdr-stripe-b: #091019;
      --hdr-border: rgba(140,215,255,0.24);
      --hdr-border-2: rgba(255,255,255,0.12);
      --hdr-glow: 0 0 18px rgba(140,215,255,0.14);
      --mode-bg-manga: linear-gradient(135deg, rgba(140,215,255,.78), rgba(10,35,55,.70));
      --mode-bg-final: linear-gradient(135deg, rgba(140,215,255,.86), rgba(255,255,255,.12));
    }

    /* T8 - OLED Minimal */
    body.skin-oled{
      --accent-rgb: 255, 255, 255;
      --accent2-rgb: 255, 45, 45;
      --bg-dark: #000000;
      --card-dark: #050505;
      --card-dark-2: #020202;
      --text-main: #ffffff;
      --text-muted: rgba(255,255,255,0.68);
      --accent-red: #ffffff;
      --accent-red-soft: rgba(255,255,255,0.22);
      --accent-orange: #ff2d2d;
      --accent-orange-soft: rgba(255,45,45,0.26);
      --accent-blue: #e5e7eb;
      --accent-blue-soft: rgba(229,231,235,0.16);
      --border-soft: rgba(255,255,255,0.14);
      --hdr-grad-a: rgba(255,255,255,0.12);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #050505;
      --hdr-stripe-b: #000000;
      --hdr-border: rgba(255,255,255,0.18);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 16px rgba(255,255,255,0.10);
      --mode-bg-manga: linear-gradient(135deg, rgba(255,255,255,.78), rgba(30,30,30,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(255,255,255,.86), rgba(255,45,45,.12));
    }
body.skin-vicpulse #manualBtn{
      background: linear-gradient(135deg, rgba(221,20,19,.28), rgba(234,234,236,.10));
      border-color: rgba(234,234,236,.18);
    }

    body.skin-vicpulse .header-skin.active{
      background: linear-gradient(135deg, rgba(221,20,19,.92), rgba(193,74,70,.78));
      color: #12060a;
      border-color: rgba(234,234,236,.20);
      box-shadow: 0 0 14px rgba(221,20,19,.35);
    }

    /* Vic Skin PRO - volumen, bordes 3D y botones premium */
    body.skin-vicpulse{
      --bg-dark: #050507;
      --card-dark: #090a0e;
      --card-dark-2: #06070b;
      --text-main: #f4f5f7;
      --text-muted: rgba(234,234,236,0.72);

      --accent-red: #dd1413;
      --accent-red-soft: rgba(221,20,19,0.52);
      --accent-orange: #c14a46;
      --accent-orange-soft: rgba(193,74,70,0.45);

      --border-soft: rgba(234,234,236,0.16);
      --edge-hi: rgba(255,255,255,0.12);
      --edge-lo: rgba(0,0,0,0.55);
      --shadow-elev: 0 14px 32px rgba(0,0,0,0.55);
      --shadow-elev2: 0 10px 22px rgba(0,0,0,0.42);
      --shadow-inset: inset 0 1px 0 rgba(255,255,255,0.10), inset 0 -12px 18px rgba(0,0,0,0.55);

      /* Fondo: maroon + carbono sutil */
      background-color: var(--bg-dark) !important;
      background-image:
        radial-gradient(circle at 18% 12%, rgba(221,20,19,0.18), transparent 56%),
        radial-gradient(circle at 82% 6%, rgba(234,234,236,0.06), transparent 58%),
        radial-gradient(circle at 60% 92%, rgba(90,26,31,0.18), transparent 62%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.028) 0, rgba(255,255,255,0.028) 2px, rgba(0,0,0,0.0) 2px, rgba(0,0,0,0.0) 7px),
        repeating-linear-gradient(45deg, rgba(255,255,255,0.020) 0, rgba(255,255,255,0.020) 1px, rgba(0,0,0,0.0) 1px, rgba(0,0,0,0.0) 6px ) !important;
      background-blend-mode: screen, screen, screen, overlay, overlay !important;
    }

    /* Panels con glass + borde doble */
    body.skin-vicpulse .app-header,
    body.skin-vicpulse .spotter-section,
    body.skin-vicpulse .pilot-card,
    body.skin-vicpulse .controls-section,
    body.skin-vicpulse .top3-mini{
      border: 1px solid rgba(234,234,236,0.16) !important;
      box-shadow: var(--shadow-elev2), 0 0 0 1px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.06) !important;
      background-image:
        radial-gradient(120% 180% at 0% 0%, rgba(221,20,19,0.14), transparent 55%),
        radial-gradient(120% 180% at 100% 0%, rgba(234,234,236,0.05), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.22));
      background-blend-mode: screen, screen, normal;
      backdrop-filter: blur(7px);
      -webkit-backdrop-filter: blur(7px);
    }

    /* Botones premium: relieve + brillo */
    body.skin-vicpulse .btn-primary,
    body.skin-vicpulse .btn-secondary,
    body.skin-vicpulse .spotter-btn,
    body.skin-vicpulse .header-help,
    body.skin-vicpulse .spotter-master-btn,
    body.skin-vicpulse .btn-mini,
    body.skin-vicpulse .btn-grid,
    body.skin-vicpulse .session-preset-card{
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(234,234,236,0.16) !important;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22)) !important;
      box-shadow: var(--shadow-elev2), var(--shadow-inset) !important;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      transform: translateZ(0);
    }

    body.skin-vicpulse .btn-primary::before,
    body.skin-vicpulse .btn-secondary::before,
    body.skin-vicpulse .spotter-btn::before,
    body.skin-vicpulse .header-help::before,
    body.skin-vicpulse .spotter-master-btn::before,
    body.skin-vicpulse .btn-mini::before,
    body.skin-vicpulse .btn-grid::before,
    body.skin-vicpulse .session-preset-card::before{
      content: "";
      position: absolute;
      inset: -2px -2px auto -2px;
      height: 58%;
      background: radial-gradient(120% 140% at 15% 0%, rgba(255,255,255,0.22), rgba(255,255,255,0.08), transparent 70%);
      pointer-events: none;
      opacity: 0.85;
    }

    body.skin-vicpulse .btn-primary:hover,
    body.skin-vicpulse .btn-secondary:hover,
    body.skin-vicpulse .spotter-btn:hover,
    body.skin-vicpulse .header-help:hover,
    body.skin-vicpulse .spotter-master-btn:hover,
    body.skin-vicpulse .btn-mini:hover,
    body.skin-vicpulse .btn-grid:hover,
    body.skin-vicpulse .session-preset-card:hover{
      filter: brightness(1.10);
    }

    body.skin-vicpulse .btn-primary:active,
    body.skin-vicpulse .btn-secondary:active,
    body.skin-vicpulse .spotter-btn:active,
    body.skin-vicpulse .header-help:active,
    body.skin-vicpulse .spotter-master-btn:active,
    body.skin-vicpulse .btn-mini:active,
    body.skin-vicpulse .btn-grid:active,
    body.skin-vicpulse .session-preset-card:active{
      transform: translateY(1px) scale(0.99) !important;
      box-shadow: 0 8px 18px rgba(0,0,0,0.50), inset 0 1px 0 rgba(255,255,255,0.08), inset 0 -10px 16px rgba(0,0,0,0.60) !important;
    }

    /* Estados activos: rojo Vic con glow */
    body.skin-vicpulse .btn-secondary.active,
    body.skin-vicpulse .spotter-btn.active,
    body.skin-vicpulse .spotter-master-btn.active,
    body.skin-vicpulse .session-preset-card.active{
      background: linear-gradient(135deg, rgba(221,20,19,0.92), rgba(193,74,70,0.74)) !important;
      color: rgba(18,6,10,0.98) !important;
      border-color: rgba(234,234,236,0.22) !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 22px rgba(221,20,19,0.22), 0 16px 32px rgba(0,0,0,0.55) !important;
      text-shadow: none;
    }

    /* Header botones un poco mas agresivos */
    body.skin-vicpulse .header-help{
      letter-spacing: 0.08em;
      font-weight: 900;
    }

    /* Contornos finos con relieve en elementos clave */
    body.skin-vicpulse .badge-mode,
    body.skin-vicpulse .badge-live,
    body.skin-vicpulse .manga-clock{
      box-shadow: 0 10px 22px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.10) !important;
    }


        * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      color-scheme: dark;
    }

body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Roboto", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif;
      background-color: var(--bg-dark);
      color: var(--text-main);
      background-image:
        radial-gradient(circle at 20% 10%, rgba(255,43,43,0.12), transparent 55%),
        radial-gradient(circle at 80% 0%, rgba(255,122,24,0.14), transparent 55%),
        radial-gradient(circle at 70% 95%, rgba(255,43,43,0.14), transparent 60%),
        repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0, rgba(255,255,255,0.02) 2px, rgba(0,0,0,0.0) 2px, rgba(0,0,0,0.0) 6px);
      background-blend-mode: screen;
      min-height: 100vh;
    }

    body.no-scroll {
      overflow: hidden !important;
    }

    .app {
      max-width: 480px;
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: calc(10px + env(safe-area-inset-top, 0px)) 12px 12px;
      padding-top: calc(10px + env(safe-area-inset-top));
      padding-left: calc(12px + env(safe-area-inset-left));
      padding-right: calc(12px + env(safe-area-inset-right));
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      gap: 8px;
    }

    .app-header {
      flex-shrink: 0;
      padding: 10px 14px;
      padding-bottom: 34px;
      position: relative;
      border-radius: var(--radius-lg);
      border: 1px solid var(--hdr-border);
      box-shadow: var(--shadow-soft), var(--hdr-glow);
      background-image:
        radial-gradient(120% 180% at 0% 0%, rgba(255,43,43,0.22), transparent 55%),
        radial-gradient(120% 180% at 100% 0%, rgba(255,255,255,0.08), transparent 55%),
        linear-gradient(135deg, var(--hdr-grad-a), var(--hdr-grad-b)),
        repeating-linear-gradient(45deg, var(--hdr-stripe-a) 0, var(--hdr-stripe-a) 2px, var(--hdr-stripe-b) 2px, var(--hdr-stripe-b) 4px),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 6px);
      background-blend-mode: screen, screen, normal, normal, overlay;
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .header-left{
      height: 123px;
      max-height: 123px;
      min-height: 123px;
      flex: 1 1 224px;
      max-width: 224px;
      min-width: 0;
      box-sizing: border-box;
      overflow: hidden;
    }

.header-title-main {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      flex-wrap: wrap;
      min-width: 0;
    }

    .badge-mode {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      border: 1px solid var(--mode-brd-neutral);
      background: var(--mode-bg-neutral);
      white-space: nowrap;
      box-shadow: 0 0 10px rgba(0,0,0,0.25);
    
      /* FORCE_VISIBLE_DEFAULT */
      background: linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06));
      color: rgba(255,255,255,0.92);
      border-color: rgba(255,255,255,0.22);
      text-shadow: 0 2px 10px rgba(0,0,0,0.55);
    
    }
    .badge-mode.mode-manga{
      background: var(--mode-bg-manga);
      border-color: rgba(255,255,255,0.14);
      color: #071018;
      box-shadow: 0 0 12px rgba(0,229,255,0.25);
   
      /* SIZE_70 */
      font-size: 11px;
      line-height: 1;
      padding: 1px 3px;
      gap: 2px;
    }
    .badge-mode.mode-final{
      background: var(--mode-bg-final);
      border-color: rgba(255,255,255,0.14);
      color: #0b0f14;
      box-shadow: 0 0 12px rgba(255,140,0,0.22);
    }
    .badge-mode.mode-finalA{
      background: var(--mode-bg-finalA);
      border-color: rgba(255,255,255,0.16);
      color: #101015;
      box-shadow: 0 0 14px rgba(255,215,0,0.22);
    }

    .header-title-sub {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent-orange-soft);
      width:225px;

  max-width:225px;
}

    .header-subline {
      font-size: 10px;
      color: var(--text-muted);
    
      line-height: 1.1;
      margin-top: 0;
      margin-bottom: 0;}

    .header-mini {
      font-size: 9px;
      color: var(--text-muted);
    
      line-height: 1.1;
      margin-top: -2px;
      margin-bottom: 0;}
    .header-right{
      height: 123px;
      max-height: 123px;
      min-height: 123px;
      flex: 0 1 200px;
      max-width: 200px;
      min-width: 160px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      text-align: center;
    }

@media (max-width: 520px){
  .app-header{ flex-wrap: wrap; padding: 10px 12px; gap: 10px; }
  .header-left{ flex: 1 1 100%; max-width: none; height: auto; min-height: 0; }
  .header-right{ flex: 1 1 100%; max-width: none; width: 100%; height: auto; min-height: 0; }
  .header-right-inner{ height: auto; min-height: 0; }

  /* Titulo: que respire en movil */
  #raceTitleMain{ justify-content: flex-start; flex-wrap: wrap; gap: 8px; }

  #raceTitleText{
    max-width: 100%;
    width: auto;
    flex: 1 1 auto;
    font-size: clamp(12px, 3.6vw, 16px);
    max-height: none;
    -webkit-line-clamp: 3;
  }

  #raceSubtitle{
    max-width: 100%;
    width: auto;
    font-size: clamp(11px, 3.0vw, 12px);
  }


  /* v0.0.1.47: Reduce secondary header info only (keep logo + main title big) */
  :root{
    --hdrSubTextScale: 0.40; /* 40% size for info lines */
    --hdrControlsScale: 0.70; /* keep controls usable */
  }

  /* Info lines smaller (race subtitle/info/tick + version) */
  .app-header .header-title-sub,
  .app-header .header-subline,
  .app-header .header-mini,
  .app-header .header-version{
    position: absolute;
    left: 0; right: 0;
    bottom: 8px;
    text-align: center;
    font-size: 11px;
    line-height: 1.1;
    letter-spacing: .6px;
    opacity: 0.88;
    pointer-events: none;
  }

  /* Mode badge: slightly reduced but still readable */
  .app-header .header-mode-row{
    transform: scale(0.78);
    transform-origin: top center;
    margin-top: -2px;
    margin-bottom: -2px;
  }

  /* Controls row smaller but clickable */
  .app-header .header-controls{
    transform: scale(var(--hdrControlsScale));
    transform-origin: top center;
    margin-top: -2px;
  }

  /* Keep header stack spacing tighter since subtext shrank */
  .app-header .header-stack{
    gap: 2px;
  }

  .header-subline{ font-size: 12px; }
}

  .header-left{ max-width: none; }
}


.header-right-bottom{
      margin-top: auto;
      display:flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      width: 100%;
    }

    .header-actions-row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: var(--hdrCtrlGap);
      width: 100%;
    }
    /* Badge de MODO dentro de controles - mismo tamao que botones */
    .header-actions-row #raceModeRow{
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .header-actions-row #raceModeBadge.badge-mode{
      height: var(--hdrCtrlH) !important;
      min-width: var(--hdrCtrlW) !important;
      width: var(--hdrCtrlW) !important;
      padding: 0 var(--hdrCtrlPadX) !important;
      font-size: var(--hdrCtrlFont) !important;
      font-weight: 800;
      letter-spacing: 0.06em;
      line-height: 1;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      border-radius: 12px !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }

    .header-logo{
      display:flex;
      align-items:center;
      justify-content:center;
      width: 100%;
      align-self: stretch;
      overflow: visible;
    }
    .header-logo img{
      width: 400px;
      height: 70px;
      max-width: 100%;
      max-height: 70px;
      object-fit: contain;
      image-rendering: auto;
      filter: drop-shadow(0 0 10px rgba(0,255,163,0.25));
    }

.badge-live {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 9px;
      border-radius: var(--radius-pill);
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 0 10px rgba(34,197,94,0.8);
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .badge-live-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background-color: #bbf7d0;
    }

    .badge-live.live-off {
      background: #4b5563;
      box-shadow: none;
    }

    .badge-live.live-off .badge-live-dot {
      background-color: #9ca3af;
    }

    .header-version {
      font-size: 10px;
      color: var(--text-muted);
      width: 100%;
      text-align: center;
    }

    .app-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
    }

    .pilot-card {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background-image:
        linear-gradient(145deg, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      border: 1px solid rgba(249,115,22,0.7);
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .pilot-card-top-strip {
      height: 4px;
      border-radius: 999px;
      background-image:
        linear-gradient(90deg, #b91c1c, var(--accent-orange), #b91c1c),
        repeating-linear-gradient(45deg, #111827 0, #111827 2px, #020617 2px, #020617 4px);
      background-blend-mode: overlay;
    }

    .pilot-row-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .pilot-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .pilot-name {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      flex: 1;
      min-width: var(--hdrCtrlW) !important;
    }

    .pilot-name-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      width:100%;
      min-width: var(--hdrCtrlW) !important;
    }

    .pilot-laps-big{
      margin-left:auto;
      font-size: 23px;
      line-height: 1;
      font-weight: 900;
      letter-spacing: -0.02em;
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
      text-shadow: 0 10px 20px rgba(0,0,0,0.55);
    }

    .pilot-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    .pilot-select {
      flex: 1;
      margin-top: 4px;
    }

    .pilot-select select {
      width: 100%;
      padding: 12px 34px 12px 14px; /* right space for arrow */
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      font-size: 18px;
      font-weight: 800;
      outline: none;

      /* Cross-browser consistency */
      color-scheme: dark;
      -webkit-appearance: none;
      appearance: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;

      /* Custom arrow (stable on Chrome/Safari/Android) */
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(242,245,255,0.72) 50%),
        linear-gradient(135deg, rgba(242,245,255,0.72) 50%, transparent 50%);
      background-position: calc(100% - 18px) 50%, calc(100% - 12px) 50%;
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;

      transition: border-color 0.12s ease, box-shadow 0.12s ease, color 0.12s ease;
    }

    .pilot-select select:focus {
      border-color: rgba(45,107,255,0.50);
      box-shadow: 0 0 0 3px rgba(255,43,43,0.14);
    }
    /* Mejor esfuerzo: algunos navegadores respetan estilos de option */
    .pilot-select select option {
      background-color: #0b1220;
      color: #ffffff;
    }

    .pilot-select select option:checked {
      background-color: rgba(45,107,255,0.55);
      color: #ffffff;
    }


    .pilot-select-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 6px;
    }

    .btn-voice-mini {
      flex: 0 0 50%;
      padding: 6px 8px;
      font-size: 11px;
      letter-spacing: 0.06em;
    }

    .btn-basic-mini {
      flex: 0 0 38%;
      padding: 6px 8px;
      font-size: 11px;
      letter-spacing: 0.06em;
      opacity: 0.95;
      border: 1px solid rgba(239,68,68,0.85);
      background: linear-gradient(135deg, rgba(239,68,68,0.38), rgba(127,29,29,0.18));
      color: rgba(255,255,255,0.94);
      box-shadow: 0 0 12px rgba(239,68,68,0.18);
    }
    .btn-basic-mini.active{
      opacity: 1.0;
      border: 1px solid rgba(34,197,94,0.92);
      background: linear-gradient(135deg, rgba(34,197,94,0.60), rgba(21,128,61,0.22));
      color: rgba(255,255,255,0.98);
      box-shadow: 0 0 14px rgba(34,197,94,0.26);
    }
    .btn-basic-mini[disabled]{
      opacity: 0.35;
      cursor: not-allowed;
      filter: grayscale(0.35);
    }

/* Color del selector por posición */
    #pilotSelect.pos-none {
      border-color: var(--border-soft);
      box-shadow: none;
    }
    #pilotSelect.pos-1 {
      background: linear-gradient(135deg, rgba(255,215,0,0.96), rgba(255,140,0,0.82));
      border-color: rgba(255,215,0,0.55);
      box-shadow: 0 0 14px rgba(255,215,0,0.18);
      color: #0b0f14;
    }
    #pilotSelect.pos-2 {
      background: linear-gradient(135deg, rgba(229,231,235,0.96), rgba(156,163,175,0.74));
      border-color: rgba(229,231,235,0.46);
      box-shadow: 0 0 14px rgba(229,231,235,0.12);
      color: #0b0f14;
    }
    #pilotSelect.pos-3 {
      background: linear-gradient(135deg, rgba(251,146,60,0.96), rgba(180,83,9,0.78));
      border-color: rgba(251,146,60,0.46);
      box-shadow: 0 0 14px rgba(251,146,60,0.14);
      color: #0b0f14;
    }
    #pilotSelect.pos-top5 {
      border-color: rgba(34,197,94,0.42);
      box-shadow: 0 0 14px rgba(34,197,94,0.12);
      background: linear-gradient(135deg, rgba(34,197,94,0.20), rgba(16,185,129,0.14));
    }
    #pilotSelect.pos-other {
      border-color: rgba(45,107,255,0.40);
      box-shadow: 0 0 12px rgba(45,107,255,0.10);
    }
    #pilotSelect.is-loading{ opacity:0.92; filter:saturate(0.85); }


    @media (max-width: 430px){
      .btn-voice-mini { flex-basis: 58%; }
      .btn-basic-mini { flex-basis: 38%; }
      .pilot-select select { font-size: 16px; padding: 10px 12px; }
    }

    .pilot-pos-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 4px;
    }

    .pos-pill {
      padding: 4px 12px;
      border-radius: var(--radius-pill);
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      box-shadow: var(--shadow-strong);
    }

    .pos-info {
      font-size: 14px;
      color: #ffffff;
      font-weight: 700;
      text-align: right;
    }

    .pilot-timings {
      margin-top: 6px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .timing-item {
      padding: 6px 6px 7px;
            border-radius: 10px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.95), rgba(3,7,18,0.98));
      border: 1px solid rgba(15,23,42,0.9);
    }

    .timing-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-muted);
      margin-bottom: 2px;
    }

    .timing-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent-cyan);
      transition: transform 0.2s ease, text-shadow 0.2s ease;
    }

    .timing-value.flash {
      transform: scale(1.22);
      text-shadow: 0 0 12px rgba(34,211,238,0.9);
    }

    .controls-section {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .controls-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .controls-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    .voice-speed-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .voice-speed-value {
      font-size: 11px;
      color: var(--accent-orange-soft);
      min-width: var(--hdrCtrlW) !important;
      text-align: right;
    }

    .voice-select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.55);
      color: var(--text-main);
      font-size: 12px;
      outline: none;
    }
    .voice-select option {
      background: #0b1120;
      color: var(--text-main);
    }

    input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(90deg, #111827, var(--accent-orange), #b91c1c);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-orange);
      box-shadow: 0 0 10px rgba(249,115,22,0.9);
      border: 2px solid #fee2e2;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-orange);
      box-shadow: 0 0 10px rgba(249,115,22,0.9);
      border: 2px solid #fee2e2;
      cursor: pointer;
    }

    .buttons-row {
      display: flex;
      gap: 8px;
    }

    .rate-row {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.08);
            border-radius: 10px;
      background: rgba(255,255,255,0.03);
    }
    .rate-label {
      min-width: var(--hdrCtrlW) !important;
      font-weight: 700;
      letter-spacing: 0.2px;
      opacity: 0.95;
    }
    #rateRange {
      flex: 1;
      accent-color: #ff5a1f;
    }
    .rate-display {
      min-width: var(--hdrCtrlW) !important;
      text-align: right;
      font-variant-numeric: tabular-nums;
      opacity: 0.95;
    }

    .btn-primary,
    .btn-secondary {
      flex: 1;
      padding: 8px 10px;
      border-radius: var(--radius-pill);
      border: none;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: transform 0.06s ease, box-shadow 0.06s ease, background 0.06s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      box-shadow: var(--shadow-strong);
    }

    .btn-secondary {
      background: transparent;
      color: var(--accent-orange-soft);
      border: 1px solid rgba(248,113,113,0.7);
    }

    .btn-primary:active,
    .btn-secondary:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 0 4px rgba(15,15,15,0.8);
    }

    .btn-primary.voice-on {
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 0 12px rgba(34,197,94,0.9);
    }

    .spotter-section {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background: linear-gradient(160deg, rgba(15,23,42,0.98), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .spotter-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
    }

    .spotter-btn {
  padding: 6px 7px;
  border-radius: var(--radius-pill);
  font-size: 11px;
  border: 1px solid var(--border-soft);
  background: rgba(15,23,42,0.96);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: pointer;
  transition: background 0.08s ease, box-shadow 0.08s ease, color 0.08s ease, border 0.08s ease;
  user-select: none;

  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;

  white-space: nowrap;
  overflow: visible;
  text-overflow: clip;
  min-height: 30px;
}

    .spotter-btn span {
  font-size: 12px;
  flex: 0 0 auto;
}

    .spotter-btn.active {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      border-color: rgba(254,242,242,0.85);
      box-shadow: var(--shadow-soft);
    }

    

    /* Categorias de mensajes */
    .spotter-cat {
      border-radius: 14px;
      padding: 6px 6px 8px;
      border: 1px solid rgba(148,163,184,0.30);
      background: rgba(2,6,23,0.35);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .spotter-cat-head {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: var(--radius-pill);
      font-size: 10px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(148,163,184,0.25);
      user-select: none;
    }

    .spotter-cat .cat-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 0 10px rgba(255,255,255,0.15);
      flex: 0 0 auto;
    }

    .spotter-btn.lock::after {
      content: "";
      font-size: 12px;
      margin-left: 6px;
      opacity: 0.95;
    }

    
    .spotter-cat[data-cat="essential"] {
      border-color: rgba(255,70,70,0.48);
    }
    .spotter-cat[data-cat="essential"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(255,70,70,0.18), rgba(255,140,0,0.14));
      border-color: rgba(255,70,70,0.32);
      color: rgba(255,230,230,0.95);
    }
    .spotter-cat[data-cat="essential"] .cat-dot {
      background: rgba(255,70,70,0.95);
      box-shadow: 0 0 12px rgba(255,70,70,0.55);
    }
    .spotter-cat[data-cat="essential"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(255,70,70,0.95), rgba(255,140,0,0.78));
      box-shadow: 0 0 14px rgba(255,70,70,0.22);
      color: #0b0f14;
      border-color: rgba(255,255,255,0.10);
    }

    .spotter-cat[data-cat="battle"] {
      border-color: rgba(255,170,0,0.46);
    }
    .spotter-cat[data-cat="battle"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(255,170,0,0.18), rgba(255,90,0,0.10));
      border-color: rgba(255,170,0,0.30);
      color: rgba(255,245,220,0.95);
    }
    .spotter-cat[data-cat="battle"] .cat-dot {
      background: rgba(255,170,0,0.95);
      box-shadow: 0 0 12px rgba(255,170,0,0.55);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,140,0,0.80));
      box-shadow: 0 0 14px rgba(255,170,0,0.20);
      color: #0b0f14;
      border-color: rgba(255,255,255,0.10);
    }

    .spotter-cat[data-cat="summary"] {
      border-color: rgba(0,255,140,0.42);
    }
    .spotter-cat[data-cat="summary"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(0,255,140,0.14), rgba(0,170,90,0.10));
      border-color: rgba(0,255,140,0.26);
      color: rgba(220,255,240,0.95);
    }
    .spotter-cat[data-cat="summary"] .cat-dot {
      background: rgba(0,255,140,0.92);
      box-shadow: 0 0 12px rgba(0,255,140,0.50);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(0,255,140,0.92), rgba(0,170,90,0.80));
      box-shadow: 0 0 14px rgba(0,255,140,0.18);
      color: #06110c;
      border-color: rgba(255,255,255,0.10);
    }
.extras-section {
      zoom: 0.67;

      border-radius: var(--radius-lg);
      padding: 2px 4px 4px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.96), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 1px;
    }

    .precision-row {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .precision-buttons {
      display: flex;
      gap: 4px;
    }

    .precision-badge {
      flex: 1;
      padding: 4px 0;
      border-radius: var(--radius-pill);
      font-size: 10px;
      border: 1px solid var(--border-soft);
      background: rgba(15,23,42,0.96);
      color: var(--text-muted);
      text-align: center;
      cursor: default;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      transition: background 0.08s ease, color 0.08s ease, border 0.08s ease;
    }

    .precision-badge.active {
      background: linear-gradient(135deg, var(--accent-orange), var(--accent-red));
      color: var(--text-main);
      border-color: rgba(254,242,242,0.85);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-top: 1px;
    }

    .toggle-label {
      font-size: 9px;
      color: var(--text-muted);
    }

    .toggle-pill {
      width: 30px;
      height: 15px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid var(--border-soft);
      position: relative;
      cursor: pointer;
      transition: background 0.08s ease, border 0.08s ease;
    }

    .toggle-thumb {
      width: 11px;
      height: 11px;
      border-radius: 999px;
      background: #9ca3af;
      position: absolute;
      top: 1px;
      left: 1px;
      transition: transform 0.12s ease, background 0.12s ease, box-shadow 0.12s ease;
    }

    .toggle-pill.active {
      background: linear-gradient(135deg, var(--accent-orange), var(--accent-red));
      border-color: rgba(254,242,242,0.85);
    }

    .toggle-pill.active .toggle-thumb {
      transform: translateX(18px);
      background: #fef2f2;
      box-shadow: 0 0 8px rgba(248,113,113,0.9);
    }

    .wake-status {
      font-size: 9px;
      color: var(--text-muted);
      text-align: right;
    }

    .grid-button-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 2px;
    }

    .btn-grid {
      flex: 1;
      padding: 8px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(248,113,113,0.7);
      background: rgba(15,23,42,0.96);
      color: var(--accent-orange-soft);
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      cursor: pointer;
    }

    .hint-text {
      font-size: 10px;
      color: var(--text-muted);
      text-align: right;
    }

    .grid-sheet-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: flex-end;
      justify-content: center;
      z-index: 30;
    }

    .grid-sheet-backdrop.open {
      display: flex;
    }

    
.grid-sheet {
      width: min(980px, 96vw);
      max-width: 980px;
      max-height: 92vh;
      height: 92vh;
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      border-radius: 18px;
      border: 1px solid rgba(248,113,113,0.45);
      box-shadow: 0 18px 40px rgba(0,0,0,0.80);
      padding: 8px 12px 12px;
      overflow: hidden;                 /* el scroll vive en la lista */
      display: flex;
      flex-direction: column;
    }

    /* Si el alto disponible es chico (cel), ancla abajo estilo sheet */
    @media (max-width: 560px) {
      .grid-sheet {
        width: 100%;
        max-width: 560px;
        height: 92vh;
        border-radius: 18px 18px 0 0;
        border-left: 0;
        border-right: 0;
        border-bottom: 0;
      }
    }
.grid-sheet-handle {
      width: 40px;
      height: 4px;
      border-radius: 999px;
      background: rgba(148,163,184,0.7);
      margin: 4px auto 8px;
    }

    
    .grid-sheet-header {
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px 8px;
      margin-bottom: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,140,0,0.22);
      box-shadow: 0 10px 18px rgba(0,0,0,0.55);
      background-image:
        radial-gradient(120% 160% at 0% 0%, rgba(0,229,255,0.18), transparent 55%),
        radial-gradient(120% 160% at 100% 0%, rgba(255,140,0,0.18), transparent 55%),
        linear-gradient(135deg, rgba(255,40,40,0.10), rgba(255,140,0,0.12)),
        repeating-linear-gradient(45deg, rgba(11,18,32,0.85) 0, rgba(11,18,32,0.85) 2px, rgba(5,7,13,0.85) 2px, rgba(5,7,13,0.85) 4px);
      background-blend-mode: screen, screen, normal, normal;
    }

    .grid-sheet-title-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .grid-sheet-title {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      font-weight: 900;
      color: rgba(255,190,120,0.95);
      line-height: 1.05;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .grid-sheet-sub {
      font-size: 10px;
      color: rgba(226,232,240,0.78);
      letter-spacing: 0.04em;
      opacity: 0.95;
    }

    .grid-sheet-hud {
      margin-top: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,140,0,0.14);
    }

    .grid-hud-left {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      min-width: 0;
    }

    .grid-hud-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border-radius: 999px;
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      background: rgba(2,6,23,0.60);
      border: 1px solid rgba(148,163,184,0.28);
      color: rgba(226,232,240,0.92);
      box-shadow: 0 0 10px rgba(0,0,0,0.30);
      white-space: nowrap;
    }

    .grid-hud-chip-mode {
      border-color: rgba(34,211,238,0.22);
      color: rgba(34,211,238,0.95);
      background: rgba(2,6,23,0.55);
    }

    .grid-hud-chip.mode-manga {
      border-color: rgba(0,229,255,0.30);
      color: rgba(0,229,255,0.95);
      background: rgba(0,229,255,0.12);
    }

    .grid-hud-chip.mode-final {
      border-color: rgba(255,140,0,0.32);
      color: rgba(255,180,90,0.96);
      background: rgba(255,140,0,0.12);
    }

    .grid-hud-chip.mode-finalA {
      border-color: rgba(255,215,0,0.35);
      color: rgba(255,215,0,0.96);
      background: rgba(255,215,0,0.12);
    }

    .grid-meta-right {
      font-size: 11px;
      font-weight: 800;
      color: var(--accent-cyan);
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 52%;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(2,6,23,0.45);
      border: 1px solid rgba(34,211,238,0.20);
    }

    .btn-sheet-close {
      width: 34px;
      height: 34px;
      flex: 0 0 auto;
            border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.28);
      background: rgba(2,6,23,0.55);
      color: rgba(226,232,240,0.90);
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0,0,0,0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .btn-sheet-close:hover {
      border-color: rgba(255,140,0,0.30);
      box-shadow: 0 0 12px rgba(255,140,0,0.18);
    }
    
    .grid-list {
      --grid-cols: 1;
 
      min-height: 0;
      display: grid;
      grid-template-columns: repeat(var(--grid-cols), minmax(220px, 1fr));
      gap: 8px;
      padding-bottom: 8px;
      overflow-y: auto;                 /* si no cabe, desliza */
      overscroll-behavior: contain;

      scrollbar-width: none;            /* Firefox */
      -ms-overflow-style: none;         /* IE/Edge legacy */
    }
    .grid-list::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }
.grid-row {
            border-radius: 10px;
      padding: 5px 8px;
      background: rgba(15,23,42,0.96);
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 11px;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    .grid-row-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .grid-pos {
      font-weight: 700;
      font-size: 12px;
    }

    .grid-name {
      flex: 1;
      font-size: 12px;
    }

    .grid-tags {
      font-size: 10px;
      color: var(--text-muted);
    }

    .grid-row.p1 {
      border-color: #facc15;
    }
    .grid-row.p2 {
      border-color: #e5e7eb;
    }
    .grid-row.p3 {
      border-color: var(--accent-orange);
    }

    .grid-row.selected {
      border-color: var(--accent-cyan);
      box-shadow: 0 0 10px rgba(34,211,238,0.7);
    }

    /* GRID COMPLETO - UI PRO (v5.0.0) */
    .grid-sheet-headleft {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
      flex: 1;
    }

    .grid-row {
      cursor: pointer;
      padding: 9px 10px;
    }
    .grid-row:hover {
      transform: translateY(-1px);
      border-color: rgba(34,211,238,0.35);
      box-shadow: 0 10px 18px rgba(0,0,0,0.45);
    }
    .grid-row-top {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .grid-pos-pill {
      min-width: 42px;
      height: 26px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      font-size: 12px;
      background: rgba(2,6,23,0.70);
      border: 1px solid rgba(148,163,184,0.35);
      color: rgba(226,232,240,0.95);
      flex: 0 0 auto;
    }
    .grid-name-wrap {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .grid-name {
      font-size: 12px;
      font-weight: 900;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      letter-spacing: 0.02em;
    }
    .grid-sub {
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.95;
    }

    .grid-metrics {
      display: flex;
      gap: 6px;
      align-items: stretch;
      justify-content: flex-end;
      flex-wrap: wrap;
      flex: 0 0 auto;
    }
    .grid-kpi {
      min-width: 70px;
      padding: 4px 6px;
      border-radius: 10px;
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(34,211,238,0.12);
      text-align: right;
    }
    .grid-kpi .k {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.9;
    }
    .grid-kpi .v {
      font-size: 11px;
      font-weight: 900;
      color: rgba(226,232,240,0.96);
      letter-spacing: 0.02em;
    }
    .grid-kpi.best .v { color: var(--accent-cyan); }
    .grid-kpi.last .v { color: var(--accent-orange-soft); }
    .grid-kpi.mean .v { color: rgba(226,232,240,0.96); }

    .grid-row-bottom {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }
    .grid-chip {
      font-size: 10px;
      color: rgba(226,232,240,0.78);
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.45);
      border: 1px solid rgba(55,65,81,0.75);
    }
    .grid-chip strong {
      color: rgba(226,232,240,0.96);
      font-weight: 800;
    }

    @media (max-width: 420px) {
      .grid-kpi { min-width: 66px; }
      .grid-meta-right { max-width: 64%; }
    }

    
    .lap-chart-wrap {
      margin-top: 8px;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid rgba(251, 146, 60, 0.22);
      background: linear-gradient(180deg, rgba(2, 6, 23, 0.55), rgba(2, 6, 23, 0.25));
      box-shadow: inset 0 0 0 1px rgba(34,211,238,0.08);
    }
    .lap-chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }
    .lap-chart-title {
      font-size: 12px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.85);
    }
    .lap-chart-meta {
      font-size: 11px;
      color: rgba(148,163,184,0.95);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 6px;
      flex: 0 0 390px;
      width: 390px;
      max-width: 390px;
      min-width: 0;
      white-space: nowrap;
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
    }
    .lap-chart-meta::-webkit-scrollbar { display: none; }
    
    .lap-pos-chip{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.22);
      background: rgba(2,6,23,0.28);
      margin-left:6px;
      line-height: 1.05;
    }
    .lap-pos-chip:first-child{ margin-left:0; }
    .lap-pos-chip .lp{
      font-weight:800;
      letter-spacing:0.02em;
      opacity:0.96;
    }
    .lap-pos-chip .nm{
      opacity:0.92;
      max-width:110px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      display:inline-block;
    }
.lap-pos-chip.pos1{ border-color: rgba(251,191,36,0.45); color: rgba(255,240,200,0.96); }
    .lap-pos-chip.pos2{ border-color: rgba(255,255,255,0.35); color: rgba(255,255,255,0.92); }
    .lap-pos-chip.pos3{ border-color: rgba(249,115,22,0.45); color: rgba(255,230,210,0.94); }

    .lap-pos-chip.active.pos1{ background: rgba(251,191,36,0.12); border-color: rgba(251,191,36,0.75); }
    .lap-pos-chip.active.pos2{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.70); }
    .lap-pos-chip.active.pos3{ background: rgba(249,115,22,0.12); border-color: rgba(249,115,22,0.78); }

    .top3-mini-grid{
      margin-top: 8px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }
.top3-mini-grid.expanded{ max-height: none; overflow: visible; }
@media (max-width: 380px){
  .top3-mini-grid.expanded{ max-height: none; overflow: visible; }
}
.top3-mini-grid.expanded .top3-mini-row{
  padding: 6px 8px;
  gap: 8px;
}
.top3-mini-grid.expanded .top3-mini-name{
  max-width: 34vw;
}
.top3-mini-grid.expanded .top3-mini-stats{
  max-width: 40vw;
  gap: 6px;
}
    .top3-mini-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 7px 10px;
            border-radius: 10px;
      background: rgba(2,6,23,0.28);
      border: 1px solid rgba(148,163,184,0.22);
      box-shadow: 0 6px 14px rgba(0,0,0,0.20);
    }
    .top3-mini-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .top3-mini-pos{
      width: 34px;
      height: 22px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      font-size: 12px;
      letter-spacing: 0.02em;
      border: 1px solid rgba(148,163,184,0.28);
      flex: 0 0 auto;
    }
    .top3-mini-name{
      font-weight: 750;
      font-size: 12px;
      color: rgba(226,232,240,0.95);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 52vw;
    }
    .top3-mini-right{
      font-weight: 650;
      font-size: 11px;
      color: rgba(148,163,184,0.95);
      flex: 0 0 auto;
      display:flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
      line-height: 1.05;
    }
    .top3-mini-num{
      font-weight: 800;
      font-size: 11px;
      color: rgba(226,232,240,0.92);
    }
    .top3-mini-stats{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
      font-size: 10px;
      color: rgba(148,163,184,0.92);
      flex-wrap: wrap;
      max-width: 46vw;
    }
    .top3-mini-stat{
      display:flex;
      align-items: baseline;
      gap: 3px;
      white-space: nowrap;
    }
    .top3-mini-k{
      font-weight: 900;
      font-size: 9px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.78);
    }
    .top3-mini-row.pos1{ border-color: rgba(251,191,36,0.28); }
    .top3-mini-row.pos2{ border-color: rgba(255,255,255,0.20); }
    .top3-mini-row.pos3{ border-color: rgba(249,115,22,0.26); }

    .top3-mini-pos.pos1{ background: rgba(251,191,36,0.14); border-color: rgba(251,191,36,0.55); color: rgba(255,245,210,0.98); }
    .top3-mini-pos.pos2{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.45); color: rgba(255,255,255,0.96); }
    .top3-mini-pos.pos3{ background: rgba(249,115,22,0.14); border-color: rgba(249,115,22,0.55); color: rgba(255,235,220,0.96); }
.top3-mini-row.posN{ border-color: rgba(148,163,184,0.16); }
.top3-mini-pos.posN{ background: rgba(148,163,184,0.10); border-color: rgba(148,163,184,0.30); color: rgba(226,232,240,0.92); }

    /* =========================
       TIMING MINI GRID (v6.5)
       Objetivo: Top3/Top20 con jerarqua de INT, nmeros tabulares, DUEL y barra de gap.
       ========================= */

    /* Dgitos parejitos (broadcast vibe) */
    .tgrid-nums{
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1, "ss01" 1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .top3-mini-row{
      padding: 6px 10px;
      gap: 10px;
    }

    /* Caja del # (auto) */
    .tgrid-numbox{
      min-width: 34px;
      height: 18px;
      padding: 0 8px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(148,163,184,0.10);
      border: 1px solid rgba(148,163,184,0.24);
      color: rgba(226,232,240,0.92);
      font-weight: 900;
      font-size: 11px;
      line-height: 1;
    }

    /* Estructura principal */
    .tgrid-main{
      width: 100%;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      min-width: 0;
    }

    .tgrid-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
      flex: 1 1 auto;
    }

    .tgrid-namewrap{ min-width: 0; flex: 1 1 auto; }

    .tgrid-name{
      font-weight: 850;
      font-size: 12px;
      color: rgba(226,232,240,0.96);
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      line-height: 1.15;
      word-break: break-word;
    }

    .tgrid-sub{
      margin-top: 2px;
      display:flex;
      align-items:baseline;
      justify-content:flex-start;
      gap: 10px;
      color: rgba(148,163,184,0.92);
      font-size: 10px;
      line-height: 1.05;
      flex-wrap: nowrap;
      white-space: nowrap;
    }

    .tgrid-sub .k{
      font-weight: 900;
      font-size: 9px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.78);
      margin-right: 4px;
    }

    /* Columnas fijas tipo timing screen */
    .tgrid-col{
      display:inline-flex;
      align-items:baseline;
      justify-content:flex-end;
      text-align:right;
      white-space: nowrap;
    }
    .tgrid-col.v{ min-width: 38px; }
    .tgrid-col.bl{ min-width: 96px; }
    .tgrid-col.int{ min-width: 96px; }

    .tgrid-right{
      display:flex;
      flex-direction: column;
      align-items:flex-end;
      justify-content:center;
      gap: 4px;
      flex: 0 0 auto;
    }

    /* INT protagonista */
    .tgrid-intwrap{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
    }

    /* INT block (line + bar) */
    .tgrid-intblock{
      display:flex;
      flex-direction: column;
      align-items:flex-end;
      gap: 4px;
    }

    .tgrid-intline{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
    }

    /* Compacto: que sea 1 lnea real (Nombre + INT + #) */
    .top3-mini-row.compact .tgrid-right{
      flex-direction: row;
      align-items:center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-intblock{
      flex-direction: row;
      align-items:center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-bar{
      width: 34px;
    }

    .tgrid-int{
      font-weight: 950;
      font-size: 14px;
      letter-spacing: 0.01em;
      line-height: 1;
      color: rgba(226,232,240,0.98);
      min-width: 72px;
      text-align:right;
    }

    .tgrid-int.muted{ color: rgba(148,163,184,0.92); }
    .tgrid-int.lapped{ color: rgba(148,163,184,0.78); }

    .top3-mini-row.duel{
      border-color: rgba(45,107,255,0.42);
      box-shadow: 0 0 16px rgba(255,43,43,0.12);
    }
    .top3-mini-row.duel .tgrid-int{
      color: rgba(45,107,255,0.98);
      text-shadow: 0 0 10px rgba(45,107,255,0.26);
    }

    /* Badge DUEL/ATK/DEF */
    .tgrid-badge{
      height: 16px;
      padding: 0 8px;
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight: 950;
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(148,163,184,0.18);
      background: rgba(148,163,184,0.08);
      color: rgba(226,232,240,0.90);
    }
    .tgrid-badge.duel{ border-color: rgba(45,107,255,0.45); background: rgba(255,43,43,0.10); }
    .tgrid-badge.atk{ border-color: rgba(255,122,24,0.55); background: rgba(255,122,24,0.12); }
    .tgrid-badge.def{ border-color: rgba(255,43,43,0.55); background: rgba(255,43,43,0.12); }

    /* Mini barra de gap */
    .tgrid-bar{
      width: 42px;
      height: 6px;
      border-radius: 999px;
      background: rgba(148,163,184,0.16);
      border: 1px solid rgba(148,163,184,0.14);
      overflow:hidden;
    }
    .tgrid-bar > i{
      display:block;
      height: 100%;
      width: 0%;
      background: rgba(226,232,240,0.85);
      border-radius: 999px;
    }
    .top3-mini-row.duel .tgrid-bar{ border-color: rgba(255,43,43,0.28); background: rgba(255,43,43,0.10); }
    .top3-mini-row.duel .tgrid-bar > i{ background: rgba(255,43,43,0.90); }

    /* Compacto P4-P20 (1 lnea pro) */
    .top3-mini-grid.expanded .top3-mini-row.compact{ padding: 5px 10px; }
    .top3-mini-row.compact .tgrid-sub{ display:none; }
    .top3-mini-row.compact .tgrid-name{ max-width: 46vw; }
    .top3-mini-row.compact .tgrid-int{ font-size: 12px; min-width: 70px; }

    /* Trend   */
    .tgrid-trend{
      font-weight: 900;
      font-size: 11px;
      opacity: 0.95;
      margin-left: 6px;
    }

    #lapChart {
      width: 100%;
      height: var(--lapchart-h, 120px);
      display: block;
            border-radius: 10px;
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(255,43,43,0.18);
    }

@media (min-height: 750px) {
      .app {
        padding-top: 12px;
      }
    }
  

    /* ULTRA COMPACT THEME OVERRIDES (v5.0.0) */
    :root {
      --radius-lg: 14px;
      --shadow-strong: none;
      --shadow-soft: none;
      --border-soft: rgba(148,163,184,0.28);
    }

    body {
      background-image: radial-gradient(circle at 25% 15%, rgba(255,43,43,0.10), transparent 55%), radial-gradient(circle at 85% 0%, rgba(255,255,255,0.04), transparent 55%) !important;
      background-color: #050508 !important;
      color-scheme: dark;
    }

    .app {
      max-width: 460px;
      padding: 8px 10px 10px;
      gap: 8px;
    }

    .app-header {
      padding: 8px 10px;
    }

    .pilot-section {
      padding: 8px 10px 10px;
    }

    .pilot-timings {
      gap: 5px;
      margin-top: 5px;
    }

    .timing-item {
      padding: 5px 6px 6px;
            border-radius: 10px;
      background: rgba(2,6,23,0.78);
    }

    .timing-label {
      font-size: 9px;
      letter-spacing: 0.12em;
      margin-bottom: 1px;
    }

    .timing-value {
      font-size: 12px;
    }

    .lap-chart-wrap {
      margin-top: 6px;
      padding: 6px 8px;
            border-radius: 10px;
      background: rgba(2,6,23,0.62);
    }

    .controls-section {
      padding: 8px 10px 10px;
      gap: 8px;
      background: rgba(2,6,23,0.82);
    }

    .buttons-row {
      gap: 6px;
    }

    .btn-primary, .btn-secondary, .btn-grid {
      padding: 10px 10px;
      border-radius: 14px;
      font-size: 12px;
      letter-spacing: 0.08em;
      box-shadow: none !important;
    }

    .rate-row {
      gap: 8px;
    }

    input[type="range"] {
      height: 3px;
      background: linear-gradient(90deg, #111827, var(--accent-orange), var(--accent-red));
    }

    input[type="range"]::-webkit-slider-thumb {
      width: 14px;
      height: 14px;
      box-shadow: none;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      box-shadow: none;
    }

    .spotter-section {
      padding: 0;
      background: transparent;
      border: none;
    }

    .spotter-cat {
      padding: 6px 6px 7px;
      gap: 6px;
      background: rgba(2,6,23,0.58);
      border: 1px solid rgba(148,163,184,0.22);
    }

    .spotter-cat-head {
      padding: 4px 8px;
      font-size: 9px;
      letter-spacing: 0.12em;
            border-radius: 10px;
      background: rgba(15,23,42,0.68);
    }

    .spotter-cat .cat-dot {
      width: 7px;
      height: 7px;
      box-shadow: none;
    }

    .spotter-grid {
      gap: 4px;
    }

    .spotter-btn {
      min-height: 26px;
      padding: 5px 6px;
      font-size: 10px;
      letter-spacing: 0.07em;
            border-radius: 10px;
      background: rgba(10,18,32,0.92);
      border-color: rgba(148,163,184,0.22);
      color: rgba(226,232,240,0.72);
    }

    .spotter-btn span {
      font-size: 11px;
    }

    .spotter-btn.active {
      background: rgba(15,23,42,0.92) !important;
      color: rgba(255,255,255,0.96) !important;
      box-shadow: none !important;
    }

    .spotter-cat[data-cat="essential"] .spotter-btn.active {
      border-color: rgba(45,107,255,0.80) !important;
    }

    .spotter-cat[data-cat="battle"] .spotter-btn.active {
      border-color: rgba(255,122,24,0.88) !important;
    }

    .spotter-cat[data-cat="summary"] .spotter-btn.active {
      border-color: rgba(255,43,43,0.78) !important;
    }

    .extras-section {
      zoom: 0.67;

      padding: 8px 10px 10px;
      gap: 8px;
      background: rgba(2,6,23,0.82);
    }

    .precision-buttons {
      gap: 5px;
    }

    .precision-badge {
      padding: 6px 0;
      font-size: 10px;
      letter-spacing: 0.06em;
            border-radius: 10px;
      box-shadow: none !important;
    }

    .precision-badge.active {
      background: rgba(15,23,42,0.92) !important;
      border-color: rgba(255,122,24,0.88) !important;
      color: rgba(255,255,255,0.96) !important;
    }

    .toggle-row {
      padding: 8px 10px;
            border-radius: 10px;
    }

    .grid-button-row {
      gap: 6px;
    }

    .hint-text {
      display: none;
    }

    /* Small screens: 2 columns for buttons */
    @media (max-width: 420px) {
      .spotter-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

  
    .btn-secondary.off{opacity:0.65;filter:grayscale(0.2);}
  /* Race Director modes */
    .rd-mode-row{
      display:flex;
      gap:10px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .rd-mode{
      flex:1 1 110px;
      min-width:110px;
      text-transform:none;
      letter-spacing:.2px;
      opacity:.82;
    }
    .rd-mode.active{
      opacity:1;
      outline:2px solid rgba(255,255,255,.22);
      box-shadow: 0 0 0 2px rgba(0,0,0,.35) inset;
    }

    /* Botones activos con color fuerte (tipo VOZ ACTIVA) */
    .btn-secondary.active,
    .btn-pill.active,
    .spotter-btn.active,
    .rd-mode.active{
      opacity: 1 !important;
      filter: none !important;
      transform: translateY(-1px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      border-color: rgba(255,255,255,.22);
    }

    /* RD ON/OFF */
    #rdToggleBtn.active{ background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75)); color:#0b0f14; border-color: rgba(255,255,255,.18); }
    #rdToggleBtn:not(.active){ background: rgba(255,255,255,.06); color: rgba(255,255,255,.82); }

    /* Modos - colores por personalidad */
    #rdModeMinimal.active { background: linear-gradient(135deg, rgba(0,229,255,.95), rgba(0,140,255,.75)); color:#071018; }
    #rdModeStratega.active{ background: linear-gradient(135deg, rgba(255,215,0,.95), rgba(255,140,0,.80)); color:#101015; }
    #rdModeCoach.active   { background: linear-gradient(135deg, rgba(255,0,140,.92), rgba(160,80,255,.78)); color:#0b0f14; }

    /* Modos extra - colores por personalidad */
    #rdModeSarca.active    { background: linear-gradient(135deg, rgba(255,40,40,.95), rgba(255,140,0,.80)); color:#101015; }
    #rdModeEngineer.active { background: linear-gradient(135deg, rgba(34,197,94,.92), rgba(0,229,255,.75)); color:#071018; }
    #rdModeHype.active     { background: linear-gradient(135deg, rgba(160,80,255,.92), rgba(255,0,140,.78)); color:#0b0f14; }

    /* Auto Locutor - colores por estilo */
    #autoLocutorPro.active { background: linear-gradient(135deg, rgba(0,229,255,.95), rgba(0,140,255,.75)); color:#071018; }
    #autoLocutorPicante.active { background: linear-gradient(135deg, rgba(255,40,40,.95), rgba(255,140,0,.80)); color:#101015; }
    #autoLocutorEngineer.active { background: linear-gradient(135deg, rgba(34,197,94,.92), rgba(0,229,255,.75)); color:#071018; }
    #autoLocutorNarrativo.active { background: linear-gradient(135deg, rgba(255,0,229,.92), rgba(0,229,255,.65)); color:#071018; }

    /* Botn Leer resumen */
    #speakBtn.active{ background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,170,0,.70)); color:#0b0f14; }

    /* Desplegables */
    .select-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-top:10px;
      padding:10px 12px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
    }
    .select-label{
      font-weight:700;
      letter-spacing:.2px;
      color: rgba(255,255,255,.92);
    }
    select.spotter-select{
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      border-radius:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.95);
      font-weight:800;
      min-width: 180px;
      outline:none;
    }
    select.spotter-select:focus{
      border-color: rgba(0,229,255,.55);
      box-shadow: 0 0 0 3px rgba(0,229,255,.15);
    }
    #precisionSelect{ display:none !important; }

    /* Controles superiores - botones tipo "Activar voz" (compactos) */
    .controls-section .btn-secondary{
      padding: 7px 10px;
      font-size: 12px;
      letter-spacing: 0.06em;
    }
    .btn-hot{
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: var(--shadow-soft);
    }
    .btn-hot:hover{
      background: rgba(255,255,255,0.09);
    }

    /* Voz: OFF (naranja) / ON (verde) */
    .btn-voice{
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      box-shadow: var(--shadow-strong);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .btn-voice.voice-on{
      background: linear-gradient(135deg, rgba(0,255,140,.92), rgba(0,170,90,.80));
      color:#06110c;
      box-shadow: var(--shadow-strong);
      border: 1px solid rgba(255,255,255,0.10);
    }

    /* Leer resumen: se ilumina al presionar */
    .btn-speak{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    .btn-speak.active{
      background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,170,0,.75));
      color:#0b0f14;
      box-shadow: var(--shadow-strong);
    }

    /* RD: OFF (gris) / ON (naranja) */
    .btn-rd{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    .btn-rd.active{
      background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75));
      color:#0b0f14;
      box-shadow: var(--shadow-strong);
    }

    /* Modos: base discreta, activo con color por modo */
    .btn-mode{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    #rdModeMinimal.active { background: linear-gradient(135deg, rgba(0,229,255,.92), rgba(0,140,255,.75)); color:#071018; box-shadow: var(--shadow-strong); }
    #rdModeStratega.active{ background: linear-gradient(135deg, rgba(255,215,0,.95), rgba(255,140,0,.80)); color:#101015; box-shadow: var(--shadow-strong); }
    #rdModeCoach.active   { background: linear-gradient(135deg, rgba(255,0,140,.92), rgba(160,80,255,.78)); color:#0b0f14; box-shadow: var(--shadow-strong); }

    /* Mensajes del spotter - color por grupo */
    .spotter-cat[data-cat="essential"] .spotter-btn{ border-color: rgba(255,70,70,0.34); }
    .spotter-cat[data-cat="battle"]    .spotter-btn{ border-color: rgba(255,170,0,0.32); }
    .spotter-cat[data-cat="summary"]   .spotter-btn{ border-color: rgba(0,255,140,0.28); }

    /* === Mensajes del spotter: colores por seccin + botones pintados al encender === */
    :root{
      --cat-ess: rgba(255,60,60,1);      /* rojo */
      --cat-bat: rgba(255,170,0,1);      /* mbar */
      --cat-res: rgba(0,220,120,1);      /* verde */
    }

    /* Bordes base por seccin (apagado) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{ border-color: rgba(255,60,60,.55); }
    .spotter-cat[data-cat="battle"]     .spotter-btn{ border-color: rgba(255,170,0,.55); }
    .spotter-cat[data-cat="summary"]    .spotter-btn{ border-color: rgba(0,220,120,.55); }

    /* Texto base (apagado) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{ color: rgba(255,235,235,.92); }
    .spotter-cat[data-cat="battle"]     .spotter-btn{ color: rgba(255,245,225,.92); }
    .spotter-cat[data-cat="summary"]    .spotter-btn{ color: rgba(230,255,242,.92); }

    /* Encendido: pintado completo */
    .spotter-cat[data-cat="essentials"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,60,60,.95), rgba(255,110,60,.75));
      border-color: rgba(255,255,255,.14);
      color:#140606;
      box-shadow: var(--shadow-strong);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,170,0,.95), rgba(255,90,0,.75));
      border-color: rgba(255,255,255,.14);
      color:#141006;
      box-shadow: var(--shadow-strong);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(0,220,120,.92), rgba(0,170,90,.75));
      border-color: rgba(255,255,255,.14);
      color:#04110a;
      box-shadow: var(--shadow-strong);
    }

    /* LAPS siempre encendido: que se vea "bloqueado" pero pintado como su seccin */
    .spotter-btn.locked{
      opacity: .95;
      cursor: default;
    }

    /* Match botones con su seccin (apagado tambin) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{
      background: rgba(255,60,60,0.10);
      border-color: rgba(255,60,60,0.60);
      color: rgba(255,240,240,0.95);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn{
      background: rgba(255,170,0,0.10);
      border-color: rgba(255,170,0,0.60);
      color: rgba(255,248,235,0.95);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn{
      background: rgba(0,220,120,0.10);
      border-color: rgba(0,220,120,0.60);
      color: rgba(235,255,245,0.95);
    }

    /* Hover con ms presencia, sin cambiar de seccin */
    .spotter-cat[data-cat="essentials"] .spotter-btn:hover{ background: rgba(255,60,60,0.14); }
    .spotter-cat[data-cat="battle"] .spotter-btn:hover{ background: rgba(255,170,0,0.14); }
    .spotter-cat[data-cat="summary"] .spotter-btn:hover{ background: rgba(0,220,120,0.14); }

    /* Cuando est locked (LAPS), que se vea firme */
    .spotter-btn.locked{
      outline: 2px solid rgba(255,255,255,0.06);
    }

    /* FIX: data-cat values (essential/battle/summary) + colores por seccin */
    .spotter-cat[data-cat="essential"] .spotter-btn{
      background: rgba(255,60,60,0.10) !important;
      border-color: rgba(255,60,60,0.60) !important;
      color: rgba(255,240,240,0.95) !important;
    }
    .spotter-cat[data-cat="battle"] .spotter-btn{
      background: rgba(255,170,0,0.10) !important;
      border-color: rgba(255,170,0,0.60) !important;
      color: rgba(255,248,235,0.95) !important;
    }
    .spotter-cat[data-cat="summary"] .spotter-btn{
      background: rgba(0,220,120,0.10) !important;
      border-color: rgba(0,220,120,0.60) !important;
      color: rgba(235,255,245,0.95) !important;
    }

    .spotter-cat[data-cat="essential"] .spotter-btn:hover{ background: rgba(255,60,60,0.14) !important; }
    .spotter-cat[data-cat="battle"] .spotter-btn:hover{ background: rgba(255,170,0,0.14) !important; }
    .spotter-cat[data-cat="summary"] .spotter-btn:hover{ background: rgba(0,220,120,0.14) !important; }

    /* Encendido pintado por seccin (corrige essential) */
    .spotter-cat[data-cat="essential"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,60,60,.95), rgba(255,110,60,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#140606 !important;
      box-shadow: var(--shadow-strong) !important;
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,170,0,.95), rgba(255,90,0,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#141006 !important;
      box-shadow: var(--shadow-strong) !important;
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(0,220,120,.92), rgba(0,170,90,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#04110a !important;
      box-shadow: var(--shadow-strong) !important;
    }

    /* Precisin - botones como el resto (compactos y con "ON" pintado) */
    .precision-badge{
      padding: 7px 10px !important;
      font-size: 12px !important;
      letter-spacing: 0.06em !important;
      border-radius: 12px !important;
      background: rgba(255,255,255,0.07) !important;
      border: 1px solid rgba(255,255,255,0.14) !important;
      color: rgba(255,255,255,0.92) !important;
      box-shadow: var(--shadow-soft) !important;
      min-width: 108px;
    }
    .precision-badge:hover{
      background: rgba(255,255,255,0.10) !important;
    }
    .precision-badge.active{
      background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75)) !important;
      color: #0b0f14 !important;
      border-color: rgba(255,255,255,0.14) !important;
      box-shadow: var(--shadow-strong) !important;
    }

    .app-header{ position: relative; overflow:hidden; }
    .app-header::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      border-radius: inherit;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    .app-header::after{
      content:"";
      position:absolute;
      left:0; right:0; top:0;
      height:2px;
      background: linear-gradient(90deg, rgba(255,40,40,0.0), rgba(255,40,40,0.55), rgba(255,140,0,0.55), rgba(255,140,0,0.0));
      opacity:.75;
      pointer-events:none;
    }





    /* Premium - Header vivo solo cuando esta LIVE (sin casino) */
    @keyframes headerBreath {
      0%, 100% { box-shadow: 0 10px 28px rgba(0,0,0,0.55), inset 0 0 0 1px rgba(255,255,255,0.06); }
      50% { box-shadow: 0 12px 34px rgba(0,0,0,0.62), 0 0 18px rgba(var(--accent-rgb), 0.22), inset 0 0 0 1px rgba(255,255,255,0.08); }
    }
    @keyframes ledSweep {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }
    .app-header.live-on{
      animation: headerBreath 3.6s ease-in-out infinite;
    
      height:200px;
      min-height:200px;
    }
    .app-header.live-on::after{
      opacity: .98;
      background-size: 200% 100%;
      animation: ledSweep 2.8s linear infinite;
    }
    .header-actions-row{ position: relative; }
    .app-header.live-on .header-actions-row::after{
      content: "";
      position: absolute;
      left: 0; right: 0;
      bottom: -4px;
      height: 1px;
      background: linear-gradient(90deg, rgba(0,0,0,0), rgba(var(--accent-rgb), .70), rgba(var(--accent2-rgb), .45), rgba(0,0,0,0));
      opacity: .85;
      pointer-events: none;
      filter: blur(.2px);
    }
    /* Header layout - ttulo manda */
    .header-left{ gap: 3px; }
    .header-title-main{
      font-size: 20px;
      letter-spacing: 0.06em;
      line-height: 1.12;
      gap: 10px;
      align-items: baseline;
    }
    #raceTitleText{
      /* Wrap PRO: evita guion al inicio de linea y reduce cortes feos */
      font-size: calc(0.67em + 0px);
      display:block;
      min-width: 0;
      max-width: 240px;
      width: 240px;
      flex: 0 0 240px;
      white-space: normal;
      word-break: keep-all;
      overflow-wrap: break-word;
      text-wrap: balance;
      /* Max 3 lineas, altura tope 60px */
      max-height: 56px;
      line-height: 1.15;
      overflow: hidden;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
    }

    #raceSubtitle{
      /* Subtitle: 1 linea, ancho fijo, ellipsis */
      max-width: 215px;
      width: 215px;
      font-size: 12px;
      line-height: 1.15;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: block;
    }

    #raceTitleText .flagImg{
      width: 20px;
      height: 20px;
      margin-right: 8px;
      vertical-align: -3px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.65));
      border-radius: 3px;
    }


    .badge-mode{
      font-size: 10px;
      padding: 3px 9px;
      letter-spacing: 0.08em;
    }
    .header-title-sub{
      font-size: 11px;
      letter-spacing: 0.08em;
      opacity: .95;
    }
    .header-subline{
      font-size: 10px;
      color: rgba(255,255,255,0.86);
    }
    .header-mini{
      font-size: 9px;
      opacity: .9;
    }
        .badge-live{
      padding: 4px 10px;
      font-size: 11px;
    }
    .header-version{
      font-size: 9px;
      opacity: .85;
    }
    .header-version-row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      flex-wrap: wrap;
      width:100%;
    }

    /* Timing colors (F1 style) */
    .timing-value.lap-purple{ color: rgb(192,132,252); }
    .timing-value.lap-green{  color: rgb(34,197,94); }
    .timing-value.lap-yellow{ color: rgb(251,191,36); }
    .timing-value.lap-neutral{ color: rgba(255,255,255,0.92); }
    .timing-value.lap-avg{ color: rgba(186,230,253,0.92); }

    /* LTIMA ms grande */
    #lastLap{
      font-size: 18px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    /* Flash solo en la última vuelta (pop) - con glow por color */
    #lastLap.flash{ transform: scale(1.28); }
    #lastLap.flash.lap-purple{ text-shadow: 0 0 14px rgba(192,132,252,0.85); }
    #lastLap.flash.lap-green{  text-shadow: 0 0 14px rgba(34,197,94,0.85); }
    #lastLap.flash.lap-yellow{ text-shadow: 0 0 14px rgba(251,191,36,0.85); }
    #lastLap.flash.lap-neutral{ text-shadow: 0 0 12px rgba(255,255,255,0.25); }

    /* Timing KPI sizes */
    #lastLap{ font-size: 22px; letter-spacing: 0.02em; }
    #bestLap, #meanLap{ font-size: 18px; letter-spacing: 0.01em; }
    /* Pop ms evidente en LTIMA */
    #lastLap.flash{ transform: scale(1.28); text-shadow: 0 0 14px rgba(255,90,0,0.35); }

    /* RD modos - permitir wrap en pantallas chicas */
    .rd-mode-row{ flex-wrap: wrap; }

    /* v0.0.0.44 - ocultar botones RD avanzados (se decide en background) */
    #rdModeSarca, #rdModeEngineer, #rdModeHype{ display:none !important; }

    /* PATCH v5.0.0 - RD ON verde + consistencia UI */
    #rdToggleBtn.active{
      background: linear-gradient(135deg, #16a34a, #22c55e) !important;
      color: #07120a !important;
      border-color: rgba(34,197,94,.55) !important;
      box-shadow: 0 0 12px rgba(34,197,94,.85) !important;
    }
    #rdToggleBtn.off{
      background: rgba(255,255,255,.06) !important;
      color: rgba(255,255,255,.82) !important;
      box-shadow: none !important;
    }

    /* Manual - modal ayuda (single-file friendly) */
    .header-help{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      padding: 4px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      user-select: none;
    }
    .header-help:hover{ filter: brightness(1.15); }
    .header-auto{ min-width: 62px; padding: 8px 10px; font-size: 12px; letter-spacing: 0.06em; }
    @media (max-width: 560px){ .header-auto{ min-width: 56px; padding: 7px 8px; font-size: 11px; } }

    .header-help:active{ transform: translateY(1px); }

    /* Skin button (toggle look) */
    .header-skin{
      min-width: 54px;
    }
    .header-skin.active{
      background: linear-gradient(135deg, rgba(255,43,43,.92), rgba(255,59,59,.72));
      color: #12060a;
      border-color: rgba(255,255,255,0.18);
      box-shadow: 0 0 14px rgba(255,43,43,.35);
    }

    .manual-backdrop{
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .manual-backdrop.open{ display:flex; }
    .manual-panel *{ max-width: 100%; }
    .manual-panel{
      width: min(450px, 100%);
      max-height: 92vh;
      overflow-y: auto;
      overflow-x: hidden; -webkit-overflow-scrolling: touch;
      border-radius: 18px;
      border: 1px solid rgba(249,115,22,0.55);
      background: linear-gradient(145deg, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      box-shadow: 0 0 0 1px rgba(0,0,0,0.65), 0 20px 60px rgba(0,0,0,0.65);
      padding: 14px;
    }
    .manual-top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .manual-title{
      font-size: 16px;
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .manual-sub{
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    .manual-title, .manual-sub{ word-break: normal; overflow-wrap: break-word; }

    .manual-close{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
            border-radius: 10px;
      padding: 6px 10px;
      font-weight: 900;
      cursor: pointer;
    }
    .manual-close:hover{ filter: brightness(1.15); }

    /* Manual tabs (v0.0.2.12) */
    .manual-tabs{
      display:flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: flex-start;
      margin: 8px 0 10px;
      padding: 8px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
      position: sticky;
      top: 0;
      z-index: 2;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .manual-tab{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.90);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      user-select: none;
    }
    .manual-tab:hover{ filter: brightness(1.12); }
    .manual-tab:active{ transform: translateY(1px); }
    .manual-tab.active{
      background: linear-gradient(135deg, rgba(34,197,94,.92), rgba(34,197,94,.55));
      color: rgba(7,18,10,0.98);
      border-color: rgba(34,197,94,.55);
      box-shadow: 0 0 12px rgba(34,197,94,.35);
    }

    .manual-sections{ display:block; }
    .manual-section{ display:none; }
    .manual-section.active{ display:block; }

    .manual-section h3{
      margin: 4px 0 8px;
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .manual-section ol, .manual-section ul{
      margin: 0 0 10px 18px;
      padding: 0;
      color: rgba(255,255,255,0.92);
      font-size: 12px;
      line-height: 1.35;
    }
    .manual-details{
      margin: 10px 0 0;
      padding: 0;
    }
    .manual-details summary{
      cursor: pointer;
      user-select: none;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.92);
      font-weight: 800;
      outline: none;
    }
    .manual-details[open] summary{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.16);
    }
    .manual-code{
      margin: 10px 0 6px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.35;
      white-space: pre-wrap;
      overflow: auto;
    }
    .manual-note{
      margin-top: 6px;
      font-size: 11px;
      color: rgba(255,255,255,0.78);
      border-left: 3px solid rgba(249,115,22,0.65);
      padding-left: 10px;
    }
    .manual-grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    
    /* Manual table */
    .manual-wide{ grid-column: 1 / -1; }
    .manual-table-wrap{ overflow-x: hidden; -webkit-overflow-scrolling: touch; border:1px solid rgba(255,255,255,.08); border-radius:12px; }
    .manual-table{ width:100%; border-collapse: collapse; min-width: 0; table-layout: fixed; }
    .manual-table th, .manual-table td{ text-align:left; padding:10px 10px; border-bottom:1px solid rgba(255,255,255,.07); vertical-align: top; word-break: break-word; overflow-wrap: anywhere; }
    .manual-table th{ font-weight:800; opacity:.95; }
    .manual-table td code{ background: rgba(0,0,0,.35); padding:1px 6px; border-radius:8px; }
    .manual-tip{ margin-top:10px; opacity:.92; font-size:13px; }
    .manual-panel code{ word-break: break-word; overflow-wrap:anywhere; }
    .manual-panel a{ word-break: break-word; overflow-wrap:anywhere; }

@media (max-width: 860px){
      .manual-grid{ grid-template-columns: 1fr; }
    }
    .manual-card{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 10px;
    }
    .manual-card h3{
      margin: 0 0 6px 0;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .manual-card ul,
    .manual-card ol{
      margin: 0;
      padding-left: 18px;
      padding-right: 6px;
      color: rgba(255,255,255,0.88);
      font-size: 12px;
      line-height: 1.35;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .manual-card li{
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .manual-card p{ margin: 6px 0 0 0; color: rgba(255,255,255,0.88); font-size: 12px; line-height: 1.35; overflow-wrap:anywhere; word-break:break-word; }
    .manual-section{ margin-top: 10px; padding-top: 10px; border-top: 1px dashed rgba(255,255,255,0.10); }
    .manual-section:first-child{ margin-top: 0; padding-top: 0; border-top: none; }
    .manual-shotgrid{ display: grid; grid-template-columns: 1fr; gap: 10px; }
    .code-inline{ display:inline-block; padding: 1px 6px; border-radius: 8px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.10); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 11px; word-break: break-all; overflow-wrap:anywhere; }
    .manual-card ol li, .manual-card ul li{ margin: 0 0 6px 0; }
    .manual-top > div{ min-width: 0; }
    .manual-title{ max-width: 300px; overflow-wrap:anywhere; word-break:break-word; }
    .manual-shot{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.25);
      overflow: hidden;
    }
        .manual-shot figcaption{
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.8);
      border-top: 1px solid rgba(255,255,255,0.08);
    }
.manual-shot img{
      display:block;
      width:100%;
      height:auto;
    }
    .manual-shot figcaption{
      padding: 8px 10px;
      font-size: 11px;
      color: var(--text-muted);
    }
    .manual-foot{
      margin-top: 10px;
      font-size: 11px;
      color: var(--text-muted);
    }

    /* MANGA UX: flash verde en contenedor del piloto seguido */
    .pilot-card.flash-green{
      border-color: #2eea7a !important;
      box-shadow: 0 0 0 2px rgba(46,234,122,.25), 0 0 18px rgba(46,234,122,.22) !important;
    }
    .pilot-card.flash-green .pilot-card-top-strip{
      background: linear-gradient(90deg, rgba(46,234,122,.9), rgba(46,234,122,.15)) !important;
    }
    
    .timing-item.timer-only{ display:none; }

    /* MANGA reloj (mismo feeling que badges) */
    .manga-clock{
      --clock-hue: 120;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.06em;
      border: 1px solid hsla(var(--clock-hue), 95%, 60%, .55);
      color: hsl(var(--clock-hue), 95%, 62%);
      background: hsla(var(--clock-hue), 95%, 20%, .18);
      box-shadow: 0 0 0 2px hsla(var(--clock-hue), 95%, 55%, .12), 0 0 18px hsla(var(--clock-hue), 95%, 55%, .12);
      font-variant-numeric: tabular-nums;
    }

    /* Pilot-timings: tipografa consistente (última se queda igual) */
    .pilot-timings .manga-clock{
      font-size: inherit;
      font-weight: inherit;
      letter-spacing: inherit;
    }

    .manga-clock.flash{
      animation: clockFlash .35s ease-in-out 0s 2;
    }

    @keyframes clockFlash{
      0%{ transform: scale(1); filter:none; }
      50%{ transform: scale(1.12); filter: drop-shadow(0 0 10px rgba(46,234,122,.55)); }
      100%{ transform: scale(1); filter:none; }
    }

    /* Manual button - ms visible */
    #manualBtn{
      background: linear-gradient(135deg, rgba(34,197,94,.22), rgba(0,229,255,.18));
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 8px 22px rgba(0,0,0,.32);
    }
    #manualBtn:hover{ filter: brightness(1.06); }
    #manualBtn:active{ transform: translateY(1px); }

    /* Master toggle */
    .spotter-master{
      padding: 8px 10px 2px 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .spotter-master-btn{
      flex: 1 1 120px;
      width: auto;
      padding: 10px 12px;
            border-radius: 10px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.90);
      font-weight: 800;
      letter-spacing: .4px;
      cursor: pointer;
      user-select: none;
    }
    .spotter-master-btn.preset{
      background: rgba(255,255,255,.05);
    }
    .spotter-master-btn.active{
      background: linear-gradient(135deg, rgba(251,191,36,.92), rgba(249,115,22,.75));
      color: rgba(10,14,18,.92);
      border-color: rgba(255,255,255,.20);
    }

    /* Top3 mini grid - anim y flash */
    .top3-mini-row{ will-change: transform; }
    .top3-mini-row.lap-flash{
      background: rgba(34,197,94,.22);
      box-shadow: 0 0 0 1px rgba(34,197,94,.35) inset, 0 10px 24px rgba(0,0,0,.28);
    }

    /* =========================
       TIMING MINI GRID - layout fix (v6.5)
       Alineacin tipo timing screen: columnas fijas, 1 columna en Top20, lapeados cortos.
       ========================= */

    .tgrid-main{
      width: 100%;
      display: grid;
      grid-template-columns: 40px 1fr 176px 46px;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .tgrid-namewrap{ min-width: 0; }
    .tgrid-name{ max-width: none; }

    .tgrid-sub{
      display: grid;
      grid-template-columns: 34px 92px 92px 66px;
      gap: 10px;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
    }
    .tgrid-sub .tgrid-col{
      min-width: 0 !important;
    }
    .tgrid-col{ justify-content: flex-end; }
    .tgrid-col.v{ justify-content: flex-start; text-align: left; }

    .tgrid-intblock{
      justify-self: end;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
      min-width: 176px;
    }

    .top3-mini-row.compact .tgrid-intblock{
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-bar{ width: 34px; margin-left: 6px; }

    .tgrid-int{ min-width: 88px; text-align: right; }

    .tgrid-numbox{
      justify-self: end;
      min-width: 38px;
      padding: 0 10px;
    }

    /* iPhone / pantallas angostas - FIX nombre vertical en Grid Completo */
    @media (max-width: 430px){
      /* Dar mas aire al nombre y recortar con ellipsis (no letras en columna) */
      .tgrid-main{
        grid-template-columns: 38px minmax(140px, 1fr) minmax(92px, 34vw) 44px;
        gap: 8px;
      }
      .tgrid-name{
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        word-break: normal;
      }
      .tgrid-int{ min-width: 58px; }
    }

    /* === Mini Grid v2 (TOP 3 / TOP 20) - clean table style === */
    .btn-mini{
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(2,6,23,0.30);
      color: rgba(226,232,240,0.92);
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      line-height: 1;
      user-select: none;
    }
    .btn-mini:hover{ filter: brightness(1.10); }
    .btn-mini:active{ transform: translateY(1px); }

    .lap-chart-header{ display:block; }
    .lap-chart-header-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 8px;
    }
    .lap-chart-meta{ margin-top: 4px; }

    .top3-mini-grid{
      margin-top: 8px !important;
      display:block !important;
      border-radius: 14px;
      overflow:hidden;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(2,6,23,0.22);
    }
    .tgrid-head,
    .tgrid-row{
      display:grid;
      grid-template-columns: 38px 1fr 52px 76px 76px 64px;
      gap: 6px;
      align-items:center;
      padding: 7px 10px;
    }
    .tgrid-head{
      background: rgba(15,23,42,0.55);
      border-bottom: 1px solid rgba(148,163,184,0.16);
      font-size: 10px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.75);
      font-weight: 900;
    }
    .tgrid-row{
      font-size: 12px;
      border-top: 1px solid rgba(148,163,184,0.10);
    }
    .tgrid-row.pos1{ background: rgba(251,191,36,0.08); }
    .tgrid-row.pos2{ background: rgba(255,255,255,0.06); }
    .tgrid-row.pos3{ background: rgba(249,115,22,0.08); }

    .tgrid-cell{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .tgrid-pos{
      width: 34px;
      text-align:center;
      border-radius: 999px;
      padding: 4px 0;
      font-weight: 950;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(148,163,184,0.08);
      color: rgba(226,232,240,0.92);
    }
    .tgrid-name{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width:0;
    }
    .tgrid-num{
      opacity: 0.70;
      font-weight: 800;
      font-size: 11px;
    }
    .tgrid-driver{
      min-width:0;
      font-weight: 900;
    }
    .tgrid-mono{
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      text-align:right;
    }
    @media (max-width: 420px){
      .tgrid-head,
      .tgrid-row{
        grid-template-columns: 34px 1fr 48px 68px 68px 58px;
        padding: 7px 8px;
      }
      .tgrid-row{ font-size: 11px; }
    }

    /* Mini timing screen (Top3/Top20) - Opcin A */
    .top3-mini-grid{ width: 100%; }
    .top3-mini-grid.expanded{ max-height: none; overflow: visible; }
    .top3-mini-grid .mini-timing{
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    .top3-mini-grid .mini-timing thead th{
      position: sticky;
      top: 0;
      z-index: 2;
      background: rgba(10,15,25,0.96);
      color: rgba(226,232,240,0.92);
      font-size: 12px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      border-bottom: 1px solid rgba(148,163,184,0.20);
      padding: 6px 8px;
    }
    .top3-mini-grid .mini-timing tbody td{
      border-bottom: 1px solid rgba(148,163,184,0.10);
      padding: 4px 6px;
      font-size: 12px;
      color: rgba(226,232,240,0.92);
      vertical-align: middle;
    }
    .top3-mini-grid .mini-timing tbody tr.pos1{ background: rgba(251,191,36,0.08); }
    .top3-mini-grid .mini-timing tbody tr.pos2{ background: rgba(255,255,255,0.05); }
    .top3-mini-grid .mini-timing tbody tr.pos3{ background: rgba(249,115,22,0.07); }
    .top3-mini-grid .mini-timing tbody tr:hover{ background: rgba(255,43,43,0.08); }
    .top3-mini-grid .mini-timing tbody tr.pos1 .mt-p{ color: rgba(251,191,36,0.95); font-weight: 900; }
    .top3-mini-grid .mini-timing tbody tr.pos2 .mt-p{ color: rgba(203,213,225,0.95); font-weight: 900; }
    .top3-mini-grid .mini-timing tbody tr.pos3 .mt-p{ color: rgba(205,127,50,0.95); font-weight: 900; }

    /* Mini rows estilo scoreboard (solo cuando expanded) */
    .top3-mini-grid.expanded .mini-rows{
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .top3-mini-grid.expanded .mini-head{
      display: grid;
      grid-template-columns: 28px minmax(0,1fr) 34px 70px 58px 48px;
      column-gap: 6px;
      gap: 0;
      padding: 2px 6px 6px 6px;
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.80);
    }
    .top3-mini-grid.expanded .mini-head > div{
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .top3-mini-grid.expanded .mini-head > div:nth-child(n+3),
    .top3-mini-grid.expanded .mini-row > div:nth-child(n+3){
      justify-self: end;
    }

    .top3-mini-grid.expanded .mini-row > div:nth-child(5){
      font-weight: 900;
      letter-spacing: 0.02em;
    }

    .top3-mini-grid.expanded .mini-row{
      display: grid;
      grid-template-columns: 28px minmax(0,1fr) 34px 70px 58px 48px;
      column-gap: 6px;
      align-items: center;
            border-radius: 10px;
            padding: 5px 6px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(10,15,25,0.55);
      box-shadow: 0 8px 22px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.08);
    }
    .top3-mini-grid.expanded .mini-row.pos1{ background: rgba(251,191,36,0.08); }
    .top3-mini-grid.expanded .mini-row.pos2{ background: rgba(255,255,255,0.05); }
    .top3-mini-grid.expanded .mini-row.pos3{ background: rgba(249,115,22,0.07); }
    .top3-mini-grid.expanded .mini-row:hover{ background: rgba(255,43,43,0.08); }

    .top3-mini-grid.expanded .mr-pos{
      width: 26px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      font-weight: 900;
      color: rgba(255,255,255,0.95);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.12);
      margin-left: 2px;
    }
    .top3-mini-grid.expanded .mini-row.pos1 .mr-pos{ color: rgba(251,191,36,0.98); }
    .top3-mini-grid.expanded .mini-row.pos2 .mr-pos{ color: rgba(203,213,225,0.98); }
    .top3-mini-grid.expanded .mini-row.pos3 .mr-pos{ color: rgba(205,127,50,0.98); }

    .top3-mini-grid.expanded .mr-name{
      display: block;
      line-height: 1.06;
      padding-right: 6px;
    }
    .top3-mini-grid.expanded .mr-line{
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: rgba(226,232,240,0.95);
      font-size: 12px;
    }
    .top3-mini-grid.expanded .mr-line2{
      font-size: 11px;
      color: rgba(226,232,240,0.78);
    }
    .top3-mini-grid.expanded .mr-mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(226,232,240,0.92);
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .top3-mini-grid.expanded .mr-st{
      text-align: right;
    }
    .top3-mini-grid.expanded .st-atk{ color: rgba(34,197,94,0.95); font-weight: 900; }
    .top3-mini-grid.expanded .st-def{ color: rgba(239,68,68,0.95); font-weight: 900; }
    .top3-mini-grid.expanded .st-duel{ color: rgba(168,85,247,0.95); font-weight: 900; }
    .top3-mini-grid.expanded .st-na{ color: rgba(226,232,240,0.70); }


    .top3-mini-grid .mt-pos{ width: 30px; }
    .top3-mini-grid .mt-laps{ width: 36px; }
    .top3-mini-grid .mt-last{ width: 76px; }
    .top3-mini-grid .mt-gap{ width: 66px; }
    .top3-mini-grid .mt-st{ width: 56px; text-align: right; }

    .top3-mini-grid .mt-name{ width: auto; }
    .top3-mini-grid .mt-driver{
      display: block;
      max-width: 100%;
      white-space: normal;
      line-height: 1.08;
    }
    .top3-mini-grid .mt-line{
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .top3-mini-grid .mt-num{
      display: inline-block;
      margin-left: 6px;
      font-size: 11px;
      opacity: 0.85;
    }
    .top3-mini-grid .mt-mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-variant-numeric: tabular-nums;
      text-align: right;
    }
    .top3-mini-grid .mt-p{
      display: inline-flex;
      min-width: 22px;
      justify-content: center;
      font-weight: 900;
    }
    .top3-mini-grid .mt-badge{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 44px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 0.05em;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(148,163,184,0.10);
      color: rgba(226,232,240,0.95);
    }
    .top3-mini-grid .mt-atk{ border-color: rgba(255,122,24,0.55); background: rgba(255,122,24,0.12); }
    .top3-mini-grid .mt-def{ border-color: rgba(255,43,43,0.55); background: rgba(255,43,43,0.12); }
    .top3-mini-grid .mt-duel{ border-color: rgba(45,107,255,0.45); background: rgba(255,43,43,0.10); }

    /* ===== Configuracin activa + Presets por sesin ===== */
    .config-status-card{
      margin: 10px 0 14px;
      padding: 12px 12px 10px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 10px 22px rgba(0,0,0,0.25);
    }
    .config-status-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .config-status-title{
      font-weight: 800;
      letter-spacing: 0.4px;
      font-size: 12px;
      opacity: 0.96;
    }
    .config-status-badges{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    .cfg-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 5px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 800;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
    }
    .cfg-pill-session{border-color: rgba(0, 255, 163, 0.25);}
    .cfg-pill-auto{border-color: rgba(255, 166, 0, 0.30);}
    .config-status-line{
      font-size: 12px;
      opacity: 0.95;
      display:flex;
      flex-wrap:wrap;
      gap:6px 8px;
      align-items:center;
    }
    .cfg-label{opacity:0.70; font-weight:700;}
    .cfg-value{font-weight:900;}
    .cfg-sep{opacity:0.35; padding: 0 4px;}
    .session-presets{margin-top:10px;}
    .session-presets-header{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;}
    .session-presets-title{font-size: 12px; font-weight: 900; opacity:0.9;}
    .session-presets-note{font-size: 11px; opacity:0.65; font-weight:700;}
    .session-preset-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 10px;
    }
    .session-preset-card{
      text-align:left;
      padding: 10px 10px 8px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.28);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      min-height: 108px;
    }
    .session-preset-card:hover{transform: translateY(-1px); border-color: rgba(255,255,255,0.18);}
    .session-preset-card.active{
      border-color: rgba(255, 166, 0, 0.55);
      background: rgba(255, 166, 0, 0.10);
      box-shadow: 0 10px 18px rgba(0,0,0,0.25);
    }
    .spc-head{display:flex; justify-content:space-between; align-items:center; gap:8px;}
    .spc-name{font-size:12px; font-weight:900;}
    .spc-tag{
      font-size: 10px;
      font-weight: 900;
      opacity:0.75;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .spc-sub{font-size: 10.5px; opacity:0.70; margin-top:4px; line-height:1.2;}
    .spc-toggles, .session-now-toggles{
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
      margin-top: 8px;
    }
    .toggle-pill{
      font-size: 10px;
      font-weight: 900;
      padding: 4px 7px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      opacity: 0.55;
    }
    .toggle-pill.on{
      opacity: 0.95;
      border-color: rgba(0, 255, 163, 0.28);
      background: rgba(0, 255, 163, 0.12);
    }
    .toggle-pill.off{
      opacity: 0.35;
      border-style: dashed;
    }
    .session-now{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed rgba(255,255,255,0.12);
    }
    .session-now-title{
      font-size: 11px;
      font-weight: 900;
      opacity: 0.80;
      margin-bottom: 6px;
    }
    @media (max-width: 520px){
      .session-preset-grid{grid-template-columns: 1fr;}
      .session-preset-card{min-height: auto;}
    }

    /* === UI simplificada: por defecto escondemos paneles "expert" === */
    body:not(.debug) .expert-only{display:none !important;}
    body.debug .expert-only{display:block !important;}

    /* v0.0.1.00: controls-section compacto (50%) - oculto por defecto, visible solo en debug */
    body.debug #controlsSection{
      padding: 4px 6px 6px !important;
      gap: 5px !important;
    }
    body.debug #controlsSection .buttons-row{ gap: 4px !important; }
    body.debug #controlsSection .btn-secondary,
    body.debug #controlsSection .btn-primary,
    body.debug #controlsSection .btn-grid{
      padding: 5px 6px !important;
      font-size: 10px !important;
      letter-spacing: 0.06em !important;
      border-radius: 10px !important;
      min-height: 0 !important;
    }
    body.debug #controlsSection .controls-label{ font-size: 9px !important; }
    body.debug #controlsSection .config-status-card{ padding: 6px 8px !important; }
    body.debug #controlsSection .cfg-pill{ font-size: 9px !important; padding: 2px 6px !important; }
    body.debug #controlsSection .session-presets-title{ font-size: 10px !important; }
    body.debug #controlsSection .spc-name{ font-size: 10px !important; }
    body.debug #controlsSection .spc-sub{ font-size: 9px !important; }
    body.debug #controlsSection .precision-badge{ font-size: 9px !important; padding: 3px 6px !important; border-radius: 9px !important; }


    
    /* Debug strip (solo body.debug) */
    .debugstrip{
      display:none;
      position: sticky;
      top: 0;
      z-index: 50;
      margin: 8px 10px 0;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: 11px;
      letter-spacing: .2px;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    body.debug .debugstrip{ display:flex; }
    .debugstrip .dbg-item{ display:flex; gap:6px; align-items:center; }
    .debugstrip .dbg-k{
      font-weight:800;
      padding:2px 6px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
    }
    .debugstrip .dbg-v{ font-weight:700; opacity: .95; }


    /* Debug speech log (solo body.debug) */
    .speechlog { display:none; position:fixed; left:10px; right:10px; bottom:10px;
      background: rgba(0,0,0,.78); border:1px solid rgba(255,255,255,.12);
      border-radius:12px; padding:10px 10px 8px; z-index:9999; backdrop-filter: blur(6px);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      max-height: 38vh; overflow:auto;
    }
    body.debug .speechlog { display:block; }
    .speechlog-title { font-weight:700; font-size:12px; letter-spacing:.6px; opacity:.9; margin-bottom:6px; }
    .speechlog-list { font-size:12px; line-height:1.25; }
    .speechlog-item { padding:4px 0; border-top:1px solid rgba(255,255,255,.08); }
    .speechlog-item:first-child { border-top:0; }
    .speechlog-meta { opacity:.65; font-size:11px; margin-bottom:2px; }
    .speechlog-hint { opacity:.55; font-size:11px; margin-top:6px; }


    

    /* === SKIN PRO (aplica a TODOS los temas) === */
    @keyframes proSheenMove{
      0%{ transform: translateX(-140%) skewX(-18deg); opacity: 0; }
      18%{ opacity: 0.0; }
      28%{ opacity: 0.24; }
      58%{ opacity: 0.16; }
      82%{ opacity: 0.0; }
      100%{ transform: translateX(140%) skewX(-18deg); opacity: 0; }
    }

    @keyframes proHdrBreath{
      0%,100%{ filter: drop-shadow(0 0 8px rgba(var(--accent-rgb,221,20,19),0.10)); }
      50%{ filter: drop-shadow(0 0 16px rgba(var(--accent-rgb,221,20,19),0.22)); }
    }

    @keyframes proHdrLine{
      0%,100%{ opacity: 0.55; }
      50%{ opacity: 0.95; }
    }

    body.skin-pro{
      --edge-hi: rgba(255,255,255,0.12);
      --edge-lo: rgba(0,0,0,0.55);
      --shadow-elev: 0 14px 32px rgba(0,0,0,0.55);
      --shadow-elev2: 0 10px 22px rgba(0,0,0,0.42);
      --shadow-inset: inset 0 1px 0 rgba(255,255,255,0.10), inset 0 -12px 18px rgba(0,0,0,0.55);

      background-color: var(--bg-dark) !important;
      background-image:
        radial-gradient(circle at 18% 12%, rgba(var(--accent-rgb,221,20,19),0.18), transparent 56%),
        radial-gradient(circle at 82% 6%, rgba(255,255,255,0.06), transparent 58%),
        radial-gradient(circle at 60% 92%, rgba(var(--accent-rgb,221,20,19),0.14), transparent 62%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.028) 0, rgba(255,255,255,0.028) 2px, rgba(0,0,0,0.0) 2px, rgba(0,0,0,0.0) 7px),
        repeating-linear-gradient(45deg, rgba(255,255,255,0.020) 0, rgba(255,255,255,0.020) 1px, rgba(0,0,0,0.0) 1px, rgba(0,0,0,0.0) 6px ) !important;
      background-blend-mode: screen, screen, screen, overlay, overlay !important;
    }

    body.skin-pro .app-header{
      animation: proHdrBreath 4.8s ease-in-out infinite;
    }
    body.skin-pro .app-header::after{
      animation: proHdrLine 3.6s ease-in-out infinite;
    }

    body.skin-pro .app-header,
    body.skin-pro .spotter-section,
    body.skin-pro .pilot-card,
    body.skin-pro .controls-section,
    body.skin-pro .top3-mini{
      border: 1px solid rgba(255,255,255,0.16) !important;
      box-shadow: var(--shadow-elev2), 0 0 0 1px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.06) !important;
      background-image:
        radial-gradient(120% 180% at 0% 0%, rgba(var(--accent-rgb,221,20,19),0.14), transparent 55%),
        radial-gradient(120% 180% at 100% 0%, rgba(255,255,255,0.05), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.22));
      background-blend-mode: screen, screen, normal;
      backdrop-filter: blur(7px);
      -webkit-backdrop-filter: blur(7px);
    }

    body.skin-pro .btn-primary,
    body.skin-pro .btn-secondary,
    body.skin-pro .spotter-btn,
    body.skin-pro .header-help,
    body.skin-pro .spotter-master-btn,
    body.skin-pro .btn-mini,
    body.skin-pro .btn-grid,
    body.skin-pro .session-preset-card{
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.16) !important;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22)) !important;
      box-shadow: var(--shadow-elev2), var(--shadow-inset) !important;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      transform: translateZ(0);
    }

    body.skin-pro .btn-primary::before,
    body.skin-pro .btn-secondary::before,
    body.skin-pro .spotter-btn::before,
    body.skin-pro .header-help::before,
    body.skin-pro .spotter-master-btn::before,
    body.skin-pro .btn-mini::before,
    body.skin-pro .btn-grid::before,
    body.skin-pro .session-preset-card::before{
      content: "";
      position: absolute;
      inset: -2px -2px auto -2px;
      height: 58%;
      background: radial-gradient(120% 140% at 15% 0%, rgba(255,255,255,0.22), rgba(255,255,255,0.08), transparent 70%);
      pointer-events: none;
      opacity: 0.85;
    }

    body.skin-pro .btn-primary:hover,
    body.skin-pro .btn-secondary:hover,
    body.skin-pro .spotter-btn:hover,
    body.skin-pro .header-help:hover,
    body.skin-pro .spotter-master-btn:hover,
    body.skin-pro .btn-mini:hover,
    body.skin-pro .btn-grid:hover,
    body.skin-pro .session-preset-card:hover{
      filter: brightness(1.10);
    }

    body.skin-pro .btn-primary:active,
    body.skin-pro .btn-secondary:active,
    body.skin-pro .spotter-btn:active,
    body.skin-pro .header-help:active,
    body.skin-pro .spotter-master-btn:active,
    body.skin-pro .btn-mini:active,
    body.skin-pro .btn-grid:active,
    body.skin-pro .session-preset-card:active{
      transform: translateY(1px) scale(0.99) !important;
      box-shadow: 0 8px 18px rgba(0,0,0,0.50), inset 0 1px 0 rgba(255,255,255,0.08), inset 0 -10px 16px rgba(0,0,0,0.60) !important;
    }

    /* ON pintado completo (tema) */
    body.skin-pro .btn-secondary.active,
    body.skin-pro .btn-pill.active,
    body.skin-pro .spotter-btn.active,
    body.skin-pro .spotter-master-btn.active,
    body.skin-pro .session-preset-card.active,
    body.skin-pro .precision-badge.active,
    body.skin-pro .btn-basic-mini.active,
    body.skin-pro .btn-speak.active,
    body.skin-pro .btn-rd.active,
    body.skin-pro #rdToggleBtn.active,
    body.skin-pro .toggle-pill.on,
    body.skin-pro .toggle-pill.active{
      background: linear-gradient(135deg, rgba(var(--accent-rgb,221,20,19),0.96), rgba(var(--accent2-rgb,193,74,70),0.86)) !important;
      color: rgba(18,6,10,0.98) !important;
      border-color: rgba(255,255,255,0.22) !important;
      opacity: 1 !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 26px rgba(var(--accent-rgb,221,20,19),0.26), 0 18px 34px rgba(0,0,0,0.58) !important;
      text-shadow: none !important;
    }

    /* Sheen SOLO cuando esta ON */
    body.skin-pro .btn-secondary.active::after,
    body.skin-pro .btn-pill.active::after,
    body.skin-pro .spotter-btn.active::after,
    body.skin-pro .spotter-master-btn.active::after,
    body.skin-pro .session-preset-card.active::after,
    body.skin-pro .precision-badge.active::after,
    body.skin-pro .btn-basic-mini.active::after,
    body.skin-pro .btn-speak.active::after,
    body.skin-pro .btn-rd.active::after,
    body.skin-pro #rdToggleBtn.active::after,
    body.skin-pro .toggle-pill.on::after,
    body.skin-pro .btn-primary.voice-on::after,
    body.skin-pro .btn-voice.voice-on::after{
      content: "";
      position: absolute;
      top: -10%;
      bottom: -10%;
      width: 42%;
      left: -60%;
      background: linear-gradient(90deg, rgba(255,255,255,0.00), rgba(255,255,255,0.32), rgba(255,255,255,0.00));
      transform: skewX(-18deg);
      pointer-events: none;
      mix-blend-mode: screen;
      animation: proSheenMove 3.8s ease-in-out infinite;
      opacity: 0.0;
    }

    @media (prefers-reduced-motion: reduce){
      body.skin-pro .app-header,
      body.skin-pro .app-header::after{ animation: none !important; }
      body.skin-pro .btn-secondary.active::after,
      body.skin-pro .btn-pill.active::after,
      body.skin-pro .spotter-btn.active::after,
      body.skin-pro .spotter-master-btn.active::after,
      body.skin-pro .session-preset-card.active::after,
      body.skin-pro .precision-badge.active::after,
      body.skin-pro .btn-basic-mini.active::after,
      body.skin-pro .btn-speak.active::after,
      body.skin-pro .btn-rd.active::after,
      body.skin-pro #rdToggleBtn.active::after,
      body.skin-pro .toggle-pill.on::after,
      body.skin-pro .btn-primary.voice-on::after,
      body.skin-pro .btn-voice.voice-on::after{
        animation: none !important;
        display: none !important;
      }
    }
/* === Vic Skin PRO+ (sheen + breathing glow + ON fully painted) === */
    @keyframes vicSheenMove{
      0%{ transform: translateX(-140%) skewX(-18deg); opacity: 0; }
      10%{ opacity: 0.0; }
      22%{ opacity: 0.26; }
      55%{ opacity: 0.16; }
      80%{ opacity: 0.0; }
      100%{ transform: translateX(140%) skewX(-18deg); opacity: 0; }
    }

    @keyframes vicHdrBreath{
      0%,100%{ filter: drop-shadow(0 0 8px rgba(221,20,19,0.10)); }
      50%{ filter: drop-shadow(0 0 16px rgba(221,20,19,0.22)); }
    }

    @keyframes vicHdrLine{
      0%,100%{ opacity: 0.55; }
      50%{ opacity: 0.95; }
    }

    /* Header: micro glow respirando (sutil, no arbol de navidad) */
    body.skin-vicpulse .app-header{
      animation: vicHdrBreath 4.8s ease-in-out infinite;
    }
    body.skin-vicpulse .app-header::after{
      animation: vicHdrLine 3.6s ease-in-out infinite;
    }

    /* ON = pintado completo (cubre TODOS los botones/toggles relevantes) */
    body.skin-vicpulse .btn-secondary.active,
    body.skin-vicpulse .btn-pill.active,
    body.skin-vicpulse .spotter-btn.active,
    body.skin-vicpulse .spotter-master-btn.active,
    body.skin-vicpulse .session-preset-card.active,
    body.skin-vicpulse .precision-badge.active,
    body.skin-vicpulse .btn-basic-mini.active,
    body.skin-vicpulse .btn-speak.active,
    body.skin-vicpulse .btn-rd.active,
    body.skin-vicpulse #rdToggleBtn.active,
    body.skin-vicpulse .toggle-pill.on,
    body.skin-vicpulse .toggle-pill.active{
      background: linear-gradient(135deg, rgba(221,20,19,0.96), rgba(193,74,70,0.86)) !important;
      color: rgba(18,6,10,0.98) !important;
      border-color: rgba(234,234,236,0.22) !important;
      opacity: 1 !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 26px rgba(221,20,19,0.26), 0 18px 34px rgba(0,0,0,0.58) !important;
      text-shadow: none !important;
    }

    /* VOZ ON (verde) tambien pintado completo */

    /* VOZ ON: verde solido en TODOS los temas (btn-voice / btn-voice-mini) */
    .btn-voice.voice-on,
    .btn-voice-mini.voice-on,
    .btn-secondary.btn-hot.btn-voice.voice-on,
    .btn-secondary.btn-hot.btn-voice-mini.voice-on,
    .btn-secondary.btn-hot.btn-voice.voice-on,
    .btn-secondary.btn-hot.voice-on{
      background: rgba(34,197,94,0.95) !important;
      color: rgba(255,255,255,0.96) !important;
      border-color: rgba(255,255,255,0.18) !important;
      text-shadow: none !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 18px rgba(34,197,94,0.22), 0 14px 28px rgba(0,0,0,0.55) !important;
      opacity: 1 !important;
    }

    body.skin-vicpulse .btn-primary.voice-on,
    body.skin-vicpulse .btn-voice.voice-on,
    body.skin-vicpulse .btn-speak.voice-on{
      background: rgba(34,197,94,0.95) !important;
      color: rgba(255,255,255,0.96) !important;
      border-color: rgba(255,255,255,0.18) !important;
      opacity: 1 !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 18px rgba(34,197,94,0.22), 0 14px 28px rgba(0,0,0,0.55) !important;
      text-shadow: none !important;
    }

    /* Asegura que el sheen se vea en chips/toggles */
    body.skin-vicpulse .toggle-pill,
    body.skin-vicpulse .precision-badge,
    body.skin-vicpulse .btn-basic-mini,
    body.skin-vicpulse .btn-speak,
    body.skin-vicpulse .btn-rd,
    body.skin-vicpulse #rdToggleBtn{
      position: relative;
      overflow: hidden;
    }

    /* Sheen: brillo que cruza SOLO cuando esta ON */
    body.skin-vicpulse .btn-secondary.active::after,
    body.skin-vicpulse .btn-pill.active::after,
    body.skin-vicpulse .spotter-btn.active::after,
    body.skin-vicpulse .spotter-master-btn.active::after,
    body.skin-vicpulse .session-preset-card.active::after,
    body.skin-vicpulse .precision-badge.active::after,
    body.skin-vicpulse .btn-basic-mini.active::after,
    body.skin-vicpulse .btn-speak.active::after,
    body.skin-vicpulse .btn-rd.active::after,
    body.skin-vicpulse #rdToggleBtn.active::after,
    body.skin-vicpulse .toggle-pill.on::after,
    body.skin-vicpulse .btn-primary.voice-on::after,
    body.skin-vicpulse .btn-voice.voice-on::after{
      content: "";
      position: absolute;
      top: -10%;
      bottom: -10%;
      width: 42%;
      left: -60%;
      background: linear-gradient(90deg, rgba(255,255,255,0.00), rgba(255,255,255,0.32), rgba(255,255,255,0.00));
      transform: skewX(-18deg);
      pointer-events: none;
      mix-blend-mode: screen;
      animation: vicSheenMove 3.8s ease-in-out infinite;
      opacity: 0.0;
    }

    /* Reduce motion: no animaciones */
    @media (prefers-reduced-motion: reduce){
      body.skin-vicpulse .app-header,
      body.skin-vicpulse .app-header::after{
        animation: none !important;
      }
      body.skin-vicpulse .btn-secondary.active::after,
      body.skin-vicpulse .btn-pill.active::after,
      body.skin-vicpulse .spotter-btn.active::after,
      body.skin-vicpulse .spotter-master-btn.active::after,
      body.skin-vicpulse .session-preset-card.active::after,
      body.skin-vicpulse .precision-badge.active::after,
      body.skin-vicpulse .btn-basic-mini.active::after,
      body.skin-vicpulse .btn-speak.active::after,
      body.skin-vicpulse .btn-rd.active::after,
      body.skin-vicpulse #rdToggleBtn.active::after,
      body.skin-vicpulse .toggle-pill.on::after,
      body.skin-vicpulse .btn-primary.voice-on::after,
      body.skin-vicpulse .btn-voice.voice-on::after{
        animation: none !important;
        display: none !important;
      }
    }

    /* v0.0.0.92 - header-actions-row: reducir botones al 50% (tamano + letra) y forzar texto blanco */
/* v0.0.0.90 - header-logo: alinear logo a la izquierda */
.header-actions-row .header-help{
  font-size: 9px !important;
  padding: 0 16px !important;
  height: 20px;
  min-width: 72px;
  width: auto !important;
  max-width: none !important;
  box-sizing: border-box;
  border-radius: 999px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  white-space: nowrap;
  overflow: hidden;
  line-height: 1;
  color: #ffffff !important;
}
.header-actions-row .header-auto{
  min-width: 33px !important;
}
.header-actions-row .header-skin{
  min-width: 32px !important;
}
@media (max-width: 560px){
  .header-actions-row .header-help{
    font-size: 6px !important;
    padding: 4px 6px !important;
    min-height: 17px;
    color: #ffffff !important;
  }
  .header-actions-row .header-auto{ min-width: 30px !important; }
  .header-actions-row .header-skin{ min-width: 29px !important; }
}

/* v0.0.0.94 - badge-live: mismo tamano que botones del header-actions-row + alineado */
.header-actions-row .badge-live{
  font-size: 6px !important;
  padding: 4px 6px !important;
  min-height: 17px;
  min-width: 33px;
  line-height: 1;
  color: #ffffff !important;
  letter-spacing: 0.06em;
  font-weight: 900;
  text-transform: uppercase;
  border-radius: var(--radius-pill);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.header-actions-row .badge-live-dot{
  width: 5px;
  height: 5px;
}



    
/* v0.0.1.78 - header-actions-row: botones racing legibles (colores + brillo) */
.header-actions-row{
  gap: 8px !important;
}

/* altura y legibilidad uniforme (badge + botones) */
.header-actions-row .header-help,
.header-actions-row .badge-live,
.header-actions-row .badge-mode{
  height: 22px !important;
  min-height: 22px !important;
  line-height: 1 !important;
}

/* Botones del header: look premium racing */
.header-actions-row .header-help{
  --btn1: 255,255,255;
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 0 12px !important;
  min-width: 54px;
  font-size: 9px !important;
  font-weight: 950;
  letter-spacing: 0.11em;
  text-transform: uppercase;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.18) !important;
  background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.03)) !important;
  color: #ffffff !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.42), inset 0 1px 0 rgba(255,255,255,0.22) !important;
  text-shadow: 0 1px 0 rgba(0,0,0,0.45);
  overflow: hidden;
  user-select: none;
}

/* Indicador tipo LED */
.header-actions-row .header-help::before{
  content: "";
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: rgba(var(--btn1), 0.95);
  box-shadow: 0 0 10px rgba(var(--btn1), 0.55);
}

/* Sheen al hover */
.header-actions-row .header-help::after{
  content:"";
  position:absolute;
  inset:0;
  background: linear-gradient(120deg, rgba(255,255,255,0.00), rgba(255,255,255,0.18), rgba(255,255,255,0.00));
  transform: translateX(-120%) skewX(-18deg);
  opacity: 0;
  transition: transform .45s ease, opacity .45s ease;
  pointer-events:none;
}
.header-actions-row .header-help:hover::after{
  transform: translateX(120%) skewX(-18deg);
  opacity: .90;
}
.header-actions-row .header-help:active{
  transform: translateY(1px);
  filter: brightness(1.05);
}

/* Colores por accion */
#autoSkinBtn{
  --btn1: 0,220,255;
  border-color: rgba(0,220,255,0.55) !important;
  background: linear-gradient(180deg, rgba(0,220,255,0.28), rgba(0,0,0,0.38)) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.42), 0 0 14px rgba(0,220,255,0.22), inset 0 1px 0 rgba(255,255,255,0.22) !important;
}
#skinBtn{
  --btn1: 176, 38, 255;
  border-color: rgba(176,38,255,0.55) !important;
  background: linear-gradient(180deg, rgba(176,38,255,0.26), rgba(0,0,0,0.40)) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.42), 0 0 14px rgba(176,38,255,0.20), inset 0 1px 0 rgba(255,255,255,0.22) !important;
}
#manualBtn{
  --btn1: 255, 180, 0;
  border-color: rgba(255,180,0,0.62) !important;
  background: linear-gradient(180deg, rgba(255,180,0,0.28), rgba(0,0,0,0.40)) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.42), 0 0 14px rgba(255,180,0,0.18), inset 0 1px 0 rgba(255,255,255,0.22) !important;
}

/* Badge LIVE: mismo look que botones */
.header-actions-row .badge-live{
  padding: 0 12px !important;
  font-size: 9px !important;
  font-weight: 950;
  letter-spacing: 0.11em;
  border: 1px solid rgba(255,255,255,0.18);
  box-shadow: 0 10px 20px rgba(0,0,0,0.40), inset 0 1px 0 rgba(255,255,255,0.18);
}
.header-actions-row .badge-live-dot{
  width: 6px !important;
  height: 6px !important;
}

/* MODO badge: ms pro y legible */
.header-actions-row .badge-mode{
  height: 22px !important;
  padding: 0 12px !important;
  font-size: 9px !important;
  font-weight: 950 !important;
  letter-spacing: 0.12em !important;
  border-radius: 999px !important;
  border: 1px solid rgba(var(--accent-rgb), 0.55) !important;
  background: linear-gradient(180deg, rgba(var(--accent-rgb), 0.24), rgba(0,0,0,0.42)) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.40), 0 0 16px rgba(var(--accent-rgb), 0.12), inset 0 1px 0 rgba(255,255,255,0.16) !important;
  color: #ffffff !important;
}

/* Compacto extremo en pantallas chicas */
@media (max-width: 520px){
  .header-actions-row{ gap: 6px !important; }
  .header-actions-row .header-help,
  .header-actions-row .badge-live,
  .header-actions-row .badge-mode{
    height: 21px !important;
    min-height: 21px !important;
  }
  .header-actions-row .header-help{ padding: 0 10px !important; font-size: 8px !important; }
  .header-actions-row .badge-live{ padding: 0 10px !important; font-size: 8px !important; }
  .header-actions-row .badge-mode{ padding: 0 10px !important; font-size: 8px !important; }
}


/* SOLID GREEN VOICE-ON OVERRIDE (all themes) */
    .btn-voice.voice-on,
    .btn-primary.voice-on,
    .btn-speak.voice-on,
    .btn-secondary.btn-hot.btn-voice.btn-voice-mini.voice-on{
      background: #22c55e !important;
      border-color: #16a34a !important;
      color: #ffffff !important;
      box-shadow: 0 10px 24px rgba(34,197,94,0.22), inset 0 1px 0 rgba(255,255,255,0.20) !important;
      text-shadow: none !important;
      filter: none !important;
    }
    .btn-voice.voice-on::after,
    .btn-primary.voice-on::after,
    .btn-speak.voice-on::after{
      opacity: 0 !important;
    }


    /* v0.0.1.49 UI refinements: dedicated mode row + uniform bigger header buttons */
.header-mode-row{
  display:flex;
  align-items:center;
  justify-content:center;
  width: 100%;
  margin-top: 2px;
}
#raceModeBadge{
  display:inline-flex !important;
  align-items:center;
  justify-content:center;
  height: 28px;
  padding: 0 14px;
  border-radius: 999px;
  font-size: 12px;
  letter-spacing: 0.08em;
  font-weight: 800;
  text-transform: uppercase;
  white-space: nowrap;
  box-shadow: 0 10px 22px rgba(0,0,0,0.28);
}
/* make header action controls larger and uniform */
.header-actions-row{
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
}
.header-actions-row .header-help,
.header-actions-row .badge-live{
  height: 36px;
  min-width: 86px;
  padding: 0 14px;
  border-radius: 999px;
  font-size: 12px;
  line-height: 36px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
}
.header-actions-row .badge-live{
  padding: 0 16px;
}
.header-actions-row .badge-live span{
  line-height: 1;
}
/* mobile: keep readable, still uniform */
@media (max-width: 420px){
  #raceModeBadge{ height: 26px; font-size: 11px; padding: 0 12px; }
  .header-actions-row .header-help,
  .header-actions-row .badge-live{
    height: 34px;
    min-width: 78px;
    font-size: 11px;
    line-height: 34px;
  }
}


/* v0.0.1.55 - Compact race mode badge inside header-controls (prevent hiding other controls) */
#headerControls{ flex-wrap: wrap !important; justify-content: center !important; row-gap: 8px !important; column-gap: 10px !important; }
#headerControls .btn{ min-width: 74px !important; }
#raceModeBadge.badge-mode{
  height: 28px !important;
  line-height: 28px !important;
  padding: 0 10px !important;
  min-width: 0 !important;
  max-width: 140px !important;
  font-size: 10px !important;
  letter-spacing: .6px !important;
  border-radius: 14px !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
@media (max-width: 380px){
  #raceModeBadge.badge-mode{ max-width: 120px !important; font-size: 10.5px !important; padding: 0 9px !important; }
  #headerControls .btn{ min-width: 70px !important; }
}


/* v0.0.1.57 - UI tune: header buttons smaller (extra -50%) + meta lines -20% + latin1 charset */
.header-actions-row .header-help,
.header-actions-row .badge-live,
#raceModeBadge.badge-mode{
  font-size: 4.5px !important;
  padding: 2px 4px !important;
  height: 12px !important;
  min-height: 12px !important;
  line-height: 12px !important;
  min-width: 26px !important;
  border-radius: 10px !important;
  letter-spacing: .08em !important;
}
.header-actions-row .badge-live{ gap: 3px !important; }
.header-actions-row .badge-live-dot{ width: 6px !important; height: 6px !important; }
#raceModeBadge.badge-mode{ max-width: 92px !important; text-overflow: ellipsis !important; overflow: hidden !important; white-space: nowrap !important; }

/* Reduce secondary header text (Turbo Racing / raceInfo / tick) by ~20% */
#raceSubtitle{ font-size: 10px !important; }
#raceInfo{ font-size: 8px !important; }
    #lastUpdateInfo{ font-size: 9px !important; opacity: .85; }




/* ===== v0.0.1.62 Header PRO layout (solo look) ===== */
.app-header{
  display:flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 8px !important;
  height: 210px !important;
  min-height: 210px !important;
  max-height: 210px !important;
  padding: 8px 10px 16px !important;
  overflow: hidden !important;
}

/* Logo arriba con presencia */
.app-header .header-top{ width:100% !important; display:flex !important; align-items:center !important; justify-content:center !important; }
.app-header .header-logo img{
  max-height: 62px !important;
  filter: drop-shadow(0 10px 22px rgba(0,0,0,0.55)) drop-shadow(0 0 14px rgba(255,80,60,0.18)) !important;
}

/* Titulo jerarquico */
.app-header .header-stack{
  width: 100% !important;
  display:flex !important;
  flex-direction: column !important;
  align-items: center !important;
  text-align: center !important;
  gap: 6px !important;
}
#raceTitleMain{ width:100% !important; display:flex !important; justify-content:center !important; }
#raceTitleText{
  display:block !important;
  width: 100% !important;
  font-size: clamp(16px, 4.6vw, 24px) !important; /* 2pt menos + responsive */
  line-height: 1.05 !important;
  letter-spacing: 0.06em !important;
  text-transform: uppercase !important;
  font-weight: 900 !important;
  text-shadow: 0 10px 24px rgba(0,0,0,0.62) !important;
  -webkit-line-clamp: 2 !important;
  max-height: none !important;
}
#raceSubtitle{
  width: 100% !important;
  max-width: none !important;
  font-size: 10px !important;
  letter-spacing: 0.14em !important;
  opacity: 0.92 !important;
}

/* Panel info tipo broadcast */
.header-info-panel{
  width: 100% !important;
  max-width: 438px !important;
  padding: 6px 10px !important;
  border-radius: 12px !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.12)) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.08), 0 10px 22px rgba(0,0,0,0.35) !important;
}
.header-subline{
  font-size: 10px !important;
  color: rgba(255,255,255,0.85) !important;
  line-height: 1.15 !important;
}
.header-mini{
  font-size: 9px !important;
  color: rgba(255,255,255,0.70) !important;
  line-height: 1.15 !important;
  margin-top: 2px !important;
}

/* Barra de controles: una fila pro */
.header-controls{ width:100% !important; display:flex !important; justify-content:center !important; }
.header-actions-row{
  width: 100% !important;
  max-width: 460px !important;
  display:flex !important;
  align-items:center !important;
  justify-content: space-between !important;
  gap: 6px !important;
  padding: 6px 8px !important;
  border-radius: 14px !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  background: linear-gradient(180deg, rgba(0,0,0,0.18), rgba(0,0,0,0.06)) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06) !important;
  flex-wrap: nowrap !important;
}

/* Botones homogeneos compactos */
:root{
  --hdrCtrlH: 14px;
  --hdrCtrlW: 82px;
  --hdrCtrlPadX: 6px;
  --hdrCtrlFont: 8px;
  --hdrCtrlGap: 4px;
}

.header-actions-row > *{ flex: 0 0 auto !important; }
.badge-live,
.header-actions-row button,
.header-actions-row #raceModeBadge.badge-mode{
  height: var(--hdrCtrlH) !important;
  min-width: var(--hdrCtrlW) !important;
  width: var(--hdrCtrlW) !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 999px !important;
}
.badge-live{ justify-content:center !important; }

/* Fix: allow long PRO button labels (Q TABLA, MANUAL) without truncation */
.header-actions-row button.btn-pro{
  width:auto !important;
  min-width: var(--hdrCtrlW) !important;
  max-width:none !important;
}

.header-actions-row button.btn-pro .t{ white-space:nowrap; }
.badge-live span:last-child{ font-weight: 900 !important; letter-spacing: 0.08em !important; }
#raceModeRow{ display:flex !important; align-items:center !important; justify-content:center !important; }

/* Version abajo discreta */
.header-version{
  position: absolute !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 6px !important;
  text-align: center !important;
  font-size: 10px !important;
  opacity: 0.72 !important;
  pointer-events: none !important;
}

/* Movil: que no reviente */
@media (max-width: 430px){
  #raceTitleText{ font-size: clamp(16px, 5.6vw, 22px) !important; -webkit-line-clamp: 2 !important; }
  .header-actions-row{ max-width: 100% !important; }
  :root{ --hdrCtrlW: 82px; --hdrCtrlH: 14px; --hdrCtrlFont: 8px; }
}
/* ===== end header pro ===== */

/* === v0.0.1.65 Header PRO: control bar homognea + modo visible + versin sin encimarse === */
:root{
  --hdrCtrlH: 14px;
  --hdrCtrlW: 82px;
  --hdrCtrlPadX: 6px;
  --hdrCtrlFont: 8px;
  --hdrCtrlGap: 4px;
}

.header-actions-row{
  flex-wrap: nowrap !important;
  gap: var(--hdrCtrlGap) !important;
  padding: 0 2px !important;
}

.header-actions-row > *{ flex: 0 0 auto !important; }

.header-actions-row .header-help,
.header-actions-row #raceModeBadge.badge-mode,
.header-actions-row #liveIndicator.badge-live{
  height: var(--hdrCtrlH) !important;
  min-width: var(--hdrCtrlW) !important;
  width: var(--hdrCtrlW) !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 12px !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  letter-spacing: 0.06em !important;
}

.header-actions-row #liveIndicator.badge-live{
  gap: 6px !important;
}
.header-actions-row #liveIndicator .badge-live-dot{
  margin: 0 !important;
}

/* Badge MODO: siempre legible */
#raceModeBadge.badge-mode{
  border: 1px solid rgba(255,255,255,0.18) !important;
  background: rgba(255,255,255,0.08) !important;
  color: rgba(255,255,255,0.92) !important;
  text-transform: uppercase;
}

/* Colores por tipo */
#raceModeBadge.mode-train{
  background: rgba(59,130,246,0.18) !important;
  border-color: rgba(59,130,246,0.55) !important;
  color: rgba(219,234,254,0.98) !important;
}
#raceModeBadge.mode-manga{
  background: rgba(34,197,94,0.18) !important;
  border-color: rgba(34,197,94,0.55) !important;
  color: rgba(220,252,231,0.98) !important;
}
#raceModeBadge.mode-finalA{
  background: rgba(250,204,21,0.18) !important;
  border-color: rgba(250,204,21,0.55) !important;
  color: rgba(254,249,195,0.98) !important;
}
#raceModeBadge.mode-finalB{
  background: rgba(248,113,113,0.16) !important;
  border-color: rgba(248,113,113,0.55) !important;
  color: rgba(254,226,226,0.98) !important;
}
#raceModeBadge.mode-final{
  background: rgba(239,68,68,0.14) !important;
  border-color: rgba(239,68,68,0.45) !important;
  color: rgba(254,226,226,0.98) !important;
}

/* Versin: no encimar con controles */
.header-version{
  position: relative !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
  margin-top: 6px !important;
  padding-top: 2px !important;
  width: 100% !important;
  text-align: center !important;
  font-size: 9px !important;
  letter-spacing: 0.6px !important;
  opacity: 0.75 !important;
}


/* ====== v0.0.1.78 header live-on compact + no overlap (PRO) ====== */
.app-header.live-on{
  height:165px !important;
  min-height:165px !important;
  max-height:165px !important;
}

/* tighten vertical rhythm */
.app-header{
  padding-top: 8px !important;
  padding-bottom: 8px !important;
  overflow: hidden !important; /* keep rounded container clean */
}

.header-top{ padding: 0 !important; margin: 0 !important; }
.header-logo img{
  max-height: 46px !important;
  width: auto !important;
}

/* title block: ensure both lines visible, no weird clipping */
.header-stack{
  gap: 2px !important;
  margin-top: 4px !important;
  height: auto !important;
  overflow: visible !important;
}
#raceTitleText{
  font-size: clamp(16px, 3.8vw, 22px) !important;
  line-height: 1.06 !important;
  letter-spacing: 0.02em !important;
}
#raceSubtitle{
  font-size: 10px !important;
  line-height: 1.05 !important;
  opacity: 0.70 !important;
  margin-top: -1px !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  max-width: 92vw !important;
}

/* controls: remove scale transform (causes overlap) and make real compact sizes */
.header-controls{
  transform: none !important;
  margin-top: 6px !important;
}

/* single row, centered, no gaps weirdness */
.header-actions-row{
  justify-content: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
  width: 100% !important;
}

/* make all controls truly uniform */
.badge-live,
#raceModeBadge,
.header-help{
  height: 26px !important;
  min-height: 26px !important;
  padding: 0 10px !important;
  font-size: 11px !important;
  border-radius: 999px !important;
  white-space: nowrap !important;
}

/* LIVE should not dominate */
.badge-live{
  min-width: 78px !important;
  justify-content: center !important;
}
#raceModeBadge{
  min-width: 92px !important;
  justify-content: center !important;
}

/* buttons uniform widths */
.header-help{
  min-width: 74px !important;
  text-align: center !important;
}

/* tick panel compact and not stealing space */
.header-info-panel{
  max-width: 150px !important;
  padding: 2px 8px !important;
  margin: 0 !important;
}
.header-mini{
  font-size: 9px !important;
  line-height: 1.05 !important;
  margin: 0 !important;
  opacity: 0.85 !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

/* version anchored at bottom but not overlapping controls */
.header-version{
  margin-top: 6px !important;
  font-size: 10px !important;
  opacity: 0.55 !important;
  position: static !important;
}

/* v0.0.1.78: appVersion + lastUpdateInfo en la misma linea */
.header-version-row{
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  gap: 10px !important;
  flex-wrap: nowrap !important;
  width: 100% !important;
  margin-top: 6px !important;
}
.header-version-row .header-version{
  position: static !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
  display: inline-block !important;
  width: auto !important;
  margin: 0 !important;
  padding: 0 !important;
  line-height: 1.05 !important;
  white-space: nowrap !important;
}
#lastUpdateInfo{
  opacity: 0.72 !important;
  max-width: 48vw !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
/* v0.0.1.78: override responsive absolute version when inside row */
.app-header .header-version-row .header-version{
  pointer-events: none !important;
  text-align: left !important;
}

/* ====== end v0.0.1.78 ====== */


/* v0.0.1.79 - LIVE radio + MODO legible (restaurar look pro) */
.header-actions-row{
  gap: 8px !important;
  justify-content: center !important;
}

/* LIVE: solo radio button */
.header-actions-row #liveIndicator.badge-live{
  width: 16px !important;
  min-width: 16px !important;
  height: 16px !important;
  min-height: 16px !important;
  padding: 0 !important;
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,0.26) !important;
  background: rgba(0,0,0,0.22) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.10), 0 8px 18px rgba(0,0,0,0.35) !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 0 !important;
  letter-spacing: 0 !important;
}
.header-actions-row #liveIndicator .badge-live-dot{
  width: 8px !important;
  height: 8px !important;
  border-radius: 999px !important;
  background: rgba(255,255,255,0.14) !important;
  box-shadow: none !important;
}
.header-actions-row #liveIndicator:not(.live-off) .badge-live-dot{
  background: #22c55e !important;
  box-shadow: 0 0 14px rgba(34,197,94,0.60) !important;
}

/* MODO: no recortar, que se lea completo y con color segun clase */
.header-actions-row #raceModeRow{
  flex: 1 1 auto !important;
  min-width: 160px !important;
  max-width: 280px !important;
  justify-content: center !important;
}
.header-actions-row #raceModeBadge.badge-mode{
  width: 100% !important;
  height: 20px !important;
  min-height: 20px !important;
  padding: 0 10px !important;
  font-size: 9px !important;
  font-weight: 950 !important;
  letter-spacing: 0.10em !important;
  border-radius: 999px !important;
  white-space: nowrap !important;
  overflow: visible !important;
  text-overflow: visible !important;
}

/* Limpia overrides viejos que lo encogian demasiado */
.header-actions-row .header-help{
  height: 20px !important;
  min-height: 20px !important;
  font-size: 9px !important;
  padding: 0 10px !important;
}

/* Mobile: si falta espacio, baja un punto y permite un poco mas de compresion */
@media (max-width: 420px){
  .header-actions-row #raceModeRow{ min-width: 140px !important; max-width: 240px !important; }
  .header-actions-row #raceModeBadge.badge-mode{ font-size: 8px !important; }
}


/* Top banner (logo) */
.top-banner-placeholder{
  display:flex;
  flex-direction: column;
  align-items:center;
  justify-content:flex-start;
  gap: 6px;
  flex: 0 0 auto;
  width: min(438px, 92vw);
  margin: 6px auto 6px auto;
  background: transparent;
}

.top-banner-placeholder img.top-banner-logo{
  width: 100%;
  max-width: 438px;
  height: auto;
  max-height: 168px;
  aspect-ratio: 438 / 168;
  display: block;
  object-fit: contain;
  pointer-events: none;
}

/* Banner subtitle row (between logo block and app-header) */
.banner-subtitle-row{
  width: min(440px, 96vw);
  margin: 0 auto 8px auto;
  text-align: center;
  display:flex;
  justify-content:center;
  align-items:center;
  pointer-events:none;
}
.banner-subtitle-row .header-title-sub{
  height: auto !important;
  overflow: visible !important;
  white-space: nowrap;
  display:block;
  color: rgba(255,255,255,0.96);
  text-shadow: 0 2px 10px rgba(0,0,0,0.75);
  padding: 2px 6px;
  border-radius: 10px;
  background: rgba(0,0,0,0.42);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
}






/* Subtitle moved under logo */
.top-banner-placeholder .header-title-sub{
  width: 100%;
  max-width: min(440px, 96vw);
  text-align:center;
  margin: 0 !important;
  padding: 0 !important;

  /* override legacy 8px clamp (v0.0.1.78) */
  height: auto !important;
  min-height: 0 !important;
  line-height: 1.15 !important;
  overflow: visible !important;

  font-size: 11px !important;
  letter-spacing: 0.10em !important;
  opacity: 0.90 !important;
}
.top-banner-placeholder #raceSubtitle{
  margin-top: 2px !important;   /* no negative shove under the logo */
}

/* Main header height requirement */
.app-header.live-on{
  height: 165px !important;
  min-height: 165px !important;
}


    /* LapChart watermark (UI only) */
    :root{
      --lapchart-watermark-url: url('https://i.ibb.co/wFx8B4mW/logo-vics-PT.gif');
      --lapchart-watermark-opacity: 0.10;
      --lapchart-watermark-size: 78%;
      --lapchart-watermark-y: 52%;
      --lapchart-watermark-scale: 1.0;
    }
    .lap-chart-canvas-wrap{
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      background: transparent;
    }
    .lap-chart-canvas-wrap::before{
      content: "";
      position: absolute;
      inset: 0;
      background-image: var(--lapchart-watermark-url);
      background-repeat: no-repeat;
      background-position: 50% var(--lapchart-watermark-y);
      background-size: var(--lapchart-watermark-size) auto;
      opacity: var(--lapchart-watermark-opacity);
      filter: saturate(0.95) contrast(1.05);
      transform: scale(var(--lapchart-watermark-scale));
      pointer-events: none;
      z-index: 0;
    }
    .lap-chart-canvas-wrap canvas{
      position: relative;
      z-index: 1;
      display: block;
      width: 100%;
      height: auto;
      background: transparent;
    }

/* ---- merged block ---- */

/* Logo size override (keeps aspect ratio, fills header area) */
.header-top{ margin-bottom: 8px !important; }
.header-logo{ width: 100% !important; display:flex !important; justify-content:center !important; align-items:center !important; overflow: visible !important; }
.header-logo img{
  height: 96px !important;
  max-height: 96px !important;
  width: auto !important;
  max-width: min(560px, 92vw) !important;
  object-fit: contain !important;
}
@media (max-width: 520px){
  .header-logo img{
    height: 72px !important;
    max-height: 72px !important;
    max-width: min(420px, 92vw) !important;
  }
}

/* ---- merged block ---- */

/* FIX v0.0.2.41: version siempre visible en header */
.header-version-row{
  position:absolute !important;
  left:0 !important; right:0 !important; bottom:6px !important;
  z-index:50 !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  gap:10px !important;
  margin:0 !important;
}
.header-version-row .header-version{
  position:static !important;
  display:inline-block !important;
  font-size:10px !important;
  letter-spacing:.6px !important;
  opacity:.86 !important;
  color: rgba(255,255,255,0.78) !important;
  text-shadow: 0 1px 0 rgba(0,0,0,0.45) !important;
  pointer-events:none !important;
}
#appVersion{
  font-weight:900 !important;
  opacity:.96 !important;
  color: rgba(255,255,255,0.90) !important;
}

/* ---- merged block ---- */

/* v0.0.2.99 - header compatibility hardening */
html { -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }

/* Avoid fixed-height traps (especially iOS with large text / dynamic viewport) */
.app-header { height: auto !important; max-height: none !important; }

/* Flex children must be allowed to shrink, otherwise text forces overflow */
.header-actions-row, .header-actions { flex-wrap: wrap !important; }
.header-actions-row > *, .header-actions > * { min-width: 0; }

/* Keep long subtitles from pushing out of the container */
.header-title-sub, .raceSubtitle, #raceSubtitle { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* Ensure header can position debug badge safely */
.app-header { position: relative; }

/* ---- merged block ---- */

/* HEADER CANON v0.0.2.99 - iOS Safari/Chrome consistent */
html, body {
  -webkit-text-size-adjust: 100% !important;
  text-size-adjust: 100% !important;
}

/* Never lock header height: allow it to grow */
.app-header, .app-header.live-on, .app-header.live-off {
  height: auto !important;
  max-height: none !important;
  min-height: 170px !important;
}

.header-actions-row {
  position: relative !important;
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  align-items: center !important;
  gap: 8px !important;
  row-gap: 8px !important;
  padding: 0 6px !important;
  width: 100% !important;
}

/* Live dot should not steal centering space */
.header-actions-row .badge-live {
  position: absolute !important;
  left: 10px !important;
  top: 0px !important;
  margin: 0 !important;
}

/* Force a clean line break: row 1 = mode pill, row 2 = buttons */
.header-actions-row .hdr-break {
  flex-basis: 100% !important;
  height: 0 !important;
}

.header-actions-row .header-mode-row {
  flex: 0 1 auto !important;
  margin: 0 auto !important;
}

/* Buttons: consistent sizing and wrapping */
.header-actions-row button {
  flex: 0 0 auto !important;
  min-width: 84px;
}

/* Subtitle truncation safety */
.header-title-sub {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
}

/* ---- merged block ---- */

.toast{ position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    background: rgba(0,0,0,0.72); color: rgba(255,255,255,0.92);
    border:1px solid rgba(255,255,255,0.14); border-radius: 999px;
    padding: 8px 14px; font-weight: 800; letter-spacing: .04em;
    z-index: 99999; opacity:0; pointer-events:none; transition: opacity .18s ease, transform .18s ease;
  }
  .toast.on{ opacity:1; transform:translateX(-50%) translateY(-4px); }


    /* --- Header layout refresh (v0.0.1.43) --- */
    .app-header{
      display: flex !important;
      flex-direction: column !important;
      align-items: stretch !important;
      gap: 8px !important;
      padding: 10px 12px !important;
      height: auto !important;
      max-height: none !important;
      min-height: 0 !important;
      overflow: visible !important;
    }
    .app-header .header-left, .app-header .header-right { display: flex; align-items: center; gap: 8px; }

    /* Header PRO (logo arriba, titulo grande, jerarquia clara) */
    .app-header{
      padding: 14px 16px;
    }

    .header-top{
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 6px;
    }
    .header-logo{
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: auto;
    }
    .header-logo img{
      max-height: 110px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 6px 14px rgba(0,0,0,0.55)) drop-shadow(0 0 14px rgba(0,255,163,0.18));
    }

    .header-stack{
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 6px;
      min-width: 0;
    }

    .header-title-main{
      width: 100%;
      max-width: 980px;
      padding: 0 8px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #raceTitleText{
      max-width: 100%;
      width: auto;
      flex: 1 1 auto;
      font-size: clamp(20px, 6.2vw, 32px);
      line-height: 1.05;
      letter-spacing: 0.02em;
      text-shadow: 0 2px 12px rgba(0,0,0,0.55);
      max-height: none;
      -webkit-line-clamp: 3;
    }

    .header-mode-row{
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 2px;
    }
    .badge-mode{
      font-size: clamp(12px, 3.4vw, 14px);
      padding: 6px 12px;
      border-radius: 999px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
    }

    .app-header .header-title-sub{
      width: 100%;
      max-width: 980px;
      font-size: clamp(12px, 3.8vw, 16px);
      opacity: 0.92;
      white-space: normal;
      padding: 0 8px;
      letter-spacing: 0.08em;
    }
    #raceSubtitle{
      max-width: 100%;
      width: auto;
      font-size: inherit;
    }

    .header-subline{
      width: 100%;
      max-width: 980px;
      font-size: clamp(12px, 3.3vw, 14px);
      opacity: 0.92;
      white-space: normal;
      padding: 0 8px;
    }
    .header-mini{
      width: 100%;
      max-width: 980px;
      font-size: clamp(11px, 3.0vw, 12px);
      opacity: 0.72;
      padding: 0 8px;
    }

    .header-controls{
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      margin-top: 8px;
    }
    .header-actions-row{
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 8px;
      width: 100%;
      max-width: 980px;
    }

    .header-version{
      width: 100%;
      text-align: center;
      font-size: 11px;
      opacity: 0.70;
      padding-top: 6px;
    }

    @media (max-width: 420px){
      .app-header{ padding: 12px 10px !important; }
      .header-actions-row{ gap: 6px; }
      .header-logo img{ max-height: 96px; }
      #raceTitleText{ font-size: clamp(22px, 7.2vw, 30px); }
      .badge-mode{ padding: 6px 10px; }
      .app-header .header-title-sub{ letter-spacing: 0.06em; }
    }

    @media (max-width: 360px){
      #raceTitleText{ font-size: clamp(20px, 7.8vw, 28px); }
      .header-logo img{ max-height: 90px; }
    }

    @media (min-width: 900px){
      .header-logo img{ max-height: 124px; }
      #raceTitleText{ font-size: clamp(24px, 3.2vw, 34px); }
    }


/* v0.0.1.47 - Header compact: fixed height 250px (without breaking logic) */
.app-header{
  height: 250px !important;
  min-height: 250px !important;
  max-height: 250px !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 6px !important;
  overflow: hidden !important;
}

.header-top{ margin-bottom: 2px !important; }

.header-logo img{
  max-height: 80px !important;
  width: auto !important;
}

.header-stack{
  width: 100% !important;
  flex: 1 1 auto !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 6px !important;
  overflow: visible !important;
  z-index: 2 !important;
}

.header-title-main{
  margin: 0 !important;
  line-height: 1.05 !important;
}
#raceTitleText{
  font-size: clamp(14px, 4.0vw, 22px) !important;
  letter-spacing: 0.5px !important;
  -webkit-line-clamp: 2 !important;
}

.header-mode-row{ margin-top: 2px !important; }

#raceModeRow{ width: 100% !important; display:flex !important; justify-content:center !important; z-index: 3 !important; }
#raceModeBadge{ font-size: 12px !important; height: 28px !important; padding: 0 14px !important; background: rgba(0,0,0,0.35) !important; border-color: rgba(255,255,255,0.28) !important; color: rgba(255,255,255,0.96) !important; text-shadow: 0 2px 10px rgba(0,0,0,0.65) !important; }

.header-title-sub{
  margin-top: 0 !important;
  font-size: clamp(10px, 2.6vw, 12px) !important;
  line-height: 1.1 !important;
  max-width: 100% !important;
}

.header-subline{
  font-size: clamp(11px, 2.8vw, 13px) !important;
  line-height: 1.15 !important;
}

.header-mini{
  font-size: 10px !important;
  opacity: 0.85 !important;
}

.header-controls{
  width: 100% !important;
  display: flex !important;
  justify-content: center !important;
  margin-top: 8px !important;
  z-index: 1 !important;
}

.header-actions-row{
  gap: 6px !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
}

.header-version{
  margin-top: auto !important;
  padding-top: 4px !important;
  font-size: 10px !important;
  opacity: 0.75 !important;
  text-align: center !important;
}

/* v0.0.1.52 - Force race mode badge visibility and contrast */
#raceModeRow{
  display: flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  z-index: 5;
}
#raceModeBadge{
  display: inline-flex !important;
  min-height: 28px;
  padding: 6px 14px;
}


/* ===== Header controls: force single row (LIVE + MODO + buttons) ===== */
:root{
  --hdrCtrlH: 14px;
  --hdrCtrlW: 82px;
  --hdrCtrlPadX: 6px;
  --hdrCtrlFont: 8px;
  --hdrCtrlGap: 4px;
}

.header-controls{
  width: 100% !important;
  margin-top: 6px !important;
}
.header-actions-row{
  display: flex !important;
  flex-wrap: nowrap !important;
  justify-content: center !important;
  align-items: center !important;
  gap: var(--hdrCtrlGap) !important;
  width: 100% !important;
  overflow: hidden !important;
}
.header-actions-row > *{
  flex: 0 1 auto !important;
  min-width: 0 !important;
}
.header-actions-row button.header-help{
  height: var(--hdrCtrlH) !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 12px !important;
  white-space: nowrap !important;
  min-width: var(--hdrCtrlW) !important;
  width: var(--hdrCtrlW) !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}
#raceModeRow{
  height: var(--hdrCtrlH) !important;
  display: inline-flex !important;
  align-items: center !important;
}
#raceModeBadge.badge-mode{
  height: var(--hdrCtrlH) !important;
  display: inline-flex !important;
  align-items: center !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 12px !important;
  white-space: nowrap !important;
}
#liveIndicator.badge-live{
  height: var(--hdrCtrlH) !important;
  display: inline-flex !important;
  align-items: center !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 12px !important;
  white-space: nowrap !important;
  min-width: var(--hdrCtrlW) !important;
  width: var(--hdrCtrlW) !important;
  justify-content: center !important;
  justify-content: center !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

/* Kill any scaling that could hide controls */
.app-header .header-controls{ transform: none !important; }

@media (max-width: 420px){
  :root{
  --hdrCtrlH: 14px;
  --hdrCtrlW: 82px;
  --hdrCtrlPadX: 6px;
  --hdrCtrlFont: 8px;
  --hdrCtrlGap: 4px;
}

.header-actions-row{
    justify-content: flex-start !important;
    padding: 0 6px !important;
  }
}
/* ===== /Header controls ===== */


/* v0.0.1.69 tweak: header-stack 50px, keep subtitle visible */
.header-stack{height:50px !important; max-height:50px !important; overflow:visible !important;}
#raceTitleText{font-size: clamp(14px, 4.0vw, 22px) !important; line-height:1.05 !important;}
#raceSubtitle{font-size: 9px !important; line-height:1.0 !important; margin-top:-4px !important; opacity:0.78 !important;}
.header-controls{margin-top:6px !important;}
.header-actions-row{gap:6px !important;}


/* v0.0.1.78 - tighten header-title-sub to 8px height */
.header-title-sub{
  height:8px !important;
  min-height:8px !important;
  line-height:8px !important;
  overflow:hidden !important;
  margin:0 !important;
  padding:0 !important;
  display:block !important;
}

/* ---- LOGO OVERRIDE (v0.0.1.96) ---- */
.header-logo img{
  width: auto !important;
  height: 96px !important;
  max-height: 96px !important;
  max-width: 95% !important;
  object-fit: contain !important;
}
@media (max-width: 520px){
  .header-logo img{
    height: 72px !important;
    max-height: 72px !important;
    max-width: 96% !important;
  }
}


/* ====== v0.0.2.12 logo fit (no crop, bigger, moved down) ====== */
.app-header .header-logo{
  height: 110px !important;
  min-height: 110px !important;
  overflow: visible !important; /* allow full logo, no clipping */
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding-top: 6px !important;
}
.app-header .header-logo img{
  width: min(620px, 96%) !important;
  height: 100% !important;
  max-height: none !important;
  max-width: none !important;
  object-fit: contain !important; /* never crop */
  transform: translateY(10px) scale(1.00) !important; /* move down 10px */
  transform-origin: center center !important;
  filter: drop-shadow(0 0 10px rgba(0,0,0,0.35)) !important;
}
@media (max-width: 520px){
  .app-header .header-logo{
    height: 84px !important;
    min-height: 84px !important;
    padding-top: 4px !important;
  }
  .app-header .header-logo img{
    width: 96% !important;
    transform: translateY(8px) scale(1.00) !important;
  }
}

/* v0.0.2.12 - Header: altura estable (sin salto al cambiar LIVE) */
.app-header{
  height: 165px !important;
  min-height: 165px !important;
  max-height: 165px !important;
  padding: 12px 14px !important;
}
.app-header.live-on,
.app-header.live-off{
  height: 165px !important;
  min-height: 165px !important;
  max-height: 165px !important;
}
.header-stack{ flex: 0 0 auto !important; }
.header-controls{ margin-top: 6px !important; }
.header-version{ padding-top: 4px !important; }


/* =========================
   Q TABLA (Clasificación) - UI only
   ========================= */
.header-help.header-qtable{ letter-spacing: .35px; font-weight: 900; }

#qualiBackdrop .manual-panel{
  width: min(880px, 100%);
  padding: 10px;
  border-radius: 16px;
}
#qualiBackdrop .manual-title{ font-size: 15px; }
#qualiBackdrop .manual-sub{ font-size: 10.5px; }

#qualiBackdrop .qmeta{ display:flex; flex-wrap:wrap; gap:6px; margin: 0 0 8px 0; }
#qualiBackdrop .qchip{
  display:inline-flex; align-items:center; gap:6px;
  padding: 5px 9px; font-size: 11px;
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.22);
  background: rgba(0,0,0,0.18);
  color: var(--text-main);
  font-weight: 900;
}
#qualiBackdrop .qsel{
  padding: 5px 7px; font-size: 11px;
  border-radius: 10px;
  border: 1px solid rgba(148,163,184,0.22);
  background: rgba(0,0,0,0.22);
  color: var(--text-main);
  outline: none;
}
#qualiBackdrop .qtable-wrap{
  overflow:auto;
  max-height: 60vh;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,0.14);
  background: rgba(0,0,0,0.14);
}
#qualiBackdrop .qtable{
  font-size: 11px;
  min-width: 720px;
  border-collapse: separate;
  border-spacing: 0;
}
#qualiBackdrop .qtable th, #qualiBackdrop .qtable td{
  padding: 6px 7px;
  vertical-align: top;
}
#qualiBackdrop .qtable th{
  position: sticky;
  top: 0;
  z-index: 2;
  background: rgba(8,10,15,0.96);
  backdrop-filter: blur(6px);
  border-bottom: 1px solid rgba(148,163,184,0.18);
}
#qualiBackdrop .qtable tbody tr:nth-child(even) td{
  background: rgba(255,255,255,0.015);
}
#qualiBackdrop .qcol-pos{ width: 46px; }
#qualiBackdrop .qcol-name{ width: 210px; }
#qualiBackdrop .qcol-q{ width: 58px; }
#qualiBackdrop .qcol-laps{ width: 82px; }
#qualiBackdrop .qcol-time{ width: 128px; }
#qualiBackdrop .qmain{ white-space: nowrap; }
#qualiBackdrop .qtag{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 2px 7px;
  border-radius: 999px;
  font-size: 10px;
  font-weight: 900;
  letter-spacing: .3px;
  border: 1px solid rgba(255,122,24,0.35);
  background: rgba(255,122,24,0.10);
  color: rgba(242,245,255,0.95);
  margin-bottom: 3px;
}
#qualiBackdrop td.qcell-best{
  background: rgba(0, 255, 160, 0.07);
  box-shadow: inset 2px 0 0 rgba(0,255,160,0.55);
}
#qualiBackdrop td.qcell-empty{
  color: rgba(163,173,189,0.65);
}


#qualiBackdrop .qtable td{
  border-bottom: 1px solid rgba(148,163,184,0.08);
}
#qualiBackdrop .qtable tbody tr:hover td{
  background: rgba(255,255,255,0.03);
}
#qualiBackdrop .qtable tbody tr:nth-child(1) td:nth-child(-n+2){
  background: rgba(255, 215, 0, 0.06);
}
#qualiBackdrop .qtable tbody tr:nth-child(2) td:nth-child(-n+2){
  background: rgba(220, 220, 220, 0.045);
}
#qualiBackdrop .qtable tbody tr:nth-child(3) td:nth-child(-n+2){
  background: rgba(205, 127, 50, 0.05);
}
#qualiBackdrop .qtable tbody tr:nth-child(-n+3) td:first-child{
  font-weight: 950;
}
#qualiBackdrop .qtable tbody tr:nth-child(1) td:first-child{ color: rgba(255,215,0,0.95); }
#qualiBackdrop .qtable tbody tr:nth-child(2) td:first-child{ color: rgba(230,230,230,0.95); }
#qualiBackdrop .qtable tbody tr:nth-child(3) td:first-child{ color: rgba(205,127,50,0.95); }

#qualiBackdrop .qbest{
  margin-top: 2px;
  font-weight: 950;
  letter-spacing: .2px;
  color: rgba(216, 170, 255, 0.96);
  text-shadow: 0 0 10px rgba(216,170,255,0.12);
}


/* =========================
   HARD OVERRIDES v0.0.2.26
   - Corrige "brinco" del header y recortes en iPhone 12
   - Ajusta header-mode-row sin scale (wrap responsive)
   - Top banner siempre responsivo (no desaparece)
========================= */
.top-banner-placeholder{
  width: min(438px, 96vw) !important;
  max-width: 438px !important;
  min-width: 0 !important;
  height: 168px !important;
  margin: 10px auto 8px auto !important;
  background: rgba(8,10,15,0.55) !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  border-radius: 18px !important;
  box-shadow: 0 12px 34px rgba(0,0,0,0.55), inset 0 0 0 1px rgba(255,255,255,0.05) !important;
  overflow: hidden !important;
  backdrop-filter: blur(6px) !important;
}

@media (max-width: 460px){
  .top-banner-placeholder{
    width: min(438px, 96vw) !important;
    max-width: 100% !important;
    min-width: 0 !important;
  }
}

.top-banner-placeholder .top-banner-logo{
  width: 100% !important;
  height: 100% !important;
  object-fit: contain !important;
  display:block !important;
}

/* Header: misma altura siempre (evita que abra grande y luego se encoja) */
.app-header,
.app-header.live-on,
.app-header.live-off{
  height: 165px !important;
  min-height: 165px !important;
  max-height: 165px !important;
}

/* El modo/controles se adaptan al ancho real, sin transform que recorta */
.app-header .header-mode-row{
  transform: none !important;
  margin: 0 !important;
  width: 100% !important;
  display:flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  gap: 6px 8px !important;
  overflow: visible !important;
}

/* En pantallas chicas: reduce gap y permite 2 renglones sin cortar */
@media (max-width: 420px){
  .app-header .header-mode-row{ gap: 5px 6px !important; }
  .app-header .header-mode-row .btn-pill,
  .app-header .header-mode-row .spotter-btn{
    padding: 7px 10px !important;
    min-width: 64px !important;
  }
}


/* ===== HOTFIX v0.0.2.41: responsive header rows (no scale, no cut) ===== */
.app-header .header-mode-row{
  transform: none !important;
  margin: 0 !important;
  padding: 0 !important;
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  gap: 6px 8px !important;
}
.app-header .header-controls{
  transform: none !important;
  margin-top: 0 !important;
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  gap: 6px 8px !important;
}
.app-header .header-actions-row{
  flex-wrap: wrap !important;
  row-gap: 6px !important;
}
@media (max-width: 420px){
  .app-header .header-controls .btn{ padding: 6px 10px !important; }
  .app-header .header-mode-row .badge-mode{ font-size: 10px !important; }
}


/* v0.0.2.99 - HEADER BULLETPROOF (iOS Pro/Max + texto grande) */
html{ -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }
.app-header,
.app-header.live-on,
.app-header.live-off{
  height: auto !important;
  min-height: 170px !important;
  max-height: none !important;
  padding-top: calc(10px + env(safe-area-inset-top)) !important;
  overflow: visible !important;
}
@supports not (overflow: clip){
  .app-header{ overflow: visible !important; }
}

.app-header .header-controls,
.app-header .header-stack,
.app-header .header-title-main,
.app-header .header-title-sub,
.app-header .header-version-row{
  min-width: 0 !important;
}

.app-header .header-actions-row{
  display: flex !important;
  flex-wrap: wrap !important;
  align-items: center !important;
  gap: 6px !important;
  row-gap: 6px !important;
}

.app-header .header-title-sub{
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

.app-header .header-version-row{
  display: flex !important;
  flex-wrap: wrap !important;
  align-items: center !important;
  gap: 6px !important;
}

@media (max-width: 420px){
  .app-header .header-actions-row{ gap: 5px !important; row-gap: 5px !important; }
  .app-header .header-title-main{ font-size: 18px !important; }
}


/* --- FINAL HEADER OVERRIDES (iOS Safari stability) --- */
html, body{
  -webkit-text-size-adjust: 100% !important;
  text-size-adjust: 100% !important;
}

/* Center button rows always (Safari was forcing flex-start somewhere) */
.app-header .header-actions-row{
  justify-content: center !important;
  align-content: center !important;
  flex-wrap: wrap !important;
  padding: 0 !important;
  row-gap: 8px !important;
}

/* Buttons: never stretch, never wrap text */
.app-header .header-actions-row button.header-help{
  flex: 0 0 auto !important;
  white-space: nowrap !important;
}

/* Make sure the version row never overlaps controls */
.app-header .header-controls{ margin-bottom: 2px !important; }
.app-header .header-version-row{ margin-top: 2px !important; }


/* =========================
   PRO HEADER BUTTONS - UI ONLY
   (No cambia JS, voz, unlock iOS ni dedupe)
   ========================= */
:root{
  --proBtnH: 34px;
  --proBtnR: 12px;
  --proBtnPadX: 10px;
  --proBtnFont: 12px;

  --proBgA: #0b0f16;
  --proBgB: #121a26;

  --proStrokeA: rgba(255,255,255,.14);
  --proStrokeB: rgba(255,255,255,.06);

  --proTxt: rgba(255,255,255,.92);
  --proTxtDim: rgba(255,255,255,.75);

  --proShadow: 0 10px 24px rgba(0,0,0,.55);
  --proGlow: 0 0 0 3px rgba(255,255,255,.06);

  --proAccentCyan: #00e5ff;
  --proAccentPurple: #a855f7;
  --proAccentRed: #ff355d;
  --proAccentAmber: #ffb020;
  --proAccentGreen: #35ff7a;
}


/* PRO header buttons sizing (fit all on mobile) */
@media (max-width: 520px){
  .app-header .header-actions-row{ gap: 6px !important; }
  .app-header .header-actions-row .btn-pro{ padding: 8px 10px !important; font-size: 12px !important; }
  .app-header .header-actions-row .btn-pro .ico{ width: 11px !important; height: 11px !important; margin-right: 6px !important; }
}
.app-header .header-actions-row .btn-pro{
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;

  height: var(--proBtnH);
  padding: 0 var(--proBtnPadX);
  border-radius: var(--proBtnR);

  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap: 7px;

  font-size: var(--proBtnFont);
  line-height: 1;
  letter-spacing: .7px;
  text-transform: uppercase;
  font-weight: 800;

  color: var(--proTxt);
  border: 1px solid var(--proStrokeA);
  background: linear-gradient(180deg, var(--proBgB), var(--proBgA));
  box-shadow: var(--proShadow);

  position: relative;
  transform: translateZ(0);
  user-select: none;
  cursor: pointer;
  will-change: transform, filter;
}

.app-header .header-actions-row .btn-pro:active{
  transform: translateY(1px);
  filter: brightness(1.05);
}

.app-header .header-actions-row .btn-pro::before{
  content:"";
  position:absolute;
  inset: 1px;
  border-radius: calc(var(--proBtnR) - 1px);
  border: 1px solid var(--proStrokeB);
  pointer-events:none;
}

.app-header .header-actions-row .btn-pro::after{
  content:"";
  position:absolute;
  left: 8px;
  right: 8px;
  top: 6px;
  height: 10px;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(255,255,255,.20), rgba(255,255,255,0));
  opacity: .55;
  pointer-events:none;
}

@media (hover:hover){
  .app-header .header-actions-row .btn-pro:hover{
    filter: brightness(1.10);
  }
}

/* Mini "dot" de acento (sin emojis, iOS safe) */
.app-header .header-actions-row .btn-pro .ico{
  width: 12px;
  height: 12px;
  border-radius: 999px;
  background: rgba(255,255,255,.25);
  box-shadow: 0 0 10px rgba(255,255,255,.10);
  flex: 0 0 auto;
}

/* Acentos por boton */
.app-header .header-actions-row .btn-pro[data-kind="auto"] .ico{ background: var(--proAccentPurple); }
.app-header .header-actions-row .btn-pro[data-kind="vic"] .ico{ background: var(--proAccentRed); }
.app-header .header-actions-row .btn-pro[data-kind="qtabla"] .ico{ background: var(--proAccentCyan); }
.app-header .header-actions-row .btn-pro[data-kind="manual"] .ico{ background: var(--proAccentAmber); }
.app-header .header-actions-row .btn-pro[data-kind="man"] .ico{ background: var(--proAccentGreen); }

/* ON/ACTIVE (respeta clases existentes y aria-pressed si ya se usa) */
.app-header .header-actions-row .btn-pro.active,
.app-header .header-actions-row .btn-pro.on,
.app-header .header-actions-row .btn-pro.is-on,
.app-header .header-actions-row .btn-pro[aria-pressed="true"]{
  border-color: rgba(255,255,255,.20);
  box-shadow: var(--proShadow), var(--proGlow);
}

/* Reduce motion */
@media (prefers-reduced-motion: reduce){
  .app-header .header-actions-row .btn-pro{
    transition: none !important;
  }
}



/* =========================
   PATCH v0.0.2.99
   Fix: raceSubtitle under logo visible
   Cause: HARD OVERRIDES forced logo to 100% height and overflow hidden
   Scope: UI only, no JS changes
========================= */
.top-banner-placeholder{
  display:flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 6px !important;
  height: auto !important;
  min-height: 110px !important;
  padding: 10px 12px 8px 12px !important;
  overflow: visible !important;
}
.top-banner-placeholder .top-banner-logo,
.top-banner-placeholder img.top-banner-logo{
  width: min(438px, 96vw);
  height: auto;
  max-height: 168px;
  aspect-ratio: 438 / 168;
  margin: 0 auto 12px;
  display: block;
  object-fit: contain;
  pointer-events: none;
}

.top-banner-placeholder #raceSubtitle{
  display:block !important;
  height:auto !important;
  min-height: 0 !important;
  line-height: 1.15 !important;
  margin-top: 2px !important;
  padding: 0 !important;
  color: rgba(255,255,255,0.92) !important;
  text-shadow: 0 2px 10px rgba(0,0,0,0.65) !important;
}


/* responsive header-left/right */
@media (max-width: 520px){
  .app-header .header-left, .app-header .header-right { display: none !important; }
}

/* v0.0.2.99 - FIX: evitar recorte de texto en botones del header (Q TABLA / MANUAL) */
.header-actions-row .header-help{
  width: auto !important;
  max-width: none !important;
  min-width: 74px !important;
  padding: 0 16px !important;
  white-space: nowrap !important;
  overflow: visible !important;
  box-sizing: border-box !important;
}


/* v0.3.09 - Header buttons: remove legacy pseudo-element overlays (no ghost, no sheen, no hover movement) */
.header-actions-row .btn-pro::before,
.header-actions-row .btn-pro::after,
.header-actions-row .header-help::before,
.header-actions-row .header-help::after{
  content:none !important;
  display:none !important;
}
.header-actions-row .btn-pro:hover,
.header-actions-row .header-help:hover{
  filter:none !important;
  transform:none !important;
}
</style>
</head>
<body class="skin-pro skin-vicpulse">
  <div class="app">
    <div class="top-banner-placeholder" aria-hidden="false"><img class="top-banner-logo" src="https://i.ibb.co/wFx8B4mW/logo-vics-PT.gif" alt="Vic's Pulse Timing" />
</div>
    <div class="banner-subtitle-row"><div class="header-title-sub" id="raceSubtitle">Turbo Racing México - x-vic!</div></div>
<header class="app-header live-off">
<div class="header-stack">
        <div class="header-title-main" id="raceTitleMain"><span id="raceTitleText">AI Spotter TRM</span></div>
        </div>

      <div class="header-controls">
        <div class="header-actions-row">
          <div class="badge-live live-off" id="liveIndicator">
            <span class="badge-live-dot"></span>
            </div>
          <div class="header-mode-row" id="raceModeRow"><span class="badge-mode" id="raceModeBadge">MODO -</span></div>
          <div class="hdr-break"></div>
          <button class="header-help header-auto btn-pro" id="autoSkinBtn" type="button" title="Auto-skin" data-kind="auto"><span class="ico"></span>&#x1F916;<span class="lbl" id="autoSkinLbl">AUTO</span></button>
          <button class="header-help header-skin btn-pro" id="skinBtn" type="button" title="Tema: VIC [AUTO]" data-kind="vic">VIC🐊</button>
          <button class="header-help header-qtable btn-pro" id="qTableBtn" type="button" title="Q TABLA (clasificación)" data-kind="qtabla"><span class="ico"></span>&#x1F4CA;</button>
          <button class="header-help btn-pro" id="manualBtn" type="button" title="Manual y ayuda" data-kind="manual"><span class="ico"></span>&#x1F4D6;</button>
        </div>
      </div>

      <div class="header-version-row">
        <div class="header-version" id="appVersion">vics_Smart_Spotter_v0.3.28</div>
        <div class="header-version" id="lastUpdateInfo"></div>
      </div>
    </header>

    <!-- Debug strip (solo en modo debug) -->
    <div id="debugStrip" class="debugstrip expert-only" aria-hidden="true">
      <div class="dbg-item"><span class="dbg-k">AUTO</span> <span id="dbgAutoPhase" class="dbg-v">-</span></div>
      <div class="dbg-item"><span class="dbg-k">LAP</span> <span id="dbgAutoLap" class="dbg-v">0</span></div>
      <div class="dbg-item"><span class="dbg-k">T</span> <span id="dbgAutoT" class="dbg-v">0</span></div>
      <div class="dbg-item"><span class="dbg-k">DUR</span> <span id="dbgAutoDur" class="dbg-v">0</span></div>
      <div class="dbg-item"><span class="dbg-k">FINAL</span> <span id="dbgAutoFinal" class="dbg-v">0</span></div>
      <div class="dbg-item"><span class="dbg-k">IDLE</span> <span id="dbgAutoIdle" class="dbg-v">0</span></div>
      <div class="dbg-item"><span class="dbg-k">TIME</span> <span id="dbgAutoTrend" class="dbg-v">?</span></div>
    </div>


    <main class="app-main">
      <section class="pilot-card">
        <div class="pilot-card-top-strip"></div>
        <div class="pilot-row-heading">
          <div style="width:100%; min-width:0;">
            <div class="pilot-label">Piloto seguido</div>
            <div class="pilot-name-row">
              <div class="pilot-name" id="pilotName">Auto Locutor</div>
              <div class="pilot-laps-big" id="pilotMeta">0 v</div>
            </div>
          </div>
        </div>
        <div class="pilot-select" style="margin-top:6px;">
          <select id="pilotSelect">
            <option value="">Sin piloto seleccionado</option>
          </select>
        </div>
        <div class="pilot-select-actions">
          <button class="btn-secondary btn-hot btn-voice btn-voice-mini" id="voiceToggleBtnMini" data-voice-toggle type="button">
             ACTIVAR VOZ
          </button>
          <button class="btn-secondary btn-hot btn-basic-mini" id="basicToggleBtnMini" type="button" title="Modo básico: solo vueltas, lap time y posición">BÁSICO</button>
        </div>
        <div class="pilot-pos-row">
          <div class="pos-pill" id="posText">P -</div>
          <div class="pos-info" id="gapInfo">Diferencia líder  vueltas  estado</div>
        </div>
        <div class="pilot-timings">
          <div class="timing-item last-lap">
            <div class="timing-label">última</div>
            <div class="timing-value" id="lastLap">-:--.---</div>
          </div>
          <div class="timing-item">
            <div class="timing-label">Mejor</div>
            <div class="timing-value" id="bestLap">-:--.---</div>
          </div>

          <!-- Record carrera (mejor vuelta global) -->
          <div class="timing-item">
            <div class="timing-label">Record carrera</div>
            <div class="timing-value" id="bestOverallLap">-:--.---</div>
            <div class="timing-meta" id="bestLapHolder" style="font-size:10px; color:var(--text-muted);">-</div>
          </div>
<div class="timing-item">
            <div class="timing-label">Media</div>
            <div class="timing-value" id="meanLap">-:--.---</div>
          </div>

          <div class="timing-item">
            <div class="timing-label">Cons</div>
            <div class="timing-value" id="consistencyVal">--%</div>
          </div>
          <div class="timing-item">
            <div class="timing-label">Std Dev</div>
            <div class="timing-value" id="sigmaVal">-.---</div>
          </div>
          <div class="timing-item timer-only" id="mangaClockItem">
            <div class="timing-label">Reloj</div>
            <div class="timing-value manga-clock" id="mangaClock">0:00.000</div>
          </div>

        </div>
      
        <div class="lap-chart-wrap">
          <div class="lap-chart-header">
            <div class="lap-chart-header-row">
              <div class="lap-chart-title">Lap chart</div>
              <button class="btn-mini" id="top3ToggleBtn" type="button" title="Alternar Top 3 / Top 20">TOP 3</button>
            </div>
            <div class="lap-chart-meta" id="lapChartMeta">Sin datos</div>
          </div>
          <div class="lap-chart-canvas-wrap">

            <canvas id="lapChart" width="600" height="180"></canvas>

          </div>
          <div class="top3-mini-grid" id="top3MiniGrid" aria-label="Top 3 grid"></div>
        </div>

      </section>

      <section class="extras-section">

        

        <div class="toggle-row expert-only">
          <div class="toggle-label">Mantener pantalla despierta</div>
          <div class="toggle-pill active" id="wakeLockToggle">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="wake-status expert-only" id="wakeLockStatus"></div>

        <div class="toggle-row expert-only">
          <div class="toggle-label">Modo background</div>
          <div class="toggle-pill" id="backgroundToggle" title="Si est ON, el spotter sigue leyendo datos aunque la pestaña no estál frente.">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="wake-status expert-only" id="backgroundStatus"></div>

        <div class="rate-row" style="margin-top:8px;">
          <div class="rate-label">Velocidad voz</div>
          <input type="range" id="rateRange" min="1.0" max="2.5" step="0.1" value="1.5" />
          <div class="rate-display" id="rateDisplay">1.5x</div>
        </div>

        <div class="select-row">
          <div class="select-label">Voz</div>
          <div style="display:flex;gap:8px;align-items:center;justify-content:flex-end;flex-wrap:wrap;">
            <select id="voiceSelect" class="spotter-select" title="Selecciona voz del sistema (depende del dispositivo)"></select>
            <button class="btn-secondary btn-hot" id="ttsTestBtn" type="button" title="Probar voz"> Test</button>
          </div>
        </div>

        <div class="grid-button-row">
          <button class="btn-grid" id="btnOpenGrid">
             TOP 3
          </button>
</div>
      </section>

      <section class="controls-section expert-only" id="controlsSection">
        

        <div class="buttons-row">
          <button class="btn-secondary btn-hot btn-voice" id="voiceToggleBtn" data-voice-toggle>
             ACTIVAR VOZ
          </button>
          <button class="btn-secondary btn-hot btn-speak expert-only" id="speakBtn">
             Leer resumen
          </button>
          <button class="btn-secondary btn-hot btn-rd expert-only" id="rdToggleBtn" title="Prender o apagar el Race Director">
             RD ON
          </button>
        </div>

        <div class="config-status-card" id="configStatusCard" aria-label="Configuracin activa">
          <div class="config-status-top">
            <div class="config-status-title"> Configuracin activa</div>
            <div class="config-status-badges">
              <span class="cfg-pill cfg-pill-session" id="cfgSessionPill">Sesin: -</span>
              <span class="cfg-pill cfg-pill-auto" id="cfgPresetPill">Preset: -</span>
              <span class="cfg-pill cfg-pill-auto" id="modeBadge">Modo: -</span>
            </div>
          </div>
          <div class="config-status-line">
            <span class="cfg-label">RD:</span> <span class="cfg-value" id="cfgRdMode">-</span>
            <span class="cfg-sep">|</span>
            <span class="cfg-label">Auto Locutor:</span> <span class="cfg-value" id="cfgAutoMode">-</span>
            <span class="cfg-sep">|</span>
            <span class="cfg-label">Precisin:</span> <span class="cfg-value" id="cfgPrec">-</span>
            <span class="cfg-sep">|</span>
            <span class="cfg-label">Voces:</span> <span class="cfg-value" id="cfgVoices">ES</span>
          </div>
          <div class="session-presets expert-only" id="sessionPresetsPanel">
            <div class="session-presets-header">
              <div class="session-presets-title"> Presets por sesin</div>
              <div class="session-presets-note" id="sessionPresetNote">Auto: ON</div>
            </div>
            <div class="session-preset-grid" role="group" aria-label="Presets por sesin">
              <button class="session-preset-card" id="presetCardTrain" data-session="TRAIN" type="button">
                <div class="spc-head">
                  <span class="spc-name">Entrenamiento</span>
                  <span class="spc-tag">TRAIN</span>
                </div>
                <div class="spc-sub" id="presetTrainMeta">-</div>
                <div class="spc-toggles" id="presetTrainToggles"></div>
              </button>
              <button class="session-preset-card" id="presetCardManga" data-session="MANGA" type="button">
                <div class="spc-head">
                  <span class="spc-name">Manga</span>
                  <span class="spc-tag">MANGA</span>
                </div>
                <div class="spc-sub" id="presetMangaMeta">-</div>
                <div class="spc-toggles" id="presetMangaToggles"></div>
              </button>
              <button class="session-preset-card" id="presetCardFinal" data-session="FINAL" type="button">
                <div class="spc-head">
                  <span class="spc-name">Final</span>
                  <span class="spc-tag">FINAL</span>
                </div>
                <div class="spc-sub" id="presetFinalMeta">-</div>
                <div class="spc-toggles" id="presetFinalToggles"></div>
              </button>
            </div>
            <div class="session-now" id="sessionNowRow">
              <div class="session-now-title">Ahora (lo que est prendido en voz)</div>
              <div class="session-now-toggles" id="sessionNowToggles"></div>
            </div>
          </div>
        </div>
        <div class="rd-mode-row expert-only" role="group" aria-label="Modo del Race Director">
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeMinimal" title="Pro Minimal">A Minimal</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeStratega" title="Pro Estratega">B Estratega</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeCoach" title="Pro Coach">C Coach</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeSarca" title="Sarcstico">D Sarcstico</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeEngineer" title="Ingeniero">E Ingeniero</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeHype" title="Hype">F Hype</button>
        </div>

        <div class="controls-label expert-only"> Auto Locutor (sin piloto)</div>
        <div class="rd-mode-row expert-only" role="group" aria-label="Modo del Auto Locutor">
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorPro" title="Locutor PRO serio">PRO</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorPicante" title="Picante light">Picante</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorEngineer" title="Ingeniero de carrera">Ingeniero</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorNarrativo" title="Narracin con hilo y contexto">Narrativo</button>
        </div>

        <div class="precision-row expert-only">
                  <div class="controls-label">Precisin de lectura del tiempo</div>
                  <div class="precision-buttons">
                    <div class="precision-badge active" data-precision="1">1 dcima</div>
                    <div class="precision-badge" data-precision="2">2 dcimas</div>
                    <div class="precision-badge" data-precision="3">3 dcimas</div>
                  </div>
                  <select id="precisionSelect" class="spotter-select" style="display:none">
                    <option value="1" selected>1 dcima</option>
                    <option value="2">2 dcimas</option>
                    <option value="3">3 dcimas</option>
                  </select>
                </div>

      </section>

      <section class="spotter-section expert-only" id="advancedMessagesPanel">
  <div class="controls-label" style="margin-bottom:2px;">Mensajes del spotter</div>

  
  <div class="spotter-master">
    <button id="presetRdProBtn" type="button" class="spotter-master-btn preset" title="Preset: RD PRO limpio (habla lo importante, sin spam)">RD PRO</button>
    <button id="presetRdShowBtn" type="button" class="spotter-master-btn preset" title="Preset: RD SHOW (ms emocin, ms narrativa)">RD SHOW</button>
    <button id="toggleAllMsgsBtn" type="button" class="spotter-master-btn" title="Prender o apagar todos los mensajes (excepto Laps)">TODO</button>
  </div>

<div class="spotter-cat" data-cat="essential">
    <div class="spotter-cat-head"><span class="cat-dot"></span>Esenciales</div>
    <div class="spotter-grid">
      <div class="spotter-btn active lock" data-flag="laps"><span></span>Laps</div>
      <div class="spotter-btn" data-flag="saylaps" title="Decir o no decir la palabra vueltas al leer Laps"><span></span>Vueltas</div>
      <div class="spotter-btn active" data-flag="blueflag" title="Azul: avisa lapeos/trafico (bandera azul)"><span></span>Azul</div>
      <div class="spotter-btn active" data-flag="ritmo" title="Ritmo: avisa si vienes mejorando o si te caes (comparado con tu promedio reciente)"><span></span>Ritmo +/-</div>
      <div class="spotter-btn" data-flag="estlap" title="Est: tiempo estimado al final (si el feed lo trae)"><span></span>Est</div>
      <div class="spotter-btn" data-flag="leadergap" title="Lider: gap al líder, cambios de líder y contexto de punta"><span></span>Lider</div>
      <div class="spotter-btn" data-flag="podium" title="Podio: llamadas enfocadas al Top 3 (en Finales, suele ser lo mas caliente)"><span></span>Podio</div>
    </div>
  </div>

  <div class="spotter-cat" data-cat="battle">
    <div class="spotter-cat-head"><span class="cat-dot"></span>Batalla</div>
    <div class="spotter-grid">
      <div class="spotter-btn" data-flag="pos" title="Pos: cambios de posicion (ganas/pierdes), y pases importantes en Auto"><span></span>Pos</div>
      <div class="spotter-btn" data-flag="gaps" title="Diferencia: gap con el de adelante y con el de atras (segundos o vueltas)"><span></span>Gap</div>
      <div class="spotter-btn" data-flag="front06" title="Adel <0.6: tienes a alguien adelante a menos de 0.6s (huele a pase)"><span></span>Adel &lt;0.6</div>
      <div class="spotter-btn" data-flag="back06" title="Atras <0.6: te vienen atacando a menos de 0.6s (defiende)"><span></span>Atras &lt;0.6</div>
      <div class="spotter-btn" data-flag="attack" title="Ataque: narrativa cuando tu gap al de adelante cae y estas para intentarlo"><span></span>Ataque</div>
      <div class="spotter-btn" data-flag="defense" title="Defensa: narrativa cuando te vienen recortando y toca aguantar"><span></span>Defensa</div>
    </div>
  </div>

  <div class="spotter-cat" data-cat="summary">
    <div class="spotter-cat-head"><span class="cat-dot"></span>Resumen</div>
    <div class="spotter-grid">
      <div class="spotter-btn" data-flag="total"><span></span>Total</div>
      <div class="spotter-btn" data-flag="cons10"><span></span>Cons 10</div>
      <div class="spotter-btn" data-flag="bestlap"><span></span>Best</div>
      <div class="spotter-btn" data-flag="box"><span></span>Box</div>
      <div class="spotter-btn" data-flag="pelea"><span></span>Pelea</div>
      <div class="spotter-btn" data-flag="netgain"><span></span>NetGain</div>
    </div>
  </div>

  <div style="display:none;">
    <input type="checkbox" id="chkLapBasic" checked />
    <input type="checkbox" id="chkPosChanges" />
    <input type="checkbox" id="chkExtraInfo" />
    <input type="checkbox" id="chkBehindAlert" />
    <input type="checkbox" id="chkTotalTime" />
    <input type="checkbox" id="chkBlueFlag" checked />
    <input type="checkbox" id="chkConsistency10" />
    <input type="checkbox" id="chkEstLap" />
    <input type="checkbox" id="chkBestLap" />
    <input type="checkbox" id="chkPaceTrend" checked />
    <input type="checkbox" id="chkAheadAlert" />
    <input type="checkbox" id="chkAutoSummary" />
  </div>
</section>

    </main>
  </div>

  <!-- Manual modal -->
<div class="manual-backdrop" id="manualBackdrop" aria-hidden="true">
  <div class="manual-panel" role="dialog" aria-modal="true" aria-labelledby="manualTitle">
    <div class="manual-top">
      <div>
        <div class="manual-title" id="manualTitle">Manual - Vic's Smart Spotter</div>
        <div class="manual-sub">Guía rápida (v0.3.28). Activa voz, elige piloto y corre. El resto es opcional.</div>
      </div>
      <button class="manual-close" id="manualCloseBtn" type="button" aria-label="Cerrar">&#x2715;</button>
    </div>

    <div class="manual-tabs" role="tablist" aria-label="Secciones del manual">
      <button class="manual-tab active" role="tab" aria-selected="true" data-tab="inicio" type="button">Inicio</button>
      <button class="manual-tab" role="tab" aria-selected="false" data-tab="botones" type="button">Botones</button>
      <button class="manual-tab" role="tab" aria-selected="false" data-tab="voz" type="button">Voz</button>
      <button class="manual-tab" role="tab" aria-selected="false" data-tab="qtabla" type="button">Q Tabla</button>
      <button class="manual-tab" role="tab" aria-selected="false" data-tab="basico" type="button">Básico</button>
      <button class="manual-tab" role="tab" aria-selected="false" data-tab="problemas" type="button">Problemas</button>
    </div>

    <div class="manual-sections">
      <div class="manual-section active" data-tab="inicio">
        <h3>Arranque en 60 segundos</h3>
        <div class="manual-card">
          <ol style="margin:0; padding-left: 18px;">
            <li>Abre el Spotter y espera 2-3 segundos a que llegue el primer dato.</li>
            <li>Toca <b>ACTIVAR VOZ</b> una vez.</li>
            <li>Si quieres seguimiento, <b>selecciona tu piloto</b>.</li>
            <li>Si quieres menos ruido, enciende <b>BÁSICO</b>.</li>
            <li>En clasificación, usa <b>Q TABLA</b> (botón 📊) para ver la tabla.</li>
          </ol>
          <div class="manual-note">El piloto seleccionado se guarda en tu navegador. Si recargas y el nombre existe, se auto-selecciona.</div>
        </div>

        <h3>Dos formas de usarlo</h3>
        <div class="manual-card">
          <b>Auto</b>: narra lo general (carrera nueva, cambios, avisos, peleas).<br>
          <b>Seguimiento</b>: se enfoca en tu piloto (posición, gaps, alertas).<br><br>
          <div class="manual-tip">Regla simple: si seleccionas piloto, el spotter debe hablar menos y más directo.</div>
        </div>

        <h3>Reglas de oro</h3>
        <div class="manual-card">
          <ul style="margin:0; padding-left: 18px;">
            <li>Una sola pestaña del Spotter. Dos pestañas = dos locutores peleando el micrófono.</li>
            <li>Si estás en iPhone, no bloquees pantalla al inicio (primero activa la voz).</li>
            <li>Si todo viene en ceros al arrancar, es normal: espera 1-2 vueltas reales.</li>
          </ul>
        </div>
      </div>

      <div class="manual-section" data-tab="botones">
        <h3>Header: lo que sí se toca</h3>
        <div class="manual-card">
          <ul style="margin:0; padding-left: 18px;">
            <li><b>🤖 AUTO</b> - modo automático (decide anuncios y ritmo de mensajes).</li>
            <li><b>VIC🐊</b> - cambia el skin/tema visual a Vic.</li>
            <li><b>📊</b> - Q TABLA (clasificación guardada).</li>
            <li><b>📖</b> - abre/cierra este manual.</li>
          </ul>
          <div class="manual-note">El punto LIVE y el badge MODO te dicen si el feed está vivo y qué sesión detectó.</div>
        </div>

        <h3>Controles principales</h3>
        <div class="manual-card">
          <ul style="margin:0; padding-left: 18px;">
            <li><b>ACTIVAR VOZ</b> - desbloquea audio del navegador.</li>
            <li><b>BÁSICO</b> - reduce mensajes (modo concentración).</li>
            <li><b>Selector de piloto</b> - activa seguimiento.</li>
          </ul>
          <div class="manual-tip">Si algo se siente atorado, refresco controlado. Mejor eso que discutir con la app en plena final.</div>
        </div>
      </div>

      <div class="manual-section" data-tab="voz">
        <h3>Voz en iPhone (Safari/Chrome iOS)</h3>
        <div class="manual-card">
          iOS solo permite audio si hay un gesto del usuario. Por eso existe <b>ACTIVAR VOZ</b>.
          <ol style="margin:8px 0 0; padding-left: 18px;">
            <li>Sube volumen y quita Silencio.</li>
            <li>Toca <b>ACTIVAR VOZ</b> una vez con la pantalla despierta.</li>
            <li>Luego selecciona piloto (si aplica).</li>
            <li>No bloquees pantalla justo al arrancar.</li>
          </ol>
          <div class="manual-note">Si estás con Bluetooth, revisa que el audio no esté saliendo por otro dispositivo.</div>
        </div>

        <h3>Voz en PC (Chrome/Brave/Edge)</h3>
        <div class="manual-card">
          <ul style="margin:0; padding-left: 18px;">
            <li>Permite audio del sitio (candado del navegador).</li>
            <li>Evita suspensión del sistema durante evento.</li>
            <li>Si usas OBS, mejor cargar como Browser Source.</li>
          </ul>
        </div>

        <h3>Segundo plano (background)</h3>
        <div class="manual-card">
          En web puedes mantener actividad, pero si el sistema entra en suspensión, nadie salva eso.
          <ul style="margin:8px 0 0; padding-left: 18px;">
            <li>Para evento: desactiva sleep y deja la pestaña viva.</li>
            <li>Si sales y vuelves, dale 1 segundo para retomar.</li>
          </ul>
        </div>
      </div>

      <div class="manual-section" data-tab="qtabla">
        <h3>Qué es Q TABLA</h3>
        <div class="manual-card">
          Q TABLA es tu "race control" para <b>clasificación</b>. Guarda y muestra resultados por sesión (Q).
          <ul style="margin:8px 0 0; padding-left: 18px;">
            <li><b>Vista: Mejor por piloto</b> - toma el mejor resultado guardado de cada piloto.</li>
            <li><b>Vista: Por Q</b> - te deja revisar cada Q guardada (Q1, Q2, etc).</li>
          </ul>
          <div class="manual-note">Los chips de arriba muestran Evento, Fecha y cuántas sesiones guardó.</div>
        </div>

        <h3>Cuándo se guarda</h3>
        <div class="manual-card">
          Se guarda cuando hay datos reales (vueltas o tiempos válidos). Se guarda en tu navegador (localStorage).
          <ul style="margin:8px 0 0; padding-left: 18px;">
            <li>Si borras datos del sitio o usas incógnito, arrancas con Q TABLA limpia.</li>
            <li>Si está vacía, es porque aún no llegó info válida.</li>
          </ul>
        </div>

        <h3>Lectura rápida</h3>
        <div class="manual-card">
          <ul style="margin:0; padding-left: 18px;">
            <li><b>Pos</b>: posición en clasificación.</li>
            <li><b>Best</b>: mejor vuelta del piloto.</li>
            <li><b>Gap</b>: diferencia contra el líder.</li>
          </ul>
          <div class="manual-tip">Si estás buscando "quién trae ritmo", mira Best y Gap. Lo demás es chisme, pero útil.</div>
        </div>
      </div>

      <div class="manual-section" data-tab="basico">
        <h3>Modo BÁSICO</h3>
        <div class="manual-card">
          BÁSICO es para correr sin radio tipo talk-show. Reduce mensajes repetidos y se enfoca en lo esencial.
          <ul style="margin:8px 0 0; padding-left: 18px;">
            <li>Ideal si estás concentrado o te saturas con mucha voz.</li>
            <li>Los avisos importantes deben seguir (carrera nueva, alertas).</li>
          </ul>
          <div class="manual-tip">Si quieres show TRM total, apaga BÁSICO y deja que hable.</div>
        </div>
      </div>

      <div class="manual-section" data-tab="problemas">
        <h3>Soluciones rápidas</h3>
        <div class="manual-card">
          <ol style="margin:0; padding-left: 18px;">
            <li><b>No habla</b> - toca ACTIVAR VOZ. En iPhone, toca con la pantalla despierta.</li>
            <li><b>Habla raro o en loop</b> - refresca una vez. Si tienes dos pestañas abiertas, cierra una.</li>
            <li><b>Q TABLA sin datos</b> - espera 1-2 vueltas reales o revisa que el feed esté vivo.</li>
            <li><b>Se calla al volver del background</b> - dale 1 segundo. Si no regresa: refresco controlado.</li>
          </ol>
          <div class="manual-note">Consejo de veterano: lo importante es que hable cuando lo necesitas, no que platique bonito.</div>
        </div>

        <h3>Buenas prácticas</h3>
        <div class="manual-card">
          <ul style="margin:0; padding-left: 18px;">
            <li>Antes de arrancar: piloto seleccionado + voz activa.</li>
            <li>Prueba Q TABLA en clasificación para confirmar que guardó sesiones.</li>
            <li>Si vas a grabar: haz una prueba de carrera nueva para confirmar anuncios.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="manual-foot">
      <span class="manual-tip">Meta: 0 fricción. Un toque para voz y listo. El resto es ventaja competitiva.</span>
    </div>
  </div>
</div>

<!-- Q TABLA modal -->
<div class="manual-backdrop" id="qualiBackdrop" aria-hidden="true">
  <div class="manual-panel" role="dialog" aria-modal="true" aria-labelledby="qualiTitle">
    <div class="manual-top">
      <div>
        <div class="manual-title" id="qualiTitle">Q TABLA</div>
        <div class="manual-sub">Clasificación guardada por sesión (Q). Mejor por piloto o vista por Q.</div>
      </div>
      <button class="manual-close" id="qualiCloseBtn" type="button" aria-label="Cerrar">&#x2715;</button>
    </div>

    <div class="qmeta" id="qualiMeta">
      <span class="qchip" id="qualiMetaEvent">Evento: -</span>
      <span class="qchip" id="qualiMetaDate">Fecha: -</span>
      <span class="qchip" id="qualiMetaSessions">Sesiones: -</span>

      <label class="qsel" style="margin-left:auto;">
        Vista:
        <select id="qualiViewSel">
          <option value="best">Mejor por piloto</option>
          <option value="byq">Por Q</option>
        </select>
      </label>
    </div>

    <div class="qtable-wrap">
      <table class="qtable" aria-label="Tabla de clasificación">
        <thead id="qualiThead"></thead>
        <tbody id="qualiTbody">
          <tr><td colspan="6" class="qcell-empty">Sin datos aún</td></tr>
        </tbody>
      </table>
    </div>

    <div class="manual-foot">
      <span class="manual-tip">Tip: si apenas arrancó la carrera y todo viene en ceros, espera 1-2 vueltas.</span>
    </div>
  </div>
</div>

<script id="appScript">


// ============================================================
// CONSOLIDATED JS (v0.3.05)
// - All inline scripts merged in source order.
// - Wrapped with init guard to avoid double-binding listeners.
// ============================================================

if (window.__AI_SPOTTER_TRM_INIT__) {
  console.warn('AI Spotter TRM: init already ran - skipping');
} else {
  window.__AI_SPOTTER_TRM_INIT__ = true;

/*
====================================================================
DOCUMENTACION TECNICA - AI Spotter TRM (v0.0.0.29)
====================================================================

Objetivo
- Spotter con UI simple y decisiones automaticas.
- 2 comportamientos principales:
  1) Seguimiento (Follow): hay piloto seleccionado.
  2) Auto Locutor (Auto): NO hay piloto seleccionado.

Principios de diseno
- El usuario no debe "configurar un avion". El spotter decide.
- Todo anuncio pasa por el motor de VOZ (cola + dedupe + prioridades).
- La tabla y el header siempre se alimentan del mismo raceData normalizado.

--------------------------------------------------------------------
0) Glosario rapido
- raceData: uúltimo snapshot de carrera (documento del feed) ya normalizado.
- classification: arreglo de pilotos (pos, nombre, lapcount, time, best, mean, gap/diff, etc).
- currentSessionInfo: tipo de sesion detectado desde raceName (MANGA / FINAL A / FINAL B+).
- selectedPilotKey: piloto elegido por el usuario. Si existe => modo Seguimiento.
- BASIC (Seguimiento): modo minimalista (solo last lap + posicion).
- speechQueue: cola de mensajes TTS. Se drena con pumpSpeechQueue().
- speechLog: bitacora de lo hablado (solo visible con ?debug=1).

--------------------------------------------------------------------
1) Flujo general de datos (pipeline)
1.1 Entrada
- Fuente: Firebase (Firestore) o feed equivalente.
- initFirebaseRuntime() carga SDK y crea listener/poll.
- Al recibir snapshot, se arma raceData y se llama a normalizacion.

1.2 Normalizacion (critico para que todo funcione)
- Se fuerza pos como numero.
- Se ordena classification por pos.
- Se calculan campos derivados (intervalos, laps, tiempo total en ms, etc).
- Resultado: raceData coherente. Si P1 esta mal, TODO se rompe (azul, top3, peleas).

1.3 Render UI
- updateHeaderFromRace(): titulo, modo, estado de feed.
- renderClassificationTable(): tabla principal.
- updateMangaClockDisplay(): reloj (en MANGA muestra "time" real del feed del piloto seleccionado).

1.4 Motor de voz (TTS)
- say(text, opts): entrada unica a voz.
- sanitizeTtsText(): limpia texto para evitar "undefined", dobles espacios, etc.
- enqueue + dedupe: evita repetir frases, y corta mensajes viejos si ya son obsoletos.
- unlockTTSOnce(): desbloqueo iOS (requiere gesto real).

--------------------------------------------------------------------
2) Modos: Seguimiento vs Auto Locutor

2.1 Seguimiento (hay piloto seleccionado)
Objetivo
- Narracion centrada en 1 piloto.
- En BASIC: solo "last lap" + "posicion" (y cambios de posicion).

Reglas
- selectedPilotKey existe => applySmartProfile(FOLLOW).
- Si BASIC esta ON:
  - Se apagan anuncios de pelea/gaps/azul/etc.
  - Se anuncian solo eventos minimos (last lap + posicion).

Eventos tipicos que dispara
- Cruce por meta del piloto: last lap.
- Cambio de posicion (estable, sin jitter): "P3" por ejemplo.
- (No BASIC) avisos: ataque/defensa, gaps por rango, bandera azul si aplica.

2.2 Auto Locutor (NO hay piloto seleccionado)
Objetivo
- Narrar la carrera completa, con enfasis en eventos importantes.
- Sin hablar antes de tiempo (silencio inteligente).

Ciclo de vida (state machine)
- IDLE: sin carrera valida.
- WAIT_START: llega raceName nuevo => anuncia titulo y espera arranque real.
- RUNNING: narracion activa (top3, cambios, cierres fuertes, azul).
- CLOSING: en finales, cuando se alcanza duracion objetivo => "finalizo" por piloto.
- FINISHED: silencio hasta que llegue nueva carrera (raceName cambia).

Deteccion de arranque
- No basta con "time". Se valida movimiento real:
  - lapcount > 0, o lastLapMs > 0, o bestLapMs > 0, o totalMs avanza de forma coherente.
- Evita hablar cuando el feed manda un "time" objetivo antes de arrancar.

--------------------------------------------------------------------
3) Bandera azul (blue flag)
Donde aplica
- Seguimiento (si no es BASIC) y Auto Locutor.

Deteccion
- Principal: diferencia de vueltas (lapDiff >= 1) o diff tipo "+1 V".
- Anti spam:
  - cooldown global y cooldown por piloto.
  - en Auto Locutor se puede repetir cada N vueltas del líder.

Fraseo
- Se usa "bandera azul" + nombre del piloto a ceder paso.
- (Se puede ajustar estilo: mandon vs fino).

--------------------------------------------------------------------
4) Lectura de gaps por rangos (narracion humana)
- Menor a 1 segundo: se habla en decimas con frases por rango ("a menos de tres decimas", "a medio segundo", etc).
- Mayor a 1 segundo: buckets a 0.5s y decide "a", "a menos de", "a mas de".
- 10+ segundos: simplifica para no aburrir.

Funcion clave
- gapToSpeech(sec): convierte segundos a frase (NO lee numeros crudos).

--------------------------------------------------------------------
5) Debug y soporte
- ?debug=1 habilita speechLog (uúúltimos mensajes hablados) para diagnostico.
- updateConfigStatusUI(): muestra estado Firebase/Feed y heartbeat.

--------------------------------------------------------------------
6) Inventario de funciones (por modulos)
Nota
- Abajo esta la lista completa de funciones detectadas. Esta pensada como indice rapido.
- Para cambios, ubica el modulo y entra por la funcion "publica" (update/render/say/auto).

BOOTSTRAP_IO (8)
  - ensureAudioCtx, ensureCanvasHiDpi, ensureFirebaseSdk, ensureMangaClockTicker, ensurePilotOptionExists, initFirebaseRuntime
  - loadRaceFromFirebase, loadVoiceSettings

PERSISTENCIA (8)
  - getCookie, lsGet, lsRemove, lsSet, prefGet, prefKey
  - prefSet, setCookie

TIEMPOS_FORMATO (6)
  - fmt, msToMinSec, parseDiff, parseInterval, parseSessionFromRaceName, parseTimeToMs

ANALITICA (4)
  - computeBattleTag, computeSessionBestMs, getTop3Rows, getTopRows

UI_RENDER (5)
  - renderAutoLapChartTop3, renderAutoTop3MiniGrid, renderPilotCard, renderPresetCards, renderSpeechLog

UI_UPDATE (14)
  - updateAutoCommentatorButtons, updateBlueFlagFromPassEvents, updateConfigStatusUI, updateHeaderFromRace, updateLapHistoryAll, updateLapRangeFromHistory
  - updateMangaClockDisplay, updateMangaPilotStartsFromClassification, updatePilotOptions, updateRdButton, updateRdModeButtons, updateRecordCarreraUI
  - updateSessionInfo, updateToggleAllMsgsBtn

VOZ_TTS (4)
  - enqueueSpeech, pumpSpeechQueue, say, unlockTTSOnce

AUTO_LOCUTOR (10)
  - __autoAnnounceFinishers, __autoBlueFlagCheck, __autoGetDurMs, __autoIsStarted, __autoNowMs, __autoParseLapDiff
  - __autoResetLifecycle, __autoSafeName, __autoScanProgress, __autoUpdateLifecycle

INTERNAL (5)
  - __buildParticipantsList, __maybeAnnounceAutoIntro, __modeBucket, __sessionBucket, __wlTry

UTILS (4)
  - clamp01, clampNum, htmlEsc, safeRacerName

OTROS (146)
  - _applyBasicOverride, _getVoiceToggleMap, _isAndroidRate, _isIOSWebKitRate, _pillHtml, _toggleMiniGrid
  - _unlock, _updateBasicBtnUI, addCand, announcePositionBrief, applyDecimalPrecision, applyMiniGridExpandedUI
  - applyPilotSelectPosTheme, applyPresetVoiceSettings, applySessionPreset, applySessionPresetFull, applySmartProfile, applyVoiceSettingsToButtons
  - autoBuildMessage, autoBuildStoryCandidate, autoCanSpeak, autoDecorate, autoFmtSec, autoFocusMsg
  - autoGapTextFromLapDiff, autoMarkPairMention, autoMarkSig, autoPairKey, autoPruneWindow, autoRaceProgress
  - autoRandPick, autoRememberPair, autoShuffleInPlace, autoSigOk, autoStageFromSec, bindSessionPresetCards
  - buildGapSummaryForPilotIndex, buildSessionFinishMessage, checkAheadAlertForPilotIndex, checkBehindAlertForPilotIndex, checkSessionFinishOnLap, classifyLapColor
  - clearWd, closeManual, consistencyPercent, detectDefaultTtsRate, diffTexto, drawDot
  - drawLabel, drawLapChartForKey, drawLapChartTop3Auto, fill, findFastestStint, findPilotIndexByKey
  - findWorstLap, flashLastLap, flashMangaClock, flashPilotCardGreen, floorTo, formatAnnouncer
  - formatClockMs, formatLaps3, formatoGapVueltas, gapDeltaSpeech, gapHalfLabel, gapLargeSpeech
  - gapNumWord, gapSmallSpeech, gapToSpeech, gapToSpeechBare, getAutoLapChartKey, getBestMsForRow
  - getConsistencyFromFirebase, getFrontBackContext, getPilotKey, getRowTotalMs, groupOf, handleAutoCommentator
  - handlePositionChangeNoLap, handleVoiceAndBeeps, handler, isAllMsgsOn, isIOSWebKit, isLapPlausible
  - lapDiffGuardAllow, maybeAutoApplySessionPreset, near2, nextAutoVoiceURI, normalizeIncomingLapValue, normalizeLapMs
  - normalizeRaceData, normalizeTtsText, numeroATexto0a999, onPilotSelectedManga, openManual, pick
  - pickDefaultVoice, playBeep, prosodyFromMood, pushCand, pushLap, rdBuildCtx
  - rdExtractPos, rdMakeMangaBattleText, rdMakeText, rdPick, rdSafeName, rdSec
  - rdShuffleInPlace, rdTrimWords, refreshSessionBestCache, refreshVoiceList, releaseWakeLock, requestWakeLock
  - resetAutoCommentatorState, resetAutoNarratorState, resetSelectedPilotTrackingState, roundRect, saveVoiceSettings, scheduleOneTapUnlock
  - selectPilotByKey, setActive, setAutoCommentatorMode, setBackgroundStatus, setLapClass, setLastLapMark
  - setLastUpdateNow, setLiveStatus, setMangaClockColorByRemaining, setMangaClockVisible, setPresetBtnActive, setRaceDirectorMode
  - setVoiceMaster, shortChipName, speakText, speakWithLaps, statsFromTimes, stopMangaClock
  - syncPrecisionBadges, tiempoATexto, toFixedFloor, tooSoonId, tooSoonTxt, ttlById
  - ttlByTxt, wordToNum

====================================================================
FIN DOCUMENTACION
====================================================================
*/

    // =========================
    // VERSION
    // =========================
const APP_NAME = "vics_Smart_Spotter_v0.3.28";
    const APP_LABEL = APP_NAME;

    // =========================
    // AI AUTO-INTRO + FINISHERS (Auto Locutor)
    // - Se anuncian solo en Auto Locutor (sin piloto seleccionado)
    // =========================
    let __autoIntroSig = '';
    let __autoIntroDoneKeys = new Set();
    let __autoIntroRetryAt = 0;
    let __autoFinishSig = '';
    let __autoFinishPrevByKey = new Map();
    let __autoFinishAnnouncedByKey = new Set();
    let __autoFinishPhase = false;
    let __autoFinishSummarySig = '';
    let __autoFinishSummaryDone = false;

    // =========================
    // Auto Locutor - Ciclo de vida de carrera (silencio inteligente)
    // - En Auto Locutor: anuncia carrera + participantes y luego ESPERA a que arranque (sin hablar)
    // - Despus narra normal (RUNNING)
    // - Al terminar: entra a CLOSING (solo finalizo en Finales) y luego FINISHED (silencio hasta nueva carrera)
    // =========================
    let __autoPhase = 'IDLE'; // IDLE | WAIT_START | RUNNING | CLOSING | FINISHED
    let __autoLifeSig = '';
    let __autoStartedStable = 0;
    let __autoCloseStartedMs = 0;
    let __autoLastActivityMs = 0;
    let __autoLastMaxLap = 0;
    let __autoLastMaxTotalMs = 0;
    let __autoActiveKeys = new Set(); // pilotos que ya "arrancaron" (laps>0 o time>0)

    let __autoDbg = { phase:'IDLE', maxLap:0, maxTotalMs:0, dur:0, isFinal:false, idleMs:0, trend:'?' };

    function __autoDbgMs(ms){
      const n = Number(ms) || 0;
      if (!n) return '0';
      if (n < 1000) return String(n|0) + 'ms';
      return (n/1000).toFixed(1) + 's';
    }
    function __autoUpdateDebugStrip(){
      try{
        if (!document.body.classList.contains('debug')) return;
        const d = __autoDbg || {};
        const $ = (id)=>document.getElementById(id);
        const ph = String(d.phase||'-');
        const lap = String(Number(d.maxLap)||0);
        const t = __autoDbgMs(d.maxTotalMs);
        const dur = __autoDbgMs(d.dur);
        const fin = d.isFinal ? '1' : '0';
        const idle = __autoDbgMs(d.idleMs);
        const trend = String(d.trend||'?');
        if ($('dbgAutoPhase')) $('dbgAutoPhase').textContent = ph;
        if ($('dbgAutoLap')) $('dbgAutoLap').textContent = lap;
        if ($('dbgAutoT')) $('dbgAutoT').textContent = t;
        if ($('dbgAutoDur')) $('dbgAutoDur').textContent = dur;
        if ($('dbgAutoFinal')) $('dbgAutoFinal').textContent = fin;
        if ($('dbgAutoIdle')) $('dbgAutoIdle').textContent = idle;
        if ($('dbgAutoTrend')) $('dbgAutoTrend').textContent = trend;
      } catch(e) {}

    }

    function __autoNowMs() {
      try { return (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now(); }
      catch(e){ return Date.now(); }
    }

    function __autoResetLifecycle(raceName) {
      try {
        __autoLifeSig = String(raceName || '');
        __autoPhase = 'WAIT_START';
      try{ __autoDbg = { phase: __autoPhase, maxLap:0, maxTotalMs:0, dur: __autoGetDurMs(), isFinal:false, idleMs:0, trend:'?' }; __autoUpdateDebugStrip(); }catch(e){}
        __autoStartedStable = 0;
        __autoCloseStartedMs = 0;
        __autoLastActivityMs = __autoNowMs();
        __autoLastMaxLap = 0;
        __autoLastMaxTotalMs = 0;
        __autoActiveKeys = new Set();
      } catch(e) {}
    }

    function __autoGetDurMs() {
      try {
        const info = currentSessionInfo || {};
        const t = String(info.type || '').toUpperCase();
        const label = String(info.label || '').toUpperCase();
        const d = Number(info.durationMs) || 0;
        if (d > 0) return d;

        // fallback seguro
        if (t === 'FINAL_A' || label.includes('FINAL A')) return 6 * 60 * 1000;
        if (t.startsWith('FINAL') || label.includes('FINAL')) return 4 * 60 * 1000;
        if (t === 'MANGA' || t === 'QUALI' || t === 'TRAIN' || label.includes('MANGA') || label.includes('QUALI') || label.includes('TRAIN')) return 3 * 60 * 1000;
        return 0;
      } catch(e) { return 0; }
    }

    function __autoScanProgress(r) {
      try {
        const rows = (r && Array.isArray(r.classification)) ? r.classification : [];
        let maxLap = 0;
        let maxTotalMs = 0;
        let maxLastLapMs = 0;

        for (const row of rows) {
          if (!row) continue;
          const laps = Number(row.lapcount) || 0;
          const totalMs = getRowTotalMs(row) || 0;
          const lastLapMs = Number(row.lastLapMs) || 0;

          if (laps > maxLap) maxLap = laps;
          if (totalMs > maxTotalMs) maxTotalMs = totalMs;
          if (lastLapMs > maxLastLapMs) maxLastLapMs = lastLapMs;

          if (laps > 0 || totalMs > 0 || lastLapMs > 0) {
            const k = getPilotKey(row) || safeRacerName(row && row.racerName) || '';
            if (k) __autoActiveKeys.add(String(k));
          }
        }

        const bestMs = Number(r && (r.bestLapMs || r.bestLapMsRaw || r.bestLapTimeMs || r.bestLapMsValue)) || 0;
        const bestTime = Number(r && (r.bestLapTime || 0)) || 0;
        const bestAny = bestMs || bestTime;

        return { maxLap, maxTotalMs, maxLastLapMs, bestAny };
      } catch(e) {
        return { maxLap:0, maxTotalMs:0, maxLastLapMs:0, bestAny:0 };
      }
    }

    function __autoIsStarted(scan) {
      try {
        if (!scan) return false;
        const maxLap = Number(scan.maxLap) || 0;
        const maxTotalMs = Number(scan.maxTotalMs) || 0;
        const maxLastLapMs = Number(scan.maxLastLapMs) || 0;
        const bestAny = Number(scan.bestAny) || 0;

        const dur = __autoGetDurMs();

        // Arranque real (evita falsos positivos cuando el feed manda "03:00.xxx" antes de empezar)
        let startedNow = false;

        if (maxLap >= 1) startedNow = true;
        else if (maxLastLapMs > 0) startedNow = true;
        else if (bestAny > 0) startedNow = true;
        else if (maxTotalMs >= 1500) {
          // Si el tiempo ya viene pegado a la duracin objetivo y no hay laps/best/lastlap, NO arranc todava
          if (dur > 0 && maxTotalMs >= (dur - 2000)) startedNow = false;
          else startedNow = true;
        }

        if (startedNow) __autoStartedStable = Math.min(3, (__autoStartedStable || 0) + 1);
        else __autoStartedStable = 0;

        return (__autoStartedStable >= 2);
      } catch(e) {
        __autoStartedStable = 0;
        return false;
      }
    }

    function __autoUpdateLifecycle(r) {
      try {
        if (!r) return;

        const rn = String(r.raceName || '');
        if (!rn) return;

        // cambio de carrera -> reset (aunque por alguna razn el intro no haya hablado)
        if (rn !== __autoLifeSig) {
          __autoResetLifecycle(rn);
          return;
        }

        const now = __autoNowMs();
        const scan = __autoScanProgress(r);

        // actividad (evitar "silencio eterno" si siguen cambiando)
        const maxLap = Number(scan.maxLap) || 0;
        const maxTotalMs = Number(scan.maxTotalMs) || 0;

        const durDbg = __autoGetDurMs();
        const infoDbg = currentSessionInfo || {};
        const typeDbg = String(infoDbg.type || '').toUpperCase();
        const isFinalDbg = (typeDbg.startsWith('FINAL') || String(infoDbg.label||'').toUpperCase().includes('FINAL'));
        __autoDbg = {
          phase: __autoPhase,
          maxLap,
          maxTotalMs,
          dur: durDbg,
          isFinal: !!isFinalDbg,
          idleMs: now - (Number(__autoLastActivityMs) || 0),
          trend: '?'
        };
        const __lastMaxTotalMs = Number(__autoLastMaxTotalMs) || 0;
        const __diffTotalMs = maxTotalMs - __lastMaxTotalMs;
        const __trend = (__diffTotalMs > 600) ? 'UP' : (__diffTotalMs < -600) ? 'DOWN' : '~';
        try{ if (__autoDbg) __autoDbg.trend = __trend; }catch(e){}
        if (maxLap > (__autoLastMaxLap || 0) || Math.abs(__diffTotalMs) > 600) {
          __autoLastActivityMs = now;
          __autoLastMaxLap = maxLap;
          __autoLastMaxTotalMs = maxTotalMs;
        }

        __autoUpdateDebugStrip();

        // WAIT_START: no hablar hasta arrancar de verdad
        if (__autoPhase === 'WAIT_START') {
          if (__autoIsStarted(scan)) {
            __autoPhase = 'RUNNING';
            __autoLastActivityMs = now;
            try{ if (__autoDbg) __autoDbg.phase = __autoPhase; }catch(e){}
            __autoUpdateDebugStrip();
          }
          return;
        }

        const dur = __autoGetDurMs();
        if (!dur) return;

        // Detectar cierre / fin
        const info = currentSessionInfo || {};
        const type = String(info.type || '').toUpperCase();
        const isFinal = (type.startsWith('FINAL') || String(info.label||'').toUpperCase().includes('FINAL'));

        // Al cruzar el tiempo objetivo entramos en cierre
        if ((__autoPhase === 'RUNNING') && maxTotalMs >= dur) {
          if (isFinal) {
            __autoPhase = 'CLOSING';
            __autoCloseStartedMs = now;
            return;
          } else {
            // Manga: anunciar cierre + Top3 y luego silencio
            try { __autoAnnounceTop3Summary(r, 'Termin la clasificacin'); } catch(e) {}
            __autoPhase = 'FINISHED';
            __autoCloseStartedMs = now;
            return;
          }
        }

        // CLOSING: solo finalizo y luego silencio
        if (__autoPhase === 'CLOSING') {
          const activeCount = (__autoActiveKeys && __autoActiveKeys.size) ? __autoActiveKeys.size : 0;
          const announcedCount = (__autoFinishAnnouncedByKey && __autoFinishAnnouncedByKey.size) ? __autoFinishAnnouncedByKey.size : 0;

          // Si ya anunciamos a todos los que arrancaron, acab
          if (activeCount > 0 && announcedCount >= activeCount) {
            try { __autoAnnounceTop3Summary(r, 'Carrera terminada'); } catch(e) {}
            __autoPhase = 'FINISHED';
            return;
          }

          // Cierre inteligente: si ya no hay movimiento (ni laps ni totalMs), cerrar por inactividad
          const idleMs = now - (__autoLastActivityMs || now);
          const sinceCloseMs = __autoCloseStartedMs ? (now - __autoCloseStartedMs) : 0;

          // Caso comun: algunos no tienen totalMs o no cruzan "bonito" -> no te quedes atorado
          if (sinceCloseMs > 7000 && idleMs > 12000) {
            try { __autoAnnounceTop3Summary(r, 'Carrera terminada'); } catch(e) {}
            __autoPhase = 'FINISHED';
            return;
          }

          // Si ya casi todos estan anunciados, y no hay actividad, cerramos rapido
          if (activeCount > 0 && announcedCount >= Math.max(1, activeCount - 1) && idleMs > 8000) {
            try { __autoAnnounceTop3Summary(r, 'Carrera terminada'); } catch(e) {}
            __autoPhase = 'FINISHED';
            return;
          }

          // Failsafe: si ya pas mucho tiempo, acab
          if (__autoCloseStartedMs && sinceCloseMs > 70000) {
            try { __autoAnnounceTop3Summary(r, 'Carrera terminada'); } catch(e) {}
            __autoPhase = 'FINISHED';
            return;
          }
          return;
        }

        // FINISHED: silencio hasta carrera nueva
        if (__autoPhase === 'FINISHED') {
          return;
        }

        // Manga: si ya pas el tiempo y no hay actividad, acabar
        if (!isFinal && maxTotalMs >= dur) {
          const idleMs = now - (__autoLastActivityMs || now);
          if (idleMs > 8000) __autoPhase = 'FINISHED';
        }
      } catch(e) {}
    }

    function __buildParticipantsList(rows, maxNames=12) {
      try {
        if (!Array.isArray(rows)) return { names: [], extra: 0 };
        const seen = new Set();
        const names = [];
        for (const r of rows) {
          const nm = safeRacerName(r && r.racerName);
          if (!nm) continue;
          const k = nm.toLowerCase();
          if (seen.has(k)) continue;
          seen.add(k);
          names.push(nm);
        }
        const extra = Math.max(0, names.length - maxNames);
        return { names: names.slice(0, maxNames), extra };

    function __autoAnnounceTop3Summary(r, forcedLabel) {
      try {
        // Si el usuario est siguiendo a un piloto, NO anunciamos el Top 3 al finalizar.
        // Solo se anuncian los datos del piloto seguido (fin de sesin).
        if (selectedPilotKey) return;
        if (!r || !Array.isArray(r.classification) || !r.classification.length) return;

        const rn = String(r.raceName || '');
        if (!rn) return;

        if (rn !== __autoFinishSummarySig) {
          __autoFinishSummarySig = rn;
          __autoFinishSummaryDone = false;
        }
        if (__autoFinishSummaryDone) return;

        const info = currentSessionInfo || {};
        const type = String(info.type || '').toUpperCase();
        const isManga = (type === 'MANGA');
        const isFinal = (type === 'FINAL');

        const rows = r.classification.slice().filter(x => x && Number(x.pos || 0) > 0);
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const top = rows.slice(0,3);
        if (!top.length) return;

        let head = forcedLabel ? String(forcedLabel) : (isManga ? 'Termin la clasificacin.' : 'Carrera terminada.');
        if (!head.endsWith('.')) head += '.';

        const part = (row, idx) => {
          const nm = safeRacerName(row && row.racerName) || ('P' + (idx+1));
          const laps = Number(row && (row.lapcount ?? row.laps ?? 0)) || 0;
          const totalMs = getRowTotalMs(row) || 0;
          let s = (idx===0 ? ' Primero ' : idx===1 ? ' Segundo ' : ' Tercero ');
          s += nm + '.';
          if (laps > 0) s += ' ' + laps + ' vueltas.';
          if (totalMs > 0) s += ' ' + formatClockMs(totalMs) + '.';
          return s;
        };

        let msg = head + part(top[0],0);
        if (top[1]) msg += part(top[1],1);
        if (top[2]) msg += part(top[2],2);

        enqueueSpeech(msg, {
          key: 'auto_top3_finish_' + rn,
          priority: 99,
          cooldownMs: 0,
          dedupe: true,
          semanticCategory: 'finish',
          semanticThreshold: 0.90,
          semanticWindowMs: 60000
        });

        __autoFinishSummaryDone = true;
      } catch(e) {}
    }

      } catch(e) {
        return { names: [], extra: 0 };
      }
    }

    function __maybeAnnounceAutoIntro(r) {
      try {
        if (!r) return;
        // Al llegar carrera nueva: anuncia siempre (Auto Locutor o Seguimiento)

        // En Auto Locutor, si el usuario no ha tocado VOZ, la activamos en silencio para poder anunciar el titulo
        if (!voiceMasterEnabled) {
          try { if (!userVoiceOverride) setVoiceMaster(true, { silent:true, auto:true }); } catch(e) {}
        }
        if (!voiceMasterEnabled) return;

        const rn = String(r.raceName || '');
        if (!rn) return;

        const introKey = 'auto_intro_title_' + rn;
        const now = Date.now();

        // Si ya anunciamos exitosamente este titulo, no repetir
        if (rn === __autoIntroSig && __autoIntroDoneKeys && __autoIntroDoneKeys.has(introKey)) return;

        // Si aun no se ha podido anunciar (TTS ocupado/errores), reintentar con cooldown corto
        if (rn === __autoIntroSig && now < (__autoIntroRetryAt || 0)) return;

        // Carrera nueva real: reset completo
        const isNewRace = (rn !== __autoIntroSig);
        const sameRace = !isNewRace;
        if (isNewRace) {
          __autoIntroSig = rn;
          try { __autoResetLifecycle(rn); } catch(e) {}
          try { __autoIntroDoneKeys.clear(); } catch(e) { __autoIntroDoneKeys = new Set(); }
        }

        __autoIntroRetryAt = now + 3000;
        // Lifecycle: al llegar carrera nueva, entramos a WAIT_START (silencio) hasta que arranque
        // (ya se resetea arriba solo cuando rn cambia)

        // Reset finishers tracking for new race
        if (isNewRace) {
          __autoFinishSig = '';
          __autoFinishPrevByKey = new Map();
          __autoFinishAnnouncedByKey = new Set();
          __autoFinishPhase = false;
        }
        // Session info SIEMPRE desde raceName nuevo (evita traer la sesion anterior)
        const info = parseSessionFromRaceName(rn) || {};
        try { currentSessionInfo = info; } catch(e) {}

        const type = String(info.type || '').toUpperCase();
        const serie = String(info.serie || '').trim();
        const main = String(info.main || '').trim();

        // Formato pedido (TTS):
        // - MANGA: \"Clasificacion - Qx - Manga X - Serie X\"
        // - FINALES: anuncio por Final A/B/C con arranque + calentamiento
        let introText = '';

                function __pickFinalIntro(mainLetter) {
          const m = String(mainLetter || '').toUpperCase();
          // Default (acordado): FINALES = HYPE, PRO y divertido sin pasarse.
          const A = [
            'Final A. La elite en pista. Vamos a arrancar, pueden calentar.',
            'Final A. Top de pilotos. Vamos a arrancar, pueden calentar.',
            'Final A. Aquíi se corre fino. Vamos a arrancar, pueden calentar.',
            'Final A. Puro nivel. Vamos a arrancar, pueden calentar.',
            'Final A. Los mejores, sin excusas. Vamos a arrancar, pueden calentar.',
            'Final A. Ojos al apex. Vamos a arrancar, pueden calentar.',
            'Final A. Se define en detalles. Vamos a arrancar, pueden calentar.',
            'Final A. La parrilla esta pesada. Vamos a arrancar, pueden calentar.'
          ];
          const B = [
            'Final B. Se pone bueno. Vamos a arrancar, pueden calentar.',
            'Final B. Segunda linea de fuego. Vamos a arrancar, pueden calentar.',
            'Final B. Aquíi se pelea de verdad. Vamos a arrancar, pueden calentar.',
            'Final B. Sin regalos. Vamos a arrancar, pueden calentar.',
            'Final B. Carrera dura, manos suaves. Vamos a arrancar, pueden calentar.',
            'Final B. El podio se gana en paciencia. Vamos a arrancar, pueden calentar.',
            'Final B. Mantengan orden en curva uno. Vamos a arrancar, pueden calentar.',
            'Final B. A correr inteligente. Vamos a arrancar, pueden calentar.'
          ];
          const C = [
            'Final C. Carrera con hambre. Vamos a arrancar, pueden calentar.',
            'Final C. Aquíi todos quieren subir. Vamos a arrancar, pueden calentar.',
            'Final C. Cero contactos, mucha cabeza. Vamos a arrancar, pueden calentar.',
            'Final C. Limpio y constante. Vamos a arrancar, pueden calentar.',
            'Final C. Si te equivocas, pagas. Vamos a arrancar, pueden calentar.',
            'Final C. Que se note el progreso. Vamos a arrancar, pueden calentar.',
            'Final C. Practica hecha, ahora cuenta. Vamos a arrancar, pueden calentar.',
            'Final C. Vamos a divertirnos, pero con control. Vamos a arrancar, pueden calentar.'
          ];
          const mm = (m || 'X');
          const O = [
            'Final ' + mm + '. Vamos a arrancar, pueden calentar.',
            'Final ' + mm + '. Se prende esto. Vamos a arrancar, pueden calentar.',
            'Final ' + mm + '. Ojo en la curva uno. Vamos a arrancar, pueden calentar.',
            'Final ' + mm + '. Ritmo y cabeza. Vamos a arrancar, pueden calentar.'
          ];
          const bag = (m==='A') ? A : (m==='B') ? B : (m==='C') ? C : O;
          // Rotacion real sin repeticion reciente
          return autoRandPick(bag, 'introFinal:' + (m || 'X')) || bag[0];
        }


        function __buildMangaTitleTts2(info) {
          // Formato TTS (pedido): "Clasificacion, Qx, Manga x, Serie x"
          // Nota: sin acento en "Clasificacion" para TTS iOS/Android.
          const parts = ['Clasificacion'];
          const q = String(info.q || '').trim();
          // En tu raceName la MANGA trae letra (ej: "Q1.Manga B") => usamos main (B).
          // Fallback: mangaNo numerico si existe.
          const mLetter = String(info.main || '').trim();
          const mNo = String(info.mangaNo || '').trim();
          const serie = String(info.serie || '').trim();
          if (q) parts.push('Q' + q);
          if (mLetter) { parts.push('Manga'); parts.push(mLetter); }
          else if (mNo) { parts.push('Manga'); parts.push(mNo); }
          if (serie) parts.push('Serie ' + serie);
          return parts.join(', ');
        }

        if (type === 'MANGA') {
          introText = __buildMangaTitleTts2(info);
        } else if (type === 'FINAL') {
          // main es A/B/C si existe
          introText = __pickFinalIntro(main || '');
        } else {
          // fallback
          const label = String(info.label || '').trim();
          const spokenTitle = String(info.spokenTitle || '').trim() || (label ? label.replace('MODO ', '').trim() : '');
          introText = (spokenTitle ? spokenTitle : 'Nueva carrera');
        }

        enqueueSpeech(introText, {
          key: introKey,
          priority: 95,
          cooldownMs: 0,
          dedupe: true,
          maxAgeMs: 60000
        });
      } catch(e) {}
    }

    function __autoAnnounceFinishers() {
      try {
        if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) return;
        // Al llegar carrera nueva: anuncia siempre (Auto Locutor o Seguimiento)
        if (!voiceMasterEnabled) return;

        const info = currentSessionInfo || {};
        const type = String(info.type || '').toUpperCase();
        if (type !== 'FINAL') return; // Solo finales, como pediste
        const dur = Number(info.durationMs) || 0;
        if (!dur) return;

        const rn = String(raceData.raceName || '');
        if (rn && rn !== __autoFinishSig) {
          __autoFinishSig = rn;
          __autoFinishPrevByKey = new Map();
          __autoFinishAnnouncedByKey = new Set();
          __autoFinishPhase = false;
        }

        // Reloj de carrera: usamos tiempo del líder (P1)
        const leader = raceData.classification.find(x => Number(x.pos) === 1) || raceData.classification[0];
        const raceClockMs = getRowTotalMs(leader) || 0;

        // Entramos en fase de cierre cuando el líder ya pas el tiempo objetivo
        if (raceClockMs >= dur) __autoFinishPhase = true;
        if (!__autoFinishPhase) {
          // Aun no toca, pero guardamos prevs
          for (const row of raceData.classification) {
            const key = getPilotKey(row) || safeRacerName(row && row.racerName) || '';
            if (!key) continue;
            const laps = Number(row.lapcount) || 0;
            const totalMs = getRowTotalMs(row) || 0;
            __autoFinishPrevByKey.set(key, { laps, totalMs });
          }
          return;
        }

        // En fase cierre: avisar "X finalizo" cuando cruce el lmite en una vuelta nueva
        let enqueued = 0;
        for (const row of raceData.classification) {
          if (enqueued >= 2) break; // No spamear en un solo tick
          const key = getPilotKey(row) || safeRacerName(row && row.racerName) || '';
          if (!key) continue;

          const nm = safeRacerName(row && row.racerName);
          const laps = Number(row.lapcount) || 0;
          const totalMs = getRowTotalMs(row) || 0;

          const prev = __autoFinishPrevByKey.get(key) || { laps: 0, totalMs: 0 };
          __autoFinishPrevByKey.set(key, { laps, totalMs });

          if (__autoFinishAnnouncedByKey.has(key)) continue;
          if (!isFinite(totalMs) || totalMs <= 0) continue;

          // Solo disparar cuando sube una vuelta
          if (laps <= (prev.laps || 0)) continue;

          // Condicin: cruz el lmite en la última vuelta
          if (totalMs < dur) continue;

          enqueueSpeech((nm || 'Piloto') + ' finalizo.', {
            key: 'auto_finalizo_' + __autoFinishSig + '_' + key,
            priority: 92,
            cooldownMs: 0, // no bloqueo duro: se controla por __autoIntroDoneKeys + retry

            dedupe: true,
            maxAgeMs: 120000
          });

          __autoFinishAnnouncedByKey.add(key);
          enqueued++;
        }
      } catch(e) {}
    }

    // Pintar versin en UI
    window.addEventListener("DOMContentLoaded", () => {
      const el = document.getElementById("appVersion");
      if (el) el.textContent = APP_LABEL;
      // tambin alinear title del documento
      try { document.title = APP_LABEL; } catch(e) {}

      // Debug UI (muestra paneles expertos): agrega ?debug=1 o guarda localStorage aiSpotterDebug=1
      try{
        const qs = new URLSearchParams(location.search);
        const dbg = (qs.get('debug') === '1') || (lsGet('aiSpotterDebug') === '1');
        document.body.classList.toggle('debug', !!dbg);
      }catch(e){}
    });

    

    // Debug: render speech log panel
    function renderSpeechLog() {
      try {
        if (!document.body.classList.contains('debug')) return;
        const box = document.getElementById('speechLogList');
        if (!box) return;
        const list = (Array.isArray(speechLog) ? speechLog : []);
        const last = list.slice(-12).reverse();
        const fmt = (t) => {
          const d = new Date(t);
          const mm = String(d.getMinutes()).padStart(2,'0');
          const ss = String(d.getSeconds()).padStart(2,'0');
          return mm + ':' + ss;
        };
        box.innerHTML = last.map(it => {
          const meta = `${fmt(it.t)} | prio ${it.priority ?? 0} | ${String(it.key||'')}`;
          const txt = String(it.text||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
          return `<div class="speechlog-item"><div class="speechlog-meta">${meta}</div><div>${txt}</div></div>`;
        }).join(' ');
      } catch(e) {}
    }
    try { setInterval(renderSpeechLog, 800); } catch(e) {}
// =========================
    // Helpers globales (compat)
    // =========================
    // =========================
    // LocalStorage SAFE (Google Sites / iOS / privacy)
    // - Si falla, no revienta el spotter; solo no persiste config
    // =========================
    let __lsOk = true;
    function lsGet(key) {
      try { return localStorage.getItem(key); } catch (e) { __lsOk = false; return null; }
    }
    function lsSet(key, value) {
      try { localStorage.setItem(key, value); return true; } catch (e) { __lsOk = false; return false; }
    }
    function lsRemove(key) {
      try { localStorage.removeItem(key); } catch (e) { __lsOk = false; }
    }

    function groupOf(msgId) {
      const id = String(msgId || '').toLowerCase().trim();
      if (!id) return 'misc';
      // Esenciales
      if (['laps','blueflag','ritmo_up','ritmo_down','estlap','leader','podium','bestlap'].includes(id)) return 'ess';
      // Batalla
      if (['pos','gaps','front06','back06','attack','defense','fight'].includes(id)) return 'bat';
      // Resumen
      if (['total','cons10','box','netgain'].includes(id)) return 'sum';
      return 'misc';
    }

    function say(text, opts = {}) {
      // Alias para compatibilidad (algunos mdulos llaman "say")
      return enqueueSpeech(text, opts);
    }

    // =========================
    // Firebase SDK (dynamic import) - evita que un fallo de red/bloqueo truene TODO el spotter
    // =========================
    let initializeApp = null;
    let initializeFirestore = null;
    let doc = null;
    let getDoc = null;
    let onSnapshot = null;
    let __firebaseSdkReady = false;

    async function ensureFirebaseSdk() {
      if (__firebaseSdkReady) return true;
      try {
        const appMod = await import("https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js");
        const fsMod  = await import("https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js");
        initializeApp = appMod.initializeApp;
        initializeFirestore = fsMod.initializeFirestore;
        doc = fsMod.doc;
        getDoc = fsMod.getDoc;
        onSnapshot = fsMod.onSnapshot;
        __firebaseSdkReady = true;
        return true;
      } catch (e) {
        __firebaseSdkReady = false;
        console.error("Firebase SDK no carg (red/bloqueador/CSP)", e);
        return false;
      }
    }

    const firebaseConfig = {
      apiKey: "AIzaSyBaySYvIxH8JsvXCETv3XwVdNecJY1ez2c",
      authDomain: "turbo-racing-zround.firebaseapp.com",
      projectId: "turbo-racing-zround",
      storageBucket: "turbo-racing-zround.firebasestorage.app",
      messagingSenderId: "628478462576",
      appId: "1:628478462576:web:c2dbc45c95bbe362ce42b5"
    };

    // Firebase runtime init (se hace en bootstrap, despus de cargar SDK)
    let appFB = null;
    let db = null;
    let __firebaseOk = false;

    // Watchdog de refresco (si se congela, lo veras en UI)
    let __lastGoodTickMs = 0;
    let __lastReadErr = '';
    let __feedTickCount = 0;

    async function initFirebaseRuntime() {
      try {
        const ok = await ensureFirebaseSdk();
        if (!ok) throw new Error("Firebase SDK no disponible");
        if (!initializeApp || !initializeFirestore || !doc || !getDoc) {
          throw new Error("Firebase SDK incompleto");
        }
        appFB = initializeApp(firebaseConfig);
        db = initializeFirestore(appFB, {
          experimentalForceLongPolling: true,
          useFetchStreams: false
        });
        __firebaseOk = true;
        return true;
      } catch (e) {
        __firebaseOk = false;
        console.error("Firebase init fall", e);
        return false;
      }
    }

    const raceTitleMain   = document.getElementById('raceTitleMain');
    const raceTitleText   = document.getElementById('raceTitleText');
    const raceModeBadge   = document.getElementById('raceModeBadge');
    const raceSubtitle    = document.getElementById('raceSubtitle');
    const raceInfo        = document.getElementById('raceInfo');
    const lastUpdateInfo  = document.getElementById('lastUpdateInfo');
    const liveIndicator   = document.getElementById('liveIndicator');
    const appHeader      = document.querySelector('.app-header');

    const pilotSelect     = document.getElementById('pilotSelect');

    // Pilot Select UX: iOS Safari a veces tarda en poblar la lista al iniciar.
    // - Muestra placeholder "Cargando pilotos..."
    // - Restaura una lista cacheada (si existe) para no dejar el selector vacio
    // - Reintenta poblar en background hasta que llegue classification
    function setPilotSelectLoading(on, msg){
      try{
        const sel = pilotSelect || document.getElementById('pilotSelect');
        if(!sel) return;
        if(on){
          sel.classList.add('is-loading');
          sel.disabled = false;
          sel.innerHTML = '';
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = msg || 'Cargando pilotos...';
          sel.appendChild(opt);
        } else {
          sel.classList.remove('is-loading');
          sel.disabled = false;
        }
      }catch(e){}
    }

    function restorePilotOptionsCache(){
      try{
        const sel = pilotSelect || document.getElementById('pilotSelect');
        if(!sel) return false;
        const raw = (localStorage.getItem('aiSpotterPilotOptionsCache') || '').trim();
        if(!raw) return false;
        const cache = JSON.parse(raw);
        if(!cache || !Array.isArray(cache.options) || cache.options.length < 2) return false;
        sel.innerHTML = '';
        cache.options.forEach(o=>{
          const opt = document.createElement('option');
          opt.value = String(o.value||'');
          opt.textContent = String(o.label||'');
          sel.appendChild(opt);
        });
        return true;
      }catch(e){ return false; }
    }

    function initPilotSelectUIOnce(){
      try{
        const sel = pilotSelect || document.getElementById('pilotSelect');
        if(!sel) return; // DOM aun no listo
        if (window.__pilotSelectUIInitDone) return;
        window.__pilotSelectUIInitDone = true;

        const hadCache = restorePilotOptionsCache();
        if(!hadCache) setPilotSelectLoading(true, 'Cargando pilotos...');

        // Reintentos suaves (Safari a veces tarda en el primer tick del feed)
        let tries = 0;
        const t = setInterval(()=>{
          tries++;
          try{
            if (raceData && Array.isArray(raceData.classification) && raceData.classification.length){
              try { updatePilotOptions(); } catch(e) {}
              setPilotSelectLoading(false);
              clearInterval(t);
              return;
            }
          }catch(e){}
          // Hint opcional (silencioso si showToast aun no existe)
          if (tries === 8){
            try { if (typeof showToast === 'function') showToast('Cargando pilotos...', 1200); } catch(e) {}
          }
          if (tries > 40) clearInterval(t);
        }, 450);
      }catch(e){}
    }

    // Arranque (si el DOM aun no existe, DOMContentLoaded lo activara)
    try { initPilotSelectUIOnce(); } catch(e) {}
    document.addEventListener('DOMContentLoaded', () => { try { initPilotSelectUIOnce(); } catch(e) {} });


    // Botones VOZ (desktop + mini)
    const voiceToggleBtns = Array.from(document.querySelectorAll('[data-voice-toggle]'));

    // Precision badges (1/2/3 dcimas)
    const precisionSelect = document.getElementById('precisionSelect');
    const precisionBadges = Array.from(document.querySelectorAll('.precision-badge'));

    function applyPilotSelectPosTheme(pos){
      if (!pilotSelect) return;
      const classes = ['pos-none','pos-1','pos-2','pos-3','pos-top5','pos-other'];
      for (const c of classes) pilotSelect.classList.remove(c);

      const n = Number(pos);
      if (!pos || !isFinite(n) || n <= 0){
        pilotSelect.classList.add('pos-none');
        return;
      }
      if (n === 1) pilotSelect.classList.add('pos-1');
      else if (n === 2) pilotSelect.classList.add('pos-2');
      else if (n === 3) pilotSelect.classList.add('pos-3');
      else if (n <= 5) pilotSelect.classList.add('pos-top5');
      else pilotSelect.classList.add('pos-other');
    }

    const pilotNameEl     = document.getElementById('pilotName');
    const pilotMetaEl     = document.getElementById('pilotMeta');
    const posTextEl       = document.getElementById('posText');
    const gapInfoEl       = document.getElementById('gapInfo');
    const lastLapEl       = document.getElementById('lastLap');
    const bestLapEl       = document.getElementById('bestLap');
    const meanLapEl       = document.getElementById('meanLap');
    const consistencyValEl = document.getElementById('consistencyVal');
    const sigmaValEl       = document.getElementById('sigmaVal');
    const lapChartEl      = document.getElementById('lapChart');
    const top3MiniGridEl  = document.getElementById('top3MiniGrid');
    const lapChartMetaEl  = document.getElementById('lapChartMeta');
    // Lap Chart - Top 3 simultneo en modo Auto Locutor (P1/P2/P3)
    let lapChartAutoKey = '';

    
    // === Preferencias persistentes (Cookies + fallback localStorage) ===
    function setCookie(name, value, days){
      try{
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        const expires = "expires=" + d.toUTCString();
        document.cookie = name + "=" + encodeURIComponent(value) + ";" + expires + ";path=/;SameSite=Lax";
      }catch(e){}
    }
    function getCookie(name){
      try{
        const n = name + "=";
        const ca = document.cookie ? document.cookie.split(';') : [];
        for (let i=0;i<ca.length;i++){
          let c = ca[i].trim();
          if (c.indexOf(n) === 0) return decodeURIComponent(c.substring(n.length, c.length));
        }
      }catch(e){}
      return null;
    }
    function prefKey(k){ return "TRMX_SPOTTER_" + String(k||""); }
    function prefGet(k, fallback=null){
      const ck = prefKey(k);
      let v = null;
      try{ v = getCookie(ck); }catch(e){}
      if (v == null){
        try{ v = localStorage.getItem(k); }catch(e){}
      }
      if (v == null) return fallback;
      return v;
    }
    function prefSet(k, value, days=365){
      const ck = prefKey(k);
      const v = (typeof value === 'string') ? value : JSON.stringify(value);
      try{ setCookie(ck, v, days); }catch(e){}
      try{ localStorage.setItem(k, v); }catch(e){}
    }

    // Mini grid (TOP 3/TOP 20) estado persistente
    let miniGridExpanded = false;
    let miniGridLimit = 3;
    try {
      miniGridExpanded = (prefGet('miniGridExpanded', '0') === '1');
      miniGridLimit = miniGridExpanded ? 20 : 3;
    } catch(e) { miniGridExpanded = false; miniGridLimit = 3; }

    function htmlEsc(s){
      return String(s == null ? '' : s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    function shortChipName(name){
      const n = (safeRacerName(name) || '').replace(/\s+/g,' ').trim();
      if (!n) return '-';
      return n.length > 12 ? (n.slice(0,12) + '...') : n;
    }

    function getTop3Rows(){
      try{
        const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const top = [];
        const seen = new Set();
        for (let i=0;i<rows.length && top.length<3;i++){
          const r = rows[i];
          if (!r) continue;
          const p = Number(r.pos);
          if (!isFinite(p) || p <= 0) continue;
          const k = getPilotKey(r);
          if (!k || seen.has(k)) continue;
          seen.add(k);
          top.push(r);
        }
        return top;
      }catch(e){ return []; }
    }

    function getTopRows(limit){
      try{
        const lim = Math.max(1, Math.min(50, Number(limit) || 3));
        const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const top = [];
        for (let i=0;i<rows.length && top.length<lim;i++){
          const r = rows[i];
          if (!r) continue;
          const k = getPilotKey(r);
          if (!k) continue;
          top.push(r);
        }
        return top;
      }catch(e){ return []; }
    }

    function getAutoLapChartKey(){
      const top = getTop3Rows();
      const leaderKey = top[0] ? getPilotKey(top[0]) : '';
      if (lapChartAutoKey && top.some(r => getPilotKey(r) === lapChartAutoKey)) return lapChartAutoKey;
      return leaderKey;
    }

    function renderAutoLapChartTop3(){
      if (!lapChartMetaEl) return;
      const top = getTop3Rows();
      if (!top.length){
        lapChartMetaEl.textContent = 'Sin datos';
        return;
      }
      const active = getAutoLapChartKey();
      lapChartMetaEl.innerHTML = top.map((r, i) => {
        const k = getPilotKey(r);
        const label = 'P' + (i+1);
        const nm = shortChipName(r.racerName);
        const posCls = (i===0?'pos1':(i===1?'pos2':'pos3'));
        const cls = (k === active) ? ('lap-pos-chip active ' + posCls) : ('lap-pos-chip ' + posCls);
        return '<span class="' + cls + '" data-key="' + htmlEsc(k) + '" title="' + htmlEsc(safeRacerName(r.racerName) || '') + '"><span class="lp">' + label + '</span><span class="nm">' + htmlEsc(nm) + '</span></span>';
      }).join(' ');
    }

    function renderAutoTop3MiniGrid(){
  if (!top3MiniGridEl) return;

  const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
  rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
  if (!rows.length){
    top3MiniGridEl.innerHTML = '';
    return;
  }

  const limit = Math.min(miniGridLimit || 3, rows.length);
  const top = rows.slice(0, limit);

  if (!window.__miniHist) window.__miniHist = new Map(); // key -> {front:[sec...], back:[sec...]}

  const parseInterval = (raw) => {
    const s0 = String(raw || '').trim();
    if (!s0 || s0 === '-' || s0 === 'LDR') return { sec:null, laps:null };
    const mV = s0.match(/([+-]?\s*\d+)\s*v/i);
    if (mV){
      const n = parseInt(String(mV[1]).replace(/\s+/g,''),10);
      if (isFinite(n)) return { sec:null, laps:Math.abs(n) };
    }
    const s = s0.toLowerCase();
    const mMas = s.match(/m[a]s\s+(\d+|una|un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s+vueltas?/i);
    if (mMas){
      const tok = mMas[1];
      const map = { 'una':1,'un':1,'uno':1,'dos':2,'tres':3,'cuatro':4,'cinco':5,'seis':6,'siete':7,'ocho':8,'nueve':9,'diez':10 };
      const n = /^\d+$/.test(tok) ? parseInt(tok,10) : (map[tok] || NaN);
      if (isFinite(n) && n > 0) return { sec:null, laps:n };
    }
    const f = parseFloat(s0.replace(/[^0-9.+-]/g,''));
    if (isFinite(f)) return { sec:Math.abs(f), laps:null };
    return { sec:null, laps:null };
  };

  const computeBattleTag = (hist, fSec, bSec) => {
    const isManga = (currentSessionInfo && currentSessionInfo.type === 'MANGA');
    const thr = isManga ? 0.55 : 0.60;

    const near2 = (arr) => {
      if (!arr || arr.length < 2) return false;
      const b = arr[arr.length - 2];
      const c = arr[arr.length - 1];
      return isFinite(b) && isFinite(c) && (b <= thr) && (c <= thr);
    };

    const atk = (fSec != null && isFinite(fSec) && fSec <= thr && (near2(hist.front) || (hist.front && hist.front.length>=1 && isFinite(hist.front[hist.front.length-1]) && hist.front[hist.front.length-1] <= thr)));
    const def = (bSec != null && isFinite(bSec) && bSec <= thr && (near2(hist.back) || (hist.back && hist.back.length>=1 && isFinite(hist.back[hist.back.length-1]) && hist.back[hist.back.length-1] <= thr)));

    if (atk && def) return 'DUEL';
    if (atk) return 'ATK';
    if (def) return 'DEF';
    return '-';
  };

  let html = '';

  // Siempre: rows estilo scoreboard (igual que expanded).
  html += '<div class="mini-rows" role="list" aria-label="Timing screen">';
  html += '<div class="mini-head" role="row">';
  html +=   '<div>P</div><div>Piloto</div><div style="text-align:right">V</div><div style="text-align:right">UL</div><div style="text-align:right">INT</div><div style="text-align:right">ST</div>';
  html += '</div>';

  for (let i=0;i<top.length;i++){
    const r = top[i];
    const posVal = Number(r.pos) || (i+1);
    const posCls = (posVal===1?'pos1':(posVal===2?'pos2':(posVal===3?'pos3':'posN')));

    const name = safeRacerName(r.racerName) || '-';
    const _nParts = String(name || '').trim().split(/\s+/).filter(Boolean);
    let name1 = name;
    let name2 = '';
    if (_nParts.length === 2){
      name1 = _nParts[0];
      name2 = _nParts[1];
    } else if (_nParts.length > 2){
      name1 = _nParts.slice(0,2).join(' ');
      name2 = _nParts.slice(2).join(' ');
    }
    const nameCell = '<span class="mt-driver"><span class="mt-line mt-line1">' + htmlEsc(name1) + '</span>' + (name2 ? ('<span class="mt-line mt-line2">' + htmlEsc(name2) + '</span>') : '') + '</span>';

    const laps = formatLaps3(r.lapcount);

    const lastMs = parseTimeToMs((typeof r.lastTime !== 'undefined' ? r.lastTime : (typeof r.lastLap !== 'undefined' ? r.lastLap : (typeof r.lastLapMs !== 'undefined' ? r.lastLapMs : 0))));
    const lastStr = (lastMs && lastMs > 0) ? msToMinSec(lastMs) : '-:--.---';

    // Intervalo al de adelante
    let intervalTxt = '';
    if (posVal === 1) {
      intervalTxt = 'LDR';
    } else {
      const raw = (r.diff != null ? r.diff : (r.interval != null ? r.interval : ''));
      const vis = formatoGapVueltas(raw) || String(raw || '').trim();
      const info = parseInterval(vis);
      if (info.laps != null) intervalTxt = info.laps + 'V';
      else if (info.sec != null && isFinite(info.sec)) intervalTxt = toFixedFloor(info.sec, 2);
      else intervalTxt = vis || '';
    }

    // ATK/DEF/DUEL usando front/back del top visible
    const key = getPilotKey(r) || r._id || (r.racerName || ('p'+posVal));
    const frontRaw = (posVal === 1) ? 'LDR' : (formatoGapVueltas(r.diff != null ? r.diff : (r.interval != null ? r.interval : '')) || (r.diff != null ? r.diff : (r.interval != null ? r.interval : '')));
    const frontInfo = (posVal === 1) ? {sec:null,laps:null} : parseInterval(frontRaw);

    const next = (i < top.length - 1) ? top[i+1] : null;
    const backVis = next ? (formatoGapVueltas(next.diff != null ? next.diff : (next.interval != null ? next.interval : '')) || String(next.diff != null ? next.diff : (next.interval != null ? next.interval : '')) ) : '';
    const backInfo = next ? parseInterval(backVis) : {sec:null,laps:null};

    const H = window.__miniHist;
    let hist = H.get(key);
    if (!hist) { hist = { front: [], back: [] }; H.set(key, hist); }

    const fSec = (frontInfo && frontInfo.laps == null && frontInfo.sec != null && isFinite(frontInfo.sec)) ? Number(frontInfo.sec) : null;
    const bSec = (backInfo  && backInfo.laps  == null && backInfo.sec  != null && isFinite(backInfo.sec))  ? Number(backInfo.sec)  : null;

    if (fSec == null) hist.front = [];
    else { hist.front.push(fSec); if (hist.front.length > 6) hist.front.splice(0, hist.front.length - 6); }

    if (bSec == null) hist.back = [];
    else { hist.back.push(bSec); if (hist.back.length > 6) hist.back.splice(0, hist.back.length - 6); }

    const state = computeBattleTag(hist, fSec, bSec);
    let stateCell = state;
    if (state === 'ATK') stateCell = '<span class="st-atk">ATK</span>';
    else if (state === 'DEF') stateCell = '<span class="st-def">DEF</span>';
    else if (state === 'DUEL') stateCell = '<span class="st-duel">DUEL</span>';
    else stateCell = '<span class="st-na">-</span>';    html += '<div class="mini-row ' + posCls + '" role="listitem">';
      html +=   '<div class="mr-pos">' + htmlEsc(String(posVal)) + '</div>';
      html +=   '<div class="mr-name">' +
                  '<span class="mr-line mr-line1">' + htmlEsc(name1) + '</span>' +
                  (name2 ? ('<span class="mr-line mr-line2">' + htmlEsc(name2) + '</span>') : '') +
                '</div>';
      html +=   '<div class="mr-mono">' + htmlEsc(laps) + '</div>';
      html +=   '<div class="mr-mono">' + htmlEsc(lastStr) + '</div>';
      html +=   '<div class="mr-mono">' + htmlEsc(String(intervalTxt)) + '</div>';
      html +=   '<div class="mr-mono mr-st">' + stateCell + '</div>';
      html += '</div>';
    }
  html += '</div>';

  top3MiniGridEl.innerHTML = html;
}

function applyMiniGridExpandedUI(){
  try{
    if (!top3MiniGridEl) return;
    top3MiniGridEl.classList.add('expanded');
    top3MiniGridEl.setAttribute('aria-label', miniGridExpanded ? 'Top 20 grid' : 'Top 3 grid');
  }catch(e){}
  try{
    const lab = miniGridExpanded ? 'TOP 20' : 'TOP 3';
    if (typeof top3ToggleBtn !== 'undefined' && top3ToggleBtn) top3ToggleBtn.textContent = lab;
    if (btnOpenGrid) btnOpenGrid.textContent = ' ' + lab;
  }catch(e){}
}
applyMiniGridExpandedUI();

try{
  const _toggleMiniGrid = () => {
    miniGridExpanded = !miniGridExpanded;
    miniGridLimit = miniGridExpanded ? 20 : 3;
    try{ prefSet('miniGridExpanded', miniGridExpanded ? '1' : '0'); }catch(e){}
    applyMiniGridExpandedUI();
    try{ renderAutoTop3MiniGrid(); }catch(e){}
  };
  if (btnOpenGrid) btnOpenGrid.addEventListener('click', _toggleMiniGrid);
  if (typeof top3ToggleBtn !== 'undefined' && top3ToggleBtn) top3ToggleBtn.addEventListener('click', _toggleMiniGrid);
}catch(e){}

    const spotterButtons   = document.querySelectorAll('.spotter-btn');
    let voiceMasterEnabled = true;
    try {
      const vme = prefGet('voiceMasterEnabled', null);
      if (vme !== null) voiceMasterEnabled = (vme === '1');
    } catch(e) {}

    // AI: si el usuario nunca ha tocado VOZ, el spotter puede activar voz en Auto Locutor.
    let userVoiceOverride = false;

    // Modo BASICO (solo vueltas, lap time y posicion)
    let basicModeEnabled = false;
    try {
      const bm = prefGet('basicModeEnabled', null);
      if (bm !== null) basicModeEnabled = (bm === '1');
    } catch(e) {}

    const DEFAULT_VOICE_SETTINGS = {
      laps: true,       // siempre activo (no se apaga)
      saylaps: false,   // decir 'vueltas' en el prefijo de LAPS

      // Esenciales (default)
      blueflag: true,
      ritmo: true,

      // Todo lo demas OFF por default (para no abrumar)
      pos: false,
      gaps: false,
      leadergap: false,
      podium: false,
      attack: false,
      defense: false,
      pelea: false,
      netgain: false,
      front06: false,
      back06: false,
      total: false,
      cons10: false,
      estlap: false,
      bestlap: false,
      box: false
    };

    // One-time: aplicar defaults de esta versin (sin pisar cada recarga)
    // - Evita que el usuario se quede con toggles viejos (todo prendido) cuando cambia de base.
    const DEFAULTS_APPLIED_KEY = 'TRM_DEFAULTS_APPLIED_AI_Spotter_TRM_v0.0.0.90';
    try{
      if (localStorage.getItem(DEFAULTS_APPLIED_KEY) === null && localStorage.getItem('spotterVoiceSettings') === null){
        localStorage.setItem('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        prefSet('spotterDecimalPrecision', '2');
        prefSet('raceDirectorEnabled', '1');
        prefSet('raceDirectorMode', 'minimal');
        prefSet('autoCommentatorMode', 'picante');
        localStorage.setItem(DEFAULTS_APPLIED_KEY, '1');
      }
    }catch(e){}

    // Defaults y migracin NO destructiva (por dispositivo)
    // - Antes reseteaba por "versin de esquema" y eso era gasolina en el fuego.
    // - Ahora: solo si no existe, se siembran defaults. Si existe, solo se rellenan faltantes.
    const SETTINGS_SCHEMA_VERSION = 'TRM_SPOTTER_SCHEMA_V1';
    try {
      const prevSchema = lsGet('spotterSettingsSchema');

      // Si es primera vez: seed defaults
      if (prevSchema === null) {
        if (lsGet('spotterVoiceSettings') === null) lsSet('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        if (lsGet('spotterDecimalPrecision') === null) lsSet('spotterDecimalPrecision', '2');
      } else {
        // Upgrade: NO sobreescribir preferencias existentes
        if (lsGet('spotterVoiceSettings') === null) lsSet('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        if (lsGet('spotterDecimalPrecision') === null) lsSet('spotterDecimalPrecision', '2');
      }

      // Actualizamos schema sin resetear
      lsSet('spotterSettingsSchema', SETTINGS_SCHEMA_VERSION);
    } catch (e) {}

    let voiceSettings = { ...DEFAULT_VOICE_SETTINGS };
    let raceDirectorEnabled = true;
    try {
      const rdStored = prefGet('raceDirectorEnabled', null);
      if (rdStored !== null) raceDirectorEnabled = (rdStored === '1');
      else { raceDirectorEnabled = true; try { prefSet('raceDirectorEnabled','1'); } catch(e) {} }
    } catch(e) {}

    const rdToggleBtn = document.getElementById('rdToggleBtn');
    
    // Manual (ayuda)
    const manualBtn       = document.getElementById('manualBtn');
    const skinBtn         = document.getElementById('skinBtn');
    const autoSkinBtn     = document.getElementById('autoSkinBtn');

    // Tema (paquete T1-T8) - orden A: VIC, CARB, BLUE, LIME, PURP, AMBR, ICE, OLED
    const THEME_KEY = 'spotterSkin';
    const AUTO_SKIN_KEY = 'spotterSkinAuto'; // '1'=auto por sesion, '0'=manual
    let autoSkinEnabled = true;

    const THEMES = [
      { key: 'vicpulse', label: 'VIC', cls: 'skin-vicpulse' },
      { key: 'carbon',   label: 'CARB', cls: 'skin-carbon' },
      { key: 'blue',     label: 'BLUE', cls: 'skin-blue' },
      { key: 'lime',     label: 'LIME', cls: 'skin-lime' },
      { key: 'purple',   label: 'PURP', cls: 'skin-purple' },
      { key: 'amber',    label: 'AMBR', cls: 'skin-amber' },
      { key: 'ice',      label: 'ICE',  cls: 'skin-ice' },
      { key: 'oled',     label: 'OLED', cls: 'skin-oled' },
    ]

    // Auto-skin: por defecto ON. Long-press (700ms) en el boton de tema para alternar AUTO/MANUAL.
    try{
      const a = prefGet(AUTO_SKIN_KEY, null);
      if (a === null) { autoSkinEnabled = true; try{ prefSet(AUTO_SKIN_KEY,'1'); }catch(e){} }
      else autoSkinEnabled = (a === '1');
    }catch(e){ autoSkinEnabled = true; }

    function __skinModeLabel(){ return autoSkinEnabled ? 'AUTO' : 'MANUAL'; }

    function refreshAutoSkinUI(){
      if (!autoSkinBtn) return;
      const lbl = document.getElementById('autoSkinLbl');
      if (lbl) lbl.textContent = autoSkinEnabled ? 'AUTO' : 'MAN';
      autoSkinBtn.classList.toggle('active', !!autoSkinEnabled);
      autoSkinBtn.title = autoSkinEnabled
        ? 'Auto-skin: ON (LIBRE->ICE, MANGA->BLUE, FINAL A->AMBR, FINAL B->PURP, FINAL C->LIME)'
        : 'Auto-skin: OFF (manual)';
      try{ if (skinBtn) skinBtn.title = 'Tema: ' + (skinBtn.textContent||'VIC') + (autoSkinEnabled ? ' [AUTO]' : ' [MAN]'); }catch(e){}
    }


    function getSessionInfoFromRaceName(raceName){
      const s0 = String(raceName || '');
      const s = s0.toUpperCase().replace(/\s+/g,' ').trim();
      const out = { kind: 'unknown', main: null, raw: s0 };
      if (!s) return out;

      // Entrenamiento / libre
      if (/(\bLIBRE\b|ENTRENAMIENTO|PRACTICE|TRAINING|WARM\s?UP)/.test(s)){
        out.kind = 'training';
        return out;
      }

      // Finales (A/B/C)
      if (/(\bFINAL\b|A\s?MAIN|B\s?MAIN|C\s?MAIN|MAIN\s?A|MAIN\s?B|MAIN\s?C|A\-MAIN|B\-MAIN|C\-MAIN)/.test(s)){
        out.kind = 'final';
        if (/(FINAL\s*A|A\s?MAIN|MAIN\s?A|A\-MAIN)/.test(s)) out.main = 'A';
        else if (/(FINAL\s*B|B\s?MAIN|MAIN\s?B|B\-MAIN)/.test(s)) out.main = 'B';
        else if (/(FINAL\s*C|C\s?MAIN|MAIN\s?C|C\-MAIN)/.test(s)) out.main = 'C';
        return out;
      }

      // Manga / clasificación (Q)
      if (/(\bMANGA\b|CLASIF|CLASIFICACI|\bQUALI\b|\bQ\d+\b|\bHEAT\b|\bROUND\b)/.test(s)){
        out.kind = 'manga';
        return out;
      }

      return out;
    }

    function getAutoThemeForSessionInfo(info){
      const k = String((info && info.kind) || '').toLowerCase();
      const m = String((info && info.main) || '').toUpperCase();

      // Mapa AUTO (lo que pediste):
      // Entrenamiento/LIBRE -> ICE
      // Manga/Clasificación -> BLUE
      // Final A -> AMBR
      // Final B -> PURP
      // Final C -> LIME
      if (k === 'training') return 'ice';
      if (k === 'manga') return 'blue';
      if (k === 'final'){
        if (m === 'A') return 'amber';
        if (m === 'B') return 'purple';
        if (m === 'C') return 'lime';
        return 'carbon';
      }
      return null;
    }

    function maybeApplyAutoThemeByRaceName(raceName, force=false){
      if ((!autoSkinEnabled) && (!force)) return;
      if (!raceName) return;

      let info = null;
      try { info = getSessionInfoFromRaceName(String(raceName)); } catch(e) { info = null; }
      const rec = getAutoThemeForSessionInfo(info);
      if (!rec) return;

      try { prefSet(THEME_KEY, rec); } catch(e) {}
      applyTheme(rec);
    }

    function toggleAutoSkin(){
      autoSkinEnabled = !autoSkinEnabled;
      try{ prefSet(AUTO_SKIN_KEY, autoSkinEnabled ? '1' : '0'); }catch(e){}

      // Al prender AUTO, aplica el recomendado segun la carrera actual.
      try{ if (typeof lastRaceName !== 'undefined' && lastRaceName) maybeApplyAutoThemeByRaceName(lastRaceName, true); }catch(e){}
      refreshAutoSkinUI();
    }


    function applyTheme(key){
      const found = THEMES.find(t => t.key === key) || THEMES[0];

      // Limpia clases de tema
      for (const t of THEMES) document.body.classList.remove(t.cls);

      // Activa PRO + tema
      document.body.classList.add('skin-pro');
      document.body.classList.add(found.cls);

      if (skinBtn){
        skinBtn.innerHTML = 'VIC&#x1F40A;';
        skinBtn.classList.add('active');
        skinBtn.title = 'Tema: ' + found.label + ' [' + __skinModeLabel() + ']';
      }
      return found.key;
    }

    function nextTheme(){
      let curKey = null;
      try{ curKey = prefGet(THEME_KEY, null); }catch(e){}
      // Compat: valores viejos
      if (curKey === 'std' || !curKey) curKey = 'vicpulse';
      const idx = Math.max(0, THEMES.findIndex(t => t.key === curKey));
      const next = THEMES[(idx + 1) % THEMES.length].key;
      // Si el usuario cambia tema manualmente, apagamos AUTO (override manual).
      try{ prefSet(AUTO_SKIN_KEY,'0'); }catch(e){}
      autoSkinEnabled = false;
      refreshAutoSkinUI();

      try{ prefSet(THEME_KEY, next); }catch(e){}
      applyTheme(next);
    }

    try{
      let stored = null;
      try{ stored = prefGet(THEME_KEY, null); }catch(e){}
      if (!stored || stored === 'std') stored = 'vicpulse';
      applyTheme(stored);
      refreshAutoSkinUI();
    }catch(e){
      applyTheme('vicpulse');
      refreshAutoSkinUI();
    }

    // Boton AUTO: toggle explcito
    if (autoSkinBtn){
      autoSkinBtn.addEventListener('click', ()=>{ toggleAutoSkin(); });
    }

    // Boton TEMA: click = siguiente tema (manual). AUTO se controla solo con el boton AUTO.
    if (skinBtn){
      skinBtn.addEventListener('click', ()=>{ nextTheme(); });
    }
    const manualBackdrop  = document.getElementById('manualBackdrop');
    const manualCloseBtn  = document.getElementById('manualCloseBtn');

    function openManual(){
      if (!manualBackdrop) return;
      manualBackdrop.classList.add('open');
      manualBackdrop.setAttribute('aria-hidden','false');
    }
    function closeManual(){
      if (!manualBackdrop) return;
      manualBackdrop.classList.remove('open');
      manualBackdrop.setAttribute('aria-hidden','true');
    }

    if (manualBtn) manualBtn.addEventListener('click', openManual);
    if (manualCloseBtn) manualCloseBtn.addEventListener('click', closeManual);
    if (manualBackdrop) manualBackdrop.addEventListener('click', (e)=>{ if (e.target === manualBackdrop) closeManual(); });
    window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeManual(); });

    // URL param: ?manual=1
    try{
      const qp = new URLSearchParams(location.search);
      if (qp.get('manual') === '1') setTimeout(openManual, 250);
    
    // Manual tabs
    (function(){
      const root = document.querySelector('#manualBackdrop .manual-panel');
      if (!root) return;
      const tabs = Array.from(root.querySelectorAll('.manual-tab'));
      const panels = Array.from(root.querySelectorAll('.manual-section'));
      if (!tabs.length || !panels.length) return;

      function setTab(id){
        tabs.forEach(t=>{
          const on = (t.dataset.tab === id);
          t.classList.toggle('active', on);
          t.setAttribute('aria-selected', on ? 'true' : 'false');
        });
        panels.forEach(p=>{
          p.classList.toggle('active', p.dataset.tab === id);
        });
      }

      tabs.forEach(t=> t.addEventListener('click', ()=> setTab(t.dataset.tab)));

      // Reset a Inicio cada vez que abres el manual
      const _openManual = openManual;
      window.openManual = function(){
        _openManual();
        setTab('inicio');
      };
    })();
}catch(e){}
let raceDirectorMode = 'minimal';
    try {
      const m = prefGet('raceDirectorMode', null);
      if (m === 'minimal' || m === 'stratega' || m === 'coach' || m === 'sarca' || m === 'engineer' || m === 'hype') raceDirectorMode = m;
      else { raceDirectorMode = 'minimal'; try { prefSet('raceDirectorMode','minimal'); } catch(e) {} }
    } catch(e) {}

    const rdModeMinimal  = document.getElementById('rdModeMinimal');
    const rdModeStratega = document.getElementById('rdModeStratega');
    const rdModeCoach    = document.getElementById('rdModeCoach');
    const rdModeSarca    = document.getElementById('rdModeSarca');
    const rdModeEngineer = document.getElementById('rdModeEngineer');
    const rdModeHype     = document.getElementById('rdModeHype');

    // ===== Auto Locutor (sin piloto) - 3 estilos
    let autoCommentatorMode = 'picante';
    let autoModeUserOverride = false;
    try {
      const m = prefGet('autoCommentatorMode', null);
      if (m === 'pro' || m === 'picante' || m === 'engineer' || m === 'narrativo') autoCommentatorMode = m;
      else { autoCommentatorMode = 'picante'; try { prefSet('autoCommentatorMode','picante'); } catch(e) {} }
    } catch(e) {}

    const autoLocutorPro      = document.getElementById('autoLocutorPro');
    const autoLocutorPicante  = document.getElementById('autoLocutorPicante');
    const autoLocutorEngineer = document.getElementById('autoLocutorEngineer');
    const autoLocutorNarrativo = document.getElementById('autoLocutorNarrativo');

    function updateAutoCommentatorButtons() {
      const setActive = (el, on) => {
        if (!el) return;
        el.classList.toggle('active', !!on);
        el.setAttribute('aria-pressed', on ? 'true' : 'false');
      };
      setActive(autoLocutorPro,      autoCommentatorMode === 'pro');
      setActive(autoLocutorPicante,  autoCommentatorMode === 'picante');
      setActive(autoLocutorEngineer, autoCommentatorMode === 'engineer');
      setActive(autoLocutorNarrativo, autoCommentatorMode === 'narrativo');
    }

    function setAutoCommentatorMode(mode) {
      if (!(mode === 'pro' || mode === 'picante' || mode === 'engineer' || mode === 'narrativo')) return;
      autoModeUserOverride = true;
      autoCommentatorMode = mode;
      try { prefSet('autoCommentatorMode', mode); } catch(e) {}
      updateAutoCommentatorButtons();
    }

    if (autoLocutorPro)      autoLocutorPro.addEventListener('click', () => setAutoCommentatorMode('pro'));
    if (autoLocutorPicante)  autoLocutorPicante.addEventListener('click', () => setAutoCommentatorMode('picante'));
    if (autoLocutorEngineer) autoLocutorEngineer.addEventListener('click', () => setAutoCommentatorMode('engineer'));
    if (autoLocutorNarrativo) autoLocutorNarrativo.addEventListener('click', () => setAutoCommentatorMode('narrativo'));

function updateRdModeButtons() {
      const setActive = (el, on) => {
        if (!el) return;
        el.classList.toggle('active', !!on);
        el.setAttribute('aria-pressed', on ? 'true' : 'false');
};
      setActive(rdModeMinimal,  raceDirectorMode === 'minimal');
      setActive(rdModeStratega, raceDirectorMode === 'stratega');
      setActive(rdModeCoach,    raceDirectorMode === 'coach');
      setActive(rdModeSarca,    raceDirectorMode === 'sarca');
      setActive(rdModeEngineer, raceDirectorMode === 'engineer');
      setActive(rdModeHype,     raceDirectorMode === 'hype');
    }
    function setRaceDirectorMode(mode) {
      if (!(mode === 'minimal' || mode === 'stratega' || mode === 'coach' || mode === 'sarca' || mode === 'engineer' || mode === 'hype')) return;
      raceDirectorMode = mode;
      try { prefSet('raceDirectorMode', mode); } catch(e) {}
      updateRdModeButtons();
    updateAutoCommentatorButtons();
      try { playBeep('tap'); } catch(e) {}
    }
    if (rdModeMinimal)  rdModeMinimal.addEventListener('click',  () => setRaceDirectorMode('minimal'));
    if (rdModeStratega) rdModeStratega.addEventListener('click', () => setRaceDirectorMode('stratega'));
    if (rdModeCoach)    rdModeCoach.addEventListener('click',    () => setRaceDirectorMode('coach'));
    if (rdModeSarca)    rdModeSarca.addEventListener('click',    () => setRaceDirectorMode('sarca'));
    if (rdModeEngineer) rdModeEngineer.addEventListener('click', () => setRaceDirectorMode('engineer'));
    if (rdModeHype)     rdModeHype.addEventListener('click',     () => setRaceDirectorMode('hype'));
updateRdModeButtons();
    updateAutoCommentatorButtons();

    
// Seleccin "shuffle bag" anti repeticin (ms variacin real)
const rdPhraseBag = new Map();

function rdShuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

function rdPick(variants, key) {
  if (!variants || !variants.length) return '';
  const k = key || 'rd';

  // Dedupe de textos idnticos (evita bancos con clones)
  const uniq = [];
  const seen = new Set();
  for (let i = 0; i < variants.length; i++) {
    const t = String(variants[i]);
    if (!seen.has(t)) { seen.add(t); uniq.push(t); }
  }
  if (!uniq.length) return '';

  let st = rdPhraseBag.get(k);
  if (!st || !Array.isArray(st.bag) || st.srcLen !== uniq.length) {
    st = { bag: [], recent: [], srcLen: uniq.length };
  }

  const RECENT_N = Math.min(6, Math.max(2, Math.floor(uniq.length / 4)));

  if (!st.bag.length) {
    const idxs = [];
    for (let i = 0; i < uniq.length; i++) idxs.push(i);
    rdShuffleInPlace(idxs);

    // Si hay suficiente variedad, empuja lo "recin usado" al final del saco
    if (st.recent && st.recent.length && uniq.length > (st.recent.length + 2)) {
      const rec = new Set(st.recent);
      const a = idxs.filter(i => !rec.has(i));
      const b = idxs.filter(i =>  rec.has(i));
      st.bag = a.concat(b);
    } else {
      st.bag = idxs;
    }
  }

  const pickIdx = st.bag.shift();
  st.recent = st.recent || [];
  st.recent.push(pickIdx);
  while (st.recent.length > RECENT_N) st.recent.shift();

  rdPhraseBag.set(k, st);
  return uniq[pickIdx % uniq.length];
}

// ---- RD helpers (persuasivo + preciso, sin metralleta) ----
    function rdSafeName(name) {
      const n = safeRacerName(name);
      return n || 'el de adelante';
    }
    function rdSec(sec) {
      if (sec == null || !isFinite(sec)) return '';
      const v = Math.max(0, sec);
      return toFixedFloor(v, decimalPrecision);
    }
    function rdExtractPos(txt) {
      const m = String(txt || '').match(/P\s*(\d+)/i);
      if (m) return parseInt(m[1], 10) || 0;
      const n = parseInt(String(txt || '').replace(/\D+/g,''), 10) || 0;
      return n;
    }
    function rdTrimWords(text, maxWords) {
      const t = String(text || '').trim();
      if (!t) return '';
      const parts = t.split(/\s+/).filter(Boolean);
      if (parts.length <= maxWords) return t;
      const cut = parts.slice(0, maxWords).join(' ');
      return cut.replace(/[,:;\-]+$/,'') + '...';
    }
    function rdBuildCtx(baseCtx, p) {
      const ctx = baseCtx || {};
      const posNow = Number((p && (p.pos || p.position)) || 0) || 0;
      const frontName = ctx.frontName || '';
      const backName  = ctx.backName || '';
      const frontSec  = ctx.frontSec;
      const backSec   = ctx.backSec;
      return {
        ...ctx,
        posNow,
        frontName,
        backName,
        frontSec,
        backSec,
        frontNameSafe: rdSafeName(frontName),
        backNameSafe: rdSafeName(backName),
        frontSecStr: rdSec(frontSec),
        backSecStr: rdSec(backSec),
      };
    }
    // Banco de frases por modo (A/B/C) - ms humano y distinto
    
    // Banco de frases por modo - humano, persuasivo y con accin
    // Nota: las plantillas aceptan {frontNameSafe}, {backNameSafe}, {frontSecStr}, {backSecStr}, {posNow}
    const RD_PHRASES = {
      minimal: {
        manga: [
          'Manga, vuelta limpia y sin errores.',
          'Manga, vuelta limpia y sin errores. Mantén el plan.',
          'Manga, vuelta limpia y sin errores. Sin regalar nada.',
          'Manga, vuelta limpia y sin errores. Sin prisa, sin pausa.',
          'Manga, vuelta limpia y sin errores. Control total.',
          'Manga, suma vueltas y cuida la trazada.',
          'Manga, suma vueltas y cuida la trazada. Mantén el plan.',
          'Manga, suma vueltas y cuida la trazada. Sin regalar nada.',
          'Manga, suma vueltas y cuida la trazada. Sin prisa, sin pausa.',
          'Manga, suma vueltas y cuida la trazada. Control total.',
          'Manga, ritmo estable, no te salgas.',
          'Manga, ritmo estable, no te salgas. Mantén el plan.',
          'Manga, ritmo estable, no te salgas. Sin regalar nada.',
          'Manga, ritmo estable, no te salgas. Sin prisa, sin pausa.',
          'Manga, ritmo estable, no te salgas. Control total.',
          'Manga, evita tráfico y busca aire limpio.',
          'Manga, evita tráfico y busca aire limpio. Mantén el plan.',
          'Manga, evita tráfico y busca aire limpio. Sin regalar nada.',
          'Manga, evita tráfico y busca aire limpio. Sin prisa, sin pausa.',
          'Manga, evita tráfico y busca aire limpio. Control total.',
          'Manga, todo es consistencia.',
          'Manga, todo es consistencia. Mantén el plan.',
          'Manga, todo es consistencia. Sin regalar nada.',
          'Manga, todo es consistencia. Sin prisa, sin pausa.',
          'Manga, todo es consistencia. Control total.'
        ],
        attack: [
          'Traes a {frontNameSafe} a {frontSecStr}. Prepara el pase.',
          'Traes a {frontNameSafe} a {frontSecStr}. Ataque con calma.',
          'Traes a {frontNameSafe} a {frontSecStr}. Busca salida fuerte.',
          'Traes a {frontNameSafe} a {frontSecStr}. Sin arriesgar de más.',
          'Traes a {frontNameSafe} a {frontSecStr}. Cuida la entrada y acelera.',
          'Traes a {frontNameSafe} a {frontSecStr}. Coloca el intento en zona segura.',
          'Traes a {frontNameSafe} a {frontSecStr}. Un giro más y lo tienes.',
          'Traes a {frontNameSafe} a {frontSecStr}. Mantén presión y el pase cae.',
          'Traes a {frontNameSafe} a {frontSecStr}. enf cate en la salida.',
          'Traes a {frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Prepara el pase.',
          'A {frontSecStr} de {frontNameSafe}. Ataque con calma.',
          'A {frontSecStr} de {frontNameSafe}. Busca salida fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Sin arriesgar de más.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada y acelera.',
          'A {frontSecStr} de {frontNameSafe}. Coloca el intento en zona segura.',
          'A {frontSecStr} de {frontNameSafe}. Un giro más y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Mantén presión y el pase cae.',
          'A {frontSecStr} de {frontNameSafe}. enf cate en la salida.',
          'A {frontSecStr} de {frontNameSafe}. No te abras en la entrada.',
          '{frontNameSafe} est cerca. Prepara el pase.',
          '{frontNameSafe} est cerca. Ataque con calma.',
          '{frontNameSafe} est cerca. Busca salida fuerte.',
          '{frontNameSafe} est cerca. Sin arriesgar de más.',
          '{frontNameSafe} est cerca. Cuida la entrada y acelera.'
        ],
        defense: [
          '{backNameSafe} a {backSecStr}. Cierra la puerta.',
          '{backNameSafe} a {backSecStr}. l nea firme.',
          '{backNameSafe} a {backSecStr}. No regales la entrada.',
          '{backNameSafe} a {backSecStr}. Protege interior.',
          '{backNameSafe} a {backSecStr}. Salida fuerte y recto.',
          '{backNameSafe} a {backSecStr}. Sin volantazos.',
          '{backNameSafe} a {backSecStr}. No te abras.',
          '{backNameSafe} a {backSecStr}. Defiende con trazada.',
          '{backNameSafe} a {backSecStr}. Cubre lo básico.',
          '{backNameSafe} a {backSecStr}. No te desconcentres.',
          'presión atr s: {backNameSafe} a {backSecStr}. Cierra la puerta.',
          'presión atr s: {backNameSafe} a {backSecStr}. l nea firme.',
          'presión atr s: {backNameSafe} a {backSecStr}. No regales la entrada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Protege interior.',
          'presión atr s: {backNameSafe} a {backSecStr}. Salida fuerte y recto.',
          'presión atr s: {backNameSafe} a {backSecStr}. Sin volantazos.',
          'presión atr s: {backNameSafe} a {backSecStr}. No te abras.',
          'presión atr s: {backNameSafe} a {backSecStr}. Defiende con trazada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Cubre lo básico.',
          'presión atr s: {backNameSafe} a {backSecStr}. No te desconcentres.',
          'Ojo atr s con {backNameSafe}. Cierra la puerta.',
          'Ojo atr s con {backNameSafe}. l nea firme.',
          'Ojo atr s con {backNameSafe}. No regales la entrada.',
          'Ojo atr s con {backNameSafe}. Protege interior.',
          'Ojo atr s con {backNameSafe}. Salida fuerte y recto.'
        ],
        fight: [
          'Dos frentes, cabeza fría.',
          'Dos frentes, cabeza fría. Controla el volante.',
          'Dos frentes, cabeza fría. Sin regalos.',
          'Dos frentes, cabeza fría. Todo con calma.',
          'Dos frentes, cabeza fría. Limpio y rápido.',
          'Pelea cerrada, cero errores.',
          'Pelea cerrada, cero errores. Controla el volante.',
          'Pelea cerrada, cero errores. Sin regalos.',
          'Pelea cerrada, cero errores. Todo con calma.',
          'Pelea cerrada, cero errores. Limpio y rápido.',
          'tráfico, no te enredes.',
          'tráfico, no te enredes. Controla el volante.',
          'tráfico, no te enredes. Sin regalos.',
          'tráfico, no te enredes. Todo con calma.',
          'tráfico, no te enredes. Limpio y rápido.',
          'Mucho movimiento, Mantén la l nea.',
          'Mucho movimiento, Mantén la l nea. Controla el volante.',
          'Mucho movimiento, Mantén la l nea. Sin regalos.',
          'Mucho movimiento, Mantén la l nea. Todo con calma.',
          'Mucho movimiento, Mantén la l nea. Limpio y rápido.',
          'Hay pelea, prioriza la salida.',
          'Hay pelea, prioriza la salida. Controla el volante.',
          'Hay pelea, prioriza la salida. Sin regalos.',
          'Hay pelea, prioriza la salida. Todo con calma.',
          'Hay pelea, prioriza la salida. Limpio y rápido.'
        ],
        blueflag: [
          'Bandera azul, Mantén l nea.',
          'Bandera azul, Mantén l nea. Sin drama.',
          'Bandera azul, Mantén l nea. Con seguridad.',
          'Bandera azul, Mantén l nea. Sin perder la l nea.',
          'Bandera azul, Mantén l nea. Todo limpio.',
          'Bandera azul, deja pasar seguro.',
          'Bandera azul, deja pasar seguro. Sin drama.',
          'Bandera azul, deja pasar seguro. Con seguridad.',
          'Bandera azul, deja pasar seguro. Sin perder la l nea.',
          'Bandera azul, deja pasar seguro. Todo limpio.',
          'Bandera azul, no pelees la posición.',
          'Bandera azul, no pelees la posición. Sin drama.',
          'Bandera azul, no pelees la posición. Con seguridad.',
          'Bandera azul, no pelees la posición. Sin perder la l nea.',
          'Bandera azul, no pelees la posición. Todo limpio.',
          'Bandera azul, cede sin frenar de más.',
          'Bandera azul, cede sin frenar de más. Sin drama.',
          'Bandera azul, cede sin frenar de más. Con seguridad.',
          'Bandera azul, cede sin frenar de más. Sin perder la l nea.',
          'Bandera azul, cede sin frenar de más. Todo limpio.',
          'Bandera azul, facilita el pase.',
          'Bandera azul, facilita el pase. Sin drama.',
          'Bandera azul, facilita el pase. Con seguridad.',
          'Bandera azul, facilita el pase. Sin perder la l nea.',
          'Bandera azul, facilita el pase. Todo limpio.'
        ],
        front06: [
          '{frontNameSafe} a {frontSecStr}. Es alcanzable.',
          '{frontNameSafe} a {frontSecStr}. Ventana de pase.',
          '{frontNameSafe} a {frontSecStr}. Mantén la presión.',
          '{frontNameSafe} a {frontSecStr}. Busca salida fuerte.',
          '{frontNameSafe} a {frontSecStr}. Sin desesperarte.',
          '{frontNameSafe} a {frontSecStr}. Cuida la entrada.',
          '{frontNameSafe} a {frontSecStr}. Una curva bien hecha y ests.',
          '{frontNameSafe} a {frontSecStr}. No te abras.',
          '{frontNameSafe} a {frontSecStr}. Pase posible en la siguiente.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Es alcanzable.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ventana de pase.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Mantén la presión.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Busca salida fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Sin desesperarte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Cuida la entrada.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una curva bien hecha y ests.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No te abras.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Pase posible en la siguiente.',
          'A {frontSecStr} de {frontNameSafe}. Es alcanzable.',
          'A {frontSecStr} de {frontNameSafe}. Ventana de pase.',
          'A {frontSecStr} de {frontNameSafe}. Mantén la presión.',
          'A {frontSecStr} de {frontNameSafe}. Busca salida fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Sin desesperarte.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Una curva bien hecha y ests.'
        ],
        back06: [
          '{backNameSafe} a {backSecStr}. Defiende.',
          '{backNameSafe} a {backSecStr}. Cubre interior.',
          '{backNameSafe} a {backSecStr}. l nea firme.',
          '{backNameSafe} a {backSecStr}. No regales la salida.',
          '{backNameSafe} a {backSecStr}. Sin errores.',
          '{backNameSafe} a {backSecStr}. No te abras.',
          '{backNameSafe} a {backSecStr}. Protege la trazada.',
          '{backNameSafe} a {backSecStr}. Salida fuerte.',
          '{backNameSafe} a {backSecStr}. Calma y control.',
          'presión atr s: {backNameSafe} {backSecStr}. Defiende.',
          'presión atr s: {backNameSafe} {backSecStr}. Cubre interior.',
          'presión atr s: {backNameSafe} {backSecStr}. l nea firme.',
          'presión atr s: {backNameSafe} {backSecStr}. No regales la salida.',
          'presión atr s: {backNameSafe} {backSecStr}. Sin errores.',
          'presión atr s: {backNameSafe} {backSecStr}. No te abras.',
          'presión atr s: {backNameSafe} {backSecStr}. Protege la trazada.',
          'presión atr s: {backNameSafe} {backSecStr}. Salida fuerte.',
          'presión atr s: {backNameSafe} {backSecStr}. Calma y control.',
          '{backNameSafe} en rango: {backSecStr}. Defiende.',
          '{backNameSafe} en rango: {backSecStr}. Cubre interior.',
          '{backNameSafe} en rango: {backSecStr}. l nea firme.',
          '{backNameSafe} en rango: {backSecStr}. No regales la salida.',
          '{backNameSafe} en rango: {backSecStr}. Sin errores.',
          '{backNameSafe} en rango: {backSecStr}. No te abras.',
          '{backNameSafe} en rango: {backSecStr}. Protege la trazada.'
        ],
        pos: [
          'Quedaste P{posNow}. enf cate.',
          'Quedaste P{posNow}. Calma y ritmo.',
          'Quedaste P{posNow}. A trabajar.',
          'Quedaste P{posNow}. No te desconcentres.',
          'Quedaste P{posNow}. Hazlo simple.',
          'Quedaste P{posNow}. Cuida la salida.',
          'Quedaste P{posNow}. Ritmo constante.',
          'Quedaste P{posNow}. Sin errores.',
          'Quedaste P{posNow}. Vuelve al plan.',
          'Ahora P{posNow}. enf cate.',
          'Ahora P{posNow}. Calma y ritmo.',
          'Ahora P{posNow}. A trabajar.',
          'Ahora P{posNow}. No te desconcentres.',
          'Ahora P{posNow}. Hazlo simple.',
          'Ahora P{posNow}. Cuida la salida.',
          'Ahora P{posNow}. Ritmo constante.',
          'Ahora P{posNow}. Sin errores.',
          'Ahora P{posNow}. Vuelve al plan.',
          'Vas P{posNow}. enf cate.',
          'Vas P{posNow}. Calma y ritmo.',
          'Vas P{posNow}. A trabajar.',
          'Vas P{posNow}. No te desconcentres.',
          'Vas P{posNow}. Hazlo simple.',
          'Vas P{posNow}. Cuida la salida.',
          'Vas P{posNow}. Ritmo constante.'
        ],
        leader: [
          'líder al frente, controla tus marcas.',
          'líder al frente, controla tus marcas. Sin errores.',
          'líder al frente, controla tus marcas. Limpio.',
          'líder al frente, controla tus marcas. Control total.',
          'líder al frente, controla tus marcas. Paso a paso.',
          'Referencia del líder, no te salgas.',
          'Referencia del líder, no te salgas. Sin errores.',
          'Referencia del líder, no te salgas. Limpio.',
          'Referencia del líder, no te salgas. Control total.',
          'Referencia del líder, no te salgas. Paso a paso.',
          'Mira al líder y copia la l nea.',
          'Mira al líder y copia la l nea. Sin errores.',
          'Mira al líder y copia la l nea. Limpio.',
          'Mira al líder y copia la l nea. Control total.',
          'Mira al líder y copia la l nea. Paso a paso.',
          'El líder marca el ritmo, Mantén precisin.',
          'El líder marca el ritmo, Mantén precisin. Sin errores.',
          'El líder marca el ritmo, Mantén precisin. Limpio.',
          'El líder marca el ritmo, Mantén precisin. Control total.',
          'El líder marca el ritmo, Mantén precisin. Paso a paso.',
          'Observa al líder, trazada limpia.',
          'Observa al líder, trazada limpia. Sin errores.',
          'Observa al líder, trazada limpia. Limpio.',
          'Observa al líder, trazada limpia. Control total.',
          'Observa al líder, trazada limpia. Paso a paso.'
        ],
        podium: [
          'Huele a podio, no te compliques.',
          'Huele a podio, no te compliques. Controla.',
          'Huele a podio, no te compliques. Sin drama.',
          'Huele a podio, no te compliques. Cero regalos.',
          'Huele a podio, no te compliques. Bien hecho.',
          'Podio posible, manejo fino.',
          'Podio posible, manejo fino. Controla.',
          'Podio posible, manejo fino. Sin drama.',
          'Podio posible, manejo fino. Cero regalos.',
          'Podio posible, manejo fino. Bien hecho.',
          'Podio a la vista, sin errores.',
          'Podio a la vista, sin errores. Controla.',
          'Podio a la vista, sin errores. Sin drama.',
          'Podio a la vista, sin errores. Cero regalos.',
          'Podio a la vista, sin errores. Bien hecho.',
          'Podio cerca, no regales la salida.',
          'Podio cerca, no regales la salida. Controla.',
          'Podio cerca, no regales la salida. Sin drama.',
          'Podio cerca, no regales la salida. Cero regalos.',
          'Podio cerca, no regales la salida. Bien hecho.',
          'Ests en zona de podio, calma.',
          'Ests en zona de podio, calma. Controla.',
          'Ests en zona de podio, calma. Sin drama.',
          'Ests en zona de podio, calma. Cero regalos.',
          'Ests en zona de podio, calma. Bien hecho.'
        ],
        trend: [
          'Buen ritmo, repite.',
          'Buen ritmo, repite. Sin apuro.',
          'Buen ritmo, repite. Sin errores.',
          'Buen ritmo, repite. Limpio.',
          'Buen ritmo, repite. Control.',
          'Ritmo cay, ajusta.',
          'Ritmo cay, ajusta. Sin apuro.',
          'Ritmo cay, ajusta. Sin errores.',
          'Ritmo cay, ajusta. Limpio.',
          'Ritmo cay, ajusta. Control.',
          'Consistente, sigue as.',
          'Consistente, sigue as. Sin apuro.',
          'Consistente, sigue as. Sin errores.',
          'Consistente, sigue as. Limpio.',
          'Consistente, sigue as. Control.',
          'Mejorando ritmo, Mantén.',
          'Mejorando ritmo, Mantén. Sin apuro.',
          'Mejorando ritmo, Mantén. Sin errores.',
          'Mejorando ritmo, Mantén. Limpio.',
          'Mejorando ritmo, Mantén. Control.',
          'Ritmo irregular, calma y l nea.',
          'Ritmo irregular, calma y l nea. Sin apuro.',
          'Ritmo irregular, calma y l nea. Sin errores.',
          'Ritmo irregular, calma y l nea. Limpio.',
          'Ritmo irregular, calma y l nea. Control.'
        ],
        est: [
          'estimación lista, Mantén el plan.',
          'estimación lista, Mantén el plan. Todo limpio.',
          'estimación lista, Mantén el plan. Sin drama.',
          'estimación lista, Mantén el plan. A tu ritmo.',
          'estimación lista, Mantén el plan. Control total.',
          'Ojo con la estimación, no te duermas.',
          'Ojo con la estimación, no te duermas. Todo limpio.',
          'Ojo con la estimación, no te duermas. Sin drama.',
          'Ojo con la estimación, no te duermas. A tu ritmo.',
          'Ojo con la estimación, no te duermas. Control total.',
          'estimación estable, sigue empujando.',
          'estimación estable, sigue empujando. Todo limpio.',
          'estimación estable, sigue empujando. Sin drama.',
          'estimación estable, sigue empujando. A tu ritmo.',
          'estimación estable, sigue empujando. Control total.',
          'estimación en marcha, cuida el ritmo.',
          'estimación en marcha, cuida el ritmo. Todo limpio.',
          'estimación en marcha, cuida el ritmo. Sin drama.',
          'estimación en marcha, cuida el ritmo. A tu ritmo.',
          'estimación en marcha, cuida el ritmo. Control total.',
          'estimación cambia, ajusta salida.',
          'estimación cambia, ajusta salida. Todo limpio.',
          'estimación cambia, ajusta salida. Sin drama.',
          'estimación cambia, ajusta salida. A tu ritmo.',
          'estimación cambia, ajusta salida. Control total.'
        ],
        bestlap: [
          'Nueva best lap, bien ahí.',
          'Nueva best lap, bien ahí. Mantén l nea.',
          'Nueva best lap, bien ahí. Sin emoción extra.',
          'Nueva best lap, bien ahí. Control.',
          'Nueva best lap, bien ahí. Perfecto.',
          'Best lap, eso es.',
          'Best lap, eso es. Mantén l nea.',
          'Best lap, eso es. Sin emoción extra.',
          'Best lap, eso es. Control.',
          'Best lap, eso es. Perfecto.',
          'Best lap, rep telo.',
          'Best lap, rep telo. Mantén l nea.',
          'Best lap, rep telo. Sin emoción extra.',
          'Best lap, rep telo. Control.',
          'Best lap, rep telo. Perfecto.',
          'Mejoraste best lap, Mantén.',
          'Mejoraste best lap, Mantén. Mantén l nea.',
          'Mejoraste best lap, Mantén. Sin emoción extra.',
          'Mejoraste best lap, Mantén. Control.',
          'Mejoraste best lap, Mantén. Perfecto.',
          'Best lap confirmada, buen trabajo.',
          'Best lap confirmada, buen trabajo. Mantén l nea.',
          'Best lap confirmada, buen trabajo. Sin emoción extra.',
          'Best lap confirmada, buen trabajo. Control.',
          'Best lap confirmada, buen trabajo. Perfecto.'
        ]
      },
      stratega: {
        manga: [
          'Manga, contra reloj. Busca vuelta limpia.',
          'Manga, contra reloj. Busca vuelta limpia. Mantén el plan.',
          'Manga, contra reloj. Busca vuelta limpia. Sin inventar.',
          'Manga, contra reloj. Busca vuelta limpia. Cero errores.',
          'Manga, contra reloj. Busca vuelta limpia. Vuelta a vuelta.',
          'Manga, suma vueltas y no te salgas.',
          'Manga, suma vueltas y no te salgas. Mantén el plan.',
          'Manga, suma vueltas y no te salgas. Sin inventar.',
          'Manga, suma vueltas y no te salgas. Cero errores.',
          'Manga, suma vueltas y no te salgas. Vuelta a vuelta.',
          'Manga, ritmo constante y sin tráfico.',
          'Manga, ritmo constante y sin tráfico. Mantén el plan.',
          'Manga, ritmo constante y sin tráfico. Sin inventar.',
          'Manga, ritmo constante y sin tráfico. Cero errores.',
          'Manga, ritmo constante y sin tráfico. Vuelta a vuelta.',
          'Manga, prioriza vuelta clara, no pelea.',
          'Manga, prioriza vuelta clara, no pelea. Mantén el plan.',
          'Manga, prioriza vuelta clara, no pelea. Sin inventar.',
          'Manga, prioriza vuelta clara, no pelea. Cero errores.',
          'Manga, prioriza vuelta clara, no pelea. Vuelta a vuelta.',
          'Manga, presión controlada, sin riesgos.',
          'Manga, presión controlada, sin riesgos. Mantén el plan.',
          'Manga, presión controlada, sin riesgos. Sin inventar.',
          'Manga, presión controlada, sin riesgos. Cero errores.',
          'Manga, presión controlada, sin riesgos. Vuelta a vuelta.'
        ],
        attack_front: [
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Ataque quirrgico.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Entra fuerte y sal más fuerte.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Busca la l nea corta.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Una vuelta más y lo ejecutas.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Ataque quirrgico.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Entra fuerte y sal más fuerte.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Busca la l nea corta.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Una vuelta más y lo ejecutas.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Ataque quirrgico.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Entra fuerte y sal más fuerte.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Busca la l nea corta.',
          'Arriba est {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.'
        ],
        attack_mid: [
          '{frontNameSafe} a {frontSecStr}. Arma el pase con paciencia.',
          '{frontNameSafe} a {frontSecStr}. Intenta en recta.',
          '{frontNameSafe} a {frontSecStr}. Cuida la entrada y sal fuerte.',
          '{frontNameSafe} a {frontSecStr}. Si no se da, vuelve a intentarlo.',
          '{frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          '{frontNameSafe} a {frontSecStr}. p salo y respira.',
          '{frontNameSafe} a {frontSecStr}. Hazlo simple y limpio.',
          '{frontNameSafe} a {frontSecStr}. Busca error y capitaliza.',
          '{frontNameSafe} a {frontSecStr}. Coloca el coche y listo.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Arma el pase con paciencia.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Intenta en recta.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Cuida la entrada y sal fuerte.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Si no se da, vuelve a intentarlo.',
          'Cierre con {frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          'Cierre con {frontNameSafe} a {frontSecStr}. p salo y respira.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Hazlo simple y limpio.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Busca error y capitaliza.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Coloca el coche y listo.',
          'A {frontSecStr} de {frontNameSafe}. Arma el pase con paciencia.',
          'A {frontSecStr} de {frontNameSafe}. Intenta en recta.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada y sal fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Si no se da, vuelve a intentarlo.',
          'A {frontSecStr} de {frontNameSafe}. No te abras en la entrada.',
          'A {frontSecStr} de {frontNameSafe}. p salo y respira.',
          'A {frontSecStr} de {frontNameSafe}. Hazlo simple y limpio.'
        ],
        attack_back: [
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec talo.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Presiona y toma la puerta.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Pase rápido, sin drama.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec talo.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Presiona y toma la puerta.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pase rápido, sin drama.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec talo.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.'
        ],
        defense_front: [
          'Defiende el podio: {backNameSafe} a {backSecStr}. Cubre interior.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. l nea dura, sin golpes.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Cierra la puerta y acelera limpio.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Defensa inteligente, sin error.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No frenes de más.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Hazlo predecible y firme.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Cubre interior.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. l nea dura, sin golpes.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Cierra la puerta y acelera limpio.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Defensa inteligente, sin error.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No frenes de más.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Hazlo predecible y firme.',
          'presión por podio: {backNameSafe} {backSecStr}. Cubre interior.',
          'presión por podio: {backNameSafe} {backSecStr}. l nea dura, sin golpes.',
          'presión por podio: {backNameSafe} {backSecStr}. Salida fuerte.',
          'presión por podio: {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'presión por podio: {backNameSafe} {backSecStr}. Cierra la puerta y acelera limpio.',
          'presión por podio: {backNameSafe} {backSecStr}. Defensa inteligente, sin error.',
          'presión por podio: {backNameSafe} {backSecStr}. No te abras en la entrada.'
        ],
        defense_mid: [
          '{backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          '{backNameSafe} a {backSecStr}. Defiende con l nea, no con volantazo.',
          '{backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          '{backNameSafe} a {backSecStr}. No regales la curva.',
          '{backNameSafe} a {backSecStr}. Calma, trazada limpia.',
          '{backNameSafe} a {backSecStr}. No frenes tarde de más.',
          '{backNameSafe} a {backSecStr}. Mantén la puerta cerrada.',
          '{backNameSafe} a {backSecStr}. Control total.',
          'Te cazan: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Te cazan: {backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          'Te cazan: {backNameSafe} a {backSecStr}. Defiende con l nea, no con volantazo.',
          'Te cazan: {backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          'Te cazan: {backNameSafe} a {backSecStr}. No regales la curva.',
          'Te cazan: {backNameSafe} a {backSecStr}. Calma, trazada limpia.',
          'Te cazan: {backNameSafe} a {backSecStr}. No frenes tarde de más.',
          'Te cazan: {backNameSafe} a {backSecStr}. Mantén la puerta cerrada.',
          'Te cazan: {backNameSafe} a {backSecStr}. Control total.',
          'presión atr s con {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'presión atr s con {backNameSafe} {backSecStr}. Salida fuerte, sin error.',
          'presión atr s con {backNameSafe} {backSecStr}. Defiende con l nea, no con volantazo.',
          'presión atr s con {backNameSafe} {backSecStr}. Cubre interior y acelera.',
          'presión atr s con {backNameSafe} {backSecStr}. No regales la curva.',
          'presión atr s con {backNameSafe} {backSecStr}. Calma, trazada limpia.',
          'presión atr s con {backNameSafe} {backSecStr}. No frenes tarde de más.'
        ],
        defense_back: [
          'No regales: {backNameSafe} a {backSecStr}. Orden y manejo.',
          'No regales: {backNameSafe} a {backSecStr}. Sube ritmo sin error.',
          'No regales: {backNameSafe} a {backSecStr}. Cubre interior y listo.',
          'No regales: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'No regales: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'No regales: {backNameSafe} a {backSecStr}. No inventes, defiende.',
          'No regales: {backNameSafe} a {backSecStr}. l nea firme.',
          'No regales: {backNameSafe} a {backSecStr}. Sin drama, pero firme.',
          'No regales: {backNameSafe} a {backSecStr}. Mantén la calma.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Orden y manejo.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Sube ritmo sin error.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Cubre interior y listo.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. No te abras en la entrada.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Salida fuerte.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. No inventes, defiende.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. l nea firme.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Sin drama, pero firme.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Mantén la calma.',
          'presión real: {backNameSafe} a {backSecStr}. Orden y manejo.',
          'presión real: {backNameSafe} a {backSecStr}. Sube ritmo sin error.',
          'presión real: {backNameSafe} a {backSecStr}. Cubre interior y listo.',
          'presión real: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'presión real: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'presión real: {backNameSafe} a {backSecStr}. No inventes, defiende.',
          'presión real: {backNameSafe} a {backSecStr}. l nea firme.'
        ],
        fight: [
          'Pelea viva: adelante y atr s. Prioriza salida.',
          'Pelea viva: adelante y atr s. Prioriza salida. Plan claro.',
          'Pelea viva: adelante y atr s. Prioriza salida. Sin riesgos tontos.',
          'Pelea viva: adelante y atr s. Prioriza salida. Salida fuerte.',
          'Pelea viva: adelante y atr s. Prioriza salida. Todo limpio.',
          'Doble presión, decide: o atacas o aseguras.',
          'Doble presión, decide: o atacas o aseguras. Plan claro.',
          'Doble presión, decide: o atacas o aseguras. Sin riesgos tontos.',
          'Doble presión, decide: o atacas o aseguras. Salida fuerte.',
          'Doble presión, decide: o atacas o aseguras. Todo limpio.',
          'tráfico pesado. No pierdas tiempo en tonteras.',
          'tráfico pesado. No pierdas tiempo en tonteras. Plan claro.',
          'tráfico pesado. No pierdas tiempo en tonteras. Sin riesgos tontos.',
          'tráfico pesado. No pierdas tiempo en tonteras. Salida fuerte.',
          'tráfico pesado. No pierdas tiempo en tonteras. Todo limpio.',
          'Dos frentes. Elige la batalla correcta.',
          'Dos frentes. Elige la batalla correcta. Plan claro.',
          'Dos frentes. Elige la batalla correcta. Sin riesgos tontos.',
          'Dos frentes. Elige la batalla correcta. Salida fuerte.',
          'Dos frentes. Elige la batalla correcta. Todo limpio.',
          'Cuidado con el tráfico, no regales segundos.',
          'Cuidado con el tráfico, no regales segundos. Plan claro.',
          'Cuidado con el tráfico, no regales segundos. Sin riesgos tontos.',
          'Cuidado con el tráfico, no regales segundos. Salida fuerte.',
          'Cuidado con el tráfico, no regales segundos. Todo limpio.'
        ],
        blueflag: [
          'Bandera azul. líder encima. Mantén l nea y deja pasar.',
          'Bandera azul. líder encima. Mantén l nea y deja pasar. Con seguridad.',
          'Bandera azul. líder encima. Mantén l nea y deja pasar. Sin perder tiempo.',
          'Bandera azul. líder encima. Mantén l nea y deja pasar. Todo limpio.',
          'Bandera azul. líder encima. Mantén l nea y deja pasar. Sin riesgos.',
          'Bandera azul. No te metas en broncas, cede seguro.',
          'Bandera azul. No te metas en broncas, cede seguro. Con seguridad.',
          'Bandera azul. No te metas en broncas, cede seguro. Sin perder tiempo.',
          'Bandera azul. No te metas en broncas, cede seguro. Todo limpio.',
          'Bandera azul. No te metas en broncas, cede seguro. Sin riesgos.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Con seguridad.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Sin perder tiempo.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Todo limpio.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Sin riesgos.',
          'Bandera azul. l nea predecible, no frenes raro.',
          'Bandera azul. l nea predecible, no frenes raro. Con seguridad.',
          'Bandera azul. l nea predecible, no frenes raro. Sin perder tiempo.',
          'Bandera azul. l nea predecible, no frenes raro. Todo limpio.',
          'Bandera azul. l nea predecible, no frenes raro. Sin riesgos.',
          'Bandera azul. Abre espacio en la salida.',
          'Bandera azul. Abre espacio en la salida. Con seguridad.',
          'Bandera azul. Abre espacio en la salida. Sin perder tiempo.',
          'Bandera azul. Abre espacio en la salida. Todo limpio.',
          'Bandera azul. Abre espacio en la salida. Sin riesgos.'
        ],
        front06: [
          '{frontNameSafe} a {frontSecStr}. Ventana de ataque abierta.',
          '{frontNameSafe} a {frontSecStr}. Prepara maniobra.',
          '{frontNameSafe} a {frontSecStr}. Entra fuerte, sal más fuerte.',
          '{frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          '{frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          '{frontNameSafe} a {frontSecStr}. Busca el error y capitaliza.',
          '{frontNameSafe} a {frontSecStr}. Ataque en zona segura.',
          '{frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          '{frontNameSafe} a {frontSecStr}. Una vuelta más y lo ejecutas.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ventana de ataque abierta.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Prepara maniobra.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Entra fuerte, sal más fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No dudes en la recta.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Corta la curva y acelera.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Busca el error y capitaliza.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ataque en zona segura.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Presiona sin regalar.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una vuelta más y lo ejecutas.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Ventana de ataque abierta.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Prepara maniobra.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Entra fuerte, sal más fuerte.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Busca el error y capitaliza.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Ataque en zona segura.'
        ],
        back06: [
          '{backNameSafe} a {backSecStr}. Defensa inteligente, sin errores.',
          '{backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          '{backNameSafe} a {backSecStr}. No abras la puerta.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          '{backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          '{backNameSafe} a {backSecStr}. Trazada firme, sin volantazo.',
          '{backNameSafe} a {backSecStr}. Defiende con cabeza.',
          '{backNameSafe} a {backSecStr}. No regales la curva.',
          '{backNameSafe} a {backSecStr}. Calma y control.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Defensa inteligente, sin errores.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Cubre interior y acelera.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. No abras la puerta.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Salida fuerte, sin error.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Trazada firme, sin volantazo.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Defiende con cabeza.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. No regales la curva.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Calma y control.',
          'presión atr s: {backNameSafe} a {backSecStr}. Defensa inteligente, sin errores.',
          'presión atr s: {backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          'presión atr s: {backNameSafe} a {backSecStr}. No abras la puerta.',
          'presión atr s: {backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          'presión atr s: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Trazada firme, sin volantazo.',
          'presión atr s: {backNameSafe} a {backSecStr}. Defiende con cabeza.'
        ],
        pos: [
          'Ahora P{posNow}. Reacciona: l nea limpia y salida fuerte.',
          'Ahora P{posNow}. Cero errores, recupera ritmo.',
          'Ahora P{posNow}. acom date y vuelve al ataque.',
          'Ahora P{posNow}. Plan claro: salida manda.',
          'Ahora P{posNow}. Busca aire limpio y aprieta.',
          'Ahora P{posNow}. Sin prisa tonta, pero firme.',
          'Ahora P{posNow}. Orden y gas.',
          'Ahora P{posNow}. No inventes, ejecuta.',
          'Ahora P{posNow}. A trabajar, vuelta a vuelta.',
          'P{posNow}. Reacciona: l nea limpia y salida fuerte.',
          'P{posNow}. Cero errores, recupera ritmo.',
          'P{posNow}. acom date y vuelve al ataque.',
          'P{posNow}. Plan claro: salida manda.',
          'P{posNow}. Busca aire limpio y aprieta.',
          'P{posNow}. Sin prisa tonta, pero firme.',
          'P{posNow}. Orden y gas.',
          'P{posNow}. No inventes, ejecuta.',
          'P{posNow}. A trabajar, vuelta a vuelta.',
          'Vas P{posNow}. Reacciona: l nea limpia y salida fuerte.',
          'Vas P{posNow}. Cero errores, recupera ritmo.',
          'Vas P{posNow}. acom date y vuelve al ataque.',
          'Vas P{posNow}. Plan claro: salida manda.',
          'Vas P{posNow}. Busca aire limpio y aprieta.',
          'Vas P{posNow}. Sin prisa tonta, pero firme.',
          'Vas P{posNow}. Orden y gas.'
        ],
        leader: [
          'líder al frente. Usa referencia y no te desesperes.',
          'líder al frente. Usa referencia y no te desesperes. Plan claro.',
          'líder al frente. Usa referencia y no te desesperes. Vuelta a vuelta.',
          'líder al frente. Usa referencia y no te desesperes. Control total.',
          'líder al frente. Usa referencia y no te desesperes. Salida fuerte.',
          'El líder marca la pauta. Copia frenada y salida.',
          'El líder marca la pauta. Copia frenada y salida. Plan claro.',
          'El líder marca la pauta. Copia frenada y salida. Vuelta a vuelta.',
          'El líder marca la pauta. Copia frenada y salida. Control total.',
          'El líder marca la pauta. Copia frenada y salida. Salida fuerte.',
          'Mide al líder. Tu carrera es precisin.',
          'Mide al líder. Tu carrera es precisin. Plan claro.',
          'Mide al líder. Tu carrera es precisin. Vuelta a vuelta.',
          'Mide al líder. Tu carrera es precisin. Control total.',
          'Mide al líder. Tu carrera es precisin. Salida fuerte.',
          'líder al frente. No persigas, ejecuta.',
          'líder al frente. No persigas, ejecuta. Plan claro.',
          'líder al frente. No persigas, ejecuta. Vuelta a vuelta.',
          'líder al frente. No persigas, ejecuta. Control total.',
          'líder al frente. No persigas, ejecuta. Salida fuerte.',
          'líder adelante. Tu vuelta, tu plan.',
          'líder adelante. Tu vuelta, tu plan. Plan claro.',
          'líder adelante. Tu vuelta, tu plan. Vuelta a vuelta.',
          'líder adelante. Tu vuelta, tu plan. Control total.',
          'líder adelante. Tu vuelta, tu plan. Salida fuerte.'
        ],
        podium: [
          'Podio posible. Prioriza consistencia y no te enredes.',
          'Podio posible. Prioriza consistencia y no te enredes. Sin riesgos tontos.',
          'Podio posible. Prioriza consistencia y no te enredes. Control.',
          'Podio posible. Prioriza consistencia y no te enredes. Limpio.',
          'Podio posible. Prioriza consistencia y no te enredes. Firme.',
          'Ests peleando podio. Manejo fino, cero regalos.',
          'Ests peleando podio. Manejo fino, cero regalos. Sin riesgos tontos.',
          'Ests peleando podio. Manejo fino, cero regalos. Control.',
          'Ests peleando podio. Manejo fino, cero regalos. Limpio.',
          'Ests peleando podio. Manejo fino, cero regalos. Firme.',
          'Podio cerca. Paciencia en el tráfico.',
          'Podio cerca. Paciencia en el tráfico. Sin riesgos tontos.',
          'Podio cerca. Paciencia en el tráfico. Control.',
          'Podio cerca. Paciencia en el tráfico. Limpio.',
          'Podio cerca. Paciencia en el tráfico. Firme.',
          'Zona de podio. Salida manda.',
          'Zona de podio. Salida manda. Sin riesgos tontos.',
          'Zona de podio. Salida manda. Control.',
          'Zona de podio. Salida manda. Limpio.',
          'Zona de podio. Salida manda. Firme.',
          'Podio en juego. No inventes en la entrada.',
          'Podio en juego. No inventes en la entrada. Sin riesgos tontos.',
          'Podio en juego. No inventes en la entrada. Control.',
          'Podio en juego. No inventes en la entrada. Limpio.',
          'Podio en juego. No inventes en la entrada. Firme.'
        ],
        trend: [
          'Ritmo subiendo. Mantén la presión.',
          'Ritmo subiendo. Mantén la presión. Vuelta a vuelta.',
          'Ritmo subiendo. Mantén la presión. Control total.',
          'Ritmo subiendo. Mantén la presión. Sin errores.',
          'Ritmo subiendo. Mantén la presión. Plan claro.',
          'Ritmo baj. Corrige trazada y salida.',
          'Ritmo baj. Corrige trazada y salida. Vuelta a vuelta.',
          'Ritmo baj. Corrige trazada y salida. Control total.',
          'Ritmo baj. Corrige trazada y salida. Sin errores.',
          'Ritmo baj. Corrige trazada y salida. Plan claro.',
          'Consistente. Repite la l nea y aprieta.',
          'Consistente. Repite la l nea y aprieta. Vuelta a vuelta.',
          'Consistente. Repite la l nea y aprieta. Control total.',
          'Consistente. Repite la l nea y aprieta. Sin errores.',
          'Consistente. Repite la l nea y aprieta. Plan claro.',
          'Ritmo slido. No cambies nada.',
          'Ritmo slido. No cambies nada. Vuelta a vuelta.',
          'Ritmo slido. No cambies nada. Control total.',
          'Ritmo slido. No cambies nada. Sin errores.',
          'Ritmo slido. No cambies nada. Plan claro.',
          'Ritmo irregular. Vuelve al plan.',
          'Ritmo irregular. Vuelve al plan. Vuelta a vuelta.',
          'Ritmo irregular. Vuelve al plan. Control total.',
          'Ritmo irregular. Vuelve al plan. Sin errores.',
          'Ritmo irregular. Vuelve al plan. Plan claro.'
        ],
        est: [
          'estimación en marcha. No te desconcentres.',
          'estimación en marcha. No te desconcentres. Control.',
          'estimación en marcha. No te desconcentres. Sin drama.',
          'estimación en marcha. No te desconcentres. Limpio.',
          'estimación en marcha. No te desconcentres. Plan claro.',
          'La estimación cambi. Ajusta y sigue.',
          'La estimación cambi. Ajusta y sigue. Control.',
          'La estimación cambi. Ajusta y sigue. Sin drama.',
          'La estimación cambi. Ajusta y sigue. Limpio.',
          'La estimación cambi. Ajusta y sigue. Plan claro.',
          'estimación estable. Mantén ritmo limpio.',
          'estimación estable. Mantén ritmo limpio. Control.',
          'estimación estable. Mantén ritmo limpio. Sin drama.',
          'estimación estable. Mantén ritmo limpio. Limpio.',
          'estimación estable. Mantén ritmo limpio. Plan claro.',
          'estimación lista. No regales la salida.',
          'estimación lista. No regales la salida. Control.',
          'estimación lista. No regales la salida. Sin drama.',
          'estimación lista. No regales la salida. Limpio.',
          'estimación lista. No regales la salida. Plan claro.',
          'estimación marcada. Control de riesgo.',
          'estimación marcada. Control de riesgo. Control.',
          'estimación marcada. Control de riesgo. Sin drama.',
          'estimación marcada. Control de riesgo. Limpio.',
          'estimación marcada. Control de riesgo. Plan claro.'
        ],
        bestlap: [
          'Best lap confirmada. Ahora rep tela sin riesgo.',
          'Best lap confirmada. Ahora rep tela sin riesgo. Sin riesgos.',
          'Best lap confirmada. Ahora rep tela sin riesgo. Limpio.',
          'Best lap confirmada. Ahora rep tela sin riesgo. Plan claro.',
          'Best lap confirmada. Ahora rep tela sin riesgo. Vuelta a vuelta.',
          'Mejoraste best lap. sostén el ritmo.',
          'Mejoraste best lap. sostén el ritmo. Sin riesgos.',
          'Mejoraste best lap. sostén el ritmo. Limpio.',
          'Mejoraste best lap. sostén el ritmo. Plan claro.',
          'Mejoraste best lap. sostén el ritmo. Vuelta a vuelta.',
          'Best lap. No te emociones, repite.',
          'Best lap. No te emociones, repite. Sin riesgos.',
          'Best lap. No te emociones, repite. Limpio.',
          'Best lap. No te emociones, repite. Plan claro.',
          'Best lap. No te emociones, repite. Vuelta a vuelta.',
          'Best lap. Buen trabajo, ahora consistencia.',
          'Best lap. Buen trabajo, ahora consistencia. Sin riesgos.',
          'Best lap. Buen trabajo, ahora consistencia. Limpio.',
          'Best lap. Buen trabajo, ahora consistencia. Plan claro.',
          'Best lap. Buen trabajo, ahora consistencia. Vuelta a vuelta.',
          'Nueva best lap. Mantén la l nea.',
          'Nueva best lap. Mantén la l nea. Sin riesgos.',
          'Nueva best lap. Mantén la l nea. Limpio.',
          'Nueva best lap. Mantén la l nea. Plan claro.',
          'Nueva best lap. Mantén la l nea. Vuelta a vuelta.'
        ]
      },
      coach: {
        manga: [
          'Manga: vuelta limpia. Respira y aprieta.',
          'Manga: vuelta limpia. Respira y aprieta. T  puedes.',
          'Manga: vuelta limpia. Respira y aprieta. Mantén el plan.',
          'Manga: vuelta limpia. Respira y aprieta. Sin presionarte.',
          'Manga: vuelta limpia. Respira y aprieta. Paso a paso.',
          'Manga: sin errores. Cada meta cuenta.',
          'Manga: sin errores. Cada meta cuenta. T  puedes.',
          'Manga: sin errores. Cada meta cuenta. Mantén el plan.',
          'Manga: sin errores. Cada meta cuenta. Sin presionarte.',
          'Manga: sin errores. Cada meta cuenta. Paso a paso.',
          'Manga: constancia. No persigas fantasmas.',
          'Manga: constancia. No persigas fantasmas. T  puedes.',
          'Manga: constancia. No persigas fantasmas. Mantén el plan.',
          'Manga: constancia. No persigas fantasmas. Sin presionarte.',
          'Manga: constancia. No persigas fantasmas. Paso a paso.',
          'Manga: manos suaves, l nea firme.',
          'Manga: manos suaves, l nea firme. T  puedes.',
          'Manga: manos suaves, l nea firme. Mantén el plan.',
          'Manga: manos suaves, l nea firme. Sin presionarte.',
          'Manga: manos suaves, l nea firme. Paso a paso.',
          'Manga: aire limpio y ritmo estable.',
          'Manga: aire limpio y ritmo estable. T  puedes.',
          'Manga: aire limpio y ritmo estable. Mantén el plan.',
          'Manga: aire limpio y ritmo estable. Sin presionarte.',
          'Manga: aire limpio y ritmo estable. Paso a paso.'
        ],
        attack: [
          'Vas alcanzando a {frontNameSafe}. Entra suave, sal fuerte.',
          'Vas alcanzando a {frontNameSafe}. Prepara el pase seguro.',
          'Vas alcanzando a {frontNameSafe}. Hazlo limpio, sin tocar.',
          'Vas alcanzando a {frontNameSafe}. Cuida la salida y lo tienes.',
          'Vas alcanzando a {frontNameSafe}. Paciencia, el pase llega.',
          'Vas alcanzando a {frontNameSafe}. No fuerces la entrada.',
          'Vas alcanzando a {frontNameSafe}. Busca aire limpio y ejecuta.',
          'Vas alcanzando a {frontNameSafe}. Un giro más y cae.',
          'Vas alcanzando a {frontNameSafe}. Con calma y precisin.',
          'Vas alcanzando a {frontNameSafe}. Sin prisa tonta.',
          'A {frontSecStr} de {frontNameSafe}. Entra suave, sal fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Prepara el pase seguro.',
          'A {frontSecStr} de {frontNameSafe}. Hazlo limpio, sin tocar.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la salida y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Paciencia, el pase llega.',
          'A {frontSecStr} de {frontNameSafe}. No fuerces la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Busca aire limpio y ejecuta.',
          'A {frontSecStr} de {frontNameSafe}. Un giro más y cae.',
          'A {frontSecStr} de {frontNameSafe}. Con calma y precisin.',
          'A {frontSecStr} de {frontNameSafe}. Sin prisa tonta.',
          '{frontNameSafe} est cerca. Entra suave, sal fuerte.',
          '{frontNameSafe} est cerca. Prepara el pase seguro.',
          '{frontNameSafe} est cerca. Hazlo limpio, sin tocar.',
          '{frontNameSafe} est cerca. Cuida la salida y lo tienes.',
          '{frontNameSafe} est cerca. Paciencia, el pase llega.'
        ],
        defense: [
          'Te viene {backNameSafe}. Mantén tu l nea y acelera limpio.',
          'Te viene {backNameSafe}. Puerta cerrada, sin frenar de más.',
          'Te viene {backNameSafe}. Protege interior.',
          'Te viene {backNameSafe}. Defiende con trazada, no con golpes.',
          'Te viene {backNameSafe}. Salida fuerte, manos suaves.',
          'Te viene {backNameSafe}. No te abras en la entrada.',
          'Te viene {backNameSafe}. Respira y controla.',
          'Te viene {backNameSafe}. Todo limpio.',
          'Te viene {backNameSafe}. Sin errores.',
          'Te viene {backNameSafe}. Calma, lo tienes.',
          '{backNameSafe} a {backSecStr}. Mantén tu l nea y acelera limpio.',
          '{backNameSafe} a {backSecStr}. Puerta cerrada, sin frenar de más.',
          '{backNameSafe} a {backSecStr}. Protege interior.',
          '{backNameSafe} a {backSecStr}. Defiende con trazada, no con golpes.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, manos suaves.',
          '{backNameSafe} a {backSecStr}. No te abras en la entrada.',
          '{backNameSafe} a {backSecStr}. Respira y controla.',
          '{backNameSafe} a {backSecStr}. Todo limpio.',
          '{backNameSafe} a {backSecStr}. Sin errores.',
          '{backNameSafe} a {backSecStr}. Calma, lo tienes.',
          'Ojo atr s con {backNameSafe}. Mantén tu l nea y acelera limpio.',
          'Ojo atr s con {backNameSafe}. Puerta cerrada, sin frenar de más.',
          'Ojo atr s con {backNameSafe}. Protege interior.',
          'Ojo atr s con {backNameSafe}. Defiende con trazada, no con golpes.',
          'Ojo atr s con {backNameSafe}. Salida fuerte, manos suaves.'
        ],
        fight: [
          'Hay pelea. Prioriza salida y cero errores.',
          'Hay pelea. Prioriza salida y cero errores. T  puedes.',
          'Hay pelea. Prioriza salida y cero errores. Paso a paso.',
          'Hay pelea. Prioriza salida y cero errores. Sin drama.',
          'Hay pelea. Prioriza salida y cero errores. Limpio y rápido.',
          'Dos frentes. Cabeza fría, trazada limpia.',
          'Dos frentes. Cabeza fría, trazada limpia. T  puedes.',
          'Dos frentes. Cabeza fría, trazada limpia. Paso a paso.',
          'Dos frentes. Cabeza fría, trazada limpia. Sin drama.',
          'Dos frentes. Cabeza fría, trazada limpia. Limpio y rápido.',
          'tráfico. No te enganches, s  inteligente.',
          'tráfico. No te enganches, s  inteligente. T  puedes.',
          'tráfico. No te enganches, s  inteligente. Paso a paso.',
          'tráfico. No te enganches, s  inteligente. Sin drama.',
          'tráfico. No te enganches, s  inteligente. Limpio y rápido.',
          'Mantén la calma, el pase llega.',
          'Mantén la calma, el pase llega. T  puedes.',
          'Mantén la calma, el pase llega. Paso a paso.',
          'Mantén la calma, el pase llega. Sin drama.',
          'Mantén la calma, el pase llega. Limpio y rápido.',
          'No todo es ahora, cuida el coche.',
          'No todo es ahora, cuida el coche. T  puedes.',
          'No todo es ahora, cuida el coche. Paso a paso.',
          'No todo es ahora, cuida el coche. Sin drama.',
          'No todo es ahora, cuida el coche. Limpio y rápido.'
        ],
        blueflag: [
          'Bandera azul. Deja pasar sin perder la l nea.',
          'Bandera azul. Deja pasar sin perder la l nea. Con seguridad.',
          'Bandera azul. Deja pasar sin perder la l nea. Sin drama.',
          'Bandera azul. Deja pasar sin perder la l nea. Todo limpio.',
          'Bandera azul. Deja pasar sin perder la l nea. Sin riesgos.',
          'Bandera azul. Cede seguro y sigue tu ritmo.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Con seguridad.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Sin drama.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Todo limpio.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Sin riesgos.',
          'Bandera azul. Respeta, no arriesgues.',
          'Bandera azul. Respeta, no arriesgues. Con seguridad.',
          'Bandera azul. Respeta, no arriesgues. Sin drama.',
          'Bandera azul. Respeta, no arriesgues. Todo limpio.',
          'Bandera azul. Respeta, no arriesgues. Sin riesgos.',
          'Bandera azul. l nea predecible.',
          'Bandera azul. l nea predecible. Con seguridad.',
          'Bandera azul. l nea predecible. Sin drama.',
          'Bandera azul. l nea predecible. Todo limpio.',
          'Bandera azul. l nea predecible. Sin riesgos.',
          'Bandera azul. Abre espacio en salida.',
          'Bandera azul. Abre espacio en salida. Con seguridad.',
          'Bandera azul. Abre espacio en salida. Sin drama.',
          'Bandera azul. Abre espacio en salida. Todo limpio.',
          'Bandera azul. Abre espacio en salida. Sin riesgos.'
        ],
        front06: [
          'Buen cierre con {frontNameSafe}. Si te abre, vas.',
          'Buen cierre con {frontNameSafe}. Mantén presión.',
          'Buen cierre con {frontNameSafe}. Una vuelta más y lo tienes.',
          'Buen cierre con {frontNameSafe}. Cuida la salida.',
          'Buen cierre con {frontNameSafe}. No fuerces la entrada.',
          'Buen cierre con {frontNameSafe}. Con calma, el pase llega.',
          'Buen cierre con {frontNameSafe}. Todo limpio.',
          'Buen cierre con {frontNameSafe}. Salida fuerte.',
          'Buen cierre con {frontNameSafe}. Aprovecha el error.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Si te abre, vas.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Mantén presión.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una vuelta más y lo tienes.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Cuida la salida.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No fuerces la entrada.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Con calma, el pase llega.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Todo limpio.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Salida fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Aprovecha el error.',
          'A {frontSecStr} de {frontNameSafe}. Si te abre, vas.',
          'A {frontSecStr} de {frontNameSafe}. Mantén presión.',
          'A {frontSecStr} de {frontNameSafe}. Una vuelta más y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la salida.',
          'A {frontSecStr} de {frontNameSafe}. No fuerces la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Con calma, el pase llega.',
          'A {frontSecStr} de {frontNameSafe}. Todo limpio.'
        ],
        back06: [
          '{backNameSafe} est encima. Defiende con trazada, no con golpes.',
          '{backNameSafe} est encima. l nea firme y salida fuerte.',
          '{backNameSafe} est encima. Sin errores, lo aguantas.',
          '{backNameSafe} est encima. Calma y control.',
          '{backNameSafe} est encima. No te abras en la entrada.',
          '{backNameSafe} est encima. Puerta cerrada.',
          '{backNameSafe} est encima. Respira y acelera limpio.',
          '{backNameSafe} est encima. Cubre interior.',
          '{backNameSafe} est encima. Todo limpio.',
          'presión atr s: {backNameSafe} a {backSecStr}. Defiende con trazada, no con golpes.',
          'presión atr s: {backNameSafe} a {backSecStr}. l nea firme y salida fuerte.',
          'presión atr s: {backNameSafe} a {backSecStr}. Sin errores, lo aguantas.',
          'presión atr s: {backNameSafe} a {backSecStr}. Calma y control.',
          'presión atr s: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Puerta cerrada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Respira y acelera limpio.',
          'presión atr s: {backNameSafe} a {backSecStr}. Cubre interior.',
          'presión atr s: {backNameSafe} a {backSecStr}. Todo limpio.',
          '{backNameSafe} en rango: {backSecStr}. Defiende con trazada, no con golpes.',
          '{backNameSafe} en rango: {backSecStr}. l nea firme y salida fuerte.',
          '{backNameSafe} en rango: {backSecStr}. Sin errores, lo aguantas.',
          '{backNameSafe} en rango: {backSecStr}. Calma y control.',
          '{backNameSafe} en rango: {backSecStr}. No te abras en la entrada.',
          '{backNameSafe} en rango: {backSecStr}. Puerta cerrada.',
          '{backNameSafe} en rango: {backSecStr}. Respira y acelera limpio.'
        ],
        pos: [
          'Ahora P{posNow}. Respira, vuelve al plan.',
          'Ahora P{posNow}. Calma y ritmo.',
          'Ahora P{posNow}. Trazada limpia.',
          'Ahora P{posNow}. A trabajar, vuelta a vuelta.',
          'Ahora P{posNow}. No te desconcentres.',
          'Ahora P{posNow}. T  puedes, sigue.',
          'Ahora P{posNow}. Sin errores.',
          'Ahora P{posNow}. Busca aire limpio.',
          'Ahora P{posNow}. Salida fuerte.',
          'Vas P{posNow}. Respira, vuelve al plan.',
          'Vas P{posNow}. Calma y ritmo.',
          'Vas P{posNow}. Trazada limpia.',
          'Vas P{posNow}. A trabajar, vuelta a vuelta.',
          'Vas P{posNow}. No te desconcentres.',
          'Vas P{posNow}. T  puedes, sigue.',
          'Vas P{posNow}. Sin errores.',
          'Vas P{posNow}. Busca aire limpio.',
          'Vas P{posNow}. Salida fuerte.',
          'posición P{posNow}. Respira, vuelve al plan.',
          'posición P{posNow}. Calma y ritmo.',
          'posición P{posNow}. Trazada limpia.',
          'posición P{posNow}. A trabajar, vuelta a vuelta.',
          'posición P{posNow}. No te desconcentres.',
          'posición P{posNow}. T  puedes, sigue.',
          'posición P{posNow}. Sin errores.'
        ],
        leader: [
          'El líder marca el ritmo. T  marca tu l nea.',
          'El líder marca el ritmo. T  marca tu l nea. T  puedes.',
          'El líder marca el ritmo. T  marca tu l nea. Paso a paso.',
          'El líder marca el ritmo. T  marca tu l nea. Sin errores.',
          'El líder marca el ritmo. T  marca tu l nea. Control.',
          'Referencia del líder, sin obsesionarte.',
          'Referencia del líder, sin obsesionarte. T  puedes.',
          'Referencia del líder, sin obsesionarte. Paso a paso.',
          'Referencia del líder, sin obsesionarte. Sin errores.',
          'Referencia del líder, sin obsesionarte. Control.',
          'líder al frente. enf cate en tus marcas.',
          'líder al frente. enf cate en tus marcas. T  puedes.',
          'líder al frente. enf cate en tus marcas. Paso a paso.',
          'líder al frente. enf cate en tus marcas. Sin errores.',
          'líder al frente. enf cate en tus marcas. Control.',
          'Observa al líder y aprende la trazada.',
          'Observa al líder y aprende la trazada. T  puedes.',
          'Observa al líder y aprende la trazada. Paso a paso.',
          'Observa al líder y aprende la trazada. Sin errores.',
          'Observa al líder y aprende la trazada. Control.',
          'líder adelante. Paciencia y consistencia.',
          'líder adelante. Paciencia y consistencia. T  puedes.',
          'líder adelante. Paciencia y consistencia. Paso a paso.',
          'líder adelante. Paciencia y consistencia. Sin errores.',
          'líder adelante. Paciencia y consistencia. Control.'
        ],
        podium: [
          'Podio posible. Mantén cabeza fría.',
          'Podio posible. Mantén cabeza fría. Paso a paso.',
          'Podio posible. Mantén cabeza fría. Sin drama.',
          'Podio posible. Mantén cabeza fría. Control.',
          'Podio posible. Mantén cabeza fría. Limpio y rápido.',
          'Zona de podio. Todo limpio.',
          'Zona de podio. Todo limpio. Paso a paso.',
          'Zona de podio. Todo limpio. Sin drama.',
          'Zona de podio. Todo limpio. Control.',
          'Zona de podio. Todo limpio. Limpio y rápido.',
          'Podio en juego. No fuerces.',
          'Podio en juego. No fuerces. Paso a paso.',
          'Podio en juego. No fuerces. Sin drama.',
          'Podio en juego. No fuerces. Control.',
          'Podio en juego. No fuerces. Limpio y rápido.',
          'Por el trofeo. Trazada firme.',
          'Por el trofeo. Trazada firme. Paso a paso.',
          'Por el trofeo. Trazada firme. Sin drama.',
          'Por el trofeo. Trazada firme. Control.',
          'Por el trofeo. Trazada firme. Limpio y rápido.',
          'Podio cerca. Cuida la salida.',
          'Podio cerca. Cuida la salida. Paso a paso.',
          'Podio cerca. Cuida la salida. Sin drama.',
          'Podio cerca. Cuida la salida. Control.',
          'Podio cerca. Cuida la salida. Limpio y rápido.'
        ],
        trend: [
          'Ritmo mejorando. Mantén.',
          'Ritmo mejorando. Mantén. T  puedes.',
          'Ritmo mejorando. Mantén. Paso a paso.',
          'Ritmo mejorando. Mantén. Sin errores.',
          'Ritmo mejorando. Mantén. Control.',
          'Ritmo baj. Ajusta y sigue.',
          'Ritmo baj. Ajusta y sigue. T  puedes.',
          'Ritmo baj. Ajusta y sigue. Paso a paso.',
          'Ritmo baj. Ajusta y sigue. Sin errores.',
          'Ritmo baj. Ajusta y sigue. Control.',
          'Consistente. Buen trabajo.',
          'Consistente. Buen trabajo. T  puedes.',
          'Consistente. Buen trabajo. Paso a paso.',
          'Consistente. Buen trabajo. Sin errores.',
          'Consistente. Buen trabajo. Control.',
          'Ritmo slido. No cambies.',
          'Ritmo slido. No cambies. T  puedes.',
          'Ritmo slido. No cambies. Paso a paso.',
          'Ritmo slido. No cambies. Sin errores.',
          'Ritmo slido. No cambies. Control.',
          'Ritmo irregular. Respira y repite.',
          'Ritmo irregular. Respira y repite. T  puedes.',
          'Ritmo irregular. Respira y repite. Paso a paso.',
          'Ritmo irregular. Respira y repite. Sin errores.',
          'Ritmo irregular. Respira y repite. Control.'
        ],
        est: [
          'estimación lista. Mantén el plan.',
          'estimación lista. Mantén el plan. T  puedes.',
          'estimación lista. Mantén el plan. Sin drama.',
          'estimación lista. Mantén el plan. Limpio.',
          'estimación lista. Mantén el plan. Control.',
          'estimación cambi. Ajusta y sigue.',
          'estimación cambi. Ajusta y sigue. T  puedes.',
          'estimación cambi. Ajusta y sigue. Sin drama.',
          'estimación cambi. Ajusta y sigue. Limpio.',
          'estimación cambi. Ajusta y sigue. Control.',
          'estimación estable. No te desconcentres.',
          'estimación estable. No te desconcentres. T  puedes.',
          'estimación estable. No te desconcentres. Sin drama.',
          'estimación estable. No te desconcentres. Limpio.',
          'estimación estable. No te desconcentres. Control.',
          'estimación marcada. Todo limpio.',
          'estimación marcada. Todo limpio. T  puedes.',
          'estimación marcada. Todo limpio. Sin drama.',
          'estimación marcada. Todo limpio. Limpio.',
          'estimación marcada. Todo limpio. Control.',
          'estimación ok. Paso a paso.',
          'estimación ok. Paso a paso. T  puedes.',
          'estimación ok. Paso a paso. Sin drama.',
          'estimación ok. Paso a paso. Limpio.',
          'estimación ok. Paso a paso. Control.'
        ],
        bestlap: [
          'Best lap. Bien ahí, repite con calma.',
          'Best lap. Bien ahí, repite con calma. Paso a paso.',
          'Best lap. Bien ahí, repite con calma. Control.',
          'Best lap. Bien ahí, repite con calma. Sin errores.',
          'Best lap. Bien ahí, repite con calma. Limpio.',
          'Nueva best lap. Buen trabajo.',
          'Nueva best lap. Buen trabajo. Paso a paso.',
          'Nueva best lap. Buen trabajo. Control.',
          'Nueva best lap. Buen trabajo. Sin errores.',
          'Nueva best lap. Buen trabajo. Limpio.',
          'Best lap confirmada. Mantén.',
          'Best lap confirmada. Mantén. Paso a paso.',
          'Best lap confirmada. Mantén. Control.',
          'Best lap confirmada. Mantén. Sin errores.',
          'Best lap confirmada. Mantén. Limpio.',
          'Mejoraste best lap. Control total.',
          'Mejoraste best lap. Control total. Paso a paso.',
          'Mejoraste best lap. Control total. Control.',
          'Mejoraste best lap. Control total. Sin errores.',
          'Mejoraste best lap. Control total. Limpio.',
          'Best lap. Ahora consistencia.',
          'Best lap. Ahora consistencia. Paso a paso.',
          'Best lap. Ahora consistencia. Control.',
          'Best lap. Ahora consistencia. Sin errores.',
          'Best lap. Ahora consistencia. Limpio.'
        ]
      }
    };

    
    function rdMakeText(id, baseText, ctx) {
      const mode = (raceDirectorMode === 'minimal' || raceDirectorMode === 'stratega' || raceDirectorMode === 'coach')
        ? raceDirectorMode : 'stratega';

      const c = (ctx || {});
      const isManga = !!c.isManga;
      const tier = c.tier || 'mid';
      const posNow = c.posNow || rdExtractPos(baseText) || 0;

      // Rellena placeholders
      const fill = (tpl) => {
        let s = String(tpl || '');
        s = s.replace(/\{frontNameSafe\}/g, c.frontNameSafe || 'el de adelante');
        s = s.replace(/\{backNameSafe\}/g, c.backNameSafe || 'el de atrs');
        s = s.replace(/\{frontSecStr\}/g, c.frontSecStr || '');
        s = s.replace(/\{backSecStr\}/g, c.backSecStr || '');
        s = s.replace(/\{posNow\}/g, String(posNow || 0));
        return s.replace(/\s+/g, ' ').trim();
      };

function rdMakeMangaBattleText(kind, c, mode) {
  const front = (c && c.frontNameSafe) ? c.frontNameSafe : 'el de adelante';
  const back  = (c && c.backNameSafe)  ? c.backNameSafe  : 'el de atrs';
  const fs = (c && c.frontSecStr) ? c.frontSecStr : '';
  const bs = (c && c.backSecStr)  ? c.backSecStr  : '';

  // Plantillas cortas, tiles y con nombres. (MANGA = suave, pero con datos)
  const attack = [
    'Manga. {frontNameSafe} a {frontSecStr}. Limpio y lo cazas.',
    'Manga. {frontNameSafe} a {frontSecStr}. Sal bien y cae el pase.',
    'Manga. {frontNameSafe} a {frontSecStr}. Lnea fina, sin drama.',
    'Manga. {frontNameSafe} a {frontSecStr}. Cero errores, aprieta.',
    'Manga. {frontNameSafe} a {frontSecStr}. Dos vueltas as y lo tienes.',
    'Manga. Vas por {frontNameSafe}. Gap {frontSecStr}.',
    'Manga. {frontNameSafe} está tiro. {frontSecStr}.',
    'Manga. Se ve el rebufo. {frontNameSafe} {frontSecStr}.',
    'Manga. Ojo con {frontNameSafe}. {frontSecStr}.',
    'Manga. Paciencia y traccin. {frontNameSafe} {frontSecStr}.',
    'Manga. Si la salida es limpia, {frontNameSafe} cae. {frontSecStr}.',
    'Manga. Ataque inteligente. {frontNameSafe} {frontSecStr}.',
    'Manga. No lo forces, provcalo. {frontNameSafe} {frontSecStr}.',
    'Manga. Gap rico para cazar. {frontNameSafe} {frontSecStr}.',
    'Manga. Est en ventana. {frontNameSafe} {frontSecStr}.'
  ];

  const defense = [
    'Manga. {backNameSafe} a {backSecStr}. Cierra puertas, suave.',
    'Manga. {backNameSafe} a {backSecStr}. Sin espejo, pero sin regalo.',
    'Manga. {backNameSafe} a {backSecStr}. Marca el apex y listo.',
    'Manga. {backNameSafe} a {backSecStr}. Control, no ansiedad.',
    'Manga. {backNameSafe} a {backSecStr}. Si te equivocas, te muerde.',
    'Manga. Te vienen oliendo. {backNameSafe} {backSecStr}.',
    'Manga. Defensa fina. {backNameSafe} {backSecStr}.',
    'Manga. No des espacio gratis. {backNameSafe} {backSecStr}.',
    'Manga. Mantn tu lnea. {backNameSafe} {backSecStr}.',
    'Manga. Respira. {backNameSafe} est encima. {backSecStr}.',
    'Manga. Sal de curva bien, y se apaga. {backNameSafe} {backSecStr}.',
    'Manga. No te enredes. {backNameSafe} {backSecStr}.',
    'Manga. Si te presiona, tu respuesta es limpieza. {backNameSafe} {backSecStr}.',
    'Manga. Cero contactos. {backNameSafe} {backSecStr}.',
    'Manga. Aguanta el ritmo. {backNameSafe} {backSecStr}.'
  ];

  const fight = [
    'Manga. Duelo doble: adelante {frontSecStr}, atrs {backSecStr}.',
    'Manga. Ests en sndwich. Adelante {frontSecStr}, atrs {backSecStr}.',
    'Manga. Se viene pelea: {frontNameSafe} {frontSecStr}, {backNameSafe} {backSecStr}.',
    'Manga. Tres autos en un respiro. Mantn calma.',
    'Manga. Esto es ajedrez en miniatura. No regales.',
    'Manga. Lnea limpia, manos suaves. Duelo real.',
    'Manga. Cada error cuesta dos posiciones. Ojo.',
    'Manga. Juega con la salida, no con el choque.',
    'Manga. Batalla cerrada. Decide con cabeza fra.',
    'Manga. Si te pones nervioso, ya perdiste. Respira.'
  ];

  let bank = null;
  if (kind === 'attack') bank = attack;
  else if (kind === 'defense') bank = defense;
  else if (kind === 'fight') bank = fight;

  if (!bank || !bank.length) return '';
  return fill(rdPick(bank, 'mb_' + String(mode || 'x') + '_' + kind));
}

    
// Manga: NO aplastar todo a frases genricas.
// - Si hay batalla, habla con nombres y gaps (suave, pero til).
if (isManga && (id === 'attack' || id === 'defense' || id === 'fight')) {
  const out = rdMakeMangaBattleText(id, c, mode);
  if (out) return out;

  const arr = RD_PHRASES[mode] && RD_PHRASES[mode].manga;
  if (arr && arr.length) return fill(rdPick(arr, mode[0] + '_manga'));
}
// Seleccin por modo
      if (mode === 'minimal') {
        const arr = RD_PHRASES.minimal[id] || null;
        if (arr && arr.length) return fill(rdPick(arr, 'm_' + id));
        if (id === 'pos' && posNow) return `P${posNow}.`;
        return String(baseText || '').trim();
      }

      if (mode === 'coach') {
        const arr = RD_PHRASES.coach[id] || null;
        if (arr && arr.length) return fill(rdPick(arr, 'c_' + id));
        return String(baseText || '').trim();
      }

      // stratega
      if (id === 'attack') {
        const arr = RD_PHRASES.stratega['attack_' + tier] || RD_PHRASES.stratega.attack_mid;
        return fill(rdPick(arr, 's_attack_' + tier));
      }
      if (id === 'defense') {
        const arr = RD_PHRASES.stratega['defense_' + tier] || RD_PHRASES.stratega.defense_mid;
        return fill(rdPick(arr, 's_def_' + tier));
      }
      const arr = RD_PHRASES.stratega[id] || null;
      if (arr && arr.length) return fill(rdPick(arr, 's_' + id));
      return String(baseText || '').trim();
    }

      

    function updateRdButton() {
      if (!rdToggleBtn) return;
      rdToggleBtn.textContent = raceDirectorEnabled ? ' RD ON' : ' RD OFF';
      rdToggleBtn.classList.toggle('active', !!raceDirectorEnabled);
      rdToggleBtn.classList.toggle('off', !raceDirectorEnabled);
      rdToggleBtn.setAttribute('aria-pressed', raceDirectorEnabled ? 'true' : 'false');
    }

    if (rdToggleBtn) {
      updateRdButton();
      rdToggleBtn.addEventListener('click', () => {
        raceDirectorEnabled = !raceDirectorEnabled;
      try { rdToggleBtn.classList.toggle('active', raceDirectorEnabled); } catch(e) {}
        try { prefSet('raceDirectorEnabled', raceDirectorEnabled ? '1' : '0'); } catch(e) {}
        updateRdButton();
        try { playBeep(raceDirectorEnabled ? 'up' : 'down'); } catch(e) {}
      });
    }
    let posImmediateLastSpokenAt = 0;
    let posImmediateLastSpokenPos = 0;
    let posDropDebounceTimer = null;
    let posDropDebounceLatest = null;

    // BASIC (Seguimiento) - estabilidad de posicion para evitar jitter/flip-flop
    const basicPosStability = { lastSeenPos: null, candidatePos: null, candidateCount: 0, pendingStablePos: null, lastAnnouncedStablePos: null };

// MANGA (clasificacin) - estabilidad de posición para evitar "flip-flop" por salida escalonada
    const mangaPosStability = { lastSeenPos: null, stablePos: null, stableCount: 0, lastAnnouncedStablePos: null };
    const mangaPosSettle = { active:false, lap:0, dueAt:0, samples:[], lastComputedPos:null };

    function startMangaPosSettle(lap, posNow){
      try{
        const now = Date.now();
        const p = (posNow!=null && isFinite(posNow)) ? Math.max(1, Math.floor(posNow)) : null;
        const jitter = 1200; // ms
        const base = 3200;   // ms
        mangaPosSettle.active = true;
        mangaPosSettle.lap = Number(lap)||0;
        mangaPosSettle.dueAt = now + base + Math.floor(Math.random()*jitter);
        mangaPosSettle.samples = [];
        if (p) mangaPosSettle.samples.push(p);
        mangaPosSettle.lastComputedPos = null;
      } catch(e){}
    }

    function modeOfIntArray(arr){
      if (!arr || !arr.length) return null;
      const m = new Map();
      let bestK = null; let bestV = 0;
      for (const x of arr){
        const k = Number(x)|0;
        if (!k) continue;
        const v = (m.get(k)||0)+1;
        m.set(k,v);
        if (v>bestV){ bestV=v; bestK=k; }
      }
      return bestK;
    }

    function tickMangaPosSettle(lapsNow, posNow){
      try{
        if (!mangaPosSettle.active) return;
        if ((Number(lapsNow)||0) !== (Number(mangaPosSettle.lap)||0)) return;
        const now = Date.now();
        const p = (posNow!=null && isFinite(posNow)) ? Math.max(1, Math.floor(posNow)) : null;
        if (p && now < (mangaPosSettle.dueAt||0)) {
          mangaPosSettle.samples.push(p);
          if (mangaPosSettle.samples.length > 20) mangaPosSettle.samples.shift();
          return;
        }
        if (now >= (mangaPosSettle.dueAt||0)){
          const stable = modeOfIntArray(mangaPosSettle.samples);
          mangaPosSettle.lastComputedPos = stable;
          mangaPosSettle.active = false;
          if (!stable) return;
          // Solo anunciamos si cambi contra la última posición estable anunciada
          if (mangaPosStability.lastAnnouncedStablePos === stable) return;
          pendingPosChange = {
            pos: stable,
            opts: { key: 'pos_manga_' + stable + '_' + lapsNow, priority: 70, cooldownMs: 1400, dedupe: true },
            expLap: (Number(lapsNow)||0) + 3,
            _mangaStablePos: stable
          };
        }
      } catch(e){}
    }

    function announcePositionBrief(pos) {
      const p = Math.max(1, Math.min(99, Math.floor(Number(pos) || 0)));
      const now = Date.now();

      // No repitas el mismo P# seguido
      if (p === posImmediateLastSpokenPos && (now - posImmediateLastSpokenAt) < 2000) return;

      // Nombre del de adelante (si existe) para que sea til, no solo "P6"
      let aheadName = '';
      try {
        const idx = findPilotIndexByKey(selectedPilotKey);
        const ctx = (idx >= 0) ? getFrontBackContext(idx) : null;
        aheadName = (ctx && ctx.frontName) ? safeRacerName(ctx.frontName) : '';
      } catch(e) {}

      const tail = aheadName ? ('. Adelante ' + aheadName) : '';
      say('P' + p + tail, { key: 'pos_brief_' + p, priority: 85, cooldownMs: 800, dedupe: true });

      posImmediateLastSpokenAt = now;
      posImmediateLastSpokenPos = p;
    }

    function handlePositionChangeNoLap(fromPos, toPos, delta) {
      const from = Math.floor(Number(fromPos) || 0);
      const to = Math.floor(Number(toPos) || 0);
      if (!to) return;

      // + = cae (peor), - = sube (mejor)
      const drop = (from && to) ? (to - from) : (delta || 0);

      // Si cae 2+ lugares, debounce 1.5s y anuncia solo la posición final (evita metralleta)
      if (drop >= 2) {
        posDropDebounceLatest = to;
        if (!posDropDebounceTimer) {
          posDropDebounceTimer = setTimeout(() => {
            announcePositionBrief(posDropDebounceLatest);
            posDropDebounceTimer = null;
            posDropDebounceLatest = null;
          }, 1500);
        }
        return;
      }

      // Si est en debounce, actualiza y no hables an
      if (posDropDebounceTimer) {
        posDropDebounceLatest = to;
        return;
      }

      const now = Date.now();
      if (now - posImmediateLastSpokenAt < 650) return;
      announcePositionBrief(to);
    }

    
function saveVoiceSettings() {
      try {
        const toSave = { ...voiceSettings, laps: true };
        prefSet('spotterVoiceSettings', JSON.stringify(toSave));
      } catch (e) {}
    }

    
function loadVoiceSettings() {
      try {
        const raw = prefGet('spotterVoiceSettings', null);
        if (raw) {
          const parsed = JSON.parse(raw);
          voiceSettings = { ...DEFAULT_VOICE_SETTINGS, ...parsed, laps: true };
        } else {
          voiceSettings = { ...DEFAULT_VOICE_SETTINGS, laps: true };
        }
      } catch (e) {
        voiceSettings = { ...DEFAULT_VOICE_SETTINGS, laps: true };
      }

      // Enforce: Laps siempre activo
      voiceSettings.laps = true;
      // Enforce: prefijo de vueltas por default
      if (voiceSettings.saylaps == null) voiceSettings.saylaps = false;

      // Refresca UI si ya existe la funcin (hoisting en function decl)
      try {
        if (typeof applyVoiceSettingsToButtons === 'function') applyVoiceSettingsToButtons();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      } catch (e) {}
    }

    loadVoiceSettings();

    // Gesto de usuario (Chrome bloquea AudioContext si no hay interaccin)
    let __userGestureUnlocked = false;
    try{
      const _unlock = () => { __userGestureUnlocked = true; };
      ['pointerdown','touchstart','keydown','click'].forEach(ev=>{
        window.addEventListener(ev, _unlock, { once:true, passive:true });
      });
    }catch(e){}

    // WebAudio beeps (sin archivos)
    // SFX: por default OFF (evita el 'tac tac' constante).
    // SFX deshabilitado (sin beeps).
    let soundFxEnabled = false; // UI SFX OFF (evita tic/tac).
    let lapBeepEnabled = true;   // Beep SOLO en SEGUIMIENTO al cerrar vuelta (mejora/empeora).

    let audioCtx = null;
    function ensureAudioCtx() {
      try {
        if (!__userGestureUnlocked) return;
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(()=>{});
        }
      } catch (e) {}
    }


     // Silent audio keep-alive (Chrome/desktop):
     // - Mantiene el AudioContext "running" con una seï¿½al inaudible.
     // - Ayuda a que el TTS no se "duerma" cuando el tab queda en background.
     // Nota: requiere gesto previo (ya cubierto por __userGestureUnlocked).
     let __silentKeepAlive = { osc:null, gain:null, started:false };
     function startSilentAudioKeepAlive(){
       try{
         if (!backgroundModeEnabled) return;
         if (!voiceMasterEnabled) return;
         ensureAudioCtx();
         if (!audioCtx) return;
         if (__silentKeepAlive.started) return;
         const now = audioCtx.currentTime;
         const osc = audioCtx.createOscillator();
         const gain = audioCtx.createGain();
         // Ultra bajo, inaudible en la prï¿½ctica
         gain.gain.setValueAtTime(0.000001, now);
         osc.type = 'sine';
         osc.frequency.setValueAtTime(18, now); // sub-audio
         osc.connect(gain);
         gain.connect(audioCtx.destination);
         osc.start(now);
         __silentKeepAlive.osc = osc;
         __silentKeepAlive.gain = gain;
         __silentKeepAlive.started = true;
       }catch(e){}
     }
     function stopSilentAudioKeepAlive(){
       try{
         if (__silentKeepAlive && __silentKeepAlive.osc){
           try{ __silentKeepAlive.osc.stop(); }catch(e){}
           try{ __silentKeepAlive.osc.disconnect(); }catch(e){}
         }
         if (__silentKeepAlive && __silentKeepAlive.gain){
           try{ __silentKeepAlive.gain.disconnect(); }catch(e){}
         }
       }catch(e){}
       try{ __silentKeepAlive = { osc:null, gain:null, started:false }; }catch(e){}
     }


function hardUnlockAudioPipe(){
  // iOS: a veces el "primer audio" requiere un micro-sonido para abrir el canal.
  try{
    ensureAudioCtx();
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.0001, now);
    osc.type = 'sine';
    osc.frequency.setValueAtTime(440, now);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.02);
  }catch(e){}
}


    function playBeep(kind = 'up') {
      const k = String(kind||'').trim();
      const isLap = (k === 'lapUp' || k === 'lapDown');
      if (isLap) { if (!lapBeepEnabled) return; }
      else { if (!soundFxEnabled) return; }
      try {
        ensureAudioCtx();
        if (!audioCtx) return;

        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        const f = (k === 'soft') ? 620 : ((k === 'lapUp' || k === 'up') ? 880 : 440);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(f, now);

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime((k === 'soft') ? 0.06 : (isLap ? 0.10 : 0.18), now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.10);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(now);
        osc.stop(now + ((k === 'soft') ? 0.07 : (isLap ? 0.10 : 0.12)));
      } catch (e) {}
    }

    // TTS
    let chosenVoiceURI = '';

    
// ===== DUO voces (solo Web/desktop): Sabina + Raul =====
// - En mobile (iOS/Android) dejamos SINGLE para no pelear con restricciones de audio.
// - En web/desktop alternamos voces por frase para sonar como duo.
let __duoWebEnabled = false;
let __duoVoiceSabinaURI = '';
let __duoVoiceRaulURI = '';
let __duoLastRole = ''; // 'sabina'|'raul'

function __isDuoWebContext() {
  try {
    const ua = navigator.userAgent || '';
    const isMobUA = /iPad|iPhone|iPod|Android/i.test(ua);
    if (isMobUA) return false;
    // Si la ventana es muy chica, tratamos como mobile para no forzar duo.
    if (window.matchMedia && window.matchMedia('(max-width: 700px)').matches) return false;
    return true;
  } catch (e) { return false; }
}

function __findVoiceByNeedle(voices, needles) {
  try {
    if (!voices || !voices.length) return null;
    const ns = (needles || []).map(s => String(s||'').toLowerCase()).filter(Boolean);
    if (!ns.length) return null;
    // Preferimos es-MX/es-ES si hay varias
    const scored = voices.map(v => {
      const name = String(v.name || '').toLowerCase();
      const uri  = String(v.voiceURI || '').toLowerCase();
      let hit = 0;
      for (const n of ns) {
        if (name.includes(n)) hit += 2;
        if (uri.includes(n)) hit += 1;
      }
      const lang = String(v.lang || '').toLowerCase();
      if (lang.startsWith('es-')) hit += 0.25;
      return { v, hit };
    }).filter(o => o.hit > 0).sort((a,b)=>b.hit-a.hit);
    return scored.length ? scored[0].v : null;
  } catch (e) { return null; }
}

function __refreshDuoVoices(voices) {
  try {
    // Solo web/desktop
    __duoWebEnabled = __isDuoWebContext();
    if (!__duoWebEnabled) { __duoVoiceSabinaURI = ''; __duoVoiceRaulURI = ''; return; }

    // Busca por nombre aproximado. Ajustable si cambian los nombres reales en tu maquina.
    const vSab = __findVoiceByNeedle(voices, ['sabina']);
    const vRau = __findVoiceByNeedle(voices, ['raul']);

    __duoVoiceSabinaURI = vSab ? (vSab.voiceURI || vSab.name || '') : '';
    __duoVoiceRaulURI   = vRau ? (vRau.voiceURI || vRau.name || '') : '';

    // Si no estan las dos, duo off (fallback SINGLE)
    if (!__duoVoiceSabinaURI || !__duoVoiceRaulURI) {
      __duoWebEnabled = false;
    }
  } catch (e) {
    __duoWebEnabled = false;
    __duoVoiceSabinaURI = '';
    __duoVoiceRaulURI = '';
  }
}

function __duoGuessRole(txt, key) {
  try {
    const t = String(txt||'');
    const k = String(key||'');
    // Datos duros y posiciones -> Raul
    if (/(\bP\d+\b|\bpos\b|posici\w+|\bgap\b|\bvuelta\b|\bvueltas\b|\btiempo\b|\bseg\b|\bsegundo\b|\btercero\b|\d)/i.test(t)) return 'raul';
    if (/(\bP\d+\b|pos|gap|lap)/i.test(k)) return 'raul';
    // Narrativa/hype -> Sabina
    return 'sabina';
  } catch (e) { return 'sabina'; }
}
// ===== Auto presets por sesin (TRAIN/MANGA/FINAL) =====
    let autoSessionPresetsEnabled = true;   // ON por default
    let __lastAutoPresetType = '';
    
    function applyDecimalPrecision(val){
      const v = Math.max(1, Math.min(3, parseInt(val,10) || 2));
      decimalPrecision = v;
      try { prefSet('spotterDecimalPrecision', String(v)); } catch(e) {}
      try { if (precisionSelect) precisionSelect.value = String(v); } catch(e) {}
      try { if (typeof syncPrecisionBadges === 'function') syncPrecisionBadges(); } catch(e) {}
    }
    
    function applySessionPreset(type){
      // Mantener compat: ahora el preset lo decide el AI (sesin + modo)
      applySmartProfile({ type: String(type || 'TRAIN').toUpperCase() }, 'manual');
    }

    function maybeAutoApplySessionPreset(sessionInfo){
      // AI Spotter: siempre decide solo (sesin + modo). Sin botones.
      if (!autoSessionPresetsEnabled) return;
      const t = String((sessionInfo && sessionInfo.type) ? sessionInfo.type : 'TRAIN').toUpperCase();
      if (!t || t === __lastAutoPresetType) return;
      __lastAutoPresetType = t;
      applySmartProfile(sessionInfo, 'auto');
      try { _updateBasicBtnUI(); } catch(e) {}
    }
    
    
    // ===== UI: Mostrar modo actual + Presets por sesin =====
    const SESSION_PRESET_PROFILES = {
      TRAIN: {
        label: 'Entrenamiento',
        rdMode: 'engineer',
        autoMode: 'engineer',
        precision: 2,
        voice: {
          laps:true, blueflag:true, ritmo:true, estlap:true, bestlap:true,
          pos:false, gaps:false, leadergap:false, podium:false,
          front06:false, back06:false, attack:false, defense:false, pelea:false,
          total:false, cons10:false, box:false, netgain:false, saylaps:false
        }
      },
      MANGA: {
        label: 'Manga',
        rdMode: 'minimal',
        autoMode: 'pro',
        precision: 2,
        voice: {
          laps:true, blueflag:true, ritmo:true, estlap:true, bestlap:true, leadergap:true,
          pos:false, gaps:false, podium:false,
          front06:false, back06:false, attack:false, defense:false, pelea:false,
          total:false, cons10:false, box:false, netgain:false, saylaps:false
        }
      },
      FINAL: {
        label: 'Final',
        rdMode: 'coach',
        autoMode: 'pro',
        precision: 2,
        voice: {
          laps:true, blueflag:true, ritmo:true, pos:true, gaps:true, leadergap:true, podium:true,
          front06:true, back06:true, attack:true, defense:true,
          bestlap:true, estlap:false,
          pelea:false, total:false, cons10:false, box:false, netgain:false, saylaps:false
        }
      }
    };

    // =========================================
    // AI Spotter - Perfiles inteligentes (sin botones)
    // - Si hay piloto seleccionado: Seguimiento
    // - Si no hay piloto: Auto Locutor
    // - Ajusta RD mode + auto locutor + mensajes por sesin
    // =========================================
    function __sessionBucket(sessionInfo){
      const raw = String((sessionInfo && sessionInfo.type) ? sessionInfo.type : 'TRAIN').toUpperCase();
      if (raw.includes('FINAL')) return 'FINAL';
      if (raw.includes('MANGA') || raw.includes('QUAL') || raw === 'Q') return 'MANGA';
      return 'TRAIN';
    }
    function __modeBucket(){
      try { return (selectedPilotKey ? 'FOLLOW' : 'AUTO'); } catch(e) { return 'AUTO'; }
    }

    const AI_SMART_PROFILES = {
      FOLLOW: {
        TRAIN: { rdMode:'engineer', autoMode:'engineer', precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:true, estlap:true, bestlap:true, leadergap:true, pos:true, gaps:true, podium:false, front06:false, back06:false, attack:false, defense:false, pelea:false, total:false, cons10:false, box:false, netgain:false } },
        MANGA: { rdMode:'minimal',  autoMode:'pro',      precision:2, voice:{ laps:true, saylaps:false, blueflag:true,  ritmo:false, estlap:false, bestlap:true,  leadergap:false, pos:true, gaps:false, podium:false, front06:false, back06:false, attack:false, defense:false, pelea:false, total:false, cons10:false, box:false, netgain:false } },
        FINAL: { rdMode:'coach',    autoMode:'pro',      precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:true, estlap:false, bestlap:true, leadergap:true, pos:true, gaps:true, podium:true,  front06:true,  back06:true,  attack:true,  defense:true,  pelea:false, total:false, cons10:false, box:false, netgain:false } }
      },
      AUTO: {
        TRAIN: { rdMode:'minimal',  autoMode:'engineer', precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:false, estlap:true, bestlap:true, leadergap:true, pos:true, gaps:true, podium:false, front06:true,  back06:true,  attack:false, defense:false, pelea:true,  total:false, cons10:false, box:false, netgain:false } },
        MANGA: { rdMode:'minimal',  autoMode:'pro',      precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:false, estlap:true, bestlap:true, leadergap:true, pos:true, gaps:true, podium:false, front06:true,  back06:true,  attack:false, defense:false, pelea:true,  total:false, cons10:false, box:false, netgain:false } },
        FINAL: { rdMode:'coach',    autoMode:'pro',      precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:false, estlap:false, bestlap:true, leadergap:true, pos:true, gaps:true, podium:true,  front06:true,  back06:true,  attack:false, defense:false, pelea:true,  total:false, cons10:false, box:false, netgain:false } }
      }
    };

    function _applyBasicOverride(sess){
      // Solo aplica en Seguimiento
      try{
        if (!basicModeEnabled) return false;
        if (__modeBucket() !== 'FOLLOW') return false;

        const next = { ...DEFAULT_VOICE_SETTINGS };
        // Siempre activo
        next.laps = true;
        // BASICO ultra limpio:
        // - Solo last lap (siempre) + posicion (solo cambios estables)
        // - Cero extras: no azul, no gaps, no best, no contexto.
        next.pos = true;
        next.gaps = false;
        next.leadergap = false;
        next.blueflag = false;
        next.ritmo = false;
        next.estlap = false;
        next.bestlap = false;
        next.front06 = false;
        next.back06 = false;
        next.podium = false;
        next.attack = false;
        next.defense = false;
        next.pelea = false;
        next.netgain = false;
        next.total = false;
        next.cons10 = false;
        next.box = false;
        next.saylaps = false;
        voiceSettings = next;

        // Modos mas sobrios
        try { applyDecimalPrecision(2); } catch(e) {}
        // RD/Auto fuera en BASICO (garantiza 0 ruido)
        try { setRaceDirectorMode('minimal'); } catch(e) {}
        try { setAutoCommentatorMode('engineer'); } catch(e) {}
        try { raceDirectorEnabled = false; } catch(e) {}
        return true;
      }catch(e){ return false; }
    }

    function _updateBasicBtnUI(){
      try{
        if (!basicToggleBtnMini) return;
        basicToggleBtnMini.disabled = false;
        basicToggleBtnMini.classList.toggle('active', !!basicModeEnabled);
        basicToggleBtnMini.textContent = (basicModeEnabled ? 'BÁSICO ON' : 'BÁSICO');
      }catch(e){}
    }

    function applySmartProfile(sessionInfo, reason){
      try{
        const sess = __sessionBucket(sessionInfo);
        const mode = __modeBucket();
        const prof = (AI_SMART_PROFILES[mode] && AI_SMART_PROFILES[mode][sess]) ? AI_SMART_PROFILES[mode][sess] : null;
        if (!prof) return;

        // Base: preset por sesin (mantiene UI/labels coherentes)
        try { applySessionPresetFull(sess, 'smart'); } catch(e) {}

        // Overrides por modo
        try { applyDecimalPrecision(prof.precision || 2); } catch(e) {}
        try { setRaceDirectorMode(prof.rdMode || 'minimal'); } catch(e) {}
        try { setAutoCommentatorMode(prof.autoMode || 'pro'); } catch(e) {}
        try { raceDirectorEnabled = true; } catch(e) {}

        // Voz: aplicar flags del perfil (sin dejar toggles viejos)
        try {
          const next = { ...DEFAULT_VOICE_SETTINGS };
          const v = prof.voice || {};
          Object.keys(next).forEach(k => { next[k] = (k === 'laps') ? true : !!v[k]; });
          next.laps = true;
          voiceSettings = next;
        } catch(e) {}

        try { applyVoiceSettingsToButtons(); } catch(e) {}
        try { if (typeof updateSessionPresetUI === 'function') updateSessionPresetUI(sess); } catch(e) {}
        try { if (typeof updateSessionNowUI === 'function') updateSessionNowUI(); } catch(e) {}

        // BASICO override (solo seguimiento)
        let basicApplied = false;
        try { basicApplied = _applyBasicOverride(sess); } catch(e) {}
        try { applyVoiceSettingsToButtons(); } catch(e) {}
        try { _updateBasicBtnUI(); } catch(e) {}

        // Etiqueta de estado (para que el usuario sepa que pasa sin botones)
        try{
          const modeTxt = (mode === 'FOLLOW') ? 'Seguimiento' : 'Auto';
          const sessTxt = (sess === 'FINAL') ? 'Final' : (sess === 'MANGA' ? 'Manga' : 'Train');
          const el = document.getElementById('modeBadge');
          const extra = (basicApplied ? ' - BASICO' : '');
          if (el) el.textContent = modeTxt + ' - ' + sessTxt + extra;
        }catch(e){}
      }catch(e){}
    }

    function _pillHtml(name, on){
      const cls = on ? 'toggle-pill on' : 'toggle-pill off';
      const safe = String(name||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      return `<span class="${cls}">${safe}</span>`;
    }

    function _getVoiceToggleMap(){
      // voiceSettings es la fuente de verdad
      const out = {};
      try{
        Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => out[k] = !!voiceSettings[k]);
        // asegurar llaves nuevas si faltan
        ['front06','back06','leadergap','podium','pelea','netgain','bestlap','estlap','cons10','box','total','gaps','pos','attack','defense','blueflag','ritmo','saylaps'].forEach(k=>{
          if (typeof out[k] === 'undefined') out[k] = !!voiceSettings[k];
        });
        out.laps = true;
      }catch(e){}
      return out;
    }

    function renderPresetCards(){
      const mapNow = _getVoiceToggleMap();
      const cards = [
        {id:'presetCardTrain', key:'TRAIN', metaId:'presetTrainMeta', togId:'presetTrainToggles'},
        {id:'presetCardManga', key:'MANGA', metaId:'presetMangaMeta', togId:'presetMangaToggles'},
        {id:'presetCardFinal', key:'FINAL', metaId:'presetFinalMeta', togId:'presetFinalToggles'}
      ];
      cards.forEach(c=>{
        const prof = SESSION_PRESET_PROFILES[c.key];
        const metaEl = document.getElementById(c.metaId);
        const togEl = document.getElementById(c.togId);
        if (metaEl) metaEl.textContent = `RD ${prof.rdMode.toUpperCase()} - Auto ${prof.autoMode.toUpperCase()} - ${prof.precision} dc.`;
        if (togEl){
          const order = ['laps','blueflag','ritmo','estlap','leadergap','podium','pos','gaps','front06','back06','attack','defense','pelea','bestlap','total','cons10','box','netgain','saylaps'];
          const nice = {
            laps:'LAPS', blueflag:'AZUL', ritmo:'RITMO', estlap:'EST', leadergap:'LDER', podium:'PODIO',
            pos:'POS', gaps:'GAP', front06:'ADEL<0.6', back06:'ATRAS<0.6', attack:'ATK', defense:'DEF', pelea:'PELEA',
            bestlap:'BEST', total:'TOTAL', cons10:'CONS10', box:'BOX', netgain:'NET', saylaps:'VUELTAS'
          };
          let html='';
          order.forEach(k=>{
            const onRec = !!prof.voice[k];
            html += _pillHtml(nice[k]||k, onRec);
          });
          togEl.innerHTML = html;
        }
      });

      // Row "Ahora"
      const nowEl = document.getElementById('sessionNowToggles');
      if (nowEl){
        const orderNow = ['laps','blueflag','ritmo','estlap','leadergap','podium','pos','gaps','front06','back06','attack','defense','pelea','bestlap','total','cons10','box','netgain','saylaps'];
        const niceNow = {
          laps:'LAPS', blueflag:'AZUL', ritmo:'RITMO', estlap:'EST', leadergap:'LDER', podium:'PODIO',
          pos:'POS', gaps:'GAP', front06:'ADEL<0.6', back06:'ATRAS<0.6', attack:'ATK', defense:'DEF', pelea:'PELEA',
          bestlap:'BEST', total:'TOTAL', cons10:'CONS10', box:'BOX', netgain:'NET', saylaps:'VUELTAS'
        };
        let html='';
        orderNow.forEach(k=>{
          const on = (k==='laps') ? true : !!mapNow[k];
          html += _pillHtml(niceNow[k]||k, on);
        });
        nowEl.innerHTML = html;
      }
    }

    function updateConfigStatusUI(){
      try{
        const sess = String(__lastAutoPresetType || 'TRAIN').toUpperCase();
        const prof = SESSION_PRESET_PROFILES[sess] || SESSION_PRESET_PROFILES.TRAIN;

        const sessionPill = document.getElementById('cfgSessionPill');
        const presetPill  = document.getElementById('cfgPresetPill');
        const rdEl        = document.getElementById('cfgRdMode');
        const autoEl      = document.getElementById('cfgAutoMode');
        const precEl      = document.getElementById('cfgPrec');
        const voicesEl    = document.getElementById('cfgVoices');
        const noteEl      = document.getElementById('sessionPresetNote');

        if (sessionPill) sessionPill.textContent = `Sesin: ${sess}`;
        if (presetPill)  presetPill.textContent  = `Preset: ${prof.label}`;

        // RD actual
        const rd = (typeof raceDirectorMode === 'string' ? raceDirectorMode : prof.rdMode);
        const am = (typeof autoCommentatorMode === 'string' ? autoCommentatorMode : prof.autoMode);
        const pr = (typeof decimalPrecision !== 'undefined' ? decimalPrecision : prof.precision);

        if (rdEl) rdEl.textContent = (raceDirectorEnabled ? rd.toUpperCase() : 'OFF');
        if (autoEl) autoEl.textContent = am.toUpperCase();
        if (precEl) precEl.textContent = `${pr} dcimas`;
        if (voicesEl) voicesEl.textContent = (autoVoiceRotateEnabled ? 'ES + rotacin' : 'ES');

        if (noteEl) noteEl.textContent = `Auto: ${autoSessionPresetsEnabled ? 'ON' : 'OFF'}`;

        // active card highlight
        ['TRAIN','MANGA','FINAL'].forEach(k=>{
          const el = document.querySelector(`.session-preset-card[data-session="${k}"]`);
          if (el) el.classList.toggle('active', k===sess);
        });

        renderPresetCards();
      }catch(e){}
    }

    function applySessionPresetFull(type, source){
      const t = String(type || 'TRAIN').toUpperCase();
      const prof = SESSION_PRESET_PROFILES[t] || SESSION_PRESET_PROFILES.TRAIN;

      // Ajustes core
      raceDirectorEnabled = true;
      try { prefSet('raceDirectorEnabled', '1'); } catch(e) {}
      try { if (typeof updateRdButton === 'function') updateRdButton(); } catch(e) {}

      try { setRaceDirectorMode(prof.rdMode); } catch(e) {}
      try { setAutoCommentatorMode(prof.autoMode); } catch(e) {}
      applyDecimalPrecision(prof.precision);

      // Ajustes de mensajes por sesin: dejar claro ON/OFF
      try{
        Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => {
          if (k === 'laps'){ voiceSettings.laps = true; return; }
          voiceSettings[k] = !!prof.voice[k];
        });
        voiceSettings.laps = true;
        applyVoiceSettingsToButtons();
        saveVoiceSettings();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      }catch(e){}

      __lastAutoPresetType = t;
      updateConfigStatusUI();
      try { if (source) console.log('[PresetSesion]', t, 'source=', source); } catch(e){}
    }

    // Click handlers para aplicar preset manual
    function bindSessionPresetCards(){
      document.querySelectorAll('.session-preset-card').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const t = btn.getAttribute('data-session') || 'TRAIN';
          applySessionPresetFull(t, 'manual');
          playBeep('up');
        });
      });
    }

// ===== Voces (solo espaol) + rotacin Auto Locutor =====
    let autoVoiceRotateEnabled = true; // ON por default
    let __autoVoicePool = [];
    let __autoVoiceIdx = 0;
    
    function nextAutoVoiceURI(){
      if (!autoVoiceRotateEnabled) return '';
      if (!__autoVoicePool || !__autoVoicePool.length) return '';
      const uri = __autoVoicePool[__autoVoiceIdx % __autoVoicePool.length];
      __autoVoiceIdx = (__autoVoiceIdx + 1) % __autoVoicePool.length;
      return uri || '';
    }

    
    // Defaults por plataforma: iPhone 1.2, Android 1.7, Web 2.0
    function _isIOSWebKitRate() {
      const ua = navigator.userAgent || '';
      return /iPad|iPhone|iPod/i.test(ua);
    }
    function _isAndroidRate() {
      const ua = navigator.userAgent || '';
      return /Android/i.test(ua);
    }
    function detectDefaultTtsRate() {
      if (_isIOSWebKitRate()) return 1.2;
      if (_isAndroidRate()) return 1.7;
      return 2.0;
    }

let ttsRate = detectDefaultTtsRate();

    try {
      const storedRate = prefGet('spotterTtsRate', null);
      if (storedRate) {
        const r = Number(storedRate);
        if (isFinite(r) && r >= 1.0 && r <= 2.5) ttsRate = r;
      }
      else {
        // Si no hay setting guardado, usamos el default por plataforma
        try { prefSet('spotterTtsRate', String(ttsRate)); } catch (e) {}
      }
} catch (e) {}

    if (rateRange) {
      rateRange.value = String(ttsRate);
      rateDisplay.textContent = `${Number(rateRange.value).toFixed(1)}x`;
      rateRange.addEventListener('input', () => {
        ttsRate = Number(rateRange.value) || 1.5;
        rateDisplay.textContent = `${Number(rateRange.value).toFixed(1)}x`;
        try { prefSet('spotterTtsRate', String(ttsRate)); } catch (e) {}
      });
    }

    function pickDefaultVoice(voices) {
      // Prioridad: es-MX, luego es (cualquier), luego lo que haya.
      const vMx = voices.find(v => (v.lang || '').toLowerCase().startsWith('es-mx'));
      if (vMx) return vMx;
      const vEs = voices.find(v => (v.lang || '').toLowerCase().startsWith('es'));
      if (vEs) return vEs;
      return voices[0] || null;
    }

    function refreshVoiceList() {
      if (!voiceSelect) return;

      const raw = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
      if (!raw || !raw.length) return;

      // Cargar seleccionado previo una sola vez
      if (!chosenVoiceURI) {
        try {
          const storedURI = prefGet('spotterVoiceURI', null);
          if (storedURI) chosenVoiceURI = storedURI;
        } catch (e) {}
      }

      // Deduplicar y ordenar (es-MX arriba)
      const seen = new Set();
      const voicesAll = raw.filter(v => {
        const k = `${v.voiceURI || v.name || ''}|${v.lang || ''}`;
        if (!k.trim()) return false;
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
      }).sort((a,b) => {
        const al = (a.lang || '').toLowerCase();
        const bl = (b.lang || '').toLowerCase();
        const aMx = al.startsWith('es-mx') ? 0 : 1;
        const bMx = bl.startsWith('es-mx') ? 0 : 1;
        if (aMx !== bMx) return aMx - bMx;
        return (a.name || '').localeCompare(b.name || '');
      });

      // Solo espaol (fallback a todo si no hay voces ES)
      const voicesES = voicesAll.filter(v => ((v.lang || '').toLowerCase().startsWith('es')));
      const voices = voicesES.length ? voicesES : voicesAll;

      // Pool para rotacion de Auto Locutor
      // - Preferimos voces ES "Microsoft" cuando existan.
      // - Si el navegador no muestra "Microsoft" (caso comun: solo ves Raul/Sabina/Helena/Laura/Pablo),
      //   las incluimos como preferidas para rotar siempre entre ellas.
      try {
        const nameL = (v) => String((v && v.name) || '').toLowerCase().trim();
        const isMS = (v) => nameL(v).includes('microsoft');
        const isES = (v) => String((v && v.lang) || '').toLowerCase().startsWith('es');

        const preferred = new Set(['raul','sabina','helena','laura','pablo']);

        const preferredES = (voicesAll || []).filter(v => isES(v) && (isMS(v) || preferred.has(nameL(v))));
        __autoVoicePool = preferredES.map(v => (v.voiceURI || v.name)).filter(Boolean);

        // fallback 1: voces espanolas visibles (rotar todas)
        if (!__autoVoicePool.length) __autoVoicePool = (voicesES.length ? voicesES : (voices || [])).map(v => (v.voiceURI || v.name)).filter(Boolean);

        // fallback 2: cualquier voz disponible
        if (!__autoVoicePool.length) __autoVoicePool = (voicesAll || []).map(v => (v.voiceURI || v.name)).filter(Boolean);
      } catch(e) {}

      voiceSelect.innerHTML = '';
      voices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI || v.name || '';
        opt.textContent = `${v.name} (${v.lang || 'lang'})`;
        voiceSelect.appendChild(opt);
      });

      let toUse = chosenVoiceURI ? voices.find(v => (v.voiceURI || v.name) === chosenVoiceURI) : null;
      if (!toUse) {
        toUse = pickDefaultVoice(voices);
        chosenVoiceURI = toUse ? (toUse.voiceURI || toUse.name) : '';
      
      try { __refreshDuoVoices(voicesAll); } catch (e) {}
}

      if (chosenVoiceURI) voiceSelect.value = chosenVoiceURI;

      if (!voiceSelect.__bound) {
        voiceSelect.__bound = true;
        voiceSelect.addEventListener('change', () => {
          chosenVoiceURI = voiceSelect.value || '';
          try { prefSet('spotterVoiceURI', chosenVoiceURI); } catch (e) {}
        });
      }
    }

    if (window.speechSynthesis) {
      refreshVoiceList();
    try { bindSessionPresetCards(); } catch(e) {}
    try { updateConfigStatusUI(); } catch(e) {}

      // Reintentos por si getVoices() llega vaco al inicio (comn en iOS/Android)
      let __vtries = 0;
      const __vtimer = setInterval(() => {
        __vtries++;
        refreshVoiceList();
        const v = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
        if ((v && v.length) || __vtries >= 10) clearInterval(__vtimer);
      }, 250);

      window.speechSynthesis.onvoiceschanged = () => refreshVoiceList();

      // Keep-alive TTS en primer plano: evita que el motor se "duerma" aunque la pantalla esté activa.
      // Solo actúa cuando VOZ está ON, la pestaña está visible y no estamos en estado de "needs unlock".
      try {
        if (!__ttsKeepAliveTimer) {
          __ttsKeepAliveTimer = setInterval(() => {
            try {
              const vis = (document && document.visibilityState) ? document.visibilityState : 'visible';
              if (vis !== 'visible') return;
              if (!voiceMasterEnabled) return;
              const __kaIOS = (typeof isIOSWebKit === 'function' ? isIOSWebKit() : false);
              if (pendingAutoVoiceUnlock && __kaIOS) return;
              if (!window.speechSynthesis) return;

              // Mantén vivo el motor
              try { if (typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
              try { if (typeof window.speechSynthesis.getVoices === 'function') window.speechSynthesis.getVoices(); } catch(e) {}

              // Si hay cola y se quedó atorado, empuja
              try {
                if (speechQueue && speechQueue.length && !speechSpeaking && !window.speechSynthesis.speaking) {
                  pumpSpeechQueue();
                }
              } catch(e) {}
            } catch(e) {}
          }, 3000);
        }
      } catch(e) {}

    }

    // Botn de prueba de voz (genera gesto de usuario y ayuda a iOS)
    if (ttsTestBtn) {
      ttsTestBtn.addEventListener('click', () => {
        try { setVoiceMaster(true, { silent:true, auto:true }); } catch(e) {}
        try { startSilentAudioKeepAlive(); } catch(e) {}
        try { hardUnlockAudioPipe(); } catch(e) {}
      try { if (voiceMasterEnabled && isIOSWebKit && isIOSWebKit()) unlockTTSOnce('voice-master'); } catch(e) {}
        try { playBeep('soft'); } catch(e) {}
        try {
          enqueueSpeech('Spotter listo. Probando voz.', { key:'tts_test', priority: 99, cooldownMs: 0, interrupt:true, dedupe: true });
        } catch(e) {}
      });
    }

    // Speech queue manager: evita que se trunque cuando entra otro mensaje.
    const speechQueue = [];
    let speechSpeaking = false;
    let speechWatchdog = 0;
    const lastSpokenKeyAt = new Map();
    const lastSpokenTextAt = new Map();
let __ttsStartGuard = 0;
    let __ttsStartGuardFails = 0; // conteo de fallos de arranque (para no exigir tap a la primera)
 // si el utterance no arranca, no drenar cola (iOS/Android post-idle)

    
    // =========================
    // TTS normalizacin de tiempos (evita que diga dgito por dgito)
    // =========================
    function normalizeTtsText(raw) {
      try {
        let s = String(raw || '');

        // Normaliza unicode (acentos) para TTS
        try { s = s.normalize('NFC'); } catch(e) {}
        // TTS-safe: evita que algunas voces pronuncien raro "Clasificación"
        s = s.replace(/Clasificación/gi, 'Clasificaci\xf3n');

        // Unidades: "123 ms" -> segundos/d\xe9cimas/cent\xe9simas/mil\xe9simas seg\xfan corresponda
        // Nota: esto SOLO aplica cuando "ms" viene con n\xfa mero. "ms" suelto se trata como "m\xe1s" m\xe1s abajo.
        const __msToSpeech = (msStr) => {
          const ms = parseInt(msStr, 10);
          if (!isFinite(ms) || ms <= 0) return msStr + ' ms';
          // >= 1s => segundos (con 1-3 decimales seg\xfan exactitud)
          if (ms >= 1000) {
            const whole = (ms % 1000) === 0;
            if (whole) {
              const secInt = Math.round(ms / 1000);
              return secInt + (secInt === 1 ? ' segundo' : ' segundos');
            }
            let decs = 3;
            if ((ms % 100) === 0) decs = 1;
            else if ((ms % 10) === 0) decs = 2;
            let secStr = (ms / 1000).toFixed(decs);
            secStr = secStr.replace(/0+$/,'').replace(/\.$/,'');
            const spoken = secStr.replace('.', ' punto ');
            return spoken + ' segundos';
          }
          // < 1s => d\xe9cimas / cent\xe9simas / mil\xe9simas (seg\xfan divisibilidad)
          if ((ms % 100) === 0) {
            const d = ms / 100;
            return d + (d === 1 ? ' d\xe9cima' : ' d\xe9cimas');
          }
          if ((ms % 10) === 0) {
            const c = ms / 10;
            return c + (c === 1 ? ' cent\xe9sima' : ' cent\xe9simas');
          }
          return ms + (ms === 1 ? ' mil\xe9sima' : ' mil\xe9simas');
        };
        s = s.replace(/\b(\d+)\s*ms\b/gi, (m, n) => __msToSpeech(n));

        // Diccionario r\xe1pido de tildes y pronunciaci\xf3n (TTS)
        // - evita lecturas raras por falta de acento ("basico") o por encoding/recortes (ej. "líder", "lnea")
        const __dict = [
          [/\bbasico\b/gi, 'b\xe1sico'],
          [/\bbásico\b/gi, 'b\xe1sico'],
          [/\bclasificaci[o\xf3]n\b/gi, 'clasificaci\xf3n'],
          [/\bclasificación\b/gi, 'clasificaci\xf3n'],
          [/\bclasificacin\b/gi, 'clasificaci\xf3n'],
          [/\bposicion\b/gi, 'posici\xf3n'],
          [/\bposición\b/gi, 'posici\xf3n'],
          [/\buúltima\b/gi, '\xfaúltima'],
          [/\búltima\b/gi, '\xfaúltima'],
          [/\blider\b/gi, 'l\xedder'],
          [/\blder\b/gi, 'l\xedder'],
          [/\bmas\b/gi, 'm\xe1s'],
          [/\bms\b/gi, 'm\xe1s'],
          [/\bpenalizacion\b/gi, 'penalizaci\xf3n'],
          [/\bpenalizacin\b/gi, 'penalizaci\xf3n'],
          [/\btrafico\b/gi, 'tr\xe1fico'],
          [/\btrfico\b/gi, 'tr\xe1fico'],
          [/\blinea\b/gi, 'l\xednea'],
          [/\blnea\b/gi, 'l\xednea'],
          [/\bpresion\b/gi, 'presi\xf3n'],
          [/\bpresin\b/gi, 'presi\xf3n'],
          [/\batras\b/gi, 'atr\xe1s'],
          [/\batrs\b/gi, 'atr\xe1s'],
          [/\brapido\b/gi, 'r\xe1pido'],
          [/\brpido\b/gi, 'r\xe1pido'],
          [/\bdecima\b/gi, 'd\xe9cima'],
          [/\bdcima\b/gi, 'd\xe9cima'],
          [/\bdecimas\b/gi, 'd\xe9cimas'],
          [/\bdcimas\b/gi, 'd\xe9cimas'],
          [/\benfocate\b/gi, 'enf\xf3cate'],
          [/\benfcate\b/gi, 'enf\xf3cate'],
          [/\bcronometro\b/gi, 'cron\xf3metro'],
          [/\best\b/gi, 'est\xe1'],
          [/HobbyShopMX/gi, 'HobbyShop M\xe9xico'],
          [/Italia\s*-\s*Messina/gi, 'Italia, Messina'],
        ];
        for (const [re, rep] of __dict) s = s.replace(re, rep);

        // P2 -> "P dos" (evita "pee two")
        const __u = ['cero','uno','dos','tres','cuatro','cinco','seis','siete','ocho','nueve','diez',
                     'once','doce','trece','catorce','quince','diecis\xe9is','diecisiete','dieciocho','diecinueve'];
        const __tens = {20:'veinte',30:'treinta',40:'cuarenta',50:'cincuenta',60:'sesenta',70:'setenta',80:'ochenta',90:'noventa'};
        const __numToEs = (n) => {
          n = Number(n);
          if (!isFinite(n)) return String(n);
          if (n < 20) return __u[n] || String(n);
          if (n === 20) return 'veinte';
          if (n < 30) return 'veinti' + (__u[n-20] || String(n-20));
          const t = Math.floor(n/10)*10, r = n%10;
          if (!r) return __tens[t] || String(n);
          return (__tens[t] || String(t)) + ' y ' + (__u[r] || String(r));
        };
        s = s.replace(/\bP\s*([0-9]{1,2})\b/gi, (m, n) => 'P ' + __numToEs(n));

        // +1 V / +2 V / +3 V -> "m\xe1s una vuelta", "m\xe1s dos vueltas" (quita el "+", que suele confundir al TTS)
        s = s.replace(/\+(\d+)\s*V\b/gi, (m, n) => {
          const k = parseInt(n,10);
          if (!isFinite(k) || k <= 0) return m;
          const w = (k <= 30) ? __numToEs(k) : String(k);
          return k === 1 ? 'm\xe1s una vuelta' : ('m\xe1s ' + w + ' vueltas');
        });
        s = s.replace(/\+(\d+)V\b/gi, (m, n) => {
          const k = parseInt(n,10);
          if (!isFinite(k) || k <= 0) return m;
          const w = (k <= 30) ? __numToEs(k) : String(k);
          return k === 1 ? 'm\xe1s una vuelta' : ('m\xe1s ' + w + ' vueltas');
        });

        // mm:ss.mmm
        s = s.replace(/\b(\d{1,2}):(\d{2})\.(\d{3})\b/g, (m0) => {
          const ms = parseTimeToMs(m0);
          return ms ? tiempoATexto(ms) : m0;
        });

        // ss.xxx (evitar tocar versiones tipo 4.0.7: usa lookaround para no estar pegado a otro punto)
        s = s.replace(/(^|[^\d.])(\d{1,2}\.\d{1,3})(?![\d.])/g, (m0, pre, tok) => {
          const v = parseFloat(tok);
          if (!isFinite(v) || v <= 0 || v >= 180) return pre + tok;
          const ms = parseTimeToMs(v);
          return pre + (ms ? tiempoATexto(ms) : tok);
        });

        
        // Limpieza: evitar repetir el mismo dato dos veces en la misma frase (bug/armado)
        // Ej: "ms una vuelta, ms una vuelta" / "0.2 segundos, 0.2 segundos"
        try {
          // Repite "ms X vuelta(s)"
          s = s.replace(/\b(m\xe1s\s+(?:una|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s+vueltas?)\b(?:\s*[,;:\-]\s*\1\b)+/gi, '$1');
          // Repite "P#"
          s = s.replace(/\b(P\s*\d+)\b(?:\s*[,;:\-]\s*\1\b)+/gi, '$1');
          // Repite "<n> segundos/dcimas/centsimas/milsimas"
          s = s.replace(/\b(\d+(?:\.\d+)?\s*(?:segundos?|d\xe9cimas?|cent\xe9simas?|mil\xe9simas?))\b(?:\s*[,;:\-]\s*\1\b)+/gi, '$1');
        } catch(e) {}
return s;
      } catch(e) {
        return String(raw || '');
      }
    }

    // =========================
    // MANGA: reloj de 3:00 POR PILOTO (arranca en su 1er cruce por meta)
    // - La sesin dura 3:00, pero cada piloto trae su propio cronmetro (salida escalonada).
    // - Guardamos el inicio por piloto (pilotKey) para que NO se reinicie al cambiar de piloto seguido.
    // =========================
    let mangaClockTimer = 0;
    const MANGA_SESSION_MS = 180000;

    // pilotKey -> epoch ms (inicio aproximado del cronmetro de ese piloto)
    let mangaPilotStartAt = new Map();
    // pilotKey -> laps vistos en el tick anterior (para detectar primer cruce)
    let mangaPrevLapsByPilot = new Map();
    // pilotKey -> ya anunciamos "Inicio cronometro" (evita repetir al volver a seleccionar)
    let mangaStartAnnouncedByPilot = new Set();

    // First-detect beep (suave) por piloto (no repetir cuando re-seleccionas)
    let firstDetectBeepedByPilot = new Map();

    function setMangaClockVisible(on) {
      const it = document.getElementById('mangaClockItem');
      if (!it) return;
      if (on) it.classList.remove('timer-only');
      else it.classList.add('timer-only');
    }

    function formatClockMs(ms) {
      const v = Math.max(0, Math.floor(ms));
      const mm = Math.floor(v / 60000);
      const ss = Math.floor((v % 60000) / 1000);
      const mmm = v % 1000;
      return String(mm) + ':' + String(ss).padStart(2,'0') + '.' + String(mmm).padStart(3,'0');
    }

    function setMangaClockColorByRemaining(remMs) {
      const el = document.getElementById('mangaClock');
      if (!el) return;
      const r = Math.max(0, Math.min(1, remMs / MANGA_SESSION_MS));
      const hue = 120 * r; // 120=verde, 60=amarillo, 0=rojo
      el.style.setProperty('--clock-hue', hue.toFixed(1));
    }

    function flashMangaClock() {
      const el = document.getElementById('mangaClock');
      if (!el) return;
      el.classList.add('flash');
      setTimeout(() => el.classList.remove('flash'), 750);
    }

    
function updateMangaClockDisplay() {
      const el = document.getElementById('mangaClock');
      if (!el) return;

      // Sin piloto seleccionado: dejamos placeholder estable
      if (!selectedPilotKey) {
        el.textContent = '0:00.000';
        setMangaClockColorByRemaining(MANGA_SESSION_MS);
        return;
      }

      // En MANGA mostramos el "time" real del feed (tiempo total del piloto)
      const pNow = (raceData && Array.isArray(raceData.classification))
        ? raceData.classification.find(r => getPilotKey(r) === selectedPilotKey)
        : null;

      const elapsedMs = pNow ? (Number(pNow.time) || 0) : 0;
      const timeTxt = elapsedMs > 0 ? msToMinSec(elapsedMs) : '0:00.000';

      el.textContent = timeTxt;

      // Color por restante estimado (3:00 - elapsed)
      const rem = Math.max(0, MANGA_SESSION_MS - elapsedMs);
      setMangaClockColorByRemaining(rem);
    }

    function ensureMangaClockTicker() {
      setMangaClockVisible(true);
      // Siempre refrescamos al menos una vez al tick actual
      updateMangaClockDisplay();

      if (mangaClockTimer) return;
      mangaClockTimer = setInterval(() => {
        updateMangaClockDisplay();
      }, 300);
    }

    function stopMangaClock() {
      if (mangaClockTimer) { clearInterval(mangaClockTimer); mangaClockTimer = 0; }
      setMangaClockVisible(false);

      // Reset total cuando se sale de MANGA / cambia carrera
      mangaPilotStartAt = new Map();
      mangaPrevLapsByPilot = new Map();
      mangaStartAnnouncedByPilot = new Set();
    }

    // MANGA: actualizar reloj por piloto en cada tick (arranca al 1er cruce REAL por meta: 0 -> 1)
function updateMangaPilotStartsFromClassification(classification) {
  try {
    if (!Array.isArray(classification)) return;

    const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
    if (!isManga) return;

    const now = Date.now();

    for (const row of classification) {
      const pk = getPilotKey(row);
      if (!pk) continue;

      const laps = Number(row.lapcount) || 0;
      const hadPrev = mangaPrevLapsByPilot.has(pk);
      const prev = hadPrev ? (Number(mangaPrevLapsByPilot.get(pk)) || 0) : 0;

      // Guardar laps vistos
      mangaPrevLapsByPilot.set(pk, laps);

      // Primer cruce detectado REAL: solo cuando YA vimos laps=0 y ahora sube a >0
      // (Evita arrancar el reloj "al seleccionar" si abres el spotter con la manga ya empezada)
      if (!mangaPilotStartAt.get(pk) && hadPrev && prev === 0 && laps > 0) {
        mangaPilotStartAt.set(pk, now);

        // Aviso solo para el piloto seleccionado (evita spam de todos)
        if (pk === selectedPilotKey && !mangaStartAnnouncedByPilot.has(pk)) {
          try { if (voiceMasterEnabled) playBeep('up'); } catch(e) {}
          enqueueSpeech('Inicio cronometro.', { key: 'manga_start_' + pk, priority: 92, cooldownMs: 8000, dedupe: true });
          try { flashPilotCardGreen(); } catch(e) {}
          try { flashMangaClock(); } catch(e) {}
          mangaStartAnnouncedByPilot.add(pk);
        }
      }
    }

    // UI: si hay piloto seleccionado, muestra reloj (3:00 hasta que arranque)
    if (selectedPilotKey) {
      setMangaClockVisible(true);
      updateMangaClockDisplay();
      if (mangaPilotStartAt.get(selectedPilotKey)) ensureMangaClockTicker();
    } else {
      // sin piloto seleccionado: opcional mantener visible 3:00
      setMangaClockVisible(true);
      updateMangaClockDisplay();
    }
  } catch(e) {}
}

function flashPilotCardGreen() {
      const card = document.querySelector('.pilot-card');
      if (!card) return;
      card.classList.add('flash-green');
      setTimeout(() => card.classList.remove('flash-green'), 650);
    }

    // =========================
    // Record de carrera: avisar cuando lo mejora CUALQUIERA
    // =========================
    let lastGlobalBestSpokenMs = 0;
    let lastGlobalBestSpokenHolderKey = null;
    let lastGlobalBestSpokenAt = 0;

function clampNum(v, lo, hi){
      const n = Number(v);
      if (!isFinite(n)) return lo;
      return Math.max(lo, Math.min(hi, n));
    }

    function prosodyFromMood(mood){
      const m = String(mood||'').toLowerCase();
      // Nota: Web Speech API no tiene "emociones" reales. Esto solo ajusta rate/pitch/volume.
      if (m === 'hype' || m === 'excited') return { rateMul: 1.06, pitch: 1.12, volume: 1.0 };
      if (m === 'urgent') return { rateMul: 1.10, pitch: 1.18, volume: 1.0 };
      if (m === 'calm') return { rateMul: 0.98, pitch: 0.96, volume: 1.0 };
      if (m === 'serious') return { rateMul: 0.99, pitch: 0.92, volume: 1.0 };
      return { rateMul: 1.0, pitch: 1.0, volume: 1.0 };
    }



// =============================
// Anti-repeticion semantica v2
// - Evita repetir la misma idea con texto distinto
// - Aplica solo en categorias narrativas (no POS/LAPS)
// =============================
const __semMem = new Map();
const __semStop = new Set([
  'el','la','los','las','un','una','unos','unas','de','del','al','y','o','a','en','por','para','con','sin','que','se','su','sus',
  'tu','tus','mi','mis','ya','va','vamos','ahi','aquí','ok','bien','dale','ahora','solo','muy','mas','menos','uno','dos','tres',
  'p','pos','posicion','vueltas','vuelta','lap','laps','seg','segundos','segundo','ms'
]);

function __semStripAccents(s){
  try{ return String(s||'').normalize('NFD').replace(/[-]/g,''); }catch(e){ return String(s||''); }
}

function __semNorm(s){
  s = __semStripAccents(String(s||'').toLowerCase());
  // quita numeros para comparar "idea" (9.812 vs 9.803)
  s = s.replace(/[0-9]+([.:][0-9]+)*/g,' # ');
  // limpia puntuacion
  s = s.replace(/[^a-z#\s]/g,' ');
  s = s.replace(/\s+/g,' ').trim();
  return s;
}

function __semTokens(s){
  const n = __semNorm(s);
  if (!n) return [];
  const parts = n.split(' ').filter(Boolean);
  const out = [];
  for (const w of parts){
    if (w === '#') continue;
    if (w.length <= 2) continue;
    if (__semStop.has(w)) continue;
    out.push(w);
  }
  return out;
}

function __semJaccard(aTokens, bTokens){
  try{
    const a = new Set(aTokens||[]);
    const b = new Set(bTokens||[]);
    if (!a.size && !b.size) return 1;
    if (!a.size || !b.size) return 0;
    let inter = 0;
    for (const x of a) if (b.has(x)) inter++;
    const uni = a.size + b.size - inter;
    return uni ? (inter / uni) : 0;
  }catch(e){ return 0; }
}

function __semPrune(list, now, windowMs){
  try{
    const w = Math.max(2000, Number(windowMs)||25000);
    const keep = [];
    for (const it of (list||[])){
      if (!it) continue;
      if ((now - (it.t||0)) <= w) keep.push(it);
    }
    return keep;
  }catch(e){ return list||[]; }
}

function __semSkipCategory(cat){
  const c = String(cat||'').toLowerCase();
  // Nunca bloquees POS ni LAPS ni test
  if (!c) return true;
  if (c === 'pos' || c === 'laps' || c === 'lap' || c === 'tts' || c === 'test') return true;
  if (c === 'manga_start') return true;
  return false;
}

function __inferSemCategoryFromKey(key){
  const k = String(key||'').toLowerCase();
  if (!k) return '';
  if (k.includes('blue') || k.includes('bandera_azul') || k.includes('blueflag')) return 'blueflag';
  if (k.startsWith('auto_finalizo_') || k.includes('finalizo')) return 'finalizo';
  if (k.startsWith('pos_') || k.includes('pos_manga_') || k.includes('pos_brief_')) return 'pos';
  if (k.startsWith('lap_') || k.includes('lastlap') || k.includes('lap')) return 'lap';
  if (k.includes('attack') || k.includes('ataque') || k.includes('defense') || k.includes('defensa') || k.includes('fight') || k.includes('duel')) return 'battle';
  if (k.includes('gap') || k.includes('interval')) return 'gaps';
  if (k.includes('leader') || k.includes('líder')) return 'leader';
  if (k.includes('best') || k.includes('record')) return 'bestlap';
  if (k.includes('session_finish')) return 'finish';
  return '';
}

function __semIsRepeat(cat, text, threshold, windowMs){
  try{
    const c = String(cat||'').toLowerCase().trim();
    if (!c) return false;
    const now = Date.now();
    const thr = (Number.isFinite(Number(threshold)) ? Number(threshold) : 0.78);
    const win = (Number.isFinite(Number(windowMs)) ? Number(windowMs) : 25000);

    const norm = __semNorm(text);
    const tokens = __semTokens(text);

    let list = __semMem.get(c) || [];
    list = __semPrune(list, now, win);

    for (const it of list){
      if (!it) continue;
      // 1) match directo por normalizado (muy estricto)
      if (it.norm && norm && it.norm === norm) {
        __semMem.set(c, list);
        return true;
      }
      // 2) similitud por tokens (jaccard)
      const sim = __semJaccard(tokens, it.tokens||[]);
      if (sim >= thr) {
        __semMem.set(c, list);
        return true;
      }
    }

    __semMem.set(c, list);
    return false;
  }catch(e){ return false; }
}

function __semRemember(cat, text, windowMs){
  try{
    const c = String(cat||'').toLowerCase().trim();
    if (!c) return;
    const now = Date.now();
    const win = (Number.isFinite(Number(windowMs)) ? Number(windowMs) : 25000);
    const norm = __semNorm(text);
    const tokens = __semTokens(text);

    let list = __semMem.get(c) || [];
    list = __semPrune(list, now, win);
    list.push({ t: now, norm, tokens });
    // limita memoria por categoria
    if (list.length > 16) list = list.slice(-16);
    __semMem.set(c, list);
  }catch(e){}
}


// =========================
// Silencio por inactividad (VOZ sigue ON)
// - Si el feed no cambia (pos/laps/top3), evitamos que el spotter repita y repita.
// - Solo dejamos pasar mensajes esenciales (bandera azul, cambios fuertes, sistema).
// =========================
let __activitySig = '';
let __lastActivityChangeTs = Date.now();
let __silenceAfterMs = 20000; // 20s sin cambios = silencio

function __setActivitySig(sig){
  try{
    const s = String(sig||'');
    if (!s) return;
    if (s !== __activitySig){
      __activitySig = s;
      __lastActivityChangeTs = Date.now();
    }
  }catch(e){}
}
function __inActivitySilence(){
  try{ return (Date.now() - (__lastActivityChangeTs||0)) > (__silenceAfterMs||20000); }catch(e){ return false; }
}
function __isEssentialSpeech(opts, key, priority){
  try{
    if (opts && (opts.force === true || opts.user === true)) return true;
    const pr = Number(priority||0) || 0;
    if (pr >= 80) return true;
    const k = String(key||'').toLowerCase();
    const cat = String((opts && (opts.semanticCategory || opts.category)) || '').toLowerCase();
    if (cat === 'ess' || cat === 'system' || cat === 'critical') return true;
    if (k.includes('blue') || k.includes('bandera') || k.includes('leader') || k.includes('líder') || k.includes('finish') || k.includes('cuadros') || k.includes('podium')) return true;
    if (k.includes('tts_test') || k.includes('unlock') || k.includes('audio listo')) return true;
    return false;
  }catch(e){ return false; }
}

// =========================
// TTS RECOVERY (evita "se tarda / no arranca / luego escupe todo")
// - Si el motor de voz se bloquea, no acumulamos backlog infinito.
// - Al reactivar, limpiamos mensajes viejos y retomamos suave.
// =========================
let __ttsBlockedSince = 0;

function __flushSpeechQueueStale(maxAgeMs = 8000){
  try{
    const now = Date.now();
    const maxAge = Math.max(1500, Number(maxAgeMs) || 8000);
    const keep = [];
    for (const it of (speechQueue || [])){
      if (!it) continue;
      const age = now - (it.ts || now);
      if ((it.priority || 0) >= 80) { keep.push(it); continue; }
      if (age <= maxAge) keep.push(it);
    }
    speechQueue.length = 0;
    keep.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));
    for (const it of keep) speechQueue.push(it);
    if (speechQueue.length > 14) speechQueue.splice(14);
  }catch(e){}
}

function __pruneQueueDuringBlock(){
  try{
    // Conserva criticos + solo los uúúltimos no-criticos (para que NO vomite al reactivar)
    const critical = [];
    const nonCrit = [];
    for (const it of (speechQueue || [])){
      if (!it) continue;
      if ((it.priority || 0) >= 80) critical.push(it);
      else nonCrit.push(it);
    }
    const tail = nonCrit.slice(-4);
    const merged = critical.concat(tail);
    speechQueue.length = 0;
    merged.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));
    for (const it of merged) speechQueue.push(it);
    if (speechQueue.length > 12) speechQueue.splice(12);
  }catch(e){}
}

function forceTtsRecover(reason = ''){
  try{
    if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;

    // Si estamos tratando de destrabar el motor (unlock), NO mates el utterance
    try { if (typeof __ttsUnlockInFlight !== 'undefined' && __ttsUnlockInFlight) return; } catch(e) {}

    // "Soft recover": reanuda motor y drena cola sin spamear cancel()
    try { if (typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e){}

    // Solo cancela si ya estaba hablando y el motivo es "stuck/idle" (evita romper unlock/primer speak)
    try {
      const r = String(reason || '');
      if (window.speechSynthesis.speaking && (r.includes('stuck') || r.includes('idle') || r.includes('recover'))) {
        if (typeof window.speechSynthesis.cancel === 'function') if (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil) window.speechSynthesis.cancel();
      }
    } catch(e){}

    try { speechSpeaking = false; } catch(e){}
    try { __flushSpeechQueueStale(8000); } catch(e){}
    try { pumpSpeechQueue(); } catch(e){}
  }catch(e){}
}



function enqueueSpeech(text, opts = {}) {
      try {
        if (!voiceMasterEnabled) return;
        const clean = String(text || '').trim();
        if (!clean) return;
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;

        const now = Date.now();
                // Anti-loop: evita repetir el MISMO texto en ventanas cortas aunque cambie el key.
        try {
          const tTTL = (typeof opts.textTtlMs === 'number') ? opts.textTtlMs : 4500;
          const lastT = lastSpokenTextAt.get(clean) || 0;
          if ((now - lastT) < tTTL) return;
        } catch(e) {}
const key = String(opts.key || '').trim() || clean; // dedupe por texto si no hay key
        const cooldownMs = Number(opts.cooldownMs || 0) || 0;
        if (cooldownMs > 0) {
          const last = lastSpokenKeyAt.get(key) || 0;
          if (now - last < cooldownMs) return;
        }
        const priority = Number.isFinite(opts.priority) ? opts.priority : 0;
        const interrupt = !!opts.interrupt;
        const dedupe = (opts.dedupe !== false);

        // Silencio por inactividad: si no hay cambios reales, no hables (salvo esenciales)
        if (__inActivitySilence() && !__isEssentialSpeech(opts, key, priority)) {
          return;
        }

        // Si el TTS esta bloqueado y espera reactivacion por gesto,
        // no acumules backlog: solo dejamos pasar mensajes esenciales.
        if (pendingAutoVoiceUnlock) {
          if (!__isEssentialSpeech(opts, key, priority)) return;
        }


        // Anti-repeticion semantica (misma idea, texto distinto)
        // - default ON en categorias narrativas
        // - se puede desactivar por mensaje: { semanticDedupe:false }
        const __semCat = String(opts.semanticCategory || opts.category || __inferSemCategoryFromKey(key) || '').trim();
        if (opts.semanticDedupe !== false && __semCat && !__semSkipCategory(__semCat)) {
          const thr = (opts.semanticThreshold != null) ? Number(opts.semanticThreshold) : 0.78;
          const win = (opts.semanticWindowMs != null) ? Number(opts.semanticWindowMs) : 25000;
          if (__semIsRepeat(__semCat, clean, thr, win)) return;
          // solo recordamos si va a entrar a cola
          __semRemember(__semCat, clean, win);
        }

        if (dedupe) {
          if (speechQueue.some(it => it.text === clean)) return;
        }

        if (interrupt) {
          speechQueue.length = 0;
          speechSpeaking = false;
          try { if (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil) window.speechSynthesis.cancel(); } catch (e) {}
        }

        const baseRate = (Number.isFinite(ttsRate) ? ttsRate : 1.5);
        const mood = opts.mood;
        const pr = prosodyFromMood(mood);
        const rate = clampNum((opts.rate != null ? opts.rate : (baseRate * (pr.rateMul || 1.0))), 0.6, 2.2);
        const pitch = clampNum((opts.pitch != null ? opts.pitch : (pr.pitch != null ? pr.pitch : 1.0)), 0.5, 2.0);
        const volume = clampNum((opts.volume != null ? opts.volume : (pr.volume != null ? pr.volume : 1.0)), 0.0, 1.0);
        const postDelayMs = clampNum((opts.postDelayMs != null ? Number(opts.postDelayMs) : 0), 0, 2000);
        speechQueue.push({ text: clean, key, priority, ts: now, rate, pitch, volume, postDelayMs, voiceURI: (opts && (opts.voiceURI || opts.voiceUri)) || '' });
        try { if (pendingAutoVoiceUnlock) __pruneQueueDuringBlock(); } catch(e) {}
        try { pushSpeechLog({ text: clean, key, priority }); } catch(e) {}
        // prioridad desc, FIFO por tiempo
        speechQueue.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));

        pumpSpeechQueue();
      } catch (e) {
        console.error('enqueueSpeech', e);
      }
    }

    function pumpSpeechQueue() {
      try {
        if (!voiceMasterEnabled) return;
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;

        if (speechSpeaking || window.speechSynthesis.speaking) return;

        // Si el TTS esta bloqueado y esperando tap, no intentes hablar (evita loops y 20 taps).
        // Pero si estamos en primer plano y ya se desbloqueo antes, auto-recupera sin exigir tap.
        if (pendingAutoVoiceUnlock) {
          try {
            const vis = (document && document.visibilityState) ? document.visibilityState : 'visible';
            if (vis === 'visible' && __ttsUnlockedOnce) {
              pendingAutoVoiceUnlock = false;
              __ttsBlockedSince = 0;
              try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
            } else {
              return;
            }
          } catch(e) { return; }
        }

        const next = speechQueue.shift();
        if (!next) return;

        const u = new SpeechSynthesisUtterance(normalizeTtsText(next.text));
        let __ttsDidStart = false;
        try {
          u.onstart = () => {
            __ttsDidStart = true;
                        try { __ttsStartGuardFails = 0; } catch(e) {}
try { if (__ttsStartGuard) { clearTimeout(__ttsStartGuard); __ttsStartGuard = 0; } } catch(e) {}
          };
        } catch(e) {}
        u.lang = 'es-MX';
        u.rate = (next.rate != null ? next.rate : (isFinite(ttsRate) ? ttsRate : 1.5));
        u.pitch = (next.pitch != null ? next.pitch : 1.0);
        u.volume = (next.volume != null ? next.volume : 1.0);

        const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
        if (voices && voices.length) {
          
let v = null;

// DUO web/desktop: alterna Sabina/Raul por frase (fallback a SINGLE si no estan ambas)
if (__duoWebEnabled && __duoVoiceSabinaURI && __duoVoiceRaulURI) {
  try {
    let role = __duoGuessRole(next.text, next.key);
    if (__duoLastRole && role === __duoLastRole) role = (role === 'raul' ? 'sabina' : 'raul');
    const wanted = (role === 'raul') ? __duoVoiceRaulURI : __duoVoiceSabinaURI;
    const dv = voices.find(x => (x.voiceURI || x.name) === wanted);
    if (dv) { v = dv; __duoLastRole = role; }
  } catch (e) {}
}
          // Auto voice override (per-message), used by Auto Locutor rotation
          if (!v && next && next.voiceURI) {
            try { v = voices.find(x => (x.voiceURI || x.name) === next.voiceURI); } catch(e) {}
          }
          if (!v && chosenVoiceURI && !(next && next.voiceURI)) v = voices.find(x => (x.voiceURI || x.name) === chosenVoiceURI);
          if (!v) v = pickDefaultVoice(voices);
          if (v) {
            u.voice = v;
            if (v.lang) u.lang = v.lang;
          }
        }

        speechSpeaking = true;

        const clearWd = () => {
          if (speechWatchdog) { clearTimeout(speechWatchdog); speechWatchdog = 0; }
        };
        clearWd();
        speechWatchdog = setTimeout(() => {
          // watchdog anti-freeze (iOS/Chrome a veces se queda "hablando")
          try { if (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil) window.speechSynthesis.cancel(); } catch (e) {}
          speechSpeaking = false;
          pumpSpeechQueue();
        }, 15000);

        u.onend = () => {
          clearWd();
          speechSpeaking = false;
                    try { __ttsStartGuardFails = 0; } catch(e) {}
try { if (next && typeof next.key === 'string' && next.key.indexOf('auto_intro_title_') === 0) { __autoIntroDoneKeys.add(next.key); } } catch(e) {}
          lastSpokenKeyAt.set(next.key, Date.now());
          try { lastSpokenTextAt.set(next.text, Date.now()); } catch(e) {}
          const d = Number(next.postDelayMs || 0) || 0;
          if (d > 0) setTimeout(pumpSpeechQueue, d);
          else pumpSpeechQueue();
        };
        u.onerror = () => {
          clearWd();
          speechSpeaking = false;
                    try { __ttsStartGuardFails = 0; } catch(e) {}
lastSpokenKeyAt.set(next.key, Date.now());
          try { lastSpokenTextAt.set(next.text, Date.now()); } catch(e) {}
          const d = Number(next.postDelayMs || 0) || 0;
          if (d > 0) setTimeout(pumpSpeechQueue, d);
          else pumpSpeechQueue();
        };

        window.speechSynthesis.speak(u);

        // Start-guard: si no arranca en ~1.2s, suele ser bloqueo de TTS (iOS/Android tras auto-lock o background).
        // Importante: NO drenamos la cola. Dejamos el mensaje en espera y pedimos un tap para reactivar.
        try {
          if (__ttsStartGuard) { clearTimeout(__ttsStartGuard); __ttsStartGuard = 0; }
          __ttsStartGuard = setTimeout(() => {
            try {
              if (__ttsDidStart) return;
              // Intento de recuperacion suave
              try {
                if (!pendingAutoVoiceUnlock && window.speechSynthesis && typeof window.speechSynthesis.cancel === 'function') {
                  const ss = window.speechSynthesis;
                  if ((ss.speaking || ss.pending) && (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil)) ss.cancel();
                }
              } catch(e) {}
              speechSpeaking = false;

              // Reinsertar el mismo mensaje al frente (no se pierde)
              try {
                speechQueue.unshift(next);
                speechQueue.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));
              } catch(e) {}

              // Si el utterance no arranco, reintenta antes de pedir tap (primer plano debe auto-recuperar).
              try { __ttsStartGuardFails = (__ttsStartGuardFails || 0) + 1; } catch(e) {}
              try {
                const vis = (document && document.visibilityState) ? document.visibilityState : 'visible';
                const canAutoRecover = (vis === 'visible' && __ttsUnlockedOnce);
                if (canAutoRecover && __ttsStartGuardFails <= 6) {
                  // Recuperacion suave: reanuda + re-pump sin bloquear UI
                  try { if (typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
                  try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
                  try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
                  try { setTimeout(() => pumpSpeechQueue(), 120); } catch(e) {}
                } else {
                  // Solo iOS/WebKit puede requerir gesto nuevo tras idle. En desktop/Android seguimos auto-recuperando.
                  const __sgIOS = (typeof isIOSWebKit === 'function' ? isIOSWebKit() : false);
                  if (!__sgIOS) {
                    try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
                    try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
                    try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
                    try { setTimeout(() => pumpSpeechQueue(), 180); } catch(e) {}
                  } else {
                    try { pendingAutoVoiceUnlock = true; } catch(e) {}
                    try { __ttsBlockedSince = Date.now(); } catch(e) {}
                    try { __pruneQueueDuringBlock(); } catch(e) {}
                    try { const vis2 = (document && document.visibilityState) ? document.visibilityState : 'visible'; if (vis2 !== 'visible') __ttsUnlockedOnce = false; } catch(e) {}
                    try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
                    try { showToast('Toca la pantalla para reactivar audio', 1800); } catch(e) {}
                  }
                }
              } catch(e) {
                try { pendingAutoVoiceUnlock = true; } catch(_e) {}
              }
              try { if (typeof scheduleOneTapUnlock === 'function') scheduleOneTapUnlock(); } catch(e) {}
            } catch(e) {}
          }, 3500);
        } catch(e) {}
      } catch (e) {
        console.error('pumpSpeechQueue', e);
        speechSpeaking = false;
      }
    }

    function speakText(text, opts) {
      enqueueSpeech(text, opts || {});
    }

    // LAPS prefix latch: evita repetir "X vueltas" dos veces en la misma vuelta
    let __lastLapsPrefixLap = null;
    let __lastLapsPrefixAt = 0;

function speakWithLaps(_laps, message, opts) {
      // Prefijo de LAPS (opcional): si "Vueltas" estápagado, no digas "10 vueltas..."
      const msg = String(message || '').trim();
      const allowPrefix = !!(voiceSettings && voiceSettings.saylaps);

      if (!allowPrefix) {
        if (msg) speakText(msg, opts || {});
        return;
      }

      // Regla: no decir "Vuelta X" ni el nmero de vuelta.
      // Aquí s leemos LAPS primero (como siempre), y metemos coma para pausar antes del mensaje.
      let prefix = '';
      const laps = (_laps == null) ? null : Number(_laps);
      const __now = Date.now();
      const __sameLapRecently = (Number.isFinite(laps) && (__lastLapsPrefixLap === Math.floor(laps)) && ((__now - __lastLapsPrefixAt) < 1800));
      if (Number.isFinite(laps) && laps >= 0) {
        if (!__sameLapRecently) {
          if (laps === 1) prefix = 'Una vuelta';
          else prefix = String(Math.floor(laps)) + ' vueltas';
          __lastLapsPrefixLap = Math.floor(laps);
          __lastLapsPrefixAt = __now;
        }
      }

      const finalText = prefix ? (msg ? (prefix + ', ' + msg) : (prefix + '.')) : msg;
      if (finalText) speakText(finalText, opts || {});
    }

    function formatAnnouncer(msg) {
      // PRO: directo y claro
      return String(msg || '').trim();
    }

    // Botn maestro de voz (iOS requiere gesto del usuario)
    if (voiceToggleBtns && voiceToggleBtns.length) {
      
    
    function isIOSWebKit() {
      const ua = navigator.userAgent || '';
      return /iPad|iPhone|iPod/i.test(ua);
    }
    let __oneTapUnlockArmed = false;
let __oneTapUnlockLastAt = 0;

function scheduleOneTapUnlock() {
  // iOS/WebKit: a veces el TTS queda mudo tras sleep/background.
  // Sencillo: armamos 1 click para intentar unlock, SIN tragarnos el toque.
  try { if (__oneTapUnlockArmed) return; } catch(e) {}
  try { __oneTapUnlockArmed = true; } catch(e) {}

  const handler = () => {
    try { __oneTapUnlockArmed = false; __oneTapUnlockLastAt = Date.now(); } catch(e) {}
    if (!pendingAutoVoiceUnlock) return;

    try { __userGestureUnlocked = true; } catch(e) {}
    try { ensureAudioCtx(); } catch(e) {}
    try { hardUnlockAudioPipe(); } catch(e) {}

    try { unlockTTSOnce('one-tap'); } catch(e) {}

    // Si sigue bloqueado, dejamos pendingAutoVoiceUnlock y se rearmar donde corresponda.
    try { if (pendingAutoVoiceUnlock) scheduleOneTapUnlock(); } catch(e) {}
  };

  try { window.addEventListener('click', handler, { once:true, passive:true }); } catch(e) {}
}

// Unlock TTS en iOS/WebKit: requiere gesto del usuario.

// Nota: NO uses cancel() aquí - en iPhone mata el "primer speak" y obliga a dar 20 taps.
let __ttsUnlockedOnce = false;
    let __ttsCancelShieldUntil = 0; // evita cancelar mientras se esta desbloqueando (iPhone)

let __ttsUnlockInFlight = false;
let __ttsUnlockStartedAt = 0;

function unlockTTSOnce(reason = '') {
      try {
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return false;
        if (!voiceMasterEnabled) return false;

        // Si ya se desbloqueo en esta sesion, solo reanuda y sigue.
        if (__ttsUnlockedOnce) {
          try { if (typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
          try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
          try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
          return true;
        }

        const now = Date.now();

        // Anti-spam: evita 20 taps que disparen 20 unlocks en paralelo.
        try {
          if (__ttsUnlockInFlight && (now - (__ttsUnlockStartedAt || 0)) < 1800) return false;
        } catch(e) {}

        try { __ttsUnlockInFlight = true; __ttsUnlockStartedAt = now; } catch(e) {}

        // Gesto de usuario + WebAudio (iOS)
        try { __userGestureUnlocked = true; } catch(e) {}
        try { ensureAudioCtx(); } catch(e) {}
        try { hardUnlockAudioPipe(); } catch(e) {}

        const synth = window.speechSynthesis;

        // Resume suave
        try { if (typeof synth.resume === 'function') synth.resume(); } catch(e) {}

        // NO canceles siempre: en iPhone a veces lo empeora.
        // Solo si estaba hablando o pendiente.
        try {
          if ((synth.speaking || synth.pending) && (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil)) {
            __ttsCancelShieldUntil = Date.now() + 1200;
            if (typeof synth.cancel === 'function') synth.cancel();
            if (typeof synth.resume === 'function') synth.resume();
          }
        } catch(e) {}

        let didStart = false;

        const u = new SpeechSynthesisUtterance('Audio listo');
        u.lang = 'es-MX';
        u.rate = clampNum((isFinite(ttsRate) ? ttsRate : 1.5), 0.8, 2.0);
        u.pitch = 1.0;
        // Casi inaudible: desbloquea sin gritarte "AUDIO LISTO" cada vez.
        u.volume = 1.0;

        try {
          u.onstart = () => {
            didStart = true;
            try { __ttsStartGuardFails = 0; } catch(e) {}
            try { __ttsUnlockedOnce = true; } catch(e) {}
            try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(e) {}

            // Ahora SI: ya arranco el motor, limpiamos estado de bloqueo.
            try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
            try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}

            try { showToast('Audio listo', 900); } catch(e) {}
            try { pumpSpeechQueue(); } catch(e) {}
          };
        } catch(e) {}

        const finishFail = () => {
          try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(e) {}
          // Seguimos marcando bloqueo: requiere otro tap
          try { pendingAutoVoiceUnlock = true; } catch(e) {}
          try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
          try { if (typeof scheduleOneTapUnlock === 'function') scheduleOneTapUnlock(); } catch(e) {}
        };

        try { u.onend = () => { if (!didStart) finishFail(); }; } catch(e) {}
        try { u.onerror = () => { finishFail(); }; } catch(e) {}

        // Respetar voz elegida (si existe)
        try {
          const voices = synth.getVoices ? synth.getVoices() : [];
          if (voices && voices.length) {
            let v = null;
            if (chosenVoiceURI) v = voices.find(x => (x.voiceURI || x.name) === chosenVoiceURI);
            if (!v) v = pickDefaultVoice(voices);
            if (v) {
              u.voice = v;
              if (v.lang) u.lang = v.lang;
            }
          }
        } catch(e) {}

        try {
          synth.speak(u);
        } catch(e) {
          try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(ex) {}
          return false;
        }

        // Watchdog: si no arranca rapido, marcamos bloqueo y pedimos otro tap.
        try {
          setTimeout(() => {
            try {
              if (__ttsUnlockedOnce) return;
              if (didStart) return;
              finishFail();
            } catch(e) {}
          }, 900);
        } catch(e) {}

        return true;
      } catch (e) {
        try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(ex) {}
        return false;
      }
    }


function setVoiceMaster(on, opts = {}) {
      
      const turningOn = !!on;

      // Si apagamos VOZ: limpiamos todo.
      // Si prendemos VOZ: NO borres 'needs-unlock' hasta que el motor realmente arranque (onstart).
      if (!turningOn) {
        try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
        try { voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
      }

      voiceMasterEnabled = turningOn;
      try { prefSet('voiceMasterEnabled', voiceMasterEnabled ? '1' : '0'); } catch(e) {}
      try { voiceToggleBtns.forEach(b => b.classList.toggle('voice-on', voiceMasterEnabled)); } catch(e) {}
      try { voiceToggleBtns.forEach(b => b.textContent = voiceMasterEnabled ? ' VOZ ACTIVA' : ' ACTIVAR VOZ'); } catch(e) {}
      // unlock audio (seleccionar piloto cuenta como gesto)
      try { ensureAudioCtx(); } catch(e) {}
      if (voiceMasterEnabled && !opts.silent) {
        try { showToast('VOZ ACTIVA', 900); } catch(e) {}
        // Intento de unlock silencioso en iOS/Android (si hay gesto)
        try { unlockTTSOnce('voice-master-on'); } catch(e) {}
      }
      if (!voiceMasterEnabled) {
        try { if (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil) window.speechSynthesis.cancel(); } catch(e) {}
        // Importante: si apagas la voz, NO dejes cola acumulada (evita que luego 'escupa todo')
        try { speechQueue.length = 0; } catch(e) {}
        try { speechSpeaking = false; } catch(e) {}
        try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
      } else {
        // Encendido: NO canceles en este punto (iPhone se queda mudo). Solo intenta unlock + drena cola.
        try { setTimeout(()=>{ try{ pumpSpeechQueue(); }catch(e){} }, 80); } catch(e) {}
}
    }

      // VOZ: respuesta inmediata al primer toque (iOS/Android).
      // - Usamos pointerdown/touchstart para evitar retrasos y taps perdidos.
      // - Si el motor se bloqueo por idle/background, aquí solo reactivamos (sin apagar).
      let __lastVoiceTapAt = 0;

      function __voiceBtnNeedsUnlock(){
        try{
          if (pendingAutoVoiceUnlock) return true;
          return voiceToggleBtns.some(b => b.classList.contains('needs-unlock'));
        }catch(e){ return !!pendingAutoVoiceUnlock; }
      }

      function __onVoiceToggle(ev){
        try{ if (ev && ev.preventDefault) ev.preventDefault(); }catch(e){}
        try{ if (ev && ev.stopPropagation) ev.stopPropagation(); }catch(e){}

        const now = Date.now();
        if (now - __lastVoiceTapAt < 320) return;
        __lastVoiceTapAt = now;

        // Esto cuenta como gesto de usuario
        try { __userGestureUnlocked = true; } catch(e) {}
        try { ensureAudioCtx(); } catch(e) {}

        // Si esta ON pero bloqueado, solo reactivamos (no toggle OFF)
        if (voiceMasterEnabled && __voiceBtnNeedsUnlock()){
          // No limpies needs-unlock aquí. Se limpia solo cuando el motor realmente arranca (onstart).
          try { unlockTTSOnce('voice-btn-recover'); } catch(e) {}
          try { forceTtsRecover('voice-btn-recover'); } catch(e) {}
          try { setTimeout(()=>{ try{ pumpSpeechQueue(); }catch(e){} }, 120); } catch(e) {}
          try { showToast('Reactivando audio...', 900); } catch(e) {}
          return;
        }

        setVoiceMaster(!voiceMasterEnabled, { user:true });

        // Al encender: intento de unlock silencioso (si aplica)
        try { if (voiceMasterEnabled) unlockTTSOnce('voice-btn'); } catch(e) {}
      }

      voiceToggleBtns.forEach(btn => {
        try { btn.style.touchAction = 'manipulation'; } catch(e) {}

        // iPhone: usar CLICK (mas confiable para destrabar TTS).
        // Otros: pointerdown/touchstart para respuesta rapida y evitar doble toggle.
        try {
          const isIOS = (() => {
            try {
              return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            } catch(e) { return false; }
          })();

          const evName = (isIOS ? 'click' : (window.PointerEvent ? 'pointerdown' : 'touchstart'));
          btn.addEventListener(evName, __onVoiceToggle, { passive:false });

          // Evita doble toggle por click fantasma SOLO cuando el handler principal no es click
          if (evName !== 'click') {
            try { btn.addEventListener('click', (ev)=>{ try{ev.preventDefault();}catch(e){} }, { passive:false }); } catch(e) {}
          }
        } catch(e) {
          try { btn.addEventListener('click', __onVoiceToggle, { passive:false }); } catch(e2) {}
        }
      });
}

      // Sync UI del boton VOZ con el estado real al cargar (evita clicks extra)
      try { setVoiceMaster(voiceMasterEnabled, { silent:true }); } catch(e) {}

      // Boton BASICO (solo seguimiento). No existe modo manual: el spotter decide todo.
    if (typeof basicToggleBtnMini !== 'undefined' && basicToggleBtnMini) {
      try {
        basicToggleBtnMini.addEventListener('click', () => {
          try {
            // Permitir BÁSICO en cualquier modo (AUTO/FOLLOW)
            
            basicModeEnabled = !basicModeEnabled;
            try { prefSet('basicModeEnabled', basicModeEnabled ? '1' : '0'); } catch(e) {}
            try { applySmartProfile(currentSessionInfo || {}, 'basic-toggle'); } catch(e) {}
            try { playBeep('tap'); } catch(e) {}
            // feedback corto (si voz activa)
            try { if (voiceMasterEnabled) speakText(basicModeEnabled ? 'Bsico activado' : 'Bsico desactivado', { priority: 'high', dedupe: true }); } catch(e) {}
          } catch(e) {}
        });
      } catch(e) {}
    }

    // Toggle UI de mensajes
    function applyVoiceSettingsToButtons() {
      spotterButtons.forEach(btn => {
        const flag = btn.getAttribute('data-flag');
        if (!flag) return;
        const on = (flag === 'laps') ? true : !!voiceSettings[flag];
        btn.classList.toggle('active', on);
      
        // LAPS siempre activo y bloqueado visual
        if (flag === 'laps') { btn.classList.add('locked'); } else { btn.classList.remove('locked'); }
});
    
      try { if (typeof updateConfigStatusUI === 'function') updateConfigStatusUI(); } catch(e) {}
}

    applyVoiceSettingsToButtons();

    spotterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const flag = btn.getAttribute('data-flag');
        if (!flag) return;

        if (flag === 'laps') {
          // no se apaga
          voiceSettings.laps = true;
          applyVoiceSettingsToButtons();
          saveVoiceSettings();
          try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
          return;
        }

        voiceSettings[flag] = !voiceSettings[flag];
        applyVoiceSettingsToButtons();
        saveVoiceSettings();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
        playBeep(voiceSettings[flag] ? 'up' : 'down');
      });
    });

    

    // =========================
    // Master: prender/apagar todos los mensajes (excepto Laps)
    // =========================
    const toggleAllMsgsBtn = document.getElementById('toggleAllMsgsBtn');

    // =========================
    // Presets rápidos (RD PRO limpio / RD SHOW)
    // - Ajusta los mismos toggles del spotter (lo que el RD usa para decidir que narrar).
    // =========================
    const presetRdProBtn  = document.getElementById('presetRdProBtn');
    const presetRdShowBtn = document.getElementById('presetRdShowBtn');
    const SPOTTER_PRESET_KEY = 'spotterMasterPreset';

    function setPresetBtnActive(name){
      try{
        if (presetRdProBtn)  presetRdProBtn.classList.toggle('active', name === 'pro');
        if (presetRdShowBtn) presetRdShowBtn.classList.toggle('active', name === 'show');
        localStorage.setItem(SPOTTER_PRESET_KEY, name || '');
      }catch(e){}
    }

    function applyPresetVoiceSettings(preset){
      // PRO limpio: directo, sin ruido
      const base = {
        laps: true,
        pos: true,
        gaps: true,
        leadergap: true,
        podium: true,
        blueflag: true,
        front06: true,
        back06: true,
        attack: true,
        defense: true,

        // OFF por defecto
        ritmo: false,
        estlap: false,
        total: false,
        cons10: false,
        bestlap: false,
        box: false,
        pelea: false,
        netgain: false
      };

      // SHOW: mas emocion
      if (preset === 'show'){
        base.bestlap = true;
        base.pelea = true;
        base.ritmo = true;
      }

      try{
        Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => {
          if (k === 'laps'){ voiceSettings.laps = true; return; }
          if (k === 'saylaps'){ return; }
          voiceSettings[k] = !!base[k];
        });
        voiceSettings.laps = true;
        applyVoiceSettingsToButtons();
        saveVoiceSettings();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      }catch(e){}
    }

    if (presetRdProBtn){
      presetRdProBtn.addEventListener('click', () => {
        applyPresetVoiceSettings('pro');
        setPresetBtnActive('pro');
        playBeep('up');
      });
    }
    if (presetRdShowBtn){
      presetRdShowBtn.addEventListener('click', () => {
        applyPresetVoiceSettings('show');
        setPresetBtnActive('show');
        playBeep('up');
      });
    }

    // Solo restaura highlight (no pisa tus settings)
    try{
      const savedPreset = localStorage.getItem(SPOTTER_PRESET_KEY);
      if (savedPreset === 'pro' || savedPreset === 'show') setPresetBtnActive(savedPreset);
    }catch(e){}

    function isAllMsgsOn(){
      let allOn = true;
      try{
        spotterButtons.forEach(btn => {
          const flag = btn.getAttribute('data-flag');
          if (!flag || flag === 'laps' || flag === 'saylaps') return;
          if (!voiceSettings[flag]) allOn = false;
        });
      }catch(e){}
      return allOn;
    }

    function updateToggleAllMsgsBtn(){
      if (!toggleAllMsgsBtn) return;
      const allOn = isAllMsgsOn();
      toggleAllMsgsBtn.textContent = allOn ? 'TODO OFF' : 'TODO ON';
      toggleAllMsgsBtn.classList.toggle('active', allOn);
    }

    if (toggleAllMsgsBtn){
      updateToggleAllMsgsBtn();
      toggleAllMsgsBtn.addEventListener('click', () => {
        const allOn = isAllMsgsOn();
        try{
          spotterButtons.forEach(btn => {
            const flag = btn.getAttribute('data-flag');
            if (!flag || flag === 'laps' || flag === 'saylaps') return;
            voiceSettings[flag] = !allOn;
          });
          voiceSettings.laps = true;
          applyVoiceSettingsToButtons();
          saveVoiceSettings();
          updateToggleAllMsgsBtn();
          playBeep(!allOn ? 'up' : 'down');
        }catch(e){}
      });
    }

    // =========================
    // Categoras desplegables (Esenciales / Batalla / Resumen)
    // =========================

// =========================
    
    const DEFAULT_MESSAGE_TOGGLES = {
      laps: true,              // siempre ON (bloqueado)
      blueflag: true,
      ritmo_up: true,
      ritmo_down: true,
      estlap: true,
      leader: true,
      podium: true,
      bestlap: true,

      pos: true,
      gaps: true,
      front06: true,
      back06: true,
      attack: true,
      defense: true,
      fight: true,

      total: true,
      cons10: true,
      box: true,
      netgain: true
    };
    let toggles = {};
    try {
      const storedMsgToggles = prefGet('spotterMessageToggles', null);
      if (storedMsgToggles) {
        toggles = JSON.parse(storedMsgToggles) || {};
      } else {
        toggles = { ...DEFAULT_MESSAGE_TOGGLES };
        prefSet('spotterMessageToggles', JSON.stringify(toggles));
      }
    } catch(e) {
      toggles = { ...DEFAULT_MESSAGE_TOGGLES };
    }

// Voice message toggles (18 botones)
    // - laps: siempre activo (no se puede apagar)
    // - blueflag: por defecto activo al abrir (si no hay config guardada)
    // =========================

    // Estado global (debe existir SIEMPRE en mdulos ES)
    let raceData = null;
    let selectedPilotKey = '';
    let selectedPilotFirstDetectBeeped = false;// hotfix: init without undefined k

    
    let pendingAutoVoiceUnlock = false;
let isLoading = false;
    let loadingSince = 0;

    let isSelectingPilot = false;
    let pendingPilotOptionsUpdate = false;
    let lastPilotOptionsSignature = '';
    let lastRaceName = '';

    let previousClassification = null;

    let decimalPrecision = 2;
    try {
      const storedDec = prefGet('spotterDecimalPrecision', null);
      if (storedDec != null) {
        const parsed = parseInt(storedDec, 10);
        if (parsed >= 1 && parsed <= 3) {
          decimalPrecision = parsed;
        }
      }
    } catch (e) {}

    if (precisionSelect) precisionSelect.value = String(decimalPrecision);
// =========================
// Truncado (sin redondeo) para lecturas/clculos mostrados o hablados
// - Requisito: no redondear, usar floor.
// =========================
function floorTo(value, decimals = 0) {
  const p = Math.pow(10, decimals);
  if (!isFinite(value)) return 0;
  return Math.floor(value * p) / p;
}

function toFixedFloor(value, decimals = 0) {
  const v = floorTo(Number(value), decimals);
  return v.toFixed(decimals);
}

    if (precisionSelect) {
      precisionSelect.addEventListener('change', () => {
        const val = parseInt(precisionSelect.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 3) {
          decimalPrecision = val;
          try {
            prefSet('spotterDecimalPrecision', String(decimalPrecision));
          } catch (e) {}
        }
      });
    }

    function syncPrecisionBadges() {
      (precisionBadges||[]).forEach(badge => {
        const val = parseInt(badge.getAttribute('data-precision'), 10);
        badge.classList.toggle('active', val === decimalPrecision);
      });
    }

    (precisionBadges||[]).forEach(badge => {
      badge.addEventListener('click', () => {
        const val = parseInt(badge.getAttribute('data-precision'), 10);
        if (!isNaN(val) && val >= 1 && val <= 3) {
          decimalPrecision = val;
          if (precisionSelect) {
            precisionSelect.value = String(val);
            precisionSelect.dispatchEvent(new Event('change'));
          }
          syncPrecisionBadges();
        }
      });
    });

    syncPrecisionBadges();

    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator && navigator.wakeLock.request) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLockStatus.textContent = 'Pantalla activa';
          wakeLock.addEventListener('release', () => {
            // Chrome puede liberar wake lock al cambiar de app / apagar pantalla.
            // Este Spotter lo mantiene SIEMPRE encendido.
            wakeLock = null;
            wakeLockStatus.textContent = 'Pantalla liberada';
            try { if (wakeLockToggle) wakeLockToggle.classList.add('active'); } catch(e) {}
            try {
              if (document.visibilityState === 'visible') {
                requestWakeLock().catch(()=>{});
              }
            } catch(e) {}
          });
        } else {
          wakeLockStatus.textContent = 'Tu navegador no soporta wake lock';
        }
      } catch (e) {
        console.error('Error wake lock', e);
        wakeLockStatus.textContent = 'Toca pantalla para mantener despierta';
      }
    }

    async function releaseWakeLock() {
      try {
        if (wakeLock) {
          await wakeLock.release();
          wakeLock = null;
        }
        wakeLockStatus.textContent = '';
      } catch (e) {
        console.error('Error liberando wake lock', e);
      }
    }

    // Wake Lock SIEMPRE ON (locked)
    try { if (wakeLockToggle) wakeLockToggle.classList.add('active'); } catch(e) {}
    try { prefSet('spotterWakeLock','1'); } catch(e) {}

    if (wakeLockToggle) {
      wakeLockToggle.addEventListener('click', async () => {
        // Bloqueado en ON
        try { wakeLockToggle.classList.add('active'); } catch(e) {}
        try { prefSet('spotterWakeLock','1'); } catch(e) {}
        await requestWakeLock();
      });
    }

    // Intento inmediato (si el navegador lo permite)
    try { requestWakeLock(); } catch(e) {}

    // Reintento en el primer gesto del usuario (por polticas del navegador)
    (function(){
      let __wlGestureDone = false;
      async function __wlTry() {
        if (__wlGestureDone) return;
        __wlGestureDone = true;
        try {
          if (wakeLockToggle && wakeLockToggle.classList.contains('active')) {
            await requestWakeLock();
          }
        } catch(e) {}
      }
      window.addEventListener('pointerdown', __wlTry, { once:true, passive:true });
      window.addEventListener('keydown', __wlTry, { once:true, passive:true });
    })();
// =========================
    // MODO BACKGROUND
    // =========================
    function setBackgroundStatus() {
      if (!backgroundStatus) return;
      backgroundStatus.textContent = backgroundModeEnabled ? 'Background ON' : '';
    }

    try {
      const savedBg = prefGet('spotterBackgroundMode', null);
      // For this build: Background is ALWAYS ON
      backgroundModeEnabled = true;
      try { prefSet('spotterBackgroundMode','1'); } catch(e){}
      if (backgroundToggle) {
        backgroundToggle.classList.toggle('active', backgroundModeEnabled);
      }
      setBackgroundStatus();
    } catch(e) {}

    if (backgroundToggle) {
      backgroundToggle.addEventListener('click', () => {
        // Background always ON (locked)
        backgroundModeEnabled = true;
        backgroundToggle.classList.add('active');
        try { prefSet('spotterBackgroundMode','1'); } catch(e) {}
        setBackgroundStatus();
      });
    }

    // Reenganche al volver al tab (Chrome puede soltar wake lock)
    let __visHiddenAt = 0;
    document.addEventListener('visibilitychange', async () => {
      try {
        const isIOS = (typeof isIOSWebKit === 'function') ? isIOSWebKit() : (/iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1));

        if (document.visibilityState === 'hidden') {
          __visHiddenAt = Date.now();


          // Desktop/Android: arranca keep-alive silencioso + reanuda motor TTS
          if (voiceMasterEnabled && !isIOS) {
            try { startSilentAudioKeepAlive(); } catch(e) {}
            try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
          }
          // iOS: al ir a background, el motor de voz suele "dormirse" y requiere gesto al volver.
          if (voiceMasterEnabled && isIOS) {
            try { __ttsUnlockedOnce = false; } catch(e) {}
            try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(e) {}
            try { pendingAutoVoiceUnlock = true; } catch(e) {}
            try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
          }
          return;
        }

        if (document.visibilityState === 'visible') {
          const awayMs = __visHiddenAt ? (Date.now() - __visHiddenAt) : 0;

          // refresh rapido al regresar
          try { loadRaceFromFirebase(); } catch(e) {}

          // Wake lock: reintento si estaba activo
          try {
            if (wakeLockToggle && wakeLockToggle.classList.contains('active')) {
              await requestWakeLock();
            }
          } catch(e) {}

          if (voiceMasterEnabled) {
            // Desktop/Android: NO forzar "needs-unlock" (si no, se queda mudo al cambiar de pestaña)
            try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
            try { confirmVoiceButtons && confirmVoiceButtons(); } catch(e) {}

            if (isIOS) {
              try { pendingAutoVoiceUnlock = true; } catch(e) {}
              try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
              try {
                const msg = (awayMs > 3000)
                  ? 'Volviste. Un tap y el audio revive.'
                  : 'Si el iPhone se quedo mudo, toca una vez.';
                showToast(msg, 2200);
              } catch(e) {}
              try { if (typeof scheduleOneTapUnlock === 'function') scheduleOneTapUnlock(); } catch(e) {}
            } else {
              try { pendingAutoVoiceUnlock = false; } catch(e) {}
              try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
              try { setTimeout(()=>{ try{ pumpSpeechQueue(); }catch(e){} }, 140); } catch(e) {}
            }
          }
        }
      } catch(e) {}

    });

    // iOS: al volver desde sleep/bfcache, forzar reenganche de audio con un solo tap
    try {
      window.addEventListener('pageshow', () => {
        try { if (voiceMasterEnabled && (typeof isIOSWebKit === 'function' ? isIOSWebKit() : false)) { __ttsUnlockedOnce = false; pendingAutoVoiceUnlock = true; if (typeof scheduleOneTapUnlock === 'function') scheduleOneTapUnlock(); } } catch(e) {}
        try { if (wakeLockToggle && wakeLockToggle.classList.contains('active')) requestWakeLock().catch(()=>{}); } catch(e) {}
      }, { passive:true });
            window.addEventListener('pagehide', () => {
        try { if (voiceMasterEnabled && (typeof isIOSWebKit === 'function' ? isIOSWebKit() : false)) { __ttsUnlockedOnce = false; pendingAutoVoiceUnlock = true; } } catch(e) {}
      }, { passive:true });
    } catch(e) {}
// KeepAlive: intenta mantener TTS vivo cuando el tab queda oculto (Chrome/Android/Safari)
    // Nota honesta: iOS puede pausar TTS si cambias de app o apagas pantalla. Para hablar "siempre",
    // deja la app al frente y la pantalla encendida (WakeLock ya va ON).
    let __bgKeepAliveTimer = 0;
    function startBgKeepAlive(){
      if (__bgKeepAliveTimer) return;
      __bgKeepAliveTimer = setInterval(() => {
        try {
          if (!backgroundModeEnabled) return;
          if (!voiceMasterEnabled) return;
          try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
          // Si Chrome se queda pegado en background, mete un micro ciclo pause/resume
          try {
            if (document.hidden && window.speechSynthesis && window.speechSynthesis.speaking && typeof window.speechSynthesis.pause === 'function') {
              window.speechSynthesis.pause();
              window.speechSynthesis.resume();
            }
          } catch(e) {}
          // Si hay cola y no esta hablando, intenta bombear
          try {
            if (document.hidden && !speechSpeaking && window.speechSynthesis && !window.speechSynthesis.speaking) {
              if (typeof pumpSpeechQueue === 'function') pumpSpeechQueue();
            }
          } catch(e) {}
          // Recovery suave (sin vomitar backlog)
          try {
            if (document.hidden && typeof forceTtsRecover === 'function') forceTtsRecover('bg_keepalive');
          } catch(e) {}
          try { startSilentAudioKeepAlive(); } catch(e) {}
        } catch(e) {}
      }, 4000);
    }
    startBgKeepAlive();

    try {
      window.addEventListener('pageshow', () => {
        try { startBgKeepAlive(); } catch(e) {}
        try { loadRaceFromFirebase(); } catch(e) {}
        try { if (typeof startRaceRealtime === 'function') startRaceRealtime(); } catch(e) {}
      }, { passive:true });
      window.addEventListener('resume', () => {
        try { startBgKeepAlive(); } catch(e) {}
        try { loadRaceFromFirebase(); } catch(e) {}
        try { if (typeof startRaceRealtime === 'function') startRaceRealtime(); } catch(e) {}
      }, { passive:true });
    } catch(e) {}

// LIVE status (debounced) - evita parpadeo por lecturas intermitentes
let __liveApplied = null;
let __liveWanted = null;
let __liveTimer = 0;

function __applyLiveStatus(online){
  const on = !!online;
  try {
    if (liveIndicator) liveIndicator.classList.toggle('live-off', !on);
  } catch(e) {}
  try {
    if (appHeader) {
      // Importante: clases no deben cambiar layout (altura estable por CSS)
      appHeader.classList.toggle('live-on', on);
      appHeader.classList.toggle('live-off', !on);
    }
  } catch(e) {}
}

function setLiveStatus(isOnline) {
  const online = !!isOnline;
  __liveWanted = online;

  // Online: aplica inmediato. Offline: espera un poco (evita "brinco" por fallos momentaneos).
  const delay = online ? 0 : 1200;

  try { if (__liveTimer) clearTimeout(__liveTimer); } catch(e) {}
  __liveTimer = setTimeout(() => {
    __liveTimer = 0;
    const target = !!__liveWanted;
    if (__liveApplied === target) return;
    __liveApplied = target;
    __applyLiveStatus(target);
  }, delay);

  if (delay === 0) {
    try {
      // Ejecuta ya en el mismo frame para que el header no cambie despues "de golpe"
      if (__liveTimer) { clearTimeout(__liveTimer); __liveTimer = 0; }
      const target = !!__liveWanted;
      if (__liveApplied !== target){
        __liveApplied = target;
        __applyLiveStatus(target);
      }
    } catch(e) {}
  }
}
    function normalizePilotKey(key) {
      const s = (key || '').toLowerCase().trim();
      if (!s) return '';
      // Backward compatibility: older keys were "num||name"
      if (s.includes('||')) {
        const parts = s.split('||').map(x=>x.trim()).filter(Boolean);
        return (parts[parts.length-1] || '').toLowerCase().trim();
      }
      return s;
    }

    function getPilotKey(row) {
      if (!row) return '';
      const nameRaw = row.racerName != null ? String(row.racerName).trim() : '';
      return (nameRaw || '').toLowerCase().trim();
    }


    function safeRacerName(name) {
      if (!name) return '';
      let s = String(name).trim();
      // Quitar prefijos numricos tipo "26 Victor" o "#26 Victor"
      s = s.replace(/^#?\d+\s+/, '');
      // Normalizar espacios
      s = s.replace(/\s{2,}/g, ' ');
      return s;
    }

    function parseTimeToMs(input) {
      if (input == null) return 0;

      // Heurstica clave:
      // - Si viene como nmero y es "chico" (ej. 9.881, 14.564), normalmente est en segundos.
      // - Si viene grande (ej. 9881, 14564), normalmente ya est en milisegundos.
      if (typeof input === 'number') {
        const n = input;
        if (!isFinite(n) || n <= 0) return 0;
        if (n < 300) return n * 1000; // tratar como segundos
        return n;                     // tratar como ms
      }

      // Strings: a veces llegan con prefijos tipo "27L 04:05.107" o texto extra.
      let str = String(input).trim();
      if (!str) return 0;

      // 1) Si hay un patrn de tiempo, tomamos el LTIMO (lo ms probable es el tiempo real).
      //    Soporta: "m:ss.mmm", "mm:ss", "h:mm:ss.mmm"
      try {
        const matches = str.match(/(?:\d{1,2}:)?\d{1,2}:\d{2}(?:\.\d{1,3})?/g);
        if (matches && matches.length) {
          str = matches[matches.length - 1];
        }
      } catch(e) {}

      // 2) Si es entero puro, asumimos ms (ej. "14564")
      if (/^\d+$/.test(str)) return parseInt(str, 10);

      // 3) Parse con ":" (m:ss o h:mm:ss)
      const parts = str.split(':');
      if (parts.length === 2) {
        const m = parseInt(parts[0], 10);
        const s = parseFloat(parts[1]);
        if (!isNaN(m) && !isNaN(s)) return (m * 60 * 1000) + (s * 1000);
      }
      if (parts.length === 3) {
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        const s = parseFloat(parts[2]);
        if (!isNaN(h) && !isNaN(m) && !isNaN(s)) return (h * 3600 * 1000) + (m * 60 * 1000) + (s * 1000);
      }

      // 4) Nmero en string sin ":" -> puede venir en segundos ("14.564") o en ms ("3000")
      // Regla:
      // - Si es entero y >= 300, lo tratamos como milisegundos.
      // - Si es decimal o < 300, lo tratamos como segundos.
      if (/^\d+$/.test(str)) {
        const n = parseInt(str, 10);
        if (!isNaN(n)) return (n < 300) ? (n * 1000) : n;
      }
      const s = parseFloat(str);
      if (!isNaN(s)) return (s < 300) ? (s * 1000) : s;

      return 0;
    }

    function msToMinSec(ms) {
      if (!ms || isNaN(ms) || ms <= 0) return '-:--.---';
      const totalSeconds = ms / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds - minutes * 60;
      const secInt = Math.floor(seconds);
      let msRemainder = Math.floor((seconds - secInt) * 1000);
      if (!isFinite(msRemainder) || msRemainder < 0) msRemainder = 0;
      if (msRemainder > 999) msRemainder = 999;
      const secStr = String(secInt).padStart(2, '0');
      const msStr = String(msRemainder).padStart(3, '0');
      return `${minutes}:${secStr}.${msStr}`;
    }

    function formatLaps3(v){
      const n = Math.floor(Number(v));
      if (!isFinite(n) || n < 0) return '-';
      if (n > 999) return '999';
      const s = String(n);
      // Mximo 3 caracteres
      return (s.length <= 3) ? s : s.slice(-3);
    }

    // Rangos plausibles de una vuelta Turbo Racing 1/76 (evita basura tipo 0:00.010)
    const LAP_MS_MIN = 2500;   // 2.5 s (hay feeds que reportan medias vueltas)
    const LAP_MS_MAX = 90000;  // 90.0 s  // 60.0 s

    
    // Normaliza valores que a veces llegan en segundos (ej 9.339) en lugar de ms (9339)
    function normalizeIncomingLapValue(v) {
      // Acepta number o string (ej. 9.339, "9.339", "0:09.339", "9339")
      const ms = parseTimeToMs(v);
      if (!ms || !isFinite(ms) || ms <= 0) return 0;
      return Math.round(ms);
    }

function isLapPlausible(ms) {
      // Validacin para guardar historial (NO depende del rango dinmico del chart).
      // As, si alguien hace una vuelta lenta (ej. >30s por choque/reincorporacin), se registra.
      return typeof ms === 'number' && isFinite(ms) && ms >= LAP_MS_MIN && ms <= LAP_MS_MAX;
    }

    function normalizeLapMs(ms) {
      return isLapPlausible(ms) ? ms : 0;
    }

    
    // Rango dinmico (se ajusta con el historial para no "matar" la grfica con umbrales fijos)
    let lapRange = { min: LAP_MS_MIN, max: LAP_MS_MAX };

    function updateLapRangeFromHistory(timesAll) {
      if (!timesAll || timesAll.length < 6) return;
      const arr = timesAll.slice(-40).filter(v => typeof v === 'number' && isFinite(v) && v > 0).sort((a,b)=>a-b);
      if (arr.length < 6) return;
      const p90 = arr[Math.floor(arr.length * 0.90)];
      if (!p90) return;

      // Escala dinmica por sesion:
      // - MANGA: zoom un poco ms apretado (3:00, ms estable)
      // - FINAL: margen ms amplio (fatiga/errores)
      const info = currentSessionInfo || {};
      const type = String(info.type || '').toUpperCase();
      const isManga = (type === 'MANGA');
      const isFinal = (type === 'FINAL');

      // IMPORTANTE:
      // No subimos el mnimo con el histrico, porque al arranque o en re-incorporaciones
      // pueden llegar "vueltas parciales" (ej. 3.0s) y se deben registrar.
      const min = LAP_MS_MIN;

      const preset = getLapChartPreset();

      let pad = preset.pad;
      // cap por seguridad
      const maxCap = preset.maxCap;
      const max = Math.min(maxCap, p90 + pad);

      lapRange = { min, max };
    }

// Consistencia en porcentaje: % de vueltas dentro de +/- tolMs del promedio
// Ej: tolMs=200 -> +/-0.200 s
function consistencyPercent(arr, tolMs = 200) {
  // Consistencia % = 100 - (variabilidad %)
  // Variabilidad % = (sigma / media) * 100  (coeficiente de variacin)
  // Nota: arr viene en ms.
  if (!arr || arr.length < 2) return 0;
  const clean = arr.filter(v => typeof v === 'number' && isFinite(v) && v > 0);
  if (clean.length < 2) return 0;
  const mean = clean.reduce((a,b)=>a+b,0) / clean.length;
  if (!isFinite(mean) || mean <= 0) return 0;
  // sigma (ms)
  let s2 = 0;
  for (const v of clean) { const d = v - mean; s2 += d*d; }
  const sigma = Math.sqrt(s2 / clean.length);
  const variabilityPct = (sigma / mean) * 100;
  let cons = 100 - variabilityPct;
  if (!isFinite(cons)) cons = 0;
  if (cons < 0) cons = 0;
  if (cons > 100) cons = 100;
  return Math.floor(cons);
}

// Consistencia desde Firebase (ya viene calculada)
function getConsistencyFromFirebase(p) {
  if (!p) return 0;
  const candidates = [
    p.consistency,
    p.consistencyPercent,
    p.consPct,
    p.cons,
    p.consistencia,
    p.consistenciaPct,
    p.consistency_pct,
    p.consistency10,
    p.cons10,
    p.CONSISTENCY
  ];
  for (const v of candidates) {
    if (v == null) continue;
    if (typeof v === 'string') {
      const m = v.match(/(\d+(?:\.\d+)?)/);
      if (m) {
        const n = Number(m[1]);
        if (isFinite(n) && n > 0) return Math.max(0, Math.min(100, Math.floor(n)));
      }
      continue;
    }
    const n = Number(v);
    if (isFinite(n) && n > 0) return Math.max(0, Math.min(100, Math.floor(n)));
  }
  return 0;
}

function statsFromTimes(arr) {
      if (!arr || !arr.length) return { n: 0, best: 0, mean: 0, sigma: 0, last: 0 };
      const n = arr.length;
      const last = arr[n - 1] || 0;
      let best = Infinity;
      let sum = 0;
      for (const v of arr) {
        if (!isLapPlausible(v)) continue;
        if (v < best) best = v;
        sum += v;
      }

      const mean = sum / n;
      let varSum = 0;
      for (const v of arr) {
        varSum += (v - mean) * (v - mean);
      }
      const sigma = Math.sqrt(varSum / n);
      return { n, best: isFinite(best) ? best : 0, mean, sigma, last };
    }

// Devuelve el mejor "stint" consecutivo de tamao window (por promedio), y la peor vuelta.
// times debe venir en ms, ya filtrado a vueltas plausibles.
function findFastestStint(times, window=5) {
  try {
    if (!Array.isArray(times) || times.length < window) return null;
    let bestSum = Infinity;
    let bestStart = 0;
    let sum = 0;
    for (let i = 0; i < times.length; i++) {
      sum += times[i];
      if (i >= window) sum -= times[i - window];
      if (i >= window - 1) {
        if (sum < bestSum) {
          bestSum = sum;
          bestStart = i - window + 1;
        }
      }
    }
    return { start: bestStart, end: bestStart + window - 1, sum: bestSum, avg: bestSum / window };
  } catch (e) { return null; }
}

function findWorstLap(times) {
  try {
    if (!Array.isArray(times) || !times.length) return null;
    let worst = -Infinity;
    let idx = -1;
    for (let i = 0; i < times.length; i++) {
      const v = times[i];
      if (!isLapPlausible(v)) continue;
      if (v > worst) { worst = v; idx = i; }
    }
    if (idx < 0) return null;
    return { idx, ms: worst };
  } catch (e) { return null; }
}
    function ensureCanvasHiDpi(canvas) {
      if (!canvas) return;
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }

    
    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

function drawLapChartForKey(pilotKey) {
      if (!lapChartEl || !lapChartMetaEl) return;
      if (!pilotKey) {
        lapChartMetaEl.textContent = 'Sin datos';
        const ctx = lapChartEl.getContext('2d');
        if (ctx) ctx.clearRect(0, 0, lapChartEl.width, lapChartEl.height);
        return;
      }
      const hist = lapHistory.get(pilotKey) || { lastLapcount: 0, times: [] };
      const timesAllRaw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
      updateLapRangeFromHistory(timesAllRaw);
      const timesAll = timesAllRaw.filter(isLapPlausible);
      if (!timesAll.length) {
        lapChartMetaEl.textContent = 'Sin datos';
        const ctx = lapChartEl.getContext('2d');
        if (ctx) ctx.clearRect(0, 0, lapChartEl.width, lapChartEl.height);
        return;
      }
      applyLapChartPreset();
      const preset = getLapChartPreset();
      const N = preset.N;
      // Eje X por TIEMPO: acumulado desde el inicio
      let __accT = 0;
      const tAll = timesAll.map(ms => (__accT += ms));
      const times = timesAll.slice(-N);
      const tMs = tAll.slice(-N);
      const marksAll = (hist.marks || []).filter(v => (typeof v === 'string' || v == null));
      const marks = marksAll.slice(-N);
      const st = statsFromTimes(times);
      const best = st.best || 0;
      const last = st.last || 0;
      const mean = st.mean || 0;

      // Best/Worst globales (historial completo) + Fast5 (mejor bloque consecutivo)
      const bestAll = timesAll.length ? Math.min(...timesAll) : 0;
      const idxBestAll = bestAll ? timesAll.indexOf(bestAll) : -1;
      const worstInfo = findWorstLap(timesAll);
      const worstAll = worstInfo ? worstInfo.ms : 0;
      const idxWorstAll = worstInfo ? worstInfo.idx : -1;
      const fast5 = findFastestStint(timesAll, 5);

      const pNow = (raceData && Array.isArray(raceData.classification))
        ? raceData.classification.find(r => getPilotKey(r) === pilotKey)
        : null;
      const lapsNow = pNow ? (Number(pNow.lapcount) || 0) : 0;
      const consFb = getConsistencyFromFirebase(pNow);

      const lapsLabel = lapsNow ? lapsNow : timesAll.length;

      const bestTxt = (bestAll && idxBestAll >= 0) ? `${msToMinSec(bestAll)} (L${idxBestAll + 1})` : '-:--.---';
      const fastTxt = (fast5 && fast5.avg) ? `${msToMinSec(fast5.avg)} (L${fast5.start + 1}-${fast5.end + 1})` : '-:--.---';
      const worstTxt = (worstAll && idxWorstAll >= 0) ? `${msToMinSec(worstAll)} (L${idxWorstAll + 1})` : '-:--.---';

      lapChartMetaEl.textContent =
        `${lapsLabel} vueltas  Hist ${timesAll.length}  Best ${bestTxt}  Fast5 ${fastTxt}  Worst ${worstTxt}  Last ${last ? msToMinSec(last) : '-:--.---'}  Cons ${consFb ? (consFb + '%') : '-'}`;

ensureCanvasHiDpi(lapChartEl);
      const ctx = lapChartEl.getContext('2d');
      if (!ctx) return;

      const w = lapChartEl.width;
      const h = lapChartEl.height;

      ctx.clearRect(0, 0, w, h);

      // fondo suave
      ctx.fillStyle = 'rgba(2,6,23,0.45)';
      ctx.fillRect(0, 0, w, h);

      // escala
      let minV = Math.min(...times);
      let maxV = Math.max(...times);
      minV = Math.min(minV, best);
      maxV = Math.max(maxV, best);

      const pad = Math.max(400, (maxV - minV) * 0.18);
      minV = Math.max((lapRange && lapRange.min) ? lapRange.min : LAP_MS_MIN, minV - pad);
      maxV = Math.min((lapRange && lapRange.max) ? lapRange.max : LAP_MS_MAX, maxV + pad);

      const left = Math.floor(w * 0.06);
      const right = Math.floor(w * 0.03);
      const top = Math.floor(h * 0.12);
      const bottom = Math.floor(h * 0.18);
      const gw = w - left - right;
      const gh = h - top - bottom;
      // X: izquierda->derecha. Inicia desde la izquierda (lap 1 a la izquierda) y se va llenando hacia la derecha.
      // Con pocas vueltas queda espacio vaco a la derecha (intencional).
      const k = times.length;
      const xMax = getLapChartXMaxMs((tMs && tMs.length) ? tMs[tMs.length - 1] : 0);
      const xFor = (i) => {
        const ii = Math.max(0, Math.min(k - 1, i));
        const t = (tMs && tMs[ii]) ? tMs[ii] : 0;
        const frac = xMax ? Math.max(0, Math.min(1, t / xMax)) : 0;
        return left + (gw * frac);
      };

      const baseIdx = timesAll.length - times.length; // ndice global del primer punto mostrado

      // grid horizontal (4)
      ctx.strokeStyle = 'rgba(148,163,184,0.18)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = top + (gh * i / 4);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(left + gw, y);
        ctx.stroke();
      }

      // grid vertical por minutos (eje X = tiempo)
      try{
        const xMaxG = getLapChartXMaxMs((tMs && tMs.length) ? tMs[tMs.length - 1] : 0);
        const mins = Math.max(0, Math.floor(xMaxG / 60000));
        for (let m=1; m<=mins; m++){
          const frac = xMaxG ? (m*60000 / xMaxG) : 0;
          const x = left + (gw * frac);
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(148,163,184,0.10)';
          ctx.lineWidth = 1;
          ctx.moveTo(x, top);
          ctx.lineTo(x, top + gh);
          ctx.stroke();
        }
      } catch(e){}

      // lnea promedio
      if (isLapPlausible(mean)) {
        const yMean = top + (1 - (Math.min(Math.max(mean, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.strokeStyle = 'rgba(34,211,238,0.35)';
        ctx.beginPath();
        ctx.moveTo(left, yMean);
        ctx.lineTo(left + gw, yMean);
        ctx.stroke();
      }

// Highlight Fast5 (mejor bloque consecutivo de 5 vueltas) si cae dentro del rango mostrado
try {
  if (fast5 && maxV > minV && times.length > 1) {
    const startDisp = fast5.start - baseIdx;
    const endDisp = fast5.end - baseIdx;
    if (endDisp >= 0 && startDisp <= (times.length - 1)) {
      const s = Math.max(0, startDisp);
      const e = Math.min(times.length - 1, endDisp);
      const x1 = xFor(s);
      const x2 = xFor(e);
      ctx.save();
      ctx.fillStyle = 'rgba(34,197,94,0.08)';
      ctx.fillRect(Math.min(x1, x2), top, Math.abs(x2 - x1), gh);
      ctx.restore();
    }
  }
} catch(e) {}

      // lnea tiempos
      ctx.strokeStyle = 'rgba(251,146,60,0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      times.forEach((v, i) => {
        const x = xFor(i);
        const y = top + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // puntos/medias/markers (Preset A)
      // banda de ritmo (extra #2): media +- 0.20s
      const BAND_MS = 200;
      if (mean && maxV > minV) {
        const lo = Math.max(minV, mean - BAND_MS);
        const hi = Math.min(maxV, mean + BAND_MS);
        const yHi = top + (1 - (Math.min(Math.max(hi, minV), maxV) - minV) / (maxV - minV)) * gh;
        const yLo = top + (1 - (Math.min(Math.max(lo, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.save();
        ctx.fillStyle = 'rgba(226,232,240,0.06)';
        ctx.fillRect(left, yHi, gw, Math.max(0, yLo - yHi));
        ctx.restore();
      }

      // lnea de media (pace)
      if (mean && maxV > minV) {
        const yM = top + (1 - (Math.min(Math.max(mean, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.save();
        ctx.strokeStyle = 'rgba(226,232,240,0.28)';
        ctx.setLineDash([Math.max(4, Math.floor(w*0.01)), Math.max(3, Math.floor(w*0.008))]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(left, yM);
        ctx.lineTo(left + gw, yM);
        ctx.stroke();
        ctx.restore();
      }

      // puntos (Preset A): best personal (verde) / best sesin (morado) / error grande (rojo) + last por estado
      const drawDot = (x, y, fill, rMul=1.0) => {
        const r = Math.max(2, Math.floor(w * 0.005)) * rMul;
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      };

      // best sesin (Opcin B: desde clasificacin visible)
      const sessionBestMs = computeSessionBestMs ? computeSessionBestMs() : 0;

      // errores grandes (rojo): +0.8s vs media o +0.9s vs best (lo que aplique)
      const ERR_A_MS = 800;
      const ERR_B_MS = 900;

      for (let i = 0; i < times.length; i++) {
        const v = times[i];
        const x = xFor(i);
        const y = top + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;

        const bigErr = (mean && v > (mean + ERR_A_MS)) || (best && v > (best + ERR_B_MS));
        if (bigErr) drawDot(x, y, 'rgba(239,68,68,0.92)', 1.15);
      }

      // last (color por mejora)
      const iLast = times.length - 1;
      const xLast = xFor(iLast);
      const yLast = top + (1 - (Math.min(Math.max(times[iLast], minV), maxV) - minV) / (maxV - minV)) * gh;
      const prevBest = (times.length > 1) ? Math.min(...times.slice(0, -1)) : 0;
      const lastClass = classifyLapColor ? classifyLapColor(times[iLast], prevBest || best || 0, sessionBestMs) : 'lap-neutral';
      const lastFill =
        lastClass === 'lap-purple' ? 'rgba(167,139,250,0.95)' :
        lastClass === 'lap-green'  ? 'rgba(34,197,94,0.95)'  :
        lastClass === 'lap-yellow' ? 'rgba(251,191,36,0.92)' :
                                     'rgba(226,232,240,0.85)';
      drawDot(xLast, yLast, lastFill, 1.18);

      // best (ndice) - verde, pero si es best sesin -> morado
      const idxBest = times.findIndex(v => v === best);
      if (idxBest >= 0) {
        const xB = xFor(idxBest);
        const yB = top + (1 - (Math.min(Math.max(best, minV), maxV) - minV) / (maxV - minV)) * gh;
        const bestFill = 'rgba(167,139,250,0.98)';
        drawDot(xB, yB, bestFill, 1.28);
      }

      // Tags de batalla (ATK/DEF/DUEL) por vuelta
      try {
        const fontPx = Math.max(9, Math.floor(w * 0.028));
        ctx.font = `600 ${fontPx}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';

        for (let i = 0; i < marks.length && i < times.length; i++) {
          const tag = marks[i];
          if (!tag) continue;
          const x = xFor(i);
          const y = top + (1 - (Math.min(Math.max(times[i], minV), maxV) - minV) / (maxV - minV)) * gh;

          let bg = 'rgba(255,255,255,0.10)';
          let fg = 'rgba(226,232,240,0.95)';
          if (tag === 'ATK') { bg = 'rgba(255,140,0,0.22)'; fg = 'rgba(255,230,200,0.95)'; }
          if (tag === 'DEF') { bg = 'rgba(59,130,246,0.22)'; fg = 'rgba(220,235,255,0.95)'; }
          if (tag === 'DUEL'){ bg = 'rgba(255,40,40,0.22)'; fg = 'rgba(255,230,230,0.95)'; }

                    // marcador visible en la grfica
          try {
            let stroke = 'rgba(226,232,240,0.35)';
            let fill = 'rgba(226,232,240,0.70)';
            if (tag === 'ATK') { stroke = 'rgba(255,140,0,0.85)'; fill = 'rgba(255,140,0,0.70)'; }
            if (tag === 'DEF') { stroke = 'rgba(59,130,246,0.85)'; fill = 'rgba(59,130,246,0.70)'; }
            if (tag === 'DUEL'){ stroke = 'rgba(239,68,68,0.85)'; fill = 'rgba(239,68,68,0.70)'; }
            ctx.save();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, top + 2);
            ctx.stroke();
            // dot ring
            const rr = Math.max(2, Math.floor(w * 0.004));
            ctx.fillStyle = 'rgba(2,6,23,0.45)';
            ctx.beginPath();
            ctx.arc(x, y, rr + 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, rr, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          } catch(e) {}

          let stroke = 'rgba(226,232,240,0.35)';
          let fill = 'rgba(226,232,240,0.70)';
          if (tag === 'ATK') { stroke = 'rgba(255,140,0,0.85)'; fill = 'rgba(255,140,0,0.70)'; }
          if (tag === 'DEF') { stroke = 'rgba(59,130,246,0.85)'; fill = 'rgba(59,130,246,0.70)'; }
          if (tag === 'DUEL'){ stroke = 'rgba(239,68,68,0.85)'; fill = 'rgba(239,68,68,0.70)'; }

          const iconS = Math.max(6, Math.floor(fontPx * 0.72));
          const iy = y - Math.max(10, iconS); // arriba del punto
          ctx.save();
          ctx.translate(x, iy);

          ctx.fillStyle = fill;
          ctx.strokeStyle = stroke;
          ctx.lineWidth = 2;

          ctx.beginPath();
          if (tag === 'ATK') {
            // tringulo arriba (zona de ataque)
            ctx.moveTo(0, -iconS * 0.65);
            ctx.lineTo(iconS * 0.65, iconS * 0.65);
            ctx.lineTo(-iconS * 0.65, iconS * 0.65);
          } else if (tag === 'DEF') {
            // tringulo abajo (zona de defensa)
            ctx.moveTo(0, iconS * 0.65);
            ctx.lineTo(iconS * 0.65, -iconS * 0.65);
            ctx.lineTo(-iconS * 0.65, -iconS * 0.65);
          } else {
            // DUEL: rombo
            ctx.moveTo(0, -iconS * 0.8);
            ctx.lineTo(iconS * 0.8, 0);
            ctx.lineTo(0, iconS * 0.8);
            ctx.lineTo(-iconS * 0.8, 0);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          ctx.restore();}
      } catch(e) {}

// Labels BEST / WORST y FAST5 (solo si estn dentro del rango mostrado)
try {
  const labelFont = Math.max(9, Math.floor(w * 0.024));
  const drawLabel = (txt, x, y, bg, fg) => {
    ctx.save();
    ctx.font = `700 ${labelFont}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    const padX = Math.max(5, Math.floor(labelFont * 0.55));
    const padY = Math.max(3, Math.floor(labelFont * 0.35));
    const tw = ctx.measureText(txt).width;
    const bw = tw + padX * 2;
    const bh = labelFont + padY * 2;
    const bx = x - bw / 2;
    const by = y - 6;
    ctx.fillStyle = bg;
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    roundRect(ctx, bx, by - bh, bw, bh, Math.max(6, Math.floor(labelFont*0.6)));
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = fg;
    ctx.fillText(txt, x, by - padY);
    ctx.restore();
  };

  // BEST global
  if (idxBestAll >= 0) {
    const iB = idxBestAll - baseIdx;
    if (iB >= 0 && iB < times.length) {
      const x = xFor(iB);
      const y = top + (1 - (Math.min(Math.max(times[iB], minV), maxV) - minV) / (maxV - minV)) * gh;
      drawLabel('BEST', x, y, 'rgba(167,139,250,0.22)', 'rgba(245,240,255,0.98)');
    }
  }

  // WORST global (dentro del rango mostrado)
  if (idxWorstAll >= 0) {
    const iW = idxWorstAll - baseIdx;
    if (iW >= 0 && iW < times.length) {
      const x = xFor(iW);
      const y = top + (1 - (Math.min(Math.max(times[iW], minV), maxV) - minV) / (maxV - minV)) * gh;
      // dot extra para que se vea
      drawDot(x, y, 'rgba(239,68,68,0.92)', 1.25);
      drawLabel('WORST', x, y, 'rgba(239,68,68,0.18)', 'rgba(255,235,235,0.95)');
    }
  }

  // FAST5 label (centro del bloque)
  if (fast5 && times.length > 1) {
    const s = fast5.start - baseIdx;
    const e = fast5.end - baseIdx;
    if (e >= 0 && s <= (times.length - 1)) {
      const ss = Math.max(0, s);
      const ee = Math.min(times.length - 1, e);
      const xc = ((xFor(ss) + xFor(ee)) / 2);
      const yTop = top + 2;
      drawLabel('FAST5', xc, yTop + labelFont + 10, 'rgba(34,197,94,0.16)', 'rgba(220,255,235,0.95)');
    }
  }
} catch(e) {}

      }

function drawLapChartTop3Auto(){
      if (!lapChartEl || !lapChartMetaEl) return;

      const top = getTop3Rows();
      const keys = top.map(r => getPilotKey(r)).filter(Boolean);

      // Si no hay top3, limpia
      if (!keys.length){
        lapChartMetaEl.textContent = 'Sin datos';
        if (top3MiniGridEl) top3MiniGridEl.innerHTML = '';
        const ctx0 = lapChartEl.getContext('2d');
        if (ctx0) ctx0.clearRect(0,0,lapChartEl.width,lapChartEl.height);
        return;
      }

      // Render UI (chips + grid)
      try { renderAutoLapChartTop3(); } catch(e) {}
      try { renderAutoTop3MiniGrid(); } catch(e) {}

      const N = 40;
      const colors = [
        { stroke: 'rgba(251,191,36,0.95)', dot: 'rgba(251,191,36,0.98)' }, // P1 amarillo
        { stroke: 'rgba(255,255,255,0.92)', dot: 'rgba(255,255,255,0.96)' }, // P2 blanco
        { stroke: 'rgba(249,115,22,0.95)', dot: 'rgba(249,115,22,0.98)' } // P3 naranja
      ];

      // Series por piloto (alineadas a la derecha)
      const series = [];
      let allVals = [];
      for (let i=0;i<keys.length && i<3;i++){
        const k = keys[i];
        const hist = lapHistory.get(k) || { times: [] };
        const raw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
        // Construye vals + tiempo acumulado (eje X)
        let valsAll = [];
        let tAll = [];
        let acc = 0;
        for (let r=0; r<raw.length; r++){
          const v0 = normalizeLapMs(raw[r]);
          if (!isLapPlausible(v0)) continue;
          acc += v0;
          valsAll.push(v0);
          tAll.push(acc);
        }

        // Fallback: si todavia no hay historial (inicio de carrera), al menos pinta un punto con lastTime/best.
        if (!valsAll.length) {
          const row = top[i] || null;
          const last = row ? normalizeLapMs(parseTimeToMs(row.lastTime)) : 0;
          const best = row ? normalizeLapMs(parseTimeToMs(row.best)) : 0;
          const candidate = isLapPlausible(last) ? last : (isLapPlausible(best) ? best : 0);
          if (candidate) {
            valsAll = [candidate];
            tAll = [candidate];
          }
        }

        if (!valsAll.length) continue;
        const vals = valsAll.slice(-N);
        const tms = tAll.slice(-N);
        series.push({ key: k, vals, tms, color: colors[i], idx: i });
        allVals = allVals.concat(vals);
      }

      if (!series.length){
        lapChartMetaEl.textContent = 'Sin datos';
        if (top3MiniGridEl) top3MiniGridEl.innerHTML = '';
        const ctx0 = lapChartEl.getContext('2d');
        if (ctx0) ctx0.clearRect(0,0,lapChartEl.width,lapChartEl.height);
        return;
      }

      updateLapRangeFromHistory(allVals);

      ensureCanvasHiDpi(lapChartEl);
      const ctx = lapChartEl.getContext('2d');
      if (!ctx) return;

      const w = lapChartEl.width;
      const h = lapChartEl.height;
      ctx.clearRect(0,0,w,h);

      // fondo
      ctx.fillStyle = 'rgba(2,6,23,0.45)';
      ctx.fillRect(0,0,w,h);

      // escala combinada
      try { updateLapRangeFromHistory(allVals); } catch(e) {}
      let minV = Math.min(...allVals);
      let maxV = Math.max(...allVals);
      const pad = Math.max(400, (maxV - minV) * 0.18);
      minV = Math.max((lapRange && lapRange.min) ? lapRange.min : LAP_MS_MIN, minV - pad);
      maxV = Math.min((lapRange && lapRange.max) ? lapRange.max : LAP_MS_MAX, maxV + pad);

      const left = Math.floor(w * 0.06);
      const right = Math.floor(w * 0.03);
      const topPad = Math.floor(h * 0.12);
      const bottom = Math.floor(h * 0.18);
      const gw = w - left - right;
      const gh = h - topPad - bottom;

      // Eje X por TIEMPO: max por modo (3/4/6 min + fraccion)
      let __lastElapsed = 0;
      for (const ss of series){
        const tt = ss.tms || [];
        const lt = tt.length ? tt[tt.length - 1] : 0;
        if (lt > __lastElapsed) __lastElapsed = lt;
      }
      const xMax = getLapChartXMaxMs(__lastElapsed);

      // grid
      ctx.strokeStyle = 'rgba(148,163,184,0.18)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = topPad + (gh * i / 4);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(left + gw, y);
        ctx.stroke();
      }

      // grid vertical por minutos (eje X = tiempo)
      try{
        const mins = Math.max(0, Math.floor(xMax / 60000));
        for (let m=1; m<=mins; m++){
          const frac = xMax ? (m*60000 / xMax) : 0;
          const x = left + (gw * frac);
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(148,163,184,0.10)';
          ctx.lineWidth = 1;
          ctx.moveTo(x, topPad);
          ctx.lineTo(x, topPad + gh);
          ctx.stroke();
        }
      } catch(e){}

      const focusKey = (lapChartAutoKey && keys.includes(lapChartAutoKey)) ? lapChartAutoKey : keys[0];

      // dibuja series
      for (const s of series){
        const vals = s.vals;
        const len = vals.length;
        if (!len) continue;

        const isFocus = (s.key === focusKey);
        ctx.save();
        ctx.globalAlpha = isFocus ? 1.0 : 0.65;
        ctx.strokeStyle = s.color.stroke;
        ctx.lineWidth = isFocus ? 2.8 : 1.9;
        ctx.beginPath();

        for (let j=0;j<len;j++){
          const t = (s.tms && s.tms[j]) ? s.tms[j] : 0;
          const frac = xMax ? Math.max(0, Math.min(1, t / xMax)) : 0;
          const x = left + (gw * frac);
          const v = vals[j];
          const y = topPad + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;
          if (j===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();

        // dot última vuelta
        const jLast = len - 1;
        const tL = (s.tms && s.tms[jLast]) ? s.tms[jLast] : 0;
        const fracL = xMax ? Math.max(0, Math.min(1, tL / xMax)) : 0;
        const xL = left + (gw * fracL);
        const vL = vals[jLast];
        const yL = topPad + (1 - (Math.min(Math.max(vL, minV), maxV) - minV) / (maxV - minV)) * gh;
        const r = Math.max(2, Math.floor(w * 0.005)) * (isFocus ? 1.25 : 1.05);
        ctx.fillStyle = s.color.dot;
        ctx.beginPath();
        ctx.arc(xL, yL, r, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
      }

      // Meta (texto corto)
      try{
        const leader = top[0];
        const lapsLabel = leader && leader.lapcount != null ? leader.lapcount : '-';
        lapChartMetaEl.title = `Top 3 (auto) - último dibujo: P1 laps ${lapsLabel}`;
      }catch(e){}
    }

    window.addEventListener('resize', () => {
      if (selectedPilotKey) drawLapChartForKey(selectedPilotKey);
      else { try { drawLapChartTop3Auto(); } catch(e) {} }
    });

    function numeroATexto0a999(n) {
      n = Math.floor(n);
      if (Number.isNaN(n) || n < 0 || n > 999) return String(n);
      const unidades = ['cero','uno','dos','tres','cuatro','cinco','seis','siete','ocho','nueve'];
      const especiales = ['diez','once','doce','trece','catorce','quince','dieciseis','diecisiete','dieciocho','diecinueve'];
      const decenas = ['','','veinte','treinta','cuarenta','cincuenta','sesenta','setenta','ochenta','noventa'];
      const centenas = ['','cien','doscientos','trescientos','cuatrocientos','quinientos','seiscientos','setecientos','ochocientos','novecientos'];

      if (n < 10) return unidades[n];
      if (n < 20) return especiales[n - 10];
      if (n < 100) {
        const d = Math.floor(n / 10);
        const u = n % 10;
        if (n === 20) return 'veinte';
        if (n < 30) return 'veinti' + unidades[u];
        if (u === 0) return decenas[d];
        return decenas[d] + ' y ' + unidades[u];
      }
      const c = Math.floor(n / 100);
      const resto = n % 100;
      if (n === 100) return 'cien';
      let resultado = centenas[c];
      if (resto > 0) {
        resultado += ' ' + numeroATexto0a999(resto);
      }
      return resultado;
    }

    function tiempoATexto(ms) {
      if (ms == null || isNaN(ms) || ms <= 0) return '';
      const totalSeconds = ms / 1000;

      // Para anuncios largos (ej: "Total X minutos..."), mantenemos texto tradicional.
      if (totalSeconds >= 60) {
        const minutes = Math.floor(totalSeconds / 60);
        const secondsFloat = totalSeconds - minutes * 60;

        const minutesTxt = numeroATexto0a999(minutes);
        const secondsStr = toFixedFloor(secondsFloat, decimalPrecision);
        const secParts = secondsStr.split('.');
        const secIntPart = parseInt(secParts[0], 10);
        const secDecStr = (secParts[1] || '').padEnd(3, '0');
        const d1 = secDecStr[0] || '0';
        const d2 = secDecStr[1] || '0';
        const d3 = secDecStr[2] || '0';

        let secondsTxt = '';
        if (!isNaN(secIntPart)) secondsTxt += numeroATexto0a999(secIntPart);
        if (secDecStr !== '000') {
          // Aquí usamos dígitos separados para que no se coma ceros.
          secondsTxt = secondsTxt ? `${secondsTxt} punto ${d1} ${d2} ${d3}` : `cero punto ${d1} ${d2} ${d3}`;
        }
        if (!secondsTxt) secondsTxt = 'cero';

        const palabraMin = minutes === 1 ? 'minuto' : 'minutos';
        return `${minutesTxt} ${palabraMin} con ${secondsTxt} segundos`;
      }

      // ---- Lap time (lo que el piloto escucha todo el rato)
      // Regla: si la dcima es 0 (X.0xx) -> "X flat"
      // Si no, el decimal (0-999) se lee como nmero completo:
      // 9.103 -> "nueve punto ciento tres"
      // 5.546 -> "cinco punto quinientos cuarenta y seis"
      const secInt = Math.floor(ms / 1000);
      const rem = Math.max(0, ms - secInt * 1000); // 0..999
      const d1 = Math.floor(rem / 100); // dcima (0..9)

      // "flat" SOLO cuando la dcima es 0 (X.0xx), sin importar la precisin seleccionada.
      if (d1 === 0) {
        return `${secInt} flat`;
      }

      // Aplicar precisin seleccionada (1, 2 o 3 decimales) a la lectura:
      // 1 decimal  -> floor(rem/100)  (0..9)
      // 2 decimales -> floor(rem/10)   (0..99)
      // 3 decimales -> rem            (0..999)
      let decN = 0;
      if (decimalPrecision === 1) decN = Math.floor(rem / 100);
      else if (decimalPrecision === 2) decN = Math.floor(rem / 10);
      else decN = rem;

      return `${secInt} punto ${numeroATexto0a999(decN)}`;
          }

    function formatoGapVueltas(raw) {
      if (!raw) return '';
      const trimmed = raw.toString().trim();
      if (!trimmed || trimmed === '-') return '';
      // Queremos UI compacta: 1V, 2V, 3V (sin texto)
      const m = trimmed.match(/^(?:\+)?(\d+)\s*V$/i);
      if (m) {
        const n = parseInt(m[1], 10);
        if (isFinite(n) && n > 0) return String(n) + 'V';
      }
      return trimmed;
    }

    function normalizeRaceData(rawRace) {
      const result = {
        raceName: rawRace.raceName || '',
        lapCount: rawRace.lapCount || 0,
        bestLapTime: parseTimeToMs(rawRace.bestLapTime),
        classification: []
      };

      const passEvents = [];
      const prevByKey = new Map();
      if (previousClassification && Array.isArray(previousClassification)) {
        previousClassification.forEach(p => {
          prevByKey.set(getPilotKey(p), p);
        });
      }

      const nextPrev = [];

      (rawRace.classification || []).forEach(row => {
        const key = getPilotKey(row);
        const lap = Number(row.lapcount) || 0;

        let totalMs = 0;
        const timeStr = row.time != null ? String(row.time) : '';
        if (typeof row.timeMs === 'number') {
          totalMs = row.timeMs;
        } else if (timeStr) {
          totalMs = parseTimeToMs(timeStr);
        }

        // bestLap suele ser NUMERO DE VUELTA (indice), no tiempo. Usar "best"/"bestLapTime" para el tiempo.
const bestTimeRaw =
  (row.best != null ? row.best :
   (row.bestMs != null ? row.bestMs :
    (row.bestLapTime != null ? row.bestLapTime :
     (row.bestLapTimeMs != null ? row.bestLapTimeMs :
      (row.bestTime != null ? row.bestTime : 0)))));
let bestMs = parseTimeToMs(bestTimeRaw);
        // meanLap a veces se usa para otra cosa; prioriza campos de tiempo.
const meanTimeRaw =
  (row.mean != null ? row.mean :
   (row.meanMs != null ? row.meanMs :
    (row.meanLapTime != null ? row.meanLapTime :
     (row.meanLapTimeMs != null ? row.meanLapTimeMs : 0))));
let meanMs = parseTimeToMs(meanTimeRaw);
        const estMs  = parseTimeToMs(row.estTime);

        let lastMs = 0;
        const prev = prevByKey.get(key);
        if (prev) {
          const prevLaps = Number(prev.lapcount) || 0;
          if (lap > prevLaps && totalMs > prev.time) {
            lastMs = totalMs - prev.time;
            // registrar evento de paso por meta para lgica de bandera azul (último paso por piloto)
            if (!lastPassEvents || typeof lastPassEvents.set !== 'function') {
              lastPassEvents = new Map();
            }
            lastPassEvents.set(key, {
              key,
              pos: row.pos,
              name: safeRacerName(row.racerName),
              lap,
              time: totalMs
            });
          } else if (lap === prevLaps && prev.lastTime && prev.lastTime > 0) {
            lastMs = prev.lastTime;
          } else if (lap === 0) {
            lastMs = 0;
          }
        }

        lastMs = normalizeLapMs(lastMs);
        bestMs = normalizeLapMs(bestMs);
        meanMs = normalizeLapMs(meanMs);

        // Correccin de best/mean cuando vienen como nmero de vuelta u otro formato raro
        const MIN_VALID_LAP_MS = LAP_MS_MIN;
        const MAX_VALID_LAP_MS = LAP_MS_MAX;
        if (!bestMs || isNaN(bestMs) || bestMs < MIN_VALID_LAP_MS || bestMs > MAX_VALID_LAP_MS) {
          if (prev && prev.best && !isNaN(prev.best) && prev.best > 0) {
            bestMs = prev.best;
          }
          if (lastMs && lastMs > 0 && (!bestMs || lastMs < bestMs)) {
            bestMs = lastMs;
          }
        }

        if ((!meanMs || isNaN(meanMs) || meanMs < MIN_VALID_LAP_MS || meanMs > MAX_VALID_LAP_MS) && lap > 0 && totalMs > 0) {
          meanMs = totalMs / lap;
        } else if ((!meanMs || isNaN(meanMs) || meanMs <= 0) && prev && prev.mean && !isNaN(prev.mean) && prev.mean > 0) {
          meanMs = prev.mean;
        }

        const normalized = {
          pos:         row.pos,
          racerNumber: row.racerNumber,
          racerName:   safeRacerName(row.racerName),
          lapcount:    lap,
          time:        totalMs,
          timeStr:     timeStr,
          lastTime:    lastMs,
          gap:         row.gap || "",
          diff:        row.diff || "",
          best:        bestMs,
          bestLap:     row.bestLap,
          mean:        meanMs,
          estLap:      row.estLap || 0,
          estTime:     estMs,
          consistency: row.consistency
        };

        result.classification.push(normalized);
        nextPrev.push({ ...normalized });
      });

      previousClassification = nextPrev;
      return result;
    }

    let lastSpokenLastTime = null;
    let lastAnnouncedLapcount = 0;
    let lastKnownPos = null;
    let lastTotalTimeAnnouncedSeconds = 0;
    let lastGapInfoLap = 0;
    let lastBehindAlertMs = 0;

    let lastBestAnnouncedMs = null;
    let lastBestAnnouncedLap = 0;
    let lastTrendSpokenLap = 0;
    let lastAheadAlertMs = 0;
    
    // Latches para alertas <0.6 (decir solo una vez hasta que se libere)
    let behind06Latch = { active:false, otherKey:'', lap:-1 };
    let ahead06Latch  = { active:false, otherKey:'', lap:-1 };

    // Latches y estado para estrategia
    let attackLatch  = { active:false, otherKey:'', lap:-1 };
    let defenseLatch = { active:false, otherKey:'', lap:-1 };
    let fightLatch   = { active:false, lap:-1 };

    // =========================
    // DUEL / ATK / DEF (EMA + histeresis)
    // - Entra: gap suavizado <= 0.45s
    // - Sale: >= 0.65s (ATAQUE) o >= 0.60s (DEFENSA)
    // - EMA reduce jitter, sobre todo en MANGA
    // =========================
    const DUEL_ENTER_SEC = 0.45;
    const DUEL_EXIT_ATTACK_SEC = 0.65;
    const DUEL_EXIT_DEFEND_SEC = 0.60;
    const DUEL_EMA_ALPHA = 0.35;
    const duelStateByPilotKey = new Map();

    let startPosForSelected = null;
    let lastNetGainValue = null;
    let lastNetGainSpokenLap = 0;
    let lastLeaderGapSpokenLap = 0;
    let lastPodiumSpokenLap = 0;
let lastAutoSummaryAnnouncedSeconds = 0;

    // =========================
    // Modo LOCUTOR (AUTO cuando NO hay piloto seleccionado)
    // =========================
    let commentatorTop3LastLeaderLap = 0;
    let commentatorTop3LastSpokenMs = 0;
    let commentatorBattleLatch = new Map(); // pairKey -> { active, lastLeadLap }
    let commentatorGapHistory = new Map();  // pairKey -> { lastGapMs, lastTrailLap, lastSpokenTrailLap }

// Narracin con contexto (Auto Locutor) - seguimiento de una pelea para que suene hilado
let autoNarratorState = {
  focusPairKey: '',
  focusPos: 0,
  focusDefender: '',
  focusAttacker: '',
  focusSinceMs: 0,
  focusLastSec: null,
  focusStage: '',
  focusLastSpeakMs: 0,
  focusStickyUntilMs: 0,
  lastSpokenType: '',
  lastSpokenMs: 0
};

// pairKey -> { lastSec, lastSec2, lastMs, lastLap, lastMentionMs }
let autoPairState = new Map();

// MANGA (clasificacin): seguimiento de pole/best lap sin saturar
let autoQualiState = {
  bestOverallMs: null,
  bestOverallKey: '',
  lastBestSpeakMs: 0,
  lastPoleFightSpeakMs: 0
};

function resetAutoNarratorState() {
  try {
    autoNarratorState = {
      focusPairKey: '',
      focusPos: 0,
      focusDefender: '',
      focusAttacker: '',
      focusSinceMs: 0,
      focusLastSec: null,
      focusStage: '',
      focusLastSpeakMs: 0,
      focusStickyUntilMs: 0,
      lastSpokenType: '',
      lastSpokenMs: 0
    };
    if (autoPairState && typeof autoPairState.clear === 'function') autoPairState.clear();
    autoQualiState = { bestOverallMs: null, bestOverallKey: '', lastBestSpeakMs: 0, lastPoleFightSpeakMs: 0 };
  } catch(e) {}
}

    function resetAutoCommentatorState() {
      try {
        commentatorTop3LastLeaderLap = 0;
        commentatorTop3LastSpokenMs = 0;
        if (commentatorBattleLatch && typeof commentatorBattleLatch.clear === 'function') commentatorBattleLatch.clear();
        if (commentatorGapHistory && typeof commentatorGapHistory.clear === 'function') commentatorGapHistory.clear();
        if (commentatorAutoState) {
          commentatorAutoState.lastSpeakMs = 0;
          commentatorAutoState.window = [];
          if (commentatorAutoState.recentSig && typeof commentatorAutoState.recentSig.clear === 'function') commentatorAutoState.recentSig.clear();
          if (commentatorAutoState.prevPosByKey && typeof commentatorAutoState.prevPosByKey.clear === 'function') commentatorAutoState.prevPosByKey.clear();
          commentatorAutoState.prevKeyByPos = [];
          commentatorAutoState.lastLeaderKey = '';
          commentatorAutoState.lastLeaderLap = 0;
          commentatorAutoState.lastQuietMs = 0;
          commentatorAutoState.lastTop3Ms = 0;
          commentatorAutoState.lastTop3Sig = '';
          commentatorAutoState.lastMilestone = 0;
          commentatorAutoState.lastTop5Sig = '';
          commentatorAutoState.stableTop5Laps = 0;
          commentatorAutoState.lastTop5Lap = 0;
        }
        try { resetAutoNarratorState(); } catch(e) {}
      } catch(e) {}
    }

    // Historial de vueltas para consistencia
    let lapHistory = new Map();
    
    // Lap Chart marks: tags por vuelta (ATK/DEF/DUEL)
    function setLastLapMark(pilotKey, tag) {
      try {
        if (!pilotKey || !tag) return;
        const hist = lapHistory.get(pilotKey);
        if (!hist) return;
        if (!Array.isArray(hist.times)) hist.times = [];
        if (!Array.isArray(hist.marks)) hist.marks = [];
        const tlen = hist.times.length;
        if (!tlen) return;
        while (hist.marks.length < tlen) hist.marks.push(null);

        const i = tlen - 1;
        const cur = hist.marks[i];
        const pr = { DUEL: 3, ATK: 2, DEF: 2, PB: 1, ERR: 1 };
        if (!cur || (pr[tag] || 0) >= (pr[cur] || 0)) {
          hist.marks[i] = tag;
        }
        lapHistory.set(pilotKey, hist);
      } catch (e) {}
    }

// Best lap previo por piloto (para detectar mejora aunque Firebase ya actualice el best)
    let prevBestByKey = new Map();
    let lastSessionSigForBest = '';

    // Race Director: memoria anti repeticin (por laps)
    let rdLastIdLap = new Map();
    let rdLastTextLap = new Map();

    let lastConsistencySpokenLap = 0;
    let lastSpokenEstLap = null;
    let lastEstLapSpokenLap = 0;

    // Pendientes para AI Director (se anuncian post-Laps)
    let pendingPosChange = null;
    let pendingNetGain   = null;
    let pendingBestLap   = null;
    let pendingEstLap    = null;

    // eventos de paso por meta y estado de bandera azul
    let lastPassEvents = new Map();
    let pendingBlueFlagForPilotKey = '';
    let pendingBlueFlagMessage = '';
    let lastBlueFlagPilotLap = 0;
    let lastBlueWarnPilotLap = 0;
    let lastBlueFlagLeaderLap = 0;
    let lastBlueWarnLeaderLap = 0;
    let blueFlagConfirm = { pilotKey:'', leaderKey:'', lap:0, hits:0, t:0 };

    function renderPilotCard(p) {
      if (!p) {
        pilotNameEl.textContent = 'Auto Locutor';
      // En Auto Locutor, mostrar vueltas del líder
      let leaderLap = 0;
      try {
        if (raceData && Array.isArray(raceData.classification) && raceData.classification.length) {
          const leader = raceData.classification.reduce((best, r) => {
            const pos = (r && r.pos != null) ? (+r.pos || 999) : 999;
            const bpos = (best && best.pos != null) ? (+best.pos || 999) : 999;
            return (pos < bpos) ? r : best;
          }, null);
          leaderLap = (leader && leader.lapcount != null) ? leader.lapcount : ((leader && leader.laps != null) ? leader.laps : 0);
          if (!isFinite(leaderLap) || leaderLap < 0) leaderLap = 0;
        }
      } catch(e) { leaderLap = 0; }
      pilotMetaEl.textContent = String(leaderLap || 0) + ' v';
        posTextEl.textContent   = 'P -';
        gapInfoEl.textContent   = 'Diferencia líder  vueltas  estado';
        lastLapEl.textContent   = '-:--.---';
        bestLapEl.textContent   = '-:--.---';
        meanLapEl.textContent   = '-:--.---';
        if (consistencyValEl) consistencyValEl.textContent = '--%';
        if (sigmaValEl) sigmaValEl.textContent = '-.---';
        try { renderAutoLapChartTop3(); } catch(e) {}
        try { drawLapChartTop3Auto(); } catch(e) {}
        try { applyPilotSelectPosTheme(null); } catch(e) {}
        try { renderAutoTop3MiniGrid(); } catch(e) {}
        return;
      }

      pilotNameEl.textContent = safeRacerName(p.racerName) || 'Sin nombre';
      pilotMetaEl.textContent = String((p.lapcount != null ? p.lapcount : 0)) + " v";

      posTextEl.textContent = p.pos ? `P ${p.pos}` : 'P -';
      try { applyPilotSelectPosTheme(p.pos); } catch(e) {}

      const gapText = formatoGapVueltas(p.gap);
      const meanStr = p.mean ? msToMinSec(p.mean) : '-:--.---';
      const totalStr = p.time ? msToMinSec(p.time) : '-:--.---';

      const partes = [];
      if (gapText) partes.push(`Diferencia ${gapText}`);
      if (p.lapcount != null) partes.push(`${p.lapcount} vueltas`);
      if (totalStr && totalStr !== '-:--.---') partes.push(`Total ${totalStr}`);
      gapInfoEl.textContent = partes.join('  ') || 'Diferencia líder  vueltas  estado';

      const key = getPilotKey(p);
      const hist = lapHistory.get(key) || { lastLapcount: 0, times: [] };
      const timesRaw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
      updateLapRangeFromHistory(timesRaw);
      const times = timesRaw.filter(isLapPlausible);

      const computed = statsFromTimes(times);

      const consPct = getConsistencyFromFirebase(p);

      // Mostrar consistencia (feed) y  (historial lap chart)
      try {
        if (consistencyValEl) consistencyValEl.textContent = consPct ? (consPct + '%') : '--%';
      } catch(e) {}
      try {
        const sig = (computed && computed.sigma && isFinite(computed.sigma)) ? (computed.sigma / 1000) : NaN;
        if (sigmaValEl) sigmaValEl.textContent = (isFinite(sig) && sig > 0) ? sig.toFixed(3) : '-.---';
      } catch(e) {}

      const computedBest = computed.best || 0;
      const computedLast = computed.last || 0;
      const computedMean = computed.mean || 0;

      const pLast = normalizeIncomingLapValue(p.lastTime);
      const pBest = normalizeIncomingLapValue(p.best);
      const pMean = normalizeIncomingLapValue(p.mean);

      const lastMsFinal = isLapPlausible(pLast) ? pLast : computedLast;
      let bestMsFinal = isLapPlausible(pBest) ? pBest : computedBest;
      // Si ya tenemos historia confiable (pasos por meta), sala para corregir "best" raro del feed
      if (computedBest && computedBest > 0) {
        if (!bestMsFinal || bestMsFinal <= 0) {
          bestMsFinal = computedBest;
        } else {
          const lapsSeen = times.length || 0;
          // Si el best del feed es demasiado mas rapido que lo visto, es casi seguro basura
          if (lapsSeen >= 3 && bestMsFinal < (computedBest * 0.80)) {
            bestMsFinal = computedBest;
          } else if (computedBest < bestMsFinal) {
            bestMsFinal = computedBest;
          }
        }
      }
const meanMsFinal = isLapPlausible(pMean) ? pMean : computedMean;

      const lastStr = lastMsFinal ? msToMinSec(lastMsFinal) : '-:--.---';
      const bestStr = bestMsFinal ? msToMinSec(bestMsFinal) : '-:--.---';
      const meanStrFinal = meanMsFinal ? msToMinSec(meanMsFinal) : meanStr;

      lastLapEl.textContent = lastStr;
      bestLapEl.textContent = bestStr;
      meanLapEl.textContent = meanStrFinal;
      // Colores estilo cronometraje (F1)
      const sessionBestMs = computeSessionBestMs();

      // LTIMA: morado (mejor absoluto) / verde (mejor personal) / amarillo (no mejora) / neutral
      const prevBest = prevBestByKey.get(key) || 0;
      const personalRef = prevBest > 0 ? prevBest : (bestMsFinal || 0);
      const lastClass = classifyLapColor(lastMsFinal, personalRef, sessionBestMs);
      // Actualiza referencia para prxima vuelta
      if (bestMsFinal && bestMsFinal > 0) prevBestByKey.set(key, bestMsFinal);
      setLapClass(lastLapEl, lastClass);

      // MEJOR: siempre morado (y si adems es el mejor absoluto, se queda morado igual)
      if (bestMsFinal && bestMsFinal > 0) setLapClass(bestLapEl, 'lap-purple');
      else setLapClass(bestLapEl, 'lap-neutral');

      // MEDIA: color distinto (suave) cuando existe
      if (meanMsFinal && meanMsFinal > 0) setLapClass(meanLapEl, 'lap-avg');
      else setLapClass(meanLapEl, 'lap-neutral');

      // grfica vuelta por vuelta
      if (selectedPilotKey && key === selectedPilotKey) {
        drawLapChartForKey(selectedPilotKey);
      }
    }

    
    
// Cache del record de carrera (best lap global) en ms
let sessionBestCache = { ms: 0, holder: '-', key: null };

function refreshSessionBestCache() {
  try {
    const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification : [];
    let best = 0;
    let holder = '-';
    let holderKey = null;

    // 1) Fuente confiable: lo que nosotros vimos pasar por meta (delta de tiempos)
    for (const r of rows) {
      const key = getPilotKey(r);
      if (!key) continue;
      const hist = lapHistory ? lapHistory.get(key) : null;
      const ms = hist && hist.bestMs ? normalizeLapMs(hist.bestMs) : 0;
      if (!ms) continue;
      if (!best || ms < best) {
        best = ms;
        holder = safeRacerName(r.racerName) || '-';
        holderKey = key;
      }
    }

    // 2) Fallback: el "best" que manda el feed (por si abriste ya avanzada la carrera)
    if (!best) {
      for (const r of rows) {
        const raw =
          (typeof r.best !== 'undefined' ? r.best :
           (typeof r.bestMs !== 'undefined' ? r.bestMs :
            (typeof r.bestLapTime !== 'undefined' ? r.bestLapTime :
             (typeof r.bestLapTimeMs !== 'undefined' ? r.bestLapTimeMs : 0))));
        const ms = normalizeLapMs(normalizeIncomingLapValue(raw));
        if (!ms) continue;
        if (!best || ms < best) {
          best = ms;
          holder = safeRacerName(r.racerName) || '-';
          holderKey = getPilotKey(r);
        }
      }
    }

    // 3) último recurso: raceData.bestLapTime (sin dueo seguro)
    if ((!best || best <= 0) && raceData && typeof raceData.bestLapTime !== 'undefined') {
      const fb = normalizeLapMs(normalizeIncomingLapValue(raceData.bestLapTime));
      if (fb) {
        best = fb;
        holder = (holder && holder !== '-') ? holder : '-';
      }
    }

    sessionBestCache = { ms: best || 0, holder: holder || '-', holderKey: holderKey || null };
    // Aviso de record de carrera (cualquiera)
    try {
      const now = Date.now();
      const cur = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
      const hKey = (sessionBestCache && sessionBestCache.holderKey) ? sessionBestCache.holderKey : null;
      const hName = (sessionBestCache && sessionBestCache.holder) ? sessionBestCache.holder : '-';
      let hPos = null;
      try {
        if (hKey && rows && rows.length) {
          const rr = rows.find(x => (getPilotKey(x) === hKey));
          if (rr && rr.pos) hPos = rr.pos;
        }
      } catch(e) {}
      const improved = cur && ((lastGlobalBestSpokenMs === 0) || (cur < (lastGlobalBestSpokenMs - 25)));
      const newHolder = hKey && (hKey !== lastGlobalBestSpokenHolderKey);
      if (improved && (newHolder || cur < (lastGlobalBestSpokenMs - 60)) && (now - lastGlobalBestSpokenAt > 2500)) {
        lastGlobalBestSpokenMs = cur;
        lastGlobalBestSpokenHolderKey = hKey;
        lastGlobalBestSpokenAt = now;
        // Beep + voz (no interrumpe si ya va hablando)
        playBeep('up');
        enqueueSpeech(`Best lap global. ${hPos != null ? ('P ' + hPos + '. ') : ''}${hName}. ${tiempoATexto(cur)}.`, { key: 'global_best_' + cur, priority: 88, cooldownMs: 2000, dedupe: true });
        flashPilotCardGreen();
        flashMangaClock();
      }
    } catch(e) {}

  } catch (e) {
    console.error('refreshSessionBestCache', e);
    sessionBestCache = { ms: 0, holder: '-', holderKey: null };
  }
}

function updateRecordCarreraUI() {
  const lapEl = document.getElementById('bestOverallLap');
  const holderEl = document.getElementById('bestLapHolder');
  if (!lapEl || !holderEl) return;

  const best = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
  if (!best) {
    lapEl.textContent = '-:--.---';
    holderEl.textContent = '-';
    return;
  }

  lapEl.textContent = msToMinSec(best);
  holderEl.textContent = (sessionBestCache && sessionBestCache.holder) ? sessionBestCache.holder : '-';
}

function computeSessionBestMs() {
      // Usar cache (se refresca en cada tick)
      const best = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
      if (best && isFinite(best)) return best;

      // fallback: recalcula si todava no hay cache por alguna razn
      refreshSessionBestCache();
      return (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
    }

    function classifyLapColor(lastMs, personalBestMs, sessionBestMs) {
      if (!lastMs || lastMs <= 0 || !isFinite(lastMs)) return 'lap-neutral';
      // Morado: mejor absoluto (tolerancia mnima)
      if (sessionBestMs && sessionBestMs > 0 && lastMs <= (sessionBestMs + 1)) return 'lap-purple';
      // Verde: mejor su propio
      if (personalBestMs && personalBestMs > 0 && lastMs <= (personalBestMs + 1)) return 'lap-green';
      // Amarillo: no mejor
      if (personalBestMs && personalBestMs > 0) return 'lap-yellow';
      return 'lap-neutral';
    }

    function setLapClass(el, cls) {
      if (!el) return;
      el.classList.remove('lap-purple','lap-green','lap-yellow','lap-neutral','lap-avg');
      if (cls) el.classList.add(cls);
    }

    function flashLastLap() {
      lastLapEl.classList.add('flash');
      setTimeout(() => {
        lastLapEl.classList.remove('flash');
      }, 300);
    }

    

    function updatePilotOptions() {
      if (isSelectingPilot) { pendingPilotOptionsUpdate = true; return; }
      if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) { try { setPilotSelectLoading(true, 'Cargando pilotos...'); } catch(e) {} return; }
      const currentKey = selectedPilotKey;

      const signature = raceData.classification
        .map(r => getPilotKey(r) + '::' + safeRacerName(r.racerName))
        .sort()
        .join('|');

      if (signature === lastPilotOptionsSignature) {
        if (currentKey) {
          const exists = raceData.classification.some(r => getPilotKey(r) === currentKey);
          if (!exists) {
            pilotSelect.value = '';
            selectedPilotKey = '';
          } else {
            pilotSelect.value = currentKey;
          }
        } else {
          pilotSelect.value = '';
        }
        return;
      }

      lastPilotOptionsSignature = signature;

      const options = [];
      options.push({ value: '', label: 'Sin piloto seleccionado' });

      raceData.classification.forEach(row => {
        const key = getPilotKey(row);
        const name = safeRacerName(row.racerName) || '(sin nombre)';
        const label = name;
        options.push({ value: key, label });
      });

      try { localStorage.setItem('aiSpotterPilotOptionsCache', JSON.stringify({ ts: Date.now(), raceName: String((raceData && raceData.raceName) || ''), options })); } catch(e) {}
      try { setPilotSelectLoading(false); } catch(e) {}

      pilotSelect.innerHTML = '';
      options.forEach(optData => {
        const opt = document.createElement('option');
        opt.value = optData.value;
        opt.textContent = optData.label;
        pilotSelect.appendChild(opt);
      });

      if (currentKey) {
        const exists = raceData.classification.some(r => getPilotKey(r) === currentKey);
        if (exists) {
          pilotSelect.value = currentKey;
          selectedPilotKey = currentKey;
        } else {
          pilotSelect.value = '';
          selectedPilotKey = '';
        }
      } else {
        pilotSelect.value = '';
      }
    }

    pilotSelect.addEventListener('focus', () => {
      isSelectingPilot = true;
    });
    pilotSelect.addEventListener('blur', () => {
      isSelectingPilot = false;
      if (pendingPilotOptionsUpdate) {
        pendingPilotOptionsUpdate = false;
        setTimeout(() => { try { updatePilotOptions(); } catch(e) {} }, 0);
      }
    });

        function resetSelectedPilotTrackingState() {
      // NO detener el reloj de MANGA aqu: el cronmetro es por piloto y debe persistir al cambiar seleccin.
      lastSpokenLastTime = null;
          lastAnnouncedLapcount = 0;
          lastKnownPos = null;
          lastTotalTimeAnnouncedSeconds = 0;
          lastBestAnnouncedMs = null;
          lastBestAnnouncedLap = 0;
          lastTrendSpokenLap = 0;
          lastAheadAlertMs = 0;
          lastAutoSummaryAnnouncedSeconds = 0;

          attackLatch  = { active:false, otherKey:'', lap:-1 };
          defenseLatch = { active:false, otherKey:'', lap:-1 };
          fightLatch   = { active:false, lap:-1 };
          startPosForSelected = null;
          lastNetGainValue = null;
          lastNetGainSpokenLap = 0;
          lastLeaderGapSpokenLap = 0;
          lastPodiumSpokenLap = 0;
        }

        function ensurePilotOptionExists(key) {
          if (!pilotSelect || !key) return;
          for (let i = 0; i < pilotSelect.options.length; i++) {
            if (pilotSelect.options[i].value === key) return;
          }
          let label = key;
          try {
            if (raceData && Array.isArray(raceData.classification)) {
              const p = raceData.classification.find(r => getPilotKey(r) === key);
              if (p) {
                const name = safeRacerName(p.racerName) || '(sin nombre)';
                label = name;
              }
            }
          } catch(e) {}
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = label;
          pilotSelect.appendChild(opt);
        }

        
        // =========================
        // Persistencia: uúltimo piloto seleccionado
        // - Guarda y restaura automaticamente la uúltima seleccion (por dispositivo)
        // - Si el piloto no existe en la carrera actual, no selecciona nada
        // =========================
        function restoreLastPilotSelectionIfNeeded() {
          try {
            if (selectedPilotKey) return;
            const saved = normalizePilotKey(localStorage.getItem('aiSpotterLastPilotKey') || '');
            if (!saved) return;
            if (!raceData || !raceData.classification || !raceData.classification.length) return;
            const exists = raceData.classification.some(r => getPilotKey(r) === saved);
            if (!exists) return;
            // Asegura que el option exista en el select antes de seleccionar
            if (typeof ensurePilotOptionExists === 'function') ensurePilotOptionExists(saved);
            selectPilotByKey(saved, { announce:false, source:'restore' });
          } catch(e) {}
        }



function showToast(msg, ms=1400){
  try{
    const el = document.getElementById('toast');
    if(!el) return;
    el.textContent = String(msg||'');
    el.classList.add('on');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>{ try{el.classList.remove('on');}catch(e){} }, ms);
  }catch(e){}
}

function selectPilotByKey(key, opts = {}) {
          const k = normalizePilotKey(key || '');
          const announce = (opts.announce !== false);

          selectedPilotKey = k;
          try { localStorage.setItem('aiSpotterLastPilotKey', k || ''); } catch(e) {}
          selectedPilotFirstDetectBeeped = !!firstDetectBeepedByPilot.get(k);
          pendingAutoVoiceUnlock = false; // solo se activa cuando el TTS se bloquea

          if (pilotSelect) {
            if (k) ensurePilotOptionExists(k);
            pilotSelect.value = k || '';
          }

          resetSelectedPilotTrackingState();

          if (k) {
            // Auto-activar voz al elegir piloto (siempre visible)
            try { setVoiceMaster(true, { silent:true }); } catch(e) {}

            // MANGA: NO inicia reloj al seleccionar (solo muestra UI)
            try { onPilotSelectedManga(k); } catch(e) {}

            // iOS/Chrome: intentar unlock inmediato dentro del gesto de seleccin
            try {
              if (isIOSWebKit && isIOSWebKit()) {
                if (unlockTTSOnce('pilot-select')) {
                  try { voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
                  pendingAutoVoiceUnlock = false;
                } else {
                  try { voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
                  scheduleOneTapUnlock();
                }
              }
            } catch(e) {}
          } else {
            // Modo locutor: sin piloto seleccionado
            try { resetAutoCommentatorState();
        if (announce){
          try { showToast('AUTO LOCUTOR activo', { tone: 'info' }); } catch(e) {}
          try { if (voiceMasterEnabled) speakText('Auto locutor activado'); } catch(e) {}
        } } catch(e) {}

            // UI/voz: avisar que estas en Auto Locutor
            try {
              if ((opts && opts.source === 'select') || (opts && opts.source === 'restore')) {
                showToast('Auto Locutor activo');
                if (announce && voiceMasterEnabled) {
                  speakText('Auto locutor activado');
                }
              }
            } catch(e) {}
          }

          // AI Spotter: en cuanto cambia la seleccin, recalcula perfil (Seguimiento vs Auto)
          try { applySmartProfile(currentSessionInfo, 'pilot-select'); } catch(e) {}
          try { _updateBasicBtnUI(); } catch(e) {}

          if (!raceData || !k) {
            renderPilotCard(null);
        try { renderAutoTop3MiniGrid(); } catch(e) {}
        try { checkSessionFinishOnLap(); } catch(e) {}
            return;
          }
          const p = raceData.classification.find(r => getPilotKey(r) === k);
          renderPilotCard(p || null);
          try { renderAutoTop3MiniGrid(); } catch(e) {}
          if (p && p.pos && p.pos > 0) { startPosForSelected = p.pos; lastNetGainValue = 0; }
          if (announce && p && voiceMasterEnabled) {
            speakText('Siguiendo a ' + safeRacerName(p.racerName));
          }
        }

        

// MANGA: NO inicia el reloj al seleccionar.
// El reloj por piloto inicia en su 1er cruce por meta (lapcount pasa de 0 -> 1).
function onPilotSelectedManga(pilotKey) {
  try {
    const pk = (pilotKey || '').toLowerCase().trim();
    if (!pk) return;

    // Asegura session info actual
    try {
      if (raceData && raceData.raceName) {
        currentSessionInfo = parseSessionFromRaceName(raceData.raceName);
       try { applyLapChartPreset(); } catch(e) {}
try { maybeAutoApplySessionPreset(currentSessionInfo); } catch(e) {}
      }
    } catch(e) {}

    const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
    if (!isManga) return;

    // Solo UI: mostrar reloj, pero NO definir inicio aqu
    setMangaClockVisible(true);
    updateMangaClockDisplay();

    // Si ya arranc por cruce (ej. seleccionas tarde), enciende ticker
    if (mangaPilotStartAt.get(pk)) {
      ensureMangaClockTicker();
    }
  } catch(e) {}
}

pilotSelect.addEventListener('change', () => {
          selectPilotByKey(pilotSelect.value || '', { source:'select', announce:true });
        });

        pilotSelect.addEventListener('input', () => {
          // iOS a veces dispara input antes de change
          selectPilotByKey(pilotSelect.value || '', { source:'select', announce:false });
        });

    function findPilotIndexByKey(key) {
      if (!raceData || !Array.isArray(raceData.classification)) return -1;
      return raceData.classification.findIndex(r => getPilotKey(r) === key);
    }

    // =========================
    // GAP lapDiff guard (anti "1 vuelta" fantasma)
    // - Solo hablamos de diferencia de vueltas si se repite estable en 2 lecturas
    // =========================
    const lapDiffSpeakGuard = new Map();
    function lapDiffGuardAllow(pairKey, lapDiff) {
      try {
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const st = lapDiffSpeakGuard.get(pairKey) || { last: null, count: 0, firstMs: 0 };
        if (st.last !== lapDiff) {
          st.last = lapDiff;
          st.count = 1;
          st.firstMs = now;
          lapDiffSpeakGuard.set(pairKey, st);
          return false;
        }
        st.count = (st.count || 0) + 1;
        lapDiffSpeakGuard.set(pairKey, st);
        if (st.count >= 2) return true;
        if ((now - (st.firstMs || 0)) >= 1200) return true;
        return false;
      } catch(e) {
        return false;
      }
    }

    function buildGapSummaryForPilotIndex(idx) {
      if (!raceData || !Array.isArray(raceData.classification)) return null;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length) return null;

      const me = arr[idx];
      const ahead = idx > 0 ? arr[idx - 1] : null;
      const behind = idx < arr.length - 1 ? arr[idx + 1] : null;

      function diffTexto(me, other, direction) {
        if (!me || !other || me.time == null || other.time == null) return null;

        const meLaps = (me.lapcount != null) ? me.lapcount : 0;
        const otherLaps = (other.lapcount != null) ? other.lapcount : 0;
        const lapDiff = meLaps - otherLaps;

        // Si hay diferencia de vueltas, dilo como "ms una vuelta" (sin nombres).
        if (lapDiff !== 0) {

          // Guard: evitar glitches de lapcount en lecturas pegadas

          const expectedOk = (direction === 'ahead') ? (lapDiff <= 0) : (lapDiff >= 0);

          if (!expectedOk) {

            // Inconsistente: tratamos como mismo giro y seguimos con segundos

          } else {

            const meKey = getPilotKey(me) || (me.racerName || 'me');

            const otherKey = getPilotKey(other) || (other.racerName || 'other');

            const pairKey = meKey + '|' + otherKey + '|' + direction;

            if (!lapDiffGuardAllow(pairKey, lapDiff)) return null;

            const v = Math.abs(lapDiff);

            const palabra = (v === 1) ? 'una vuelta' : (v + ' vueltas');

            if (direction === 'ahead') return 'Gap con ' + (other.racerName || 'adelante') + ' ms ' + palabra;

            return 'Gap con ' + (other.racerName || 'atrs') + ' ms ' + palabra;

          }
        }
        const diffMs = Math.abs(me.time - other.time);
        if (!diffMs || diffMs <= 0) {
          if (direction === 'ahead') return 'Diferencia adelante pegados';
          return 'Diferencia atrs pegados';
        }

        const secStr = gapToSpeech((diffMs / 1000), 'pilotgaps');
        if (direction === 'ahead') return 'Gap con ' + (other.racerName || 'adelante') + ' ' + secStr;
        return 'Gap con ' + (other.racerName || 'atrs') + ' ' + secStr;
      }

      const parts = [];
      if (ahead) {
        const t = diffTexto(me, ahead, 'ahead');
        if (t) parts.push(t);
      }
      if (behind) {
        const t = diffTexto(me, behind, 'behind');
        if (t) parts.push(t);
      }
      if (!parts.length) return null;
      return parts.join('. ');
    }

    function getFrontBackContext(idx) {
      if (!raceData || !Array.isArray(raceData.classification)) return null;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length) return null;

      const me = arr[idx];
      const ahead = idx > 0 ? arr[idx - 1] : null;
      const behind = idx < arr.length - 1 ? arr[idx + 1] : null;

      const meLaps = (me && me.lapcount != null) ? Number(me.lapcount) || 0 : 0;

      const wordToNum = (w) => {
        const map = { 'una':1,'un':1,'uno':1,'dos':2,'tres':3,'cuatro':4,'cinco':5,'seis':6,'siete':7,'ocho':8,'nueve':9,'diez':10 };
        return map[w] || NaN;
      };

      const parseDiff = (raw) => {
        try{
          const s0 = String(raw || '').trim();
          if (!s0 || s0 === '-' || s0 === '') return { sec: null, laps: null };
          const mV = s0.match(/([+-]?\s*\d+)\s*v/i);
          if (mV){
            const n = parseInt(String(mV[1]).replace(/\s+/g,''),10);
            if (isFinite(n)) return { sec: null, laps: Math.abs(n) };
          }
          const s = s0.toLowerCase();
          const mMas = s.match(/m[a]s\s+(\d+|una|un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s+vueltas?/i);
          if (mMas){
            const tok = mMas[1];
            const n = /^\d+$/.test(tok) ? parseInt(tok,10) : wordToNum(tok);
            if (isFinite(n) && n > 0) return { sec: null, laps: n };
          }
          if (s0.includes(':')){
            const parts = s0.split(':');
            if (parts.length >= 2){
              const mm = parseFloat(parts[0].replace(/[^0-9.]/g,''));
              const sec = parseFloat(parts.slice(1).join(':').replace(/[^0-9.]/g,''));
              if (isFinite(mm) && isFinite(sec)) return { sec: Math.abs((mm*60)+sec), laps: null };
            }
          }
          const f = parseFloat(s0.replace(/[^0-9.+-]/g,''));
          if (isFinite(f)) return { sec: Math.abs(f), laps: null };
          return { sec: null, laps: null };
        }catch(e){
          return { sec: null, laps: null };
        }
      };

      let frontSec = null, backSec = null;
      let frontKey = '', backKey = '';
      let frontName = '', backName = '';
      let sameFrontLap = false, sameBackLap = false;

      if (ahead && me) {
        const meDiff = (me.diff != null ? me.diff : (me.interval != null ? me.interval : ''));
        const info = parseDiff(formatoGapVueltas(meDiff) || meDiff);
        const aLaps = (ahead.lapcount != null) ? Number(ahead.lapcount) || 0 : 0;

        if (info.laps != null) {
          sameFrontLap = false;
          frontSec = null;
        } else if (info.sec != null && isFinite(info.sec)) {
          sameFrontLap = true;
          frontSec = info.sec;
        } else {
          sameFrontLap = (aLaps === meLaps && meLaps > 0);
          if (sameFrontLap && me.time != null && ahead.time != null) {
            const diffMs = Number(me.time) - Number(ahead.time);
            if (diffMs && diffMs > 0) frontSec = diffMs / 1000;
          }
        }
        frontKey = getPilotKey(ahead) || ahead._id || ahead.racerName || String(idx - 1);
        frontName = ahead.racerName || '';
      }

      if (behind && me) {
        const bDiff = (behind.diff != null ? behind.diff : (behind.interval != null ? behind.interval : ''));
        const infoB = parseDiff(formatoGapVueltas(bDiff) || bDiff);
        const bLaps = (behind.lapcount != null) ? Number(behind.lapcount) || 0 : 0;

        if (infoB.laps != null) {
          sameBackLap = false;
          backSec = null;
        } else if (infoB.sec != null && isFinite(infoB.sec)) {
          sameBackLap = true;
          backSec = infoB.sec;
        } else {
          sameBackLap = (bLaps === meLaps && meLaps > 0);
          if (sameBackLap && me.time != null && behind.time != null) {
            const diffMs = Number(behind.time) - Number(me.time);
            if (diffMs && diffMs > 0) backSec = diffMs / 1000;
          }
        }
        backKey = getPilotKey(behind) || behind._id || behind.racerName || String(idx + 1);
        backName = behind.racerName || '';
      }

      // DUEL (EMA + histeresis)
      const meKey = getPilotKey(me) || (me && (me._id || me.racerName)) || String(idx);
      let st = duelStateByPilotKey.get(meKey);
      if (!st) st = { frontEma:null, backEma:null, active:false, kind:'' };
      const ema = (prev, x) => (prev == null || !isFinite(prev)) ? x : (DUEL_EMA_ALPHA * x + (1 - DUEL_EMA_ALPHA) * prev);

      let frontSecEma = null;
      let backSecEma  = null;

      if (sameFrontLap && frontSec != null && isFinite(frontSec)) {
        st.frontEma = ema(st.frontEma, frontSec);
        frontSecEma = st.frontEma;
      } else {
        st.frontEma = null;
      }

      if (sameBackLap && backSec != null && isFinite(backSec)) {
        st.backEma = ema(st.backEma, backSec);
        backSecEma = st.backEma;
      } else {
        st.backEma = null;
      }

      let preferred = '';
      let duelSec = null;
      if (frontSecEma != null && backSecEma != null) {
        preferred = (frontSecEma <= backSecEma) ? 'ATTACK' : 'DEFEND';
        duelSec = Math.min(frontSecEma, backSecEma);
      } else if (frontSecEma != null) {
        preferred = 'ATTACK';
        duelSec = frontSecEma;
      } else if (backSecEma != null) {
        preferred = 'DEFEND';
        duelSec = backSecEma;
      }

      // Histeresis
      if (st.active) {
        if (st.kind === 'ATTACK') {
          if (!sameFrontLap || frontSecEma == null || frontSecEma >= DUEL_EXIT_ATTACK_SEC) st.active = false;
        } else if (st.kind === 'DEFEND') {
          if (!sameBackLap || backSecEma == null || backSecEma >= DUEL_EXIT_DEFEND_SEC) st.active = false;
        } else {
          if (duelSec == null || duelSec >= 0.70) st.active = false;
        }
      }

      if (!st.active) {
        if (preferred === 'ATTACK' && frontSecEma != null && sameFrontLap && frontSecEma <= DUEL_ENTER_SEC) {
          st.active = true;
          st.kind = 'ATTACK';
        } else if (preferred === 'DEFEND' && backSecEma != null && sameBackLap && backSecEma <= DUEL_ENTER_SEC) {
          st.active = true;
          st.kind = 'DEFEND';
        } else {
          st.kind = preferred || st.kind || '';
        }
      } else {
        // Permite cambio de rol solo si la diferencia es clara (evita flip-flop)
        if (preferred && preferred !== st.kind && frontSecEma != null && backSecEma != null) {
          if (Math.abs(frontSecEma - backSecEma) >= 0.12) st.kind = preferred;
        } else if (preferred && preferred !== st.kind && (frontSecEma == null || backSecEma == null)) {
          st.kind = preferred;
        }
      }

      duelStateByPilotKey.set(meKey, st);

      const duelActive = !!st.active;
      const duelKind = duelActive ? st.kind : (preferred || '');
      const duelGapSec = duelActive ? (duelKind === 'ATTACK' ? frontSecEma : (duelKind === 'DEFEND' ? backSecEma : duelSec)) : duelSec;

      return {
        me, ahead, behind,
        meLaps,
        frontSec, backSec,
        frontSecEma, backSecEma,
        duelActive, duelKind, duelGapSec,
        frontKey, backKey,
        frontName, backName,
        sameFrontLap, sameBackLap
      };
    }

    function checkBehindAlertForPilotIndex(idx) {

      if (!raceData || !Array.isArray(raceData.classification)) return;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length - 1) return;

      const me = arr[idx];
      const behind = arr[idx + 1];
      if (!me || !behind || !me.time || !behind.time) return;

      const meLaps = me.lapcount != null ? me.lapcount : 0;
      const behindLaps = behind.lapcount != null ? behind.lapcount : 0;

      // Si estn en distinta vuelta, liberamos latch (y no avisamos)
      if (meLaps !== behindLaps) {
        behind06Latch.active = false;
        return;
      }

      const diffMs = behind.time - me.time;
      if (!diffMs || diffMs <= 0) return;

      const sec = diffMs / 1000;

      // Histeresis: solo rearmamos cuando se libera bien el gap
      const otherKey = behind._id || behind.racerName || String(idx + 1);

      if (behind06Latch.active) {
        // Si cambia el rival o cambia la vuelta o ya se liber el gap, se rearma
        if (behind06Latch.otherKey !== otherKey || sec >= 0.80) {
          behind06Latch.active = false;
        } else {
          return; // sigue activo: NO repetir
        }
      }

      if (sec >= 0.6) return;

      const secStr = toFixedFloor(sec, decimalPrecision);
      const nombreDetras = behind.racerName || '';
      if (nombreDetras) {
        speakWithLaps(meLaps, 'Cuidado, ' + nombreDetras + ' viene atrs a ' + secStr + ' segundos', { key: 'back06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      } else {
        speakWithLaps(meLaps, 'Cuidado, traes un piloto atrs a ' + secStr + ' segundos', { key: 'back06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      }

      behind06Latch.active = true;
      behind06Latch.otherKey = otherKey;
      behind06Latch.lap = meLaps;

      const ahora = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      lastBehindAlertMs = ahora;
    }
    function checkAheadAlertForPilotIndex(idx) {

      if (!raceData || !Array.isArray(raceData.classification)) return;
      const arr = raceData.classification;
      if (idx <= 0 || idx >= arr.length) return;

      const me = arr[idx];
      const ahead = arr[idx - 1];
      if (!me || !ahead || !me.time || !ahead.time) return;

      const meLaps = me.lapcount != null ? me.lapcount : 0;
      const aheadLaps = ahead.lapcount != null ? ahead.lapcount : 0;

      if (meLaps !== aheadLaps) {
        ahead06Latch.active = false;
        return;
      }

      const diffMs = me.time - ahead.time;
      if (!diffMs || diffMs <= 0) return;

      const sec = diffMs / 1000;
      const otherKey = ahead._id || ahead.racerName || String(idx - 1);

      if (ahead06Latch.active) {
        if (ahead06Latch.otherKey !== otherKey || sec >= 0.80) {
          ahead06Latch.active = false;
        } else {
          return;
        }
      }

      if (sec >= 0.6) return;

      const secStr = toFixedFloor(sec, decimalPrecision);
      const nombreAdelante = ahead.racerName || '';
      if (nombreAdelante) {
        speakWithLaps(meLaps, 'Lo traes a tiro. ' + nombreAdelante + ' adelante a ' + secStr + ' segundos', { key: 'front06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      } else {
        speakWithLaps(meLaps, 'Lo traes a tiro. Adelante a ' + secStr + ' segundos', { key: 'front06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      }

      ahead06Latch.active = true;
      ahead06Latch.otherKey = otherKey;
      ahead06Latch.lap = meLaps;

      const ahora = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      lastAheadAlertMs = ahora;
      }

function updateBlueFlagFromPassEvents() {
      try {
        if (!raceData || !Array.isArray(raceData.classification) || !selectedPilotKey) return;
        if (!lastPassEvents || typeof lastPassEvents.get !== 'function') return;
        if (typeof voiceSettings !== 'undefined' && voiceSettings && voiceSettings.blueflag === false) return;

        // Bandera azul por proximidad real de cruce (0.8s fijo) + considera P1/P2/P3 cuando lapean.
        // Se dispara solo cuando el lapeador (Top3) pasa MUY cerca por meta DESPUES del rezagado
        // y ya trae al menos +1 vuelta (lapDiff>=1). Evita falsos por el salto a "+1" cuando estan lejos.
        const BLUE_PROX_MS = 800;
        const sessionType = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
        const isFinal = (sessionType === 'FINAL');

        const arr = raceData.classification.slice().filter(r => r && (r.pos != null));
        if (!arr.length) return;
        arr.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));

        const top3 = arr.filter(r => {
          const p = Number(r.pos)||999;
          return p >= 1 && p <= 3;
        }).slice(0,3);
        if (!top3.length) return;

        const selEvent = lastPassEvents.get(selectedPilotKey);
        if (!selEvent || !isFinite(selEvent.time)) return;

        const selLap = Number(selEvent.lap) || 0;
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

        let best = null;
        for (const laper of top3) {
          if (!laper) continue;
          const lk = getPilotKey(laper);
          if (!lk) continue;
          const le = lastPassEvents.get(lk);
          if (!le || !isFinite(le.time)) continue;
          if (le.time <= selEvent.time) continue; // laper paso antes o igual, no viene detras

          const delta = le.time - selEvent.time;
          if (delta <= 0 || delta > BLUE_PROX_MS) continue;

          const laperLap = Number(le.lap) || 0;
          const lapDiff = laperLap - selLap;
          if (lapDiff < 1) continue; // no hay lapeo confirmado

          if (!best || delta < best.delta) {
            best = { laper, lk, le, delta, laperLap, lapDiff };
          }
        }
        if (!best) return;

        // Confirmacion anti-jitter (2 hits cercanos con mismo par y misma vuelta del rezagado)
        const samePair = (blueFlagConfirm.pilotKey === selectedPilotKey && blueFlagConfirm.leaderKey === best.lk && blueFlagConfirm.lap === selLap);
        if (samePair && (now - (blueFlagConfirm.t || 0)) <= 2600) {
          blueFlagConfirm.hits = (blueFlagConfirm.hits || 0) + 1;
          blueFlagConfirm.t = now;
        } else {
          blueFlagConfirm = { pilotKey: selectedPilotKey, leaderKey: best.lk, lap: selLap, hits: 1, t: now };
        }
        if ((blueFlagConfirm.hits || 0) < 2) return;

        // Cooldowns: una vez cada 2 vueltas del lapeador y no repetir en la misma vuelta del rezagado
        if (selLap && selLap <= lastBlueFlagPilotLap) { blueFlagConfirm.hits = 0; return; }
        if (best.laperLap && (best.laperLap - lastBlueFlagLeaderLap) < 2) { blueFlagConfirm.hits = 0; return; }
        const laperPos = Number(best.laper.pos) || 0;
        const laperName = (best.laper && (best.laper.racerName || best.laper.name || best.laper.pilotName)) || '';
        const laperNameClean = String(laperName).replace(/\s+/g,' ').trim();
        if (!laperNameClean) return;
        const who = (laperPos === 1) ? ('el líder P1 ' + laperNameClean) : ('P' + laperPos + ' ' + laperNameClean);

        pendingBlueFlagForPilotKey = selectedPilotKey;
        pendingBlueFlagMessage = isFinal
          ? ('Bandera azul! Detrs viene ' + who + '. Mantn tu lnea y djalo pasar en la recta')
          : ('Bandera azul. Detrs viene ' + who + '. Mantn tu lnea y djalo pasar en la recta');

        lastBlueFlagPilotLap = selLap || lastBlueFlagPilotLap;
        lastBlueFlagLeaderLap = best.laperLap || lastBlueFlagLeaderLap;
        blueFlagConfirm.hits = 0;

      } catch (e) {
        console.error('Error en updateBlueFlagFromPassEvents', e);
      }
    }

    function updateLapHistoryAll() {
      try {
        if (!raceData || !Array.isArray(raceData.classification)) return;

        for (const p of raceData.classification) {
          const key = getPilotKey(p);
          if (!key) continue;

          const lapsNow = Number(p.lapcount) || 0;

          // Tiempo total del piloto (string "02:01.964" o ms/seg)
          const totalNowMs = parseTimeToMs(
            (typeof p.time !== 'undefined' ? p.time :
             (typeof p.totalTime !== 'undefined' ? p.totalTime :
              (typeof p.totalMs !== 'undefined' ? p.totalMs :
               (typeof p.totalTimeMs !== 'undefined' ? p.totalTimeMs :
                (typeof p.estTime !== 'undefined' ? p.estTime : 0)))))
          );

          let hist = lapHistory.get(key);
          if (!hist) hist = { lastLapcount: 0, lastTotalLapMs: 0, times: [], marks: [], bestMs: 0 };

          // Reset por re-arranque / cambio de heat sin cambiar raceName (o data rara)
          if (lapsNow < (hist.lastLapcount || 0)) {
            hist.lastLapcount = lapsNow;
            hist.lastTotalLapMs = (totalNowMs && isFinite(totalNowMs) && totalNowMs > 0) ? totalNowMs : 0;
            hist.times = [];
            hist.marks = [];
            hist.bestMs = 0;
            lapHistory.set(key, hist);
            continue;
          }

          // Nueva(s) vuelta(s)
          if (lapsNow > (hist.lastLapcount || 0)) {
            const diffLaps = lapsNow - (hist.lastLapcount || 0);

            const lastTimeMs = normalizeLapMs(parseTimeToMs(
              (typeof p.lastTime !== 'undefined' ? p.lastTime :
               (typeof p.lastLap !== 'undefined' ? p.lastLap :
                (typeof p.lastLapMs !== 'undefined' ? p.lastLapMs : 0)))
            ));

            const pushLap = (ms) => {
              if (!ms) return;
              hist.times.push(ms);
              if (!hist.marks) hist.marks = [];
              hist.marks.push(null);
              while (hist.times.length > 180) hist.times.shift();
              while (hist.marks.length > 180) hist.marks.shift();
              if (!hist.bestMs || ms < hist.bestMs) hist.bestMs = ms;
            };

            let didPush = false;

            // 1) Prioridad: lastTime del feed (mejor para Lap Chart y marcas)
            if (lastTimeMs && isFinite(lastTimeMs) && lastTimeMs > 0) {
              const pushN = Math.min(Math.max(1, diffLaps), 6);
              for (let i = 0; i < pushN; i++) pushLap(lastTimeMs);
              didPush = true;
            }

            // 2) Fallback: delta de tiempo total distribuido (si el feed brinc y no trae lastTime confiable)
            if (!didPush && hist.lastTotalLapMs && totalNowMs && isFinite(totalNowMs) && totalNowMs > hist.lastTotalLapMs) {
              const deltaMs = totalNowMs - hist.lastTotalLapMs;
              const nLaps = Math.max(1, diffLaps);
              const avgLapMs = normalizeLapMs(Math.round(deltaMs / nLaps));
              if (avgLapMs) {
                const pushN = Math.min(nLaps, 6);
                for (let i = 0; i < pushN; i++) pushLap(avgLapMs);
              }
            }

            hist.lastLapcount = lapsNow;
          }

          // Siempre actualiza el total para el siguiente delta (aunque no haya nueva vuelta)
          if (typeof totalNowMs === 'number' && isFinite(totalNowMs) && totalNowMs > 0) {
            hist.lastTotalLapMs = totalNowMs;
          }

          lapHistory.set(key, hist);
        }
      } catch (e) {
        console.error('updateLapHistoryAll', e);
      }
    }

    // =========================
    // LOCUTOR AUTO (cuando NO hay piloto seleccionado)
    // Objetivo:
    // - Decidir QUE vale la pena decir (scoring)
    // - Decirlo con variedad (frases)
    // - No saturar (rate limit + dedupe)
    // =========================

    const commentatorAutoCfg = {
      // Calma por defecto: el Auto Locutor solo debe hablar cuando hay "accin real"
      // (cambios de posición, líder, peleas cerradas, best lap/pole en mangas).
      minIntervalMs: 11000,
      windowMs: 60000,
      maxMsgsInWindow: 3,
      sigDefaultCooldownMs: 24000,
      top3CooldownMs: 38000,
      allowUrgentOverLimitScore: 9.0,
      baseThresholdScore: 4.6,
      quietMinMs: 30000,// C: mini resumen 30-40s,
      quietMaxMs: 40000
    };

    let commentatorAutoState = {
      lastSpeakMs: 0,
      window: [],
      recentSig: new Map(),
      prevPosByKey: new Map(),
      prevKeyByPos: [],
      lastLeaderKey: '',
      lastLeaderLap: 0,
      lastQuietMs: 0,
      lastTop3Ms: 0,
      lastTop3Sig: '',
      lastMilestone: 0,
      nextQuietCooldownMs: 0,
      lastTop5Sig: '',
      stableTop5Laps: 0,
      lastTop5Lap: 0
    };

    function autoGapTextFromLapDiff(lapDiff) {
      if (!lapDiff || lapDiff <= 0) return '';
      // Voz compacta: 'a 1V', 'a 2V'
      return 'a ' + String(lapDiff) + 'V';
    }

    function autoPairKey(aKey, bKey) {
      return String(aKey || '') + '::' + String(bKey || '');
    }

    function clamp01(x) {
      if (!isFinite(x)) return 0;
      if (x < 0) return 0;
      if (x > 1) return 1;
      return x;
    }

    
// Auto Locutor: shuffle bag anti repeticin (evita "me dijo eso hace 2 segundos")
const autoPhraseBag = new Map();

function autoShuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
  }
  return arr;
}

function autoRandPick(list, key) {
  try {
    if (!Array.isArray(list) || !list.length) return null;
    const k = String(key || 'auto');
    let st = autoPhraseBag.get(k);
    if (!st || !Array.isArray(st.bag) || st.srcLen !== list.length) {
      st = { bag: [], recent: [], srcLen: list.length };
    }

    const RECENT_N = Math.min(5, Math.max(2, Math.floor(list.length / 4)));

    if (!st.bag.length) {
      const idxs = [];
      for (let i = 0; i < list.length; i++) idxs.push(i);
      autoShuffleInPlace(idxs);

      if (st.recent && st.recent.length && list.length > (st.recent.length + 2)) {
        const rec = new Set(st.recent);
        const a = idxs.filter(i => !rec.has(i));
        const b = idxs.filter(i =>  rec.has(i));
        st.bag = a.concat(b);
      } else {
        st.bag = idxs;
      }
    }

    const pickIdx = st.bag.shift();
    st.recent = st.recent || [];
    st.recent.push(pickIdx);
    while (st.recent.length > RECENT_N) st.recent.shift();
    autoPhraseBag.set(k, st);

    return list[pickIdx % list.length];
  } catch(e) { return null; }
}

    function autoFmtSec(sec) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      return String(toFixedFloor(s, decimalPrecision));
    }

    // ========================================================
    // GAP SPEECH (TV style): frases condicionales por rangos
    // - < 1s: dcimas y frases tipo "a menos de tres dcimas"
    // - >= 1s: segundos con "a", "a menos de", "a ms de" y buckets de 0.5s
    // ========================================================
    function gapNumWord(n) {
      const m = {
        0:'cero',1:'uno',2:'dos',3:'tres',4:'cuatro',5:'cinco',6:'seis',7:'siete',8:'ocho',9:'nueve',
        10:'diez',11:'once',12:'doce',13:'trece',14:'catorce',15:'quince',16:'dieciseis',17:'diecisiete',18:'dieciocho',19:'diecinueve',
        20:'veinte',21:'veintiuno',22:'veintidos',23:'veintitres',24:'veinticuatro',25:'veinticinco',
        30:'treinta',35:'treinta y cinco',40:'cuarenta',45:'cuarenta y cinco',50:'cincuenta',55:'cincuenta y cinco',60:'sesenta'
      };
      const k = Number(n);
      return m[k] || String(k);
    }

    function gapHalfLabel(base) {
      const b = Number(base);
      if (!isFinite(b) || b <= 0) return '';
      const whole = Math.floor(b + 1e-9);
      const isHalf = Math.abs(b - (whole + 0.5)) < 1e-6;

      // 1.x es especial
      if (whole === 1 && !isHalf) return 'un segundo';
      if (whole === 1 && isHalf) return 'un segundo y medio';

      // 2.x: "dos segundos" / "dos y medio"
      if (whole === 2 && !isHalf) return 'dos segundos';
      if (whole === 2 && isHalf) return 'dos y medio';

      // 3+ : "tres segundos" / "tres y medio"
      const w = gapNumWord(whole);
      return isHalf ? (w + ' y medio') : (w + ' segundos');
    }

    function gapSmallSpeech(sec, bagKey) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      const key = String(bagKey || 'gap') + ':<1:' + Math.floor(s * 100);

      const pick = (arr) => {
        const v = autoRandPick(arr, key);
        return String(v || '').trim();
      };

      if (s < 0.12) {
        return pick(['a nada', 'a menos de una dcima', 'pegadsimo, a nada']);
      }
      if (s < 0.25) {
        return pick(['a menos de dos dcimas', 'a poco ms de una dcima', 'a dos dcimas']);
      }
      if (s < 0.35) {
        return pick(['a menos de tres dcimas', 'a tres dcimas', 'a unas tres dcimas']);
      }
      if (s < 0.45) {
        return pick(['a menos de cinco dcimas', 'a cuatro dcimas', 'a menos de medio segundo']);
      }
      if (s < 0.55) {
        return pick(['a medio segundo', 'a cinco dcimas', 'a medio segundo cerrado']);
      }
      if (s < 0.75) {
        return pick(['a menos de ocho dcimas', 'a siete dcimas', 'a menos de un segundo']);
      }
      return pick(['a menos de un segundo', 'a menos de un segundo clavado', 'a un segundo menos']);
    }

    function gapLargeSpeech(sec) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      // buckets de 5s para no aburrir
      const b = Math.max(10, Math.floor(s / 5) * 5);
      const w = gapNumWord(b);
      return 'a ms de ' + w + ' segundos';
    }

    function gapToSpeech(sec, bagKey) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      if (s < 1) return gapSmallSpeech(s, bagKey);
      if (s >= 10) return gapLargeSpeech(s);

      const bucket = Math.round(s * 2) / 2; // 0.5s
      const label = gapHalfLabel(bucket);
      if (!label) return '';
      const eps = 0.08;

      if (Math.abs(s - bucket) <= eps) return 'a ' + label;
      if (s < (bucket - eps)) return 'a menos de ' + label;
      return 'a ms de ' + label;
    }

    function gapToSpeechBare(sec, bagKey) {
      const s = gapToSpeech(sec, bagKey);
      if (!s) return '';
      const ss = String(s).trim();
      // Si empieza con "a ", quitamos solo ese prefijo para evitar "a a ..."
      if (ss.toLowerCase().startsWith('a ')) return ss.slice(2).trim();
      return ss;
    }

    function gapDeltaSpeech(deltaSec) {
      const d = Number(deltaSec);
      if (!isFinite(d) || d <= 0) return '';
      // delta se dice sin "a"
      if (d < 0.15) return 'una dcima';
      if (d < 0.35) return 'un par de dcimas';
      if (d < 0.60) return 'medio segundo';
      const bucket = Math.round(d * 2) / 2;
      return gapHalfLabel(bucket) || '';
    }

    function autoRaceProgress(leaderLap) {
      const total = Number(raceData && raceData.lapCount);
      if (!isFinite(total) || total <= 0) return 0;
      const lap = Number(leaderLap) || 0;
      return clamp01(lap / total);
    }

    function autoPruneWindow(now) {
      const w = commentatorAutoState.window || [];
      const keep = [];
      for (const t of w) {
        if (now - t <= commentatorAutoCfg.windowMs) keep.push(t);
      }
      commentatorAutoState.window = keep;
      return keep.length;
    }

    function autoSigOk(sig, cooldownMs, now) {
      try {
        if (!sig) return true;
        const cd = Number(cooldownMs || 0) || commentatorAutoCfg.sigDefaultCooldownMs;
        const last = commentatorAutoState.recentSig.get(sig) || 0;
        return (now - last) >= cd;
      } catch(e) { return true; }
    }

    function autoMarkSig(sig, now) {
      try {
        if (!sig) return;
        commentatorAutoState.recentSig.set(sig, now);
      } catch(e) {}
    }

    function autoCanSpeak(score, sig, sigCooldownMs, now) {
      try {
        const winCount = autoPruneWindow(now);
        const since = now - (commentatorAutoState.lastSpeakMs || 0);

        // dedupe por firma
        if (!autoSigOk(sig, sigCooldownMs, now)) return false;

        // anti metralleta
        if (since < commentatorAutoCfg.minIntervalMs && score < commentatorAutoCfg.allowUrgentOverLimitScore) return false;

        // ventana
        if (winCount >= commentatorAutoCfg.maxMsgsInWindow && score < commentatorAutoCfg.allowUrgentOverLimitScore) return false;

        // umbral dinamico (si ya hablaste mucho, sube la barra)
        let threshold = commentatorAutoCfg.baseThresholdScore;
        threshold += Math.max(0, winCount - 1) * 0.8;
        if (since < 11000) threshold += 0.6;

        return score >= threshold;
      } catch(e) {
        return false;
      }
    }

// =========================
// Auto Locutor - Narracin con contexto (focus battle)
// =========================

function autoStageFromSec(sec) {
  const s = Number(sec);
  if (!isFinite(s) || s <= 0) return '';
  if (s <= 0.32) return 'strike';
  if (s <= 0.50) return 'attack';
  if (s <= 0.80) return 'pressure';
  if (s <= 1.25) return 'closing';
  return 'loose';
}

function autoRememberPair(pairKey, sec, leaderLap, now) {
  try {
    if (!pairKey) return { prevSec:null, deltaSec:0, rate:0, lastMentionMs:0 };
    const st = autoPairState.get(pairKey) || { lastSec:null, lastSec2:null, lastMs:0, lastLap:0, lastMentionMs:0 };
    const prev = (st.lastSec != null) ? Number(st.lastSec) : null;
    const prev2 = (st.lastSec2 != null) ? Number(st.lastSec2) : null;
    st.lastSec2 = prev;
    st.lastSec = Number(sec);
    st.lastMs = now;
    st.lastLap = Number(leaderLap) || st.lastLap || 0;

    const deltaSec = (prev != null && isFinite(prev)) ? (Number(sec) - prev) : 0;
    // rate aprox: cambio por tick (negativo = cerrando)
    const rate = (prev2 != null && isFinite(prev2)) ? (Number(sec) - prev2) : deltaSec;

    autoPairState.set(pairKey, st);
    return { prevSec: prev, deltaSec, rate, lastMentionMs: st.lastMentionMs || 0 };
  } catch(e) {
    return { prevSec:null, deltaSec:0, rate:0, lastMentionMs:0 };
  }
}

function autoMarkPairMention(pairKey, now) {
  try {
    if (!pairKey) return;
    const st = autoPairState.get(pairKey) || { lastSec:null, lastSec2:null, lastMs:0, lastLap:0, lastMentionMs:0 };
    st.lastMentionMs = now;
    autoPairState.set(pairKey, st);
  } catch(e) {}
}

function autoFocusMsg(stage, c, style) {
  const st = String(stage || '');
  const pos = c.pos;
  const a = c.attacker;
  const d = c.defender;
  const sec = c.sec;
  const delta = c.deltaStr || '';
  const fromSec = c.fromSec || '';
  const toSec = c.toSec || '';
  const ctx = { pos, attacker: a, defender: d, sec, delta, fromSec, toSec };

  // Conectores para hilar (menos robot, mas TV)
  const connectors = {
    pro: [
      'Ojo con esto.',
      'Atencion aquí.',
      'Se calienta la cosa.',
      'Dato clave.',
      'Esto se mueve.',
      'Importante.',
      'Tenemos tema.'
    ],
    picante: [
      'Se prendio.',
      'Uy.',
      'Ahi viene.',
      'Huele a pase.',
      'Ahora si.',
      'Aguas.',
      'Esto va a tronar.'
    ],
    engineer: [
      'Telemetria rapida.',
      'Lectura de ritmo.',
      'Numero mata chisme.',
      'Datos en corto.',
      'Aquíi hay delta.',
      'Lo que importa.'
    ],
    narrativo: [
      'Seguimos con la historia.',
      'Mientras tanto...',
      'En el radar...',
      'Y ojo, porque...',
      'La pelea sigue viva.',
      'Sin soltar el volante...',
      'Atencion, que esto cambia.',
      'Del otro lado...'
    ]
  };

  const s = (style === 'picante' || style === 'engineer' || style === 'narrativo') ? style : 'pro';
  const c0 = autoRandPick(connectors[s] || connectors.pro, 'auto:conn:' + s);

  const BANK = {
    keep: [
      (x) => `${c0} ${x.defender} aguanta en P${x.pos}. ${x.attacker} sigue pegado a ${x.sec}.`,
      (x) => `${c0} La pelea por P${x.pos} no se suelta: ${x.attacker} a ${x.sec} de ${x.defender}.`,
      (x) => `${c0} P${x.pos}: ${x.defender} adelante, ${x.attacker} atras. Gap ${x.sec}.`,
      (x) => `${c0} P${x.pos} esta en modo espejo: ${x.attacker} no lo suelta a ${x.defender}.`
    ],
    closing: [
      (x) => `${c0} Se esta cerrando P${x.pos}: ${x.attacker} recorta ${x.delta} y ya esta a ${x.toSec || x.sec} de ${x.defender}.`,
      (x) => `${c0} P${x.pos} se aprieta: de ${x.fromSec} baja a ${x.toSec}. ${x.attacker} viene encima.`,
      (x) => `${c0} P${x.pos}: ${x.attacker} acorta el gap. ${x.defender} ya lo trae en el espejo a ${x.toSec || x.sec}.`,
      (x) => `${c0} P${x.pos} se esta cocinando. ${x.attacker} viene recortando y ya esta a ${x.toSec || x.sec}.`
    ],
    opening: [
      (x) => `${c0} Se abre un poco la pelea en P${x.pos}. ${x.defender} estira a ${x.sec}.`,
      (x) => `${c0} Respiro para ${x.defender}: P${x.pos} se va a ${x.sec}.`,
      (x) => `${c0} P${x.pos} afloja tantito. ${x.attacker} pierde el contacto, gap ${x.sec}.`
    ],
    pass: [
      (x) => `${c0} Cambio de mando en P${x.pos}. ${x.attacker} le quita la posicion a ${x.defender}.`,
      (x) => `${c0} Pase hecho en P${x.pos}. ${x.attacker} se mete por delante de ${x.defender}.`,
      (x) => `${c0} P${x.pos} ya cambio. ${x.attacker} adelante, ${x.defender} a perseguir.`
    ]
  };

  const pool = BANK[st] || BANK.keep;
  return autoRandPick(pool, 'auto:focus:' + st + ':' + s)(ctx);
}

function autoBuildStoryCandidate(args) {
  try {
    const { battles, now, leaderLap, progress, isMangaSess } = args;
    if (!battles || !battles.length) return null;

    // 1) si hay foco vigente, intentamos seguirlo
    const stickyOk = (autoNarratorState.focusPairKey && now < (autoNarratorState.focusStickyUntilMs || 0));
    const focusPair = autoNarratorState.focusPairKey || '';
    let focus = null;

    if (focusPair) {
      focus = battles.find(b => b && b.pairKey === focusPair) || null;
      // si ya no existe o se abri demasiado, lo soltamos
      if (!focus || !isFinite(focus.secNum) || focus.secNum > 1.60) {
        autoNarratorState.focusPairKey = '';
        autoNarratorState.focusStage = '';
        focus = null;
      }
    }

    // 2) si no hay foco, elegimos uno (podio y cierres pesan ms)
    if (!focus) {
      let best = null;
      let bestScore = -1e9;
      for (const b of battles) {
        if (!b || !isFinite(b.score)) continue;
        const mentionedMs = (b.lastMentionMs || 0);
        const penalty = (now - mentionedMs < 14000) ? 1.2 : 0;
        const s = b.score - penalty;
        if (s > bestScore) { bestScore = s; best = b; }
      }
      if (!best) return null;

      autoNarratorState.focusPairKey = best.pairKey;
      autoNarratorState.focusPos = best.pos;
      autoNarratorState.focusDefender = best.defender;
      autoNarratorState.focusAttacker = best.attacker;
      autoNarratorState.focusSinceMs = now;
      autoNarratorState.focusLastSec = best.secNum;
      autoNarratorState.focusStage = 'intro';
      autoNarratorState.focusStickyUntilMs = now + 28000; // 18s de hilo antes de cambiar (si sigue viva)
      focus = best;
    }

    if (!focus) return null;

    // 3) construir update segn tendencia
    const sec = Number(focus.secNum);
    const prev = (autoNarratorState.focusLastSec != null) ? Number(autoNarratorState.focusLastSec) : null;
    const stageNow = autoStageFromSec(sec);
    const stagePrev = String(autoNarratorState.focusStage || '');

    const delta = (prev != null && isFinite(prev)) ? (sec - prev) : 0;
    const absDelta = Math.abs(delta);

    // decidir si hablar: cambio real o etapa nueva o pas mucho
    const sinceSpeak = now - (autoNarratorState.focusLastSpeakMs || 0);
    const stageChanged = (stageNow && stageNow !== stagePrev && stagePrev !== 'intro');

    if (sinceSpeak < 15000 && !stageChanged && absDelta < 0.12) return null;

    let stage = stageNow || 'closing';
    if (stagePrev === 'intro') stage = 'closing';

    // si se abri, usar "opening"
    if (prev != null && isFinite(prev) && delta > 0.09) stage = 'opening';

    const secStr = gapToSpeechBare(sec, 'focus');
    const deltaStr = (prev != null && isFinite(prev)) ? gapDeltaSpeech(Math.abs(delta)) : '';
    const style = (autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || autoCommentatorMode === 'narrativo') ? autoCommentatorMode : 'pro';

    const fromSec = (prev != null && isFinite(prev)) ? gapToSpeechBare(prev, 'focus') : '';
    const toSec = secStr;

    const text = autoFocusMsg((stagePrev === '' ? 'intro' : stage), {
      pos: focus.pos,
      attacker: focus.attacker,
      defender: focus.defender,
      sec: secStr,
      secNum: sec,
      deltaStr,
      fromSec,
      toSec
    }, style);

    // score: focus manda pero no todo el tiempo
    let score = 6.4;
    score += clamp01((1.20 - sec) / 1.20) * 2.2;
    if (focus.pos <= 3) score += 1.4;
    if (focus.pos === 1) score += 0.8;
    if (progress > 0.80 && focus.pos <= 5) score += 0.6;

    // manga: menos frecuencia
    if (isMangaSess) score -= 0.7;

    const sig = 'auto:story:' + focus.pairKey + ':' + stage;
    const key = 'auto_story_' + focus.pairKey;

    return {
      type: 'story',
      score,
      text,
      key,
      sig,
      sigCooldownMs: isMangaSess ? 24000 : 20000,
      priority: 5,
      onCommit: () => {
        autoNarratorState.focusLastSpeakMs = now;
        autoNarratorState.focusLastSec = sec;
        autoNarratorState.focusStage = stage;
        autoNarratorState.lastSpokenType = 'story';
        autoNarratorState.lastSpokenMs = now;
        autoMarkPairMention(focus.pairKey, now);
      }
    };
  } catch(e) {
    return null;
  }
}

    const AUTO_PHRASES_PRO = {
      leaderChange: [
        (c) => 'Cambio de líder. ' + c.winner + ' toma P1. ' + c.loser + ' queda P2.',
        (c) => 'Cambio de líder: ' + c.winner + ' se pone al frente. ' + c.loser + ' a perseguir.',
        (c) => 'Nueva punta. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => c.winner + ' recupera la punta. ' + c.loser + ' baja a segundo.',
        (c) => 'Intercambio en P1. ' + c.winner + ' adelante. ' + c.loser + ' segundo.',
        (c) => 'Se mueve la cabeza: ' + c.winner + ' manda. ' + c.loser + ' responde en P2.',
        (c) => 'Liderato para ' + c.winner + '. ' + c.loser + ' pierde P1.',
        (c) => 'Punta nueva: ' + c.winner + '. ' + c.loser + ' se queda a rueda.',
        (c) => 'Swap en la punta. ' + c.winner + ' P1, ' + c.loser + ' P2.',
        (c) => 'Cambio arriba. ' + c.winner + ' primero. ' + c.loser + ' segundo.',
        (c) => 'Golpe de autoridad: ' + c.winner + ' toma P1. ' + c.loser + ' a reorganizar.',
        (c) => 'Actualizacion punta: ' + c.winner + ' lidera. ' + c.loser + ' queda P2.'
      ],

      pass: [
        (c) => 'Rebase confirmado. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => c.winner + ' ejecuta el pase y asegura P' + c.newPos + '. ' + c.loser + ' baja a P' + c.oldPos + '.',
        (c) => 'Cambio de posición. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' queda P' + c.oldPos + '.',
        (c) => 'Movimiento limpio: ' + c.winner + ' por delante. Ahora P' + c.newPos + '.',
        (c) => 'Pase hecho. ' + c.winner + ' gana el lugar en P' + c.newPos + '.',
        (c) => 'Rebase con calma. ' + c.winner + ' se instala en P' + c.newPos + '.',
        (c) => 'Posición ganada: ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' pierde el sitio.',
        (c) => 'Se concreta el intercambio. ' + c.winner + ' arriba a P' + c.newPos + '.',
        (c) => 'Adelantamiento al conteo. ' + c.winner + ' sube. ' + c.loser + ' baja.',
        (c) => 'P' + c.newPos + ' cambia de manos. ' + c.winner + ' toma la plaza.',
        (c) => 'Buen pase. ' + c.winner + ' ya esta delante de ' + c.loser + '. P' + c.newPos + '.',
        (c) => 'Rebase cerrado: ' + c.winner + ' gana P' + c.newPos + ', ' + c.loser + ' a P' + c.oldPos + '.'
      ],

      battle: [
        (c) => 'Duelo en P' + c.pos + '. ' + c.attacker + ' a rueda de ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en pelea. ' + c.attacker + ' presiona a ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Ojo P' + c.pos + '. ' + c.attacker + ' trae el ataque. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' caliente. ' + c.defender + ' defiende, ' + c.attacker + ' insiste. ' + c.sec + '.',
        (c) => 'Rango de pase en P' + c.pos + '. ' + c.attacker + ' pegado. ' + c.sec + '.',
        (c) => 'Camara a P' + c.pos + '. ' + c.attacker + ' en el espejo de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Separacion minima en P' + c.pos + ': ' + c.sec + '. ' + c.attacker + ' encima.',
        (c) => 'P' + c.pos + ' sin aire. ' + c.attacker + ' no se despega. ' + c.sec + '.',
        (c) => 'Atencion P' + c.pos + '. ' + c.attacker + ' busca hueco con ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en mano a mano. ' + c.attacker + ' contra ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Duelo directo. P' + c.pos + ' con gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' bajo fuego. ' + c.attacker + ' viene encima. ' + c.sec + '.'
      ],

      battlePodium: [
        (c) => 'Podio en juego en P' + c.pos + '. ' + c.attacker + ' presiona. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por trofeo. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Zona de podio. ' + c.defender + ' defiende. ' + c.attacker + ' insiste. ' + c.sec + '.',
        (c) => 'Podio apretado. Gap ' + c.sec + '. ' + c.attacker + ' con opcion.',
        (c) => 'Pelea de podio: ' + c.attacker + ' a tiro de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por podio con gap ' + c.sec + '. Esto puede cambiar.',
        (c) => 'Ojo al podio. ' + c.attacker + ' trae ritmo sobre ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Trofeo en la mira. ' + c.attacker + ' ya lo trae. ' + c.sec + '.',
        (c) => 'Podio sin margen. ' + c.sec + '. ' + c.defender + ' aguantando.',
        (c) => 'P' + c.pos + ' de podio: ' + c.attacker + ' en espejo. ' + c.sec + '.',
        (c) => 'Batalla por el podio. ' + c.attacker + ' quiere P' + c.pos + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por podio. Ventana de pase abierta. ' + c.sec + '.'
      ],

      // closing = cierre de gap (trend)
      closing: [
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Recorte en P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + '.',
        (c) => 'Gap en P' + c.pos + ' cae: ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se acerca en P' + c.pos + '. ' + c.attacker + ' ya esta a ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Tendencia positiva P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + '.',
        (c) => 'Ojo P' + c.pos + '. ' + c.attacker + ' recorta ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre confirmado. P' + c.pos + ' ahora ' + c.toSec + '.',
        (c) => 'Se aprieta P' + c.pos + '. ' + c.attacker + ' trae el gap en ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se esta cerrando. ' + c.toSec + ' entre ellos.',
        (c) => 'Recorte constante. P' + c.pos + ' de ' + c.fromSec + ' a ' + c.toSec + '.'
      ],

      gap: [
        (c) => 'Gap P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Separacion P' + c.pos + ': ' + c.sec + 's. ' + c.defender + ' adelante.',
        (c) => 'P' + c.pos + ' entre ' + c.defender + ' y ' + c.attacker + ': ' + c.sec + 's.',
        (c) => 'Distancia P' + c.pos + '. ' + c.attacker + ' marca ' + c.sec + 's.',
        (c) => 'Gap estable en P' + c.pos + ': ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con ' + c.sec + 's de diferencia.',
        (c) => 'Referencia P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'Tiempo entre autos P' + c.pos + ': ' + c.sec + 's.',
        (c) => 'Brecha P' + c.pos + ': ' + c.sec + 's.',
        (c) => 'Gap P' + c.pos + ' = ' + c.sec + 's.'
      ],

      pressure: [
        (c) => 'Presin en P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' defendiendo. ' + c.defender + ' con ' + c.attacker + ' pegado.',
        (c) => 'Ataque en P' + c.pos + '. ' + c.attacker + ' con opcion.',
        (c) => 'P' + c.pos + ' sin margen. ' + c.attacker + ' lo trae.',
        (c) => 'Defensa activa en P' + c.pos + '. ' + c.defender + ' aguanta.',
        (c) => 'P' + c.pos + ' bajo presin. Ojo en la siguiente curva.',
        (c) => 'P' + c.pos + ' en modo espejo. ' + c.attacker + ' no suelta.',
        (c) => 'Sombra en P' + c.pos + '. ' + c.attacker + ' pegado.',
        (c) => 'P' + c.pos + ' con ataque constante de ' + c.attacker + '.',
        (c) => 'Presin sostenida en P' + c.pos + '. No hay respiro.'
      ],

      top3: [
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Arriba van: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Punta y podio: ' + c.p1 + ' lidera, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Tabla de punta: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Frente de carrera: ' + c.p1 + ' al frente. ' + c.p2 + ' y ' + c.p3 + ' atrs.',
        (c) => 'Orden actual: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Podio provisional: ' + c.p1 + ' / ' + c.p2 + ' / ' + c.p3 + '.',
        (c) => 'Lder ' + c.p1 + '. Segundo ' + c.p2 + '. Tercero ' + c.p3 + '.',
        (c) => 'P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'As va el Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'En la punta: ' + c.p1 + ' lidera. Detras ' + c.p2 + ' y ' + c.p3 + '.'
      ],

      train: [
        (c) => 'Paquete P2 a P4. ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. Nadie regala.',
        (c) => 'Tren por el podio. ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. Error y se voltean.',
        (c) => 'Grupo compacto. ' + c.p2 + ' adelante, ' + c.p3 + ' y ' + c.p4 + ' pegados.',
        (c) => 'P2 a P4 en fila: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. Ventana de pase.',
        (c) => 'Tres autos en paquete. P2 a P4 muy cerrados.',
        (c) => 'P2 a P4 sin aire. ' + c.p2 + ' con ' + c.p3 + ' encima y ' + c.p4 + ' esperando.',
        (c) => 'Cluster por el podio. Nadie parpadee.',
        (c) => 'Paquete apretado P2 a P4. Cualquier curva cambia todo.',
        (c) => 'Tren formado. P2 a P4 en rango. Precision.',
        (c) => 'P2 a P4 en modo acordeon. Se viene el swap.',
        (c) => 'Grupo P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. Alto riesgo.',
        (c) => 'Paquete por P2-P4. No hay espacio para fallar.'
      ],

      record: [
        (c) => 'Best lap. ' + c.pilot + ' marca ' + c.best + '.',
        (c) => 'Nueva mejor vuelta para ' + c.pilot + ': ' + c.best + '.',
        (c) => 'Referencia de ritmo: ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Se apunta best lap. ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Mejor vuelta del stint: ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Tiempo top para ' + c.pilot + ': ' + c.best + '.',
        (c) => 'Best lap registrado: ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Ritmo fuerte. ' + c.pilot + ' clava ' + c.best + '.',
        (c) => 'Mejor vuelta. ' + c.pilot + ' firma ' + c.best + '.',
        (c) => 'Se actualiza best lap: ' + c.pilot + ' ' + c.best + '.'
      ],

      qualiBest: [
        (c) => 'En clasificacin, ' + c.pilot + ' marca ' + c.best + '.',
        (c) => 'Tiempo fuerte en quali: ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Clasificación: ' + c.pilot + ' mejora con ' + c.best + '.',
        (c) => 'Queda el registro. ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Buen intento. ' + c.pilot + ' suelta ' + c.best + '.',
        (c) => 'Clasificación se mueve. ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Queda la vuelta. ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Queda el tiempo: ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Ojo ese ritmo. ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Clasificación al detalle. ' + c.pilot + ' marca ' + c.best + '.'
      ]
    };


    const AUTO_PHRASES_PICANTE = {
      leaderChange: [
        (c) => 'Cambio de líder. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Cambio de líder. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Cambio de líder. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Cambio de líder. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Cambio de líder. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Cambio de líder. ' + c.winner + ' al frente. ' + c.loser + ' con presin encima.',
        (c) => 'Cambio de líder. ' + c.loser + ' pierde la punta. ' + c.winner + ' líder.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Nuevo jefe en pista. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' al frente. ' + c.loser + ' con presin encima.',
        (c) => 'Nuevo jefe en pista. ' + c.loser + ' pierde la punta. ' + c.winner + ' líder.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Se volte la tortilla. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' al frente. ' + c.loser + ' con presin encima.',
        (c) => 'Se volte la tortilla. ' + c.loser + ' pierde la punta. ' + c.winner + ' líder.',
        (c) => 'Golpe en la punta. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Golpe en la punta. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Golpe en la punta. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Golpe en la punta. P1 ' + c.winner + '. P2 ' + c.loser + '.'
      ],
      pass: [
        (c) => 'Rebase con colmillo. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Rebase con colmillo. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Se la cobra. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Puesto robado. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.'
      ],
      battle: [
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.'
      ],
      battlePodium: [
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' ya se asom. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' ya se asom. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' ya se asom. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' ya se asom. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' ya se asom. ' + c.sec + '.'
      ],
      closing: [
        (c) => 'Se est cerrando P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se est cerrando P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est encima.',
        (c) => 'Se est cerrando P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Se est cerrando P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se est cerrando P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Se est cerrando P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est encima.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' se cocina. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' ya está ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'Atencin en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Atencin en P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est encima.',
        (c) => 'Atencin en P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Atencin en P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Atencin en P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Atencin en P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est encima.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' en recorte serio. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.'
      ],
      top3: [
        (c) => 'Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Top 3: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Top 3: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Arriba va as: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Arriba va as: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Arriba va as: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Arriba va as: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Arriba va as: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Los de la punta: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Los de la punta: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Los de la punta: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Los de la punta: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Los de la punta: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Podio provisional: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Podio provisional: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Podio provisional: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Podio provisional: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Podio provisional: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'As est el frente: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'As est el frente: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'As est el frente: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'As est el frente: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'As est el frente: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.'
      ],
      train: [
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Aquí nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Aquí nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Aquí nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Aquí nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Pista chica, orgullo grande.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Aquí nadie respira.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Esto se decide en una curva.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Pista chica, orgullo grande.'
      ]
    };

// ====== EXPANSION: catalogo extra de frases (estilo picante TRM) ======
(function(){
  try {
    AUTO_PHRASES_PICANTE.leaderChange = (AUTO_PHRASES_PICANTE.leaderChange||[]).concat([
      (c) => 'Se prende la punta. ' + c.winner + ' toma P1 y ' + c.loser + ' se queda masticando polvo.',
      (c) => 'Punta nueva. ' + c.winner + ' al frente. ' + c.loser + ' no se despega.',
      (c) => 'La cima cambia de dueo. ' + c.winner + ' manda. ' + c.loser + ' a remar.'
    ]);

    AUTO_PHRASES_PICANTE.pass = (AUTO_PHRASES_PICANTE.pass||[]).concat([
      (c) => 'Pase quirurgico. ' + c.winner + ' se mete a P' + c.newPos + '. ' + c.loser + ' se reacomoda.',
      (c) => 'Le cerro la puerta tarde. ' + c.winner + ' gana P' + c.newPos + '.',
      (c) => 'Con permiso y gracias. ' + c.winner + ' toma P' + c.newPos + '.'
    ]);

    AUTO_PHRASES_PICANTE.battle = (AUTO_PHRASES_PICANTE.battle||[]).concat([
      (c) => 'P' + c.pos + ' apretadisimo. ' + c.attacker + ' viene con hambre. ' + c.sec + '.',
      (c) => 'P' + c.pos + ' sin respiro. ' + c.defender + ' trae espejo lleno. ' + c.sec + '.',
      (c) => 'Esto es duelo real en P' + c.pos + '. ' + c.attacker + ' lo trae medido. ' + c.sec + '.'
    ]);

    AUTO_PHRASES_PICANTE.closing = (AUTO_PHRASES_PICANTE.closing||[]).concat([
      (c) => 'Cierre serio en P' + c.pos + '. ' + c.attacker + ' ya lo trae en la bolsa. ' + c.toSec + '.',
      (c) => 'Se viene el golpe en P' + c.pos + '. ' + c.attacker + ' ya esta a ' + c.toSec + '.',
      (c) => 'P' + c.pos + ' en zona de error cero. ' + c.defender + ' con ' + c.attacker + ' encima. ' + c.toSec + '.'
    ]);

    AUTO_PHRASES_PICANTE.top3 = (AUTO_PHRASES_PICANTE.top3||[]).concat([
      (c) => 'Arriba estan con manos. ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
      (c) => 'Punta caliente. ' + c.p1 + ' lidera. ' + c.p2 + ' lo trae en la mira. ' + c.p3 + ' espera el error.',
      (c) => 'Top 3 en orden. ' + c.p1 + '. ' + c.p2 + '. ' + c.p3 + '.'
    ]);
  } catch(e) {}
})();

    const AUTO_PHRASES_ENGINEER = {
      leaderChange: [
        (c) => 'Update punta. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Update punta. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Update punta. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Update punta. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecucin.',
        (c) => 'Update punta. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Update punta. P1 para ' + c.winner + '. ' + c.loser + ' queda detrs.',
        (c) => 'Update punta. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Cambio en P1. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Cambio en P1. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Cambio en P1. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Cambio en P1. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecucin.',
        (c) => 'Cambio en P1. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Cambio en P1. P1 para ' + c.winner + '. ' + c.loser + ' queda detrs.',
        (c) => 'Cambio en P1. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Telemetra: nuevo líder. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Telemetra: nuevo líder. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Telemetra: nuevo líder. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Telemetra: nuevo líder. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecucin.',
        (c) => 'Telemetra: nuevo líder. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Telemetra: nuevo líder. P1 para ' + c.winner + '. ' + c.loser + ' queda detrs.',
        (c) => 'Telemetra: nuevo líder. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Estado de carrera. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Estado de carrera. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Estado de carrera. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Estado de carrera. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecucin.'
      ],
      pass: [
        (c) => 'Overtake confirmado. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Overtake confirmado. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Overtake confirmado. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Overtake confirmado. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Overtake confirmado. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Overtake confirmado. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Overtake confirmado. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Cambio de posición. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de posición. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Cambio de posición. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Cambio de posición. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Cambio de posición. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Cambio de posición. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Cambio de posición. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Swap de posición. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Swap de posición. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Swap de posición. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Swap de posición. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Swap de posición. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Swap de posición. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Swap de posición. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Movimiento de ranking. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Movimiento de ranking. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Movimiento de ranking. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Movimiento de ranking. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.'
      ],
      battle: [
        (c) => 'Duelo P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'Duelo P' + c.pos + '. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'Duelo P' + c.pos + '. Rango crtico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. Rango crtico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. Rango crtico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. Rango crtico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' bajo presin. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.'
      ],
      battlePodium: [
        (c) => 'Podio P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Podio P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Podio P' + c.pos + '. Delta ' + c.sec + 's por el podio.',
        (c) => 'Podio P' + c.pos + '. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'Podio P' + c.pos + '. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' por trofeo. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' por trofeo. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' por trofeo. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' por trofeo. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' por trofeo. Rango de pase: ' + c.sec + 's.',
        (c) => 'Zona de podio P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Zona de podio P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Zona de podio P' + c.pos + '. Delta ' + c.sec + 's por el podio.',
        (c) => 'Zona de podio P' + c.pos + '. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'Zona de podio P' + c.pos + '. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' crtico para podio. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' crtico para podio. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' crtico para podio. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' crtico para podio. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' crtico para podio. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' de podio en disputa. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' de podio en disputa. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' de podio en disputa. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' de podio en disputa. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' de podio en disputa. Rango de pase: ' + c.sec + 's.'
      ],
      closing: [
        (c) => 'Cierre en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Cierre en P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Tendencia P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Tendencia P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Delta en P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Delta en P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'P' + c.pos + ' con recorte. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con recorte. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. ' + c.attacker + ' ya está ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Gap bajando en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.'
      ],
      
      gap: [
        (c) => 'Gap P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Gap P' + c.pos + '. ' + c.defender + ' adelante, ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' gap ' + c.sec + 's. ' + c.attacker + ' viene detrs.',
        (c) => 'P' + c.pos + '. Separacin ' + c.sec + 's entre ' + c.defender + ' y ' + c.attacker + '.',
        (c) => 'P' + c.pos + '. ' + c.attacker + ' marca ' + c.sec + 's al de adelante.'
      ],
      pressure: [
        (c) => 'Presin en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' bajo presin. ' + c.attacker + ' a ' + c.sec + 's. Ojo defensa.',
        (c) => 'Defensa en P' + c.pos + '. ' + c.defender + ' se sostiene con ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en modo defensa. ' + c.attacker + ' est encima, ' + c.sec + 's.'
      ],
      top3: [
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Top 3: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.',
        (c) => 'Tabla de punta: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Tabla de punta: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.',
        (c) => 'Estado del podio: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Estado del podio: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.',
        (c) => 'Orden actual: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Orden actual: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.',
        (c) => 'Lectura de top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Lectura de top 3: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.'
      ],
      train: [
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'La siguiente curva es clave.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Alto riesgo de swap.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Ventana de pase abierta.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Cualquier error altera la tabla.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'La siguiente curva es clave.'
      ]
    };

    const AUTO_PHRASES_NARRATIVO = Object.assign({}, AUTO_PHRASES_PRO, {
      // Finales: mas hilo, mas variedad, menos repeticion.
      leaderChange: [
        (c) => 'Cambio de líder. ' + (c.winner||c.attacker) + ' roba P1. ' + (c.loser||c.defender) + ' cae a P2.',
        (c) => 'Se volteo la pelicula. ' + (c.winner||c.attacker) + ' toma la punta. ' + (c.loser||c.defender) + ' a remar.',
        (c) => 'Swap arriba. ' + (c.winner||c.attacker) + ' manda. ' + (c.loser||c.defender) + ' queda segundo.',
        (c) => 'P1 cambia de manos. ' + (c.winner||c.attacker) + ' al frente. ' + (c.loser||c.defender) + ' no lo suelta.',
        (c) => 'Que golpe. ' + (c.winner||c.attacker) + ' se queda con P1. ' + (c.loser||c.defender) + ' se acomoda P2.',
        (c) => 'La punta tiene nuevo dueno: ' + (c.winner||c.attacker) + '.',
        (c) => 'Arriba se mueven. P1 ' + (c.winner||c.attacker) + ', P2 ' + (c.loser||c.defender) + '.',
        (c) => 'Cambio de guion. ' + (c.winner||c.attacker) + ' lidera. ' + (c.loser||c.defender) + ' responde.',
        (c) => 'Se reescribe la Final. ' + (c.winner||c.attacker) + ' primero. ' + (c.loser||c.defender) + ' segundo.',
        (c) => 'Nueva punta. ' + (c.winner||c.attacker) + ' arriba. ' + (c.loser||c.defender) + ' detras.',
        (c) => 'Punta para ' + (c.winner||c.attacker) + '. Esto esta vivo.',
        (c) => 'Cambio en la cima. ' + (c.winner||c.attacker) + ' se queda con P1.'
      ],

      pass: [
        (c) => 'Pase confirmado. ' + (c.winner||c.attacker) + ' ya esta en P' + (c.newPos||c.pos) + '.',
        (c) => 'Lo hizo. ' + (c.winner||c.attacker) + ' se mete por dentro y gana la plaza.',
        (c) => 'Movimiento limpio. ' + (c.winner||c.attacker) + ' pasa a ' + (c.loser||c.defender) + '. P' + (c.newPos||c.pos) + '.',
        (c) => 'Se concreta el intercambio. ' + (c.winner||c.attacker) + ' por delante.',
        (c) => 'Pase con autoridad. ' + (c.winner||c.attacker) + ' toma P' + (c.newPos||c.pos) + '.',
        (c) => 'Buen rebase. ' + (c.winner||c.attacker) + ' asegura la posicion.',
        (c) => 'Cambio de posicion en vivo. ' + (c.winner||c.attacker) + ' sube.',
        (c) => 'Lo cierra y lo firma. ' + (c.winner||c.attacker) + ' gana el lugar.',
        (c) => 'P' + (c.newPos||c.pos) + ' cambia de manos. ' + (c.winner||c.attacker) + ' se lo queda.',
        (c) => 'Pase al limite. ' + (c.winner||c.attacker) + ' por delante.',
        (c) => 'Rebase completo. ' + (c.winner||c.attacker) + ' ya esta arriba.',
        (c) => 'Se confirma el pase. ' + (c.winner||c.attacker) + ' gana la plaza.'
      ],

      battle: [
        (c) => 'Camara a P' + c.pos + '. ' + c.attacker + ' en el espejo de ' + c.defender + '. Gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' al rojo. ' + c.attacker + ' lo trae pegado. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' en mano a mano. ' + c.attacker + ' buscando el hueco. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Duelo real. ' + c.defender + ' defendiendo, ' + c.attacker + ' atacando. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Esto puede cambiar en P' + c.pos + '. Gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' sin respiro. ' + c.attacker + ' no suelta. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Rango de ataque en P' + c.pos + '. ' + c.attacker + ' con opcion.',
        (c) => 'Ojo esa pelea. ' + c.attacker + ' trae mejor linea sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en la mira. ' + c.attacker + ' esta listo.',
        (c) => 'Se ven espejos. P' + c.pos + ' con gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' apretado. Todo se decide por milimetros.',
        (c) => 'Duelo continuo en P' + c.pos + '. ' + (c.sec||c.deltaStr) + '.'
      ],

      battlePodium: [
        (c) => 'Podio en juego. P' + c.pos + ' con gap ' + (c.sec||c.deltaStr) + '. ' + c.attacker + ' presiona.',
        (c) => 'Trofeo en la mira. ' + c.attacker + ' encima de ' + c.defender + '. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' por podio. ' + c.defender + ' se defiende con el retrovisor lleno.',
        (c) => 'Zona de podio al limite. ' + c.attacker + ' con opcion clara.',
        (c) => 'Esto huele a swap por el podio. Gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Pelea de podio. ' + c.attacker + ' no perdona. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' por trofeo, sin margen. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Podio provisional temblando. ' + c.attacker + ' lo quiere.',
        (c) => 'P' + c.pos + ' en disputa. Cualquier error y cambia el podio.',
        (c) => 'Podio en fuego. ' + c.attacker + ' a tiro. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Se aprieta el podio. Gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' por podio. Esto esta bravo.'
      ],

      closing: [
        (c) => 'Recorte. P' + c.pos + ' de ' + c.fromSec + ' a ' + c.toSec + '. ' + c.attacker + ' se acerca.',
        (c) => 'Se viene. ' + c.attacker + ' baja a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Gap cayendo en P' + c.pos + '. ' + c.toSec + ' ahora.',
        (c) => 'Cierre confirmado. P' + c.pos + ' ya esta en ' + c.toSec + '.',
        (c) => 'Tendencia clara. ' + c.attacker + ' recorta y pone presion.',
        (c) => 'Atencion. P' + c.pos + ' se aprieta rapido.',
        (c) => 'Se compacta P' + c.pos + '. Se huele el pase.',
        (c) => 'Recorte constante. ' + c.attacker + ' viene con ritmo.',
        (c) => 'De ' + c.fromSec + ' a ' + c.toSec + '. Eso es recortar.',
        (c) => 'P' + c.pos + ' ahora en rango. ' + c.toSec + '.'
      ],

      train: [
        (c) => 'Tren por el podio. ' + (c.p2 ? (c.p2 + ', ' + c.p3 + ', ' + c.p4 + '.') : 'P2 a P4 en paquete.') + ' Nadie respira.',
        (c) => 'Paquete compacto. Una curva y cambia todo.',
        (c) => 'P2 a P4 en fila india. Ventana de pase abierta.',
        (c) => 'Tres autos pegados por el podio. Precision pura.',
        (c) => 'Cluster por el podio. Se viene el swap.',
        (c) => 'P2 a P4 sin aire. Error y se voltean.',
        (c) => 'Paquete por P2-P4. Nadie regala.',
        (c) => 'Tren formado. Ojo con el toque.',
        (c) => 'P2 a P4: aquí se gana con cabeza fria.',
        (c) => 'Grupo compacto. Todo se decide en la proxima chicana.',
        (c) => 'Trenecito armado. El podio tiembla.',
        (c) => 'Paquete apretado. Se siente la presion.'
      ]
    });


    const AUTO_PHRASES_BY_STYLE = {
      pro: AUTO_PHRASES_PRO,
      picante: AUTO_PHRASES_PICANTE,
      engineer: AUTO_PHRASES_ENGINEER,
      narrativo: AUTO_PHRASES_NARRATIVO
    };

function autoDecorate(text, type, style) {
  const t = String(text || '').trim();
  if (!t) return '';
  // Micro-variacin (pocas veces, para que no suene payaso)
  const r = Math.random();
  const st = String(style || 'pro');
  const tp = String(type || 'x');

  const prefixes = (st === 'engineer')
    ? ['Dato.', 'Info.', 'Control.']
    : (st === 'picante')
      ? ['Ojo.', 'Atencin.', 'Se prende.']
      : (st === 'narrativo')
        ? ['Ahora.', 'Cambiamos cmara.', 'Seguimos.', 'Atencin.', 'Foco.']
        : ['Ojo.', 'Atencin.', 'Momento.'];

  const suffixes = (st === 'engineer')
    ? ['Sin margen.', 'Sigue as.']
    : (st === 'picante')
      ? ['Se puso bueno.', 'Sin piedad.']
      : (st === 'narrativo')
        ? ['No se sueltan.', 'Se viene el pase.', 'Sin respiro.', 'Esto est vivo.']
        : ['Esto se pone bueno.', 'Ojo ah.'];

  // Narrativo: un poquito ms de "hilo", pero sin spam
  const pRate = (st === 'narrativo') ? 0.22 : 0.18;
  const sRate = (st === 'narrativo') ? 0.40 : 0.30;

  if (r < pRate) {
    const p = autoRandPick(prefixes, 'decorP:' + st + ':' + tp);
    return p ? (p + ' ' + t) : t;
  }
  if (r < sRate) {
    const s = autoRandPick(suffixes, 'decorS:' + st + ':' + tp);
    return s ? (t + ' ' + s) : t;
  }
  return t;
}

    function autoIsUsableText(s, type) {
      try {
        const t = String(s || '').replace(/\s+/g,' ').trim();
        if (!t || t.length < 3) return false;
        if (/\b(undefined|null|nan)\b/i.test(t)) return false;
        // Si menciona gap/delta pero no trae numero, mejor callar.
        if (/\b(gap|delta)\b/i.test(t) && !/\d/.test(t)) return false;
        // No deberian quedar llaves sin reemplazar
        if (/[{}]/.test(t)) return false;
        // Evita frases con comas dobles por datos faltantes
        if (/,\s*,/.test(t)) return false;
        return true;
      } catch(e) {
        return false;
      }
    }


    function autoBuildMessage(type, ctx) {
      const style = (autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || autoCommentatorMode === 'narrativo') ? autoCommentatorMode : 'pro';
      const dict = (AUTO_PHRASES_BY_STYLE && AUTO_PHRASES_BY_STYLE[style]) ? AUTO_PHRASES_BY_STYLE[style] : AUTO_PHRASES_PRO;
      const bank = (dict && dict[type]) ? dict[type] : (AUTO_PHRASES_PRO[type] || []);
      const keyBase = style + ':' + type;

      // Intento 1 + re-roll 1 vez si la frase queda incompleta (sin datos)
      for (let attempt = 0; attempt < 2; attempt++) {
        const fn = autoRandPick(bank, keyBase);
        if (typeof fn !== 'function') break;
        const out = String(fn(ctx) || '').trim();
        if (!autoIsUsableText(out, type)) continue;
        return autoDecorate(out, type, style);
      }
      return '';
    }

    // =========================
// BLUE FLAG (Auto Locutor)
// - Se anuncia solo en Auto Locutor (sin piloto seleccionado)
// - Lgica: si el líder ya te sac 1 vuelta (lapDiff>=1 o gap "+1 V"), pide cortesa
// - Anti-spam: 1 por tick, cooldown global y por piloto, y repetir mximo cada 2 vueltas del líder
// =========================
const __autoBlueLatch = new Map(); // pilotKey -> { lastLeaderLap, lastSpeakMs }
let __autoBlueLastGlobalMs = 0;

function __autoParseLapDiff(raw){
  try{
    const s0 = String(raw || '').trim();
    if (!s0) return 0;
    const mV = s0.match(/([+-]?\s*\d+)\s*v/i);
    if (mV){
      const n = parseInt(String(mV[1]).replace(/\s+/g,''), 10);
      if (isFinite(n)) return Math.abs(n);
    }
    const s = s0.toLowerCase();
    const mMas = s.match(/m[a]s\s+(\d+)\s+vueltas?/i);
    if (mMas){
      const n = parseInt(mMas[1], 10);
      if (isFinite(n) && n > 0) return n;
    }
  }catch(e){}
  return 0;
}
function __autoSafeName(r){
  const n = (r && (r.racerName || r.name || r.pilotName || r.piloto || r.driverName)) || '';
  return String(n).replace(/\s+/g,' ').trim();
}

function __autoBlueFlagCheck(arr, leader, nowMs, vs){
  try{
    if (!vs || !vs.blueflag) return;
    if (!arr || arr.length < 2) return;
    if (!lastPassEvents || typeof lastPassEvents.get !== 'function') return;

    const BLUE_PROX_MS = 800; // fijo (0.8s)
    const sessionType = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
    const isMangaSess = (sessionType === 'MANGA' || sessionType === 'TRAIN');
    const isFinalSess = (sessionType === 'FINAL');

    // Evita spam al inicio (espera un poco de carrera)
    const leaderLap = Number(leader && leader.lapcount) || 0;
    const minLap = isMangaSess ? 4 : 3;
    if (leaderLap < minLap) return;

    // Cooldown global (Final mas reactivo, Manga mas conservador)
    const globalCd = isFinalSess ? 7000 : (isMangaSess ? 11000 : 9000);
    if (nowMs - __autoBlueLastGlobalMs < globalCd) return;

    const sorted = arr.slice().filter(r => r && (r.pos != null));
    sorted.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));

    const top3 = sorted.filter(r => {
      const p = Number(r.pos)||999;
      return p >= 1 && p <= 3;
    }).slice(0,3);
    if (!top3.length) return;

    const topKeys = new Set(top3.map(p => getPilotKey(p)).filter(Boolean));

    // Recorremos rezagados y buscamos si algun Top3 lo esta lapeando MUY cerca por meta.
    for (const r of sorted){
      if (!r) continue;
      const rk = getPilotKey(r);
      if (!rk || topKeys.has(rk)) continue;

      const re = lastPassEvents.get(rk);
      if (!re || !isFinite(re.time)) continue;
      const rLap = Number(re.lap) || 0;
      if (rLap <= 0) continue;

      let best = null;
      for (const laper of top3){
        const lk = getPilotKey(laper);
        if (!lk) continue;
        const le = lastPassEvents.get(lk);
        if (!le || !isFinite(le.time)) continue;
        if (le.time <= re.time) continue;

        const delta = le.time - re.time;
        if (delta <= 0 || delta > BLUE_PROX_MS) continue;

        const laperLap = Number(le.lap) || 0;
        const lapDiff = laperLap - rLap;
        if (lapDiff < 1) continue;

        if (!best || delta < best.delta) {
          best = { laper, lk, le, delta, laperLap, lapDiff };
        }
      }
      if (!best) continue;

      let st = __autoBlueLatch.get(rk) || {
        lastLeaderLap: -999,
        lastSpeakMs: 0,
        blueHits: 0,
        blueWindowMs: 0
      };

      // repetir max cada 2 vueltas del lapeador (Top3)
      if (best.laperLap && (best.laperLap - st.lastLeaderLap) < 2) continue;

      // cooldown por piloto
      const pilotCd = isFinalSess ? 16000 : 18000;
      if (nowMs - (st.lastSpeakMs || 0) < pilotCd) continue;

      const name = __autoSafeName(r);
      if (!name) continue;
      const laperPos = Number(best.laper && best.laper.pos) || 0;
      const laperName = __autoSafeName(best.laper);
      if (!laperName) continue;
      const who = (laperPos === 1) ? ('el líder P1 ' + laperName) : ('P' + laperPos + ' ' + laperName);

      const baseMsg = isFinalSess
        ? `Bandera azul. ${name}, detras viene ${who}. Abre en la recta.`
        : `Bandera azul. ${name}, detras viene ${who}. Abre en la recta.`;

      // Azul crtica en Finales: si en 30s ya son 2 veces, sube tono
      st.blueHits = st.blueHits || 0;
      st.blueWindowMs = st.blueWindowMs || 0;
      if (!st.blueWindowMs || (nowMs - st.blueWindowMs) > 30000) {
        st.blueWindowMs = nowMs;
        st.blueHits = 0;
      }
      st.blueHits++;
      const useCrit = isFinalSess && st.blueHits >= 2 && (nowMs - st.blueWindowMs) <= 30000;
      const finalMsg = useCrit
        ? `Azul critica. ${name}, suelta en la recta. Detras viene ${who}.`
        : baseMsg;

      enqueueSpeech(finalMsg, {
        key: `auto_blue_${rk}`,
        priority: 6,
        cooldownMs: 8000,
        postDelayMs: 260
      });

      st.lastLeaderLap = best.laperLap || st.lastLeaderLap;
      st.lastSpeakMs = nowMs;
      __autoBlueLatch.set(rk, st);
      __autoBlueLastGlobalMs = nowMs;
      break; // 1 por tick
    }
  }catch(e){}
}

function handleAutoCommentator() {
      try {
        if (!raceData || !Array.isArray(raceData.classification)) return;
        if (selectedPilotKey) return; // modo espectador
        // AI: en Auto Locutor, si el usuario no ha tocado VOZ, activamos voz automticamente
        if (!voiceMasterEnabled) {
          try { if (!userVoiceOverride) setVoiceMaster(true, { silent:true, auto:true }); } catch(e) {}
        }
        if (!voiceMasterEnabled) return;

        const vs = (typeof voiceSettings !== 'undefined' && voiceSettings) ? voiceSettings : {};
        // Si el usuario apaga TODO menos laps, no inventamos
        const autoOn = !!(vs.pos || vs.podium || vs.pelea || vs.gaps || vs.leadergap || vs.bestlap || vs.estlap || vs.attack || vs.defense || vs.front06 || vs.back06 || vs.ritmo || vs.total || vs.blueflag || vs.cons10 || vs.netgain);
        if (!autoOn) return;

        const arr = raceData.classification.slice().filter(r => r && (r.pos != null));
        // Auto Locutor: ciclo de vida (espera a que arranque, silencio al terminar)
        try { __autoUpdateLifecycle(raceData); } catch(e) {}
        if (__autoPhase === 'WAIT_START') return; // ya se anunci, ahora silencio hasta que arranque
        if (__autoPhase === 'FINISHED') return;   // carrera terminada, espera siguiente raceName
        if (!arr.length) return;

        arr.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));

        // Auto Locutor: al cumplirse el tiempo de la final, anunciar quienes van finalizando
        try { __autoAnnounceFinishers(); } catch(e) {}

        // En cierre: solo 'finalizo' y silencio (no narrar peleas ni swaps)
        if (__autoPhase === 'CLOSING') return;

        const leader = arr.find(r => Number(r.pos) === 1) || arr[0];
        const leaderLap = Number(leader && leader.lapcount) || 0;
        const progress = autoRaceProgress(leaderLap);


        // ====== Top5 stability gate (para anunciar pases en posiciones bajas)
        try {
          const top5 = arr.slice(0, 5);
          const top5Sig = top5.map(r => String(getPilotKey(r) || '')).join('|');
          if (leaderLap && leaderLap !== (commentatorAutoState.lastTop5Lap || 0)) {
            if (top5Sig && top5Sig === (commentatorAutoState.lastTop5Sig || '')) {
              commentatorAutoState.stableTop5Laps = (Number(commentatorAutoState.stableTop5Laps) || 0) + 1;
            } else {
              commentatorAutoState.stableTop5Laps = 0;
            }
            commentatorAutoState.lastTop5Sig = top5Sig;
            commentatorAutoState.lastTop5Lap = leaderLap;
          }
        } catch(e) {}
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

        // ====== bandera azul (Auto Locutor)
        try { __autoBlueFlagCheck(arr, leader, now, vs); } catch(e) {}

        // ====== candidatos (score decide)
        const candidates = [];
        const battles = [];
        const addCand = (c) => { if (c && c.text && isFinite(c.score)) candidates.push(c); };

        // ====== cambios de líder / posiciones
        const leaderKey = getPilotKey(leader);
        if (leaderKey && commentatorAutoState.lastLeaderKey && leaderKey !== commentatorAutoState.lastLeaderKey) {
          if (vs.pos || vs.leadergap || vs.podium) {
            const prevLeaderName = safeRacerName((commentatorAutoState.lastLeaderKeyName || ''));
            const winner = safeRacerName(leader.racerName) || 'el líder nuevo';
            const loser = prevLeaderName || 'el líder anterior';
            const text = autoBuildMessage('leaderChange', { winner, loser });
            addCand({
              type:'leaderChange',
              score: 10.0 + (progress > 0.75 ? 0.6 : 0),
              text,
              key: 'auto_leader_change',
              sig: 'auto:leaderChange',
              sigCooldownMs: 9000,
              priority: 9
            });
          }
        }
        // guardar nombre del líder para el siguiente tick
        commentatorAutoState.lastLeaderKeyName = safeRacerName(leader && leader.racerName);

        // Overtakes por swap de posiciones
        if (commentatorAutoState.prevKeyByPos && commentatorAutoState.prevKeyByPos.length) {
          // detecta swaps simples: key actual en pos i y key previa diferente
          for (let i = 0; i < Math.min(arr.length, 10); i++) {
            const curr = arr[i];
            const currPos = Number(curr.pos) || (i+1);
            const currKey = getPilotKey(curr);
            if (!currKey) continue;
            const prevKeyAtThisPos = commentatorAutoState.prevKeyByPos[currPos-1];
            if (prevKeyAtThisPos && prevKeyAtThisPos !== currKey) {
              const prevPos = commentatorAutoState.prevPosByKey.get(currKey);
              // solo si realmente gan posiciones
              if (prevPos && currPos < prevPos) {
                const loserKey = prevKeyAtThisPos;
                if (!loserKey || loserKey === currKey) continue;

                // Snapshot de posiciones previas (tick anterior) para un pase consistente:
                // - winnerPrevPos: de dnde vena el ganador
                // - loserPrevPos: dnde iba el perdedor (debe coincidir con currPos para un swap simple)
                const winnerPrevPos = prevPos;
                const loserPrevPos = commentatorAutoState.prevPosByKey.get(loserKey);

                // Solo narramos swaps simples (evita anunciar cosas raras y evita "P1...P1"):
                if (loserPrevPos && loserPrevPos !== currPos) continue;

                // Nueva posición del perdedor: cae al lugar de donde vena el ganador
                let loserNewPos = winnerPrevPos || (currPos + 1);
                // Guardrail: nunca narrar que ambos quedaron en la misma posición
                if (loserNewPos === currPos) loserNewPos = currPos + 1;

                const winner = safeRacerName(curr.racerName) || 'un piloto';
                const loser = safeRacerName((arr.find(x => getPilotKey(x)===loserKey)||{}).racerName) || 'otro piloto';

                const text = autoBuildMessage('pass', { winner, loser, newPos: currPos, oldPos: loserNewPos });


                // Gate: cambios en posiciones bajas solo si Top5 sin cambios en 3 vueltas
                try {
                  const stable = Number(commentatorAutoState && commentatorAutoState.stableTop5Laps) || 0;
                  if (Number(currPos) > 5 && stable < 3) {
                    continue;
                  }
                } catch(e) {}
                let s = 8.8;
                if (currPos <= 3) s += 0.9;
                if (currPos === 1) s += 0.6;
                if (progress > 0.75 && currPos <= 5) s += 0.6;

                addCand({
                  type:'pass',
                  score: s,
                  text,
                  key: 'auto_pass_' + currKey + '_' + currPos,
                  sig: 'auto:pass:' + currKey + ':' + currPos,
                  sigCooldownMs: 12000,
                  priority: 8
                });
              }
            }
          }
        }

        // ====== top 3 (resumen inteligente: solo cuando aporta)
        if (vs.pos || vs.podium || vs.leadergap) {
          if (arr.length >= 3) {
            const p1 = safeRacerName(arr[0].racerName) || 'P1';
            const p2 = safeRacerName(arr[1].racerName) || 'P2';
            const p3 = safeRacerName(arr[2].racerName) || 'P3';

            const sig = `${p1}|${p2}|${p3}`;
            const hadSig = !!(commentatorAutoState.lastTop3Sig);
            const orderChanged = hadSig && (sig !== commentatorAutoState.lastTop3Sig);

            // milestones para no repetir sin sentido
            const msArr = [0.25, 0.50, 0.75, 0.90];
            let hitMilestone = 0;
            for (const m0 of msArr) {
              if (progress >= m0 && (commentatorAutoState.lastMilestone || 0) < m0) { hitMilestone = m0; break; }
            }

            const stableCooldownMs = 35000;// C: mas frecuente (30-40s) // si no cambia nada, habla mucho menos
            const shouldByChange = orderChanged;
            const shouldByMilestone = !!hitMilestone;
            const shouldByTime = (now - (commentatorAutoState.lastTop3Ms || 0) > stableCooldownMs);

            if ((shouldByChange || shouldByMilestone || shouldByTime) && leaderLap > 0) {
              const lapNow = leaderLap || 0;
              const lapTotal = Number(raceData.lapCount) || 0;
              const text = autoBuildMessage('top3', { p1, p2, p3, lapNow, lapTotal });

              let s = 3.3;
              if (orderChanged) s += 1.3;
              if (hitMilestone) s += 0.7;
              if (progress > 0.80) s += 0.4;

              addCand({
                type:'top3',
                score: s,
                text,
                key:'auto_top3',
                sig:'auto:top3',
                sigCooldownMs: commentatorAutoCfg.top3CooldownMs,
                priority: 3,
                onCommit: () => {
                  commentatorAutoState.lastTop3Ms = now;
                  commentatorAutoState.lastTop3Sig = sig;
                  if (hitMilestone) commentatorAutoState.lastMilestone = hitMilestone;
                  commentatorTop3LastLeaderLap = leaderLap || commentatorTop3LastLeaderLap;
                }
              });
            }
          }
        }

        // ====== batallas cerradas (<=0.5s) y trenecito
        if (vs.pelea) {
          // trenecito podio: P2-P4 muy juntos
          if (arr.length >= 4) {
            const a2 = arr[1], a3 = arr[2], a4 = arr[3];
            const k2 = getPilotKey(a2), k3 = getPilotKey(a3), k4 = getPilotKey(a4);
            const sameLap = (Number(a2.lapcount)||0)===(Number(a3.lapcount)||0) && (Number(a3.lapcount)||0)===(Number(a4.lapcount)||0);
            if (sameLap && a2.time!=null && a3.time!=null && a4.time!=null) {
              const d23 = (a3.time - a2.time)/1000;
              const d34 = (a4.time - a3.time)/1000;
              if (d23>0 && d34>0 && d23<=0.60 && d34<=0.60) {
                const p2n = safeRacerName(a2.racerName) || 'P2';
                const p3n = safeRacerName(a3.racerName) || 'P3';
                const p4n = safeRacerName(a4.racerName) || 'P4';
                const text = autoBuildMessage('train', { p2: p2n, p3: p3n, p4: p4n });
                addCand({
                  type:'train',
                  score: 7.2 + (progress>0.75?0.6:0),
                  text,
                  key:'auto_train_podium',
                  sig:'auto:train',
                  sigCooldownMs: 18000,
                  priority: 7
                });
              }
            }
          }

          for (let i = 0; i < arr.length - 1; i++) {
            const ahead = arr[i];
            const behind = arr[i + 1];
            if (!ahead || !behind) continue;

            const aKey = getPilotKey(ahead);
            const bKey = getPilotKey(behind);
            if (!aKey || !bKey) continue;

            const aLaps = Number(ahead.lapcount) || 0;
            const bLaps = Number(behind.lapcount) || 0;
            const pairKey = autoPairKey(aKey, bKey);

            // si no estan en la misma vuelta, rearmar latch
            if (aLaps !== bLaps) {
              if (commentatorBattleLatch && commentatorBattleLatch.has(pairKey)) commentatorBattleLatch.delete(pairKey);
              continue;
            }

            if (ahead.time == null || behind.time == null) continue;
            const diffMs = (behind.time - ahead.time);
            if (!diffMs || diffMs <= 0) continue;

const sec = diffMs / 1000;

const posFight = Number(ahead.pos) || (i + 1);

// Pool para narracin con hilo (seguimos la pelea aunque no est en 0.50 exacto)
const defenderName = safeRacerName(ahead.racerName) || 'el de adelante';
const attackerName = safeRacerName(behind.racerName) || 'el de atrs';
const secNum = sec;

// Tendencia (si el atacante viene ms rápido en la última vuelta, pesa ms)
const aLast = Number(ahead.lastTime) || 0;
const bLast = Number(behind.lastTime) || 0;
const attackerFaster = (aLast > 0 && bLast > 0) ? ((aLast - bLast) / 1000) : 0; // >0 = el de atrs viene ms rápido

const rem = autoRememberPair(pairKey, secNum, leaderLap, now);
const trendBonus = (rem.deltaSec < -0.08) ? 0.8 : (rem.deltaSec < -0.04 ? 0.4 : 0);

// Score base para el pool
let poolScore = 4.0 + clamp01((1.25 - secNum) / 1.25) * 4.2;
if (posFight <= 3) poolScore += 1.3;
if (posFight === 1) poolScore += 0.7;
if (progress > 0.80 && posFight <= 5) poolScore += 0.5;
poolScore += trendBonus;
if (attackerFaster > 0.10) poolScore += 0.5;

if (secNum <= 1.25) {
  battles.push({
    pairKey,
    pos: posFight,
    defender: defenderName,
    attacker: attackerName,
    secNum,
    score: poolScore,
    lastMentionMs: rem.lastMentionMs || 0
  });
}

// histeresis: rearmar cuando se abre
            const prevLatch = commentatorBattleLatch ? commentatorBattleLatch.get(pairKey) : null;
            if (prevLatch && prevLatch.active) {
              if (sec >= 0.72) commentatorBattleLatch.delete(pairKey);
              else continue;
            }

            if (sec <= 0.50) {
              const defender = safeRacerName(ahead.racerName) || 'el de adelante';
              const attacker = safeRacerName(behind.racerName) || 'el de atrs';
              const secStr = gapToSpeech(sec, 'battle');

              const closeness = clamp01((0.50 - sec) / 0.50);
              let score = 6.0 + closeness * 3.0;
              if (posFight <= 3) score += 1.6;
              if (posFight === 1) score += 0.8;
              if (progress > 0.80 && posFight <= 5) score += 0.7;

              const type = (posFight <= 3) ? 'battlePodium' : 'battle';
              const text = autoBuildMessage(type, { pos: posFight, attacker, defender, sec: secStr });

              addCand({
                type,
                secNum: secNum,
                score,
                text,
                key: 'auto_duel_' + pairKey,
                sig: 'auto:duel:' + pairKey,
                sigCooldownMs: 12000,
                priority: 6
              });

              if (commentatorBattleLatch) commentatorBattleLatch.set(pairKey, { active: true, lastLeadLap: leaderLap });
            }
          }
        }

        // ====== se cierra (0.5 a 1.6, baja gap fuerte)
        // Nota: POS ya no dispara cierres (para evitar duplicados). Cierres=ATAQUE/DEFENSA, gaps=nmeros.
        if (vs.attack || vs.defense || vs.front06 || vs.back06 || vs.gaps) {
          for (let i = 0; i < arr.length - 1; i++) {
            const ahead = arr[i];
            const behind = arr[i + 1];
            if (!ahead || !behind) continue;

            const aKey = getPilotKey(ahead);
            const bKey = getPilotKey(behind);
            if (!aKey || !bKey) continue;

            const aLaps = Number(ahead.lapcount) || 0;
            const bLaps = Number(behind.lapcount) || 0;
            const pairKey = autoPairKey(aKey, bKey);

            if (aLaps !== bLaps) {
              if (commentatorGapHistory && commentatorGapHistory.has(pairKey)) commentatorGapHistory.delete(pairKey);
              continue;
            }

            if (ahead.time == null || behind.time == null) continue;
            const diffMs = (behind.time - ahead.time);
            if (!diffMs || diffMs <= 0) continue;
            const sec = diffMs / 1000;

            const hist = commentatorGapHistory ? commentatorGapHistory.get(pairKey) : null;
            const lastTrailLap = hist ? (hist.lastTrailLap || 0) : 0;
            if (hist && lastTrailLap === bLaps) continue;

            const newHist = {
              lastGapMs: diffMs,
              lastTrailLap: bLaps,
              lastSpokenTrailLap: hist ? (hist.lastSpokenTrailLap || 0) : 0
            };
            if (commentatorGapHistory) commentatorGapHistory.set(pairKey, newHist);

            if (sec < 0.35 || sec > 1.35) continue;
            if (!hist || !hist.lastGapMs) continue;

            const deltaMs = (hist.lastGapMs - diffMs); // positivo: se acerca
            if (deltaMs < 260) continue;

            // no hablar cada vuelta
            if (newHist.lastSpokenTrailLap && bLaps <= (newHist.lastSpokenTrailLap + 1)) continue;

const posFight = Number(ahead.pos) || (i + 1);
const defender = safeRacerName(ahead.racerName) || 'el de adelante';
const attacker = safeRacerName(behind.racerName) || 'el de atrs';
const fromSec = gapToSpeechBare(hist.lastGapMs / 1000, 'close');
const toSec = gapToSpeechBare(sec, 'close');

// Pool de narracin: cuando se cierra fuerte, conviene seguirlo
try {
  const rem2 = autoRememberPair(pairKey, sec, leaderLap, now);
  let poolScore2 = 4.0 + clamp01((1.25 - sec) / 1.25) * 3.6;
  poolScore2 += clamp01(deltaMs / 700) * 1.2;
  if (posFight <= 3) poolScore2 += 1.1;
  if (progress > 0.80 && posFight <= 5) poolScore2 += 0.5;
  if (sec <= 1.25) {
    battles.push({
      pairKey,
      pos: posFight,
      defender,
      attacker,
      secNum: sec,
      score: poolScore2 + 0.6,
      lastMentionMs: rem2.lastMentionMs || 0
    });
  }
} catch(e) {}

            let score = 4.6 + clamp01(deltaMs / 600) * 2.5;
            if (posFight <= 3) score += 1.1;
            if (progress > 0.80 && posFight <= 5) score += 0.5;

            const deltaStr = gapDeltaSpeech(Math.max(0, deltaMs)/1000);

            // ATAQUE: tendencia de recorte (ms narrativa)
            if (vs.attack) {
              const text = autoBuildMessage('closing', { pos: posFight, attacker, defender, fromSec, toSec, delta: deltaStr });
              addCand({
                type:'closing',
                score,
                text,
                key:'auto_close_' + pairKey,
                sig:'auto:close:' + pairKey,
                sigCooldownMs: 9000,
                priority: 4
              });
            }

            // GAPS: solo nmeros (sin hype), con cooldown largo para no spamear
            if (vs.gaps && posFight <= 6 && sec <= 2.0) {
              const text = autoBuildMessage('gap', { pos: posFight, attacker, defender, sec: gapToSpeech(sec, 'gap') });
              addCand({
                type:'gap',
                score: Math.max(2.8, score - 1.9),
                text,
                key:'auto_gap_' + pairKey,
                sig:'auto:gap:' + pairKey,
                sigCooldownMs: 22000,
                priority: 2
              });
            }

            // DEFENSA: presin real (<=0.6) para el de adelante
            if ((vs.defense || vs.back06) && posFight <= 8 && sec <= 0.60) {
              const text = autoBuildMessage('pressure', { pos: posFight, attacker, defender, sec: gapToSpeech(sec, 'pressure') });
              addCand({
                type:'pressure',
                score: 6.2,
                text,
                key:'auto_pressure_' + pairKey,
                sig:'auto:press:' + pairKey,
                sigCooldownMs: 16000,
                priority: 5
              });
            }

            newHist.lastSpokenTrailLap = bLaps;
            if (commentatorGapHistory) commentatorGapHistory.set(pairKey, newHist);
          }
        }

// ====== modo de sesin
const sessionType = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
const isMangaSess = (sessionType === 'MANGA' || sessionType === 'TRAIN');
const isFinalSess = (sessionType === 'FINAL');

// Auto-estilo por sesion (default): MANGA=SERIO (pro), FINALES=HYPE (narrativo)
if (!autoModeUserOverride) {
  const wantMode = isFinalSess ? 'narrativo' : (isMangaSess ? 'pro' : autoCommentatorMode);
  if (wantMode && autoCommentatorMode !== wantMode) {
    autoCommentatorMode = wantMode;
    try { prefSet('autoCommentatorMode', wantMode); } catch(e) {}
    try { updateAutoCommentatorButtons(); } catch(e) {}
  }
}

// ====== narracin con hilo: elegimos una pelea y la seguimos con contexto
if ((voiceSettings.pelea || voiceSettings.attack || voiceSettings.defense) && battles && battles.length) {
  const sc = autoBuildStoryCandidate({ battles, now, leaderLap, progress, isMangaSess });
  if (sc) addCand(sc);
}

// ====== MANGA (clasificacin): pole/best lap (menos ruido, ms sustancia)
if (isMangaSess) {
  const wantBest = !!vs.bestlap;
  const wantPoleFight = !!(vs.bestlap || vs.pelea);

  try {
    // Mejor vuelta global
    if (wantBest) {
      let bestMs = null;
      let bestKey = '';
      let bestName = '';
      for (let i = 0; i < Math.min(arr.length, 12); i++) {
        const r = arr[i];
        const k = getPilotKey(r);
        const b = Number(r && r.best) || 0;
        if (!k || !b || !isFinite(b)) continue;
        if (bestMs == null || b < bestMs) {
          bestMs = b; bestKey = k; bestName = safeRacerName(r.racerName) || '';
        }
      }

      if (bestMs != null && isFinite(bestMs) && bestMs > 0) {
        const improved = (autoQualiState.bestOverallMs == null) ? true : (bestMs < (autoQualiState.bestOverallMs - 20));
        const since = now - (autoQualiState.lastBestSpeakMs || 0);

        if (improved && since > 10000) {
          const t = msToVoiceTime(bestMs); // ya aplica regla flat/precision
          const txt = bestName ? (`Vuelta rápida. ${bestName} marca ${t}`) : (`Vuelta rápida. ${t}`);
          addCand({
            type: 'qualiBest',
            score: 6.8,
            text: txt,
            key: 'auto_quali_best',
            sig: 'auto:qualiBest:' + String(bestKey || ''),
            sigCooldownMs: 24000,
            priority: 6,
            onCommit: () => {
              autoQualiState.bestOverallMs = bestMs;
              autoQualiState.bestOverallKey = bestKey;
              autoQualiState.lastBestSpeakMs = now;
            }
          });
        }
      }
    }

    // Pelea por la pole (Top2)
    if (wantPoleFight) {
      if (arr.length >= 2) {
        const r1 = arr[0], r2 = arr[1];
        const b1 = Number(r1 && r1.best) || 0;
        const b2 = Number(r2 && r2.best) || 0;
        const n1 = safeRacerName(r1 && r1.racerName) || 'P1';
        const n2 = safeRacerName(r2 && r2.racerName) || 'P2';
        if (b1 > 0 && b2 > 0 && isFinite(b1) && isFinite(b2)) {
          const gap = Math.abs(b2 - b1) / 1000;
          const sincePF = now - (autoQualiState.lastPoleFightSpeakMs || 0);
          if (gap <= 0.10 && sincePF > 14000) {
            const g = gapToSpeech(gap, 'pole');
            const txt = `Pelea por la pole. ${n1} y ${n2} separados por ${g}.`;
            addCand({
              type: 'qualiPole',
              score: 6.1,
              text: txt,
              key: 'auto_quali_pole',
              sig: 'auto:qualiPole',
              sigCooldownMs: 16000,
              priority: 5,
              onCommit: () => { autoQualiState.lastPoleFightSpeakMs = now; }
            });
          }
        }
      }
    }
  } catch(e) {}
}

// ====== si no hay accion real, mini resumen (C: Top5 + pelea mas cerrada)
        try {
          let maxScore = 0;
          for (const c of candidates) maxScore = Math.max(maxScore, Number(c && c.score) || 0);

          const quietCooldownMs = Number(commentatorAutoState.nextQuietCooldownMs || 0) || Math.floor((commentatorAutoCfg.quietMinMs || 30000) + Math.random() * Math.max(0, (commentatorAutoCfg.quietMaxMs || 40000) - (commentatorAutoCfg.quietMinMs || 30000)));
          const sinceQuiet = now - (commentatorAutoState.lastQuietMs || 0);

          const allowMini = !!(vs.pos || vs.podium || vs.total || vs.leadergap || vs.pelea);
          const sinceSpeak = now - (commentatorAutoState.lastSpeakMs || 0);

          // Solo si ya arranco y no hay "accion fuerte"; evita perico, pero mantiene narrativa.
          if (allowMini && sinceQuiet > quietCooldownMs && maxScore < (commentatorAutoCfg.baseThresholdScore || 4.6) && sinceSpeak > 26000 && leaderLap > 0) {
            // Top 5 (con pausas)
            const top = arr.slice(0, 5);
            const names = top.map((r, idx) => safeRacerName(r && r.racerName) || ('P' + String((Number(r && r.pos) || (idx + 1))))).filter(Boolean);
            let topTxt = '';
            if (names.length) topTxt = 'Top cinco. ' + names.map(n => String(n)).join('. ') + '.';

            // Pelea mas cerrada en Top10 (misma vuelta y <= 1.5s)
            let battleTxt = '';
            try {
              let best = null;
              for (let i = 0; i < Math.min(arr.length, 10) - 1; i++) {
                const a = arr[i], b = arr[i + 1];
                if (!a || !b) continue;
                const la = Number(a.lapcount) || 0;
                const lb = Number(b.lapcount) || 0;
                if (la !== lb) continue;
                if (a.time == null || b.time == null) continue;
                const sec = (Number(b.time) - Number(a.time)) / 1000;
                if (!isFinite(sec) || sec <= 0) continue;
                if (sec > 1.50) continue;
                if (!best || sec < best.sec) {
                  best = {
                    sec,
                    pos: Number(a.pos) || (i + 1),
                    defender: safeRacerName(a.racerName) || 'el de adelante',
                    attacker: safeRacerName(b.racerName) || 'el de atras'
                  };
                }
              }
              if (best) {
                const g = gapToSpeech(best.sec, 'close');
                battleTxt = `Pelea ms cerrada. ${best.attacker} viene ${g} de ${best.defender} por la P${best.pos}.`;
              }
            } catch (e) {}

            // Tiempo restante si aplica
            let leftTxt = '';
            try {
              const dur = Number(currentSessionInfo && currentSessionInfo.durationMs) || 0;
              const elapsed = Number(leader && leader.time) || 0;
              if (dur > 0 && elapsed > 0) {
                const left = Math.max(0, dur - elapsed);
                leftTxt = formatClockMs(left);
              }
            } catch (e) {}

            // Mini resumen con estilo (pro/picante/engineer/narrativo)
            const styleMini = (autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || autoCommentatorMode === 'narrativo') ? autoCommentatorMode : 'pro';

            const MINI_HDR = {
              pro: {
                manga: ['Clasificacion.', 'Clasificacion en vivo.', 'Como va la clasificación.'],
                final: ['Carrera.', 'Carrera en vivo.', 'Como va la carrera.'],
                other: ['Seguimos.', 'Actualizacion.', 'Estado.']
              },
              picante: {
                manga: ['Clasificacion.', 'Clasificacion, sin llorar.', 'Clasificacion, a ver quien trae manos.'],
                final: ['Carrera.', 'Carrera, sin piedad.', 'Carrera, esto ya se prendio.'],
                other: ['Seguimos.', 'Ojo.', 'Atencion.']
              },
              engineer: {
                manga: ['Clasificacion.', 'Control. Clasificacion.', 'Dato. Clasificacion.'],
                final: ['Carrera.', 'Control. Carrera.', 'Dato. Carrera.'],
                other: ['Control.', 'Dato.', 'Info.']
              },
              narrativo: {
                manga: ['Clasificacion.', 'Cambiamos camara. Clasificacion.', 'Vamos con la clasificación.'],
                final: ['Carrera.', 'Cambiamos camara. Carrera.', 'Vamos con la carrera.'],
                other: ['Seguimos.', 'Cambiamos camara.', 'Atencion.']
              }
            };

            const MINI_TOP = {
              pro: ['Top cinco', 'Top 5', 'Los primeros cinco'],
              picante: ['Top cinco', 'Top cinco, sin regalos', 'Top cinco, a puro control'],
              engineer: ['Top cinco', 'Top cinco. Control', 'Top cinco. Dato'],
              narrativo: ['Top cinco', 'Los cinco del frente', 'Los cinco que mandan']
            };

            const MINI_BATTLE = {
              pro: [
                (b) => `Pelea ms cerrada. ${b.attacker} viene ${b.g} de ${b.defender} por la P${b.pos}.`,
                (b) => `Cierre en P${b.pos}. ${b.attacker} a ${b.g} de ${b.defender}.`,
                (b) => `Ojo P${b.pos}. ${b.attacker} trae a tiro a ${b.defender}. ${b.g}.`
              ],
              picante: [
                (b) => `Pelea ms cerrada. ${b.attacker} viene ${b.g} de ${b.defender} por la P${b.pos}.`,
                (b) => `P${b.pos} al rojo vivo. ${b.attacker} trae a tiro a ${b.defender}. ${b.g}.`,
                (b) => `Cierre con colmillo en P${b.pos}. ${b.attacker} ya lo huele. ${b.g}.`,
                (b) => `P${b.pos} sin respiro. ${b.defender} con espejo lleno. ${b.g}.`
              ],
              engineer: [
                (b) => `Gap minimo en P${b.pos}. ${b.attacker} a ${b.g} de ${b.defender}.`,
                (b) => `Cierre en P${b.pos}. Delta ${b.g}.`,
                (b) => `P${b.pos}. ${b.defender} vs ${b.attacker}. ${b.g}.`
              ],
              narrativo: [
                (b) => `La pelea ms cerrada esta en P${b.pos}. ${b.attacker} viene ${b.g} de ${b.defender}.`,
                (b) => `En P${b.pos} se respira tension. ${b.attacker} a ${b.g} de ${b.defender}.`,
                (b) => `Cierre en P${b.pos}. ${b.attacker} no se despega. ${b.g}.`
              ]
            };

            const MINI_TIME = {
              pro: ['Quedan', 'Tiempo restante', 'Restan'],
              picante: ['Quedan', 'Tiempo, ojo', 'Restan'],
              engineer: ['Quedan', 'Restan', 'Tiempo'],
              narrativo: ['Quedan', 'Nos quedan', 'Tiempo restante']
            };

            const hb = MINI_HDR[styleMini] || MINI_HDR.pro;
            const header = autoRandPick(isMangaSess ? hb.manga : isFinalSess ? hb.final : hb.other, 'miniHdr:' + styleMini) || (isMangaSess ? 'Clasificacion.' : isFinalSess ? 'Carrera.' : 'Seguimos.');
            const topIntro = autoRandPick((MINI_TOP[styleMini] || MINI_TOP.pro), 'miniTopIntro:' + styleMini) || 'Top cinco';

            let msg = (header + ' ' + ((topTxt && names.length) ? (topIntro + '. ' + names.map(n => String(n)).join('. ') + '.') : (topTxt || ''))).trim();

            if (battleTxt) {
              // battleTxt viene armado, pero aquí le damos variacion
              try {
                const fn = autoRandPick((MINI_BATTLE[styleMini] || MINI_BATTLE.pro), 'miniBattle:' + styleMini);
                if (fn && typeof fn === 'function') {
                  // extrae datos del string actual (ya tenemos best)
                  // si falla, usamos battleTxt directo
                  msg = (msg + ' ' + String(fn({ attacker: best.attacker, defender: best.defender, pos: best.pos, g: gapToSpeech(best.sec, 'close') }) || battleTxt)).trim();
                } else {
                  msg = (msg + ' ' + battleTxt).trim();
                }
              } catch(e) {
                msg = (msg + ' ' + battleTxt).trim();
              }
            }

            if (leftTxt) {
              const tW = autoRandPick((MINI_TIME[styleMini] || MINI_TIME.pro), 'miniTime:' + styleMini) || 'Quedan';
              msg = (msg + ' ' + tW + ' ' + leftTxt + '.').trim();
            }

            addCand({
              type: 'mini',
              score: 3.2 + (progress > 0.85 ? 0.2 : 0),
              text: msg,
              key: 'auto_mini',
              sig: 'auto:mini',
              sigCooldownMs: quietCooldownMs,
              priority: 2,
              onCommit: () => {
                commentatorAutoState.lastQuietMs = now;
                commentatorAutoState.nextQuietCooldownMs = Math.floor((commentatorAutoCfg.quietMinMs || 30000) + Math.random() * Math.max(0, (commentatorAutoCfg.quietMaxMs || 40000) - (commentatorAutoCfg.quietMinMs || 30000)));
              }
            });
          }
        } catch (e) {}

// ====== elegir el mejor mensaje \(1 por tick\)
        if (!candidates.length) {
          // silencio es oro
          commentatorAutoState.lastLeaderKey = leaderKey || commentatorAutoState.lastLeaderKey;
          commentatorAutoState.lastLeaderLap = leaderLap || commentatorAutoState.lastLeaderLap;
        } else {
          
// MANGA: reduce ruido (menos swaps, ms info til)
if (isMangaSess && candidates && candidates.length) {
  // Top3 + cierres + trenes. Lo dems en manga suele ser "ruido" por salida escalonada.
  const allow = new Set(['top3','closing','train','story','qualiBest','qualiPole','mini']);
  const filtered = [];
  for (const c of candidates) {
    if (c && c.type && allow.has(c.type)) filtered.push(c);
  }
  if (filtered.length) {
    candidates.length = 0;
    for (const c of filtered) candidates.push(c);
  }
}

// Conflict rule: pass vs battle. Prefer battle only if gap <= 0.30s, else pass.
try {
  let hasPass = false;
  let hasBattle = false;
  let minBattleSec = Infinity;
  for (const c of candidates) {
    if (!c) continue;
    if (c.type === 'pass') hasPass = true;
    if (c.type === 'battle' || c.type === 'battlePodium') {
      hasBattle = true;
      const s = Number(c.secNum);
      if (isFinite(s)) minBattleSec = Math.min(minBattleSec, s);
    }
  }
  if (hasPass && hasBattle) {
    const battleWins = isFinite(minBattleSec) && minBattleSec <= 0.30;
    for (const c of candidates) {
      if (!c) continue;
      if (battleWins) {
        if (c.type === 'pass') { c.score -= 3.5; }
        if (c.type === 'battle' || c.type === 'battlePodium') { c.score += 2.0; c.priority = Math.max(Number(c.priority)||0, 9); }
      } else {
        if (c.type === 'pass') { c.score += 1.5; c.priority = Math.max(Number(c.priority)||0, 9); }
        if (c.type === 'battle' || c.type === 'battlePodium') { c.score -= 2.5; }
      }
    }
  }
} catch(e) {}

candidates.sort((a,b) => (b.score - a.score) || (b.priority - a.priority));

for (const c of candidates) {
            const sigCd = Number(c.sigCooldownMs || 0) || commentatorAutoCfg.sigDefaultCooldownMs;
            if (!autoCanSpeak(c.score, c.sig, sigCd, now)) continue;

            // hablar
            speakWithLaps(leaderLap, c.text, { voiceURI: nextAutoVoiceURI(), key: c.key || c.sig || ('auto_' + c.type), priority: c.priority || 0, cooldownMs: 2500, dedupe: true,
              mood: (c.type==='battle' || c.type==='closing' || c.type==='leaderChange' || c.type==='pass' || c.type==='pressure' || c.type==='train') ? 'hype' : (c.type==='qualiBest' || c.type==='qualiPole') ? 'serious' : 'calm' });

            commentatorAutoState.lastSpeakMs = now;
            commentatorAutoState.window.push(now);
            autoMarkSig(c.sig, now);
            try { if (typeof c.onCommit === 'function') c.onCommit(); } catch(e) {}
            break;
          }

          commentatorAutoState.lastLeaderKey = leaderKey || commentatorAutoState.lastLeaderKey;
          commentatorAutoState.lastLeaderLap = leaderLap || commentatorAutoState.lastLeaderLap;
        }

        // ====== actualizar snapshot de posiciones
        const prevPos = new Map();
        const prevByPos = [];
        for (let i = 0; i < arr.length; i++) {
          const r = arr[i];
          const k = getPilotKey(r);
          const p = Number(r.pos) || (i+1);
          if (k) {
            prevPos.set(k, p);
            prevByPos[p-1] = k;
          }
        }
        commentatorAutoState.prevPosByKey = prevPos;
        commentatorAutoState.prevKeyByPos = prevByPos;

      } catch (e) {
        console.error('handleAutoCommentator', e);
      }
    }

function handleVoiceAndBeeps() {
      if (!raceData || !Array.isArray(raceData.classification)) return;
      if (!selectedPilotKey) return;

      const p = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey);
      if (!p) return;

      // Beep tenue al primer detect del piloto seleccionado
      if (!selectedPilotFirstDetectBeeped) {
        selectedPilotFirstDetectBeeped = true;
        try { if (selectedPilotKey) firstDetectBeepedByPilot.set(selectedPilotKey, true); } catch(e) {}

        try { if (voiceMasterEnabled) playBeep('soft'); } catch(e) {}
      }

      const lapsNow = Number(p.lapcount) || 0;
      const idx = findPilotIndexByKey(selectedPilotKey);
      const hist = lapHistory.get(selectedPilotKey) || { lastLapcount: 0, times: [] };

      const lapMsNow = normalizeLapMs(p.lastTime);

      

      // Track de cambios de posición en este tick
      let posChangedTick = false;
      let posFrom = null;
      let posTo = null;
      let posDelta = 0;
// Helper
      const say = (m, opts) => speakWithLaps(lapsNow, m, opts);

      // Actualiza el modo desde raceName (ya viene de Firebase)
      if (raceData && raceData.raceName) {
        currentSessionInfo = parseSessionFromRaceName(raceData.raceName);
       try { applyLapChartPreset(); } catch(e) {}
try { maybeAutoApplySessionPreset(currentSessionInfo); } catch(e) {}
      }

      const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
      const isFinal = currentSessionInfo && currentSessionInfo.type === 'FINAL';

      // =========================
      // 1) Detecta eventos y genera pendientes (no habla aquí)
      // =========================

      // Posición (evento)
      if (p.pos && p.pos > 0) {
        if (lastKnownPos == null) lastKnownPos = p.pos;
        if (startPosForSelected == null) startPosForSelected = p.pos;

        // MANGA: estabilidad de posición (evita flip-flop en ranking por salida escalonada)
        if (isManga) {
          const curPos = Math.floor(p.pos);
          if (mangaPosStability.lastSeenPos == null) {
            mangaPosStability.lastSeenPos = curPos;
            mangaPosStability.stablePos = curPos;
            mangaPosStability.stableCount = 1;
          } else if (curPos === mangaPosStability.lastSeenPos) {
            mangaPosStability.stableCount = Math.min(10, (mangaPosStability.stableCount || 0) + 1);
            if (mangaPosStability.stableCount >= 2) mangaPosStability.stablePos = curPos;
          } else {
            mangaPosStability.lastSeenPos = curPos;
            mangaPosStability.stableCount = 1;
          }
        }

        if (p.pos !== lastKnownPos) {
          posChangedTick = true;
          posFrom = lastKnownPos;
          posTo = p.pos;
          posDelta = (Math.floor(posTo) - Math.floor(posFrom)); // + = cae, - = sube
        }
        // BASIC: estabilidad de posicion (no spam, solo cambios estables)
        if (!isManga && basicModeEnabled && voiceSettings.pos) {
          try{
            const curPosInt = Math.max(1, Math.floor(Number(p.pos) || 0));
            if (basicPosStability.candidatePos == null) {
              basicPosStability.candidatePos = curPosInt;
              basicPosStability.candidateCount = 1;
            } else if (curPosInt === basicPosStability.candidatePos) {
              basicPosStability.candidateCount = Math.min(6, (basicPosStability.candidateCount || 0) + 1);
            } else {
              basicPosStability.candidatePos = curPosInt;
              basicPosStability.candidateCount = 1;
            }

            if (basicPosStability.candidateCount >= 2 && basicPosStability.lastAnnouncedStablePos !== curPosInt) {
              basicPosStability.pendingStablePos = curPosInt;
            }

            const lapWillSpeak = (lapsNow > lastAnnouncedLapcount);
            if (lapWillSpeak && basicPosStability.pendingStablePos != null && basicPosStability.pendingStablePos !== basicPosStability.lastAnnouncedStablePos) {
              const stable = basicPosStability.pendingStablePos;
              pendingPosChange = {
                pos: stable,
                opts: { key: 'pos_basic_' + stable, priority: 75, cooldownMs: 1200, dedupe: true },
                expLap: lapsNow + 2
              };
              basicPosStability.lastAnnouncedStablePos = stable;
              basicPosStability.pendingStablePos = null;
            }
          }catch(e){}
        }

        // Mensaje corto de posicion: solo se agenda en paso por meta.
        // En MANGA (quali) NO se anuncia inmediato: se usa ventana de asentamiento post-cruce (start/tickMangaPosSettle).
        if (!basicModeEnabled && voiceSettings.pos && p.pos !== lastKnownPos) {
          const lapWillSpeak = (lapsNow > lastAnnouncedLapcount); // tu cruce por meta pendiente
          if (lapWillSpeak && !isManga) {
            const curPos = Math.floor(p.pos);
            pendingPosChange = {
              pos: curPos,
              opts: { key: 'pos_' + curPos, priority: 75, cooldownMs: 900, dedupe: true },
              expLap: lapsNow + 2
            };
          }
        }
        lastKnownPos = p.pos;
      }

      // NetGain (evento)
      if (voiceSettings.netgain && p.pos && p.pos > 0) {
        if (startPosForSelected == null) startPosForSelected = p.pos;
        const net = startPosForSelected - p.pos;
        if (lastNetGainValue == null) lastNetGainValue = net;

        if (net !== lastNetGainValue) {
          let t = '';
          if (net > 0) t = `Vas +${Math.floor(net)}`;
          else if (net < 0) t = `Vas ${Math.floor(net)}`; // net ya es negativo
          else t = 'Regresas a tu posición de salida';

          pendingNetGain = {
            text: t,
            opts: { key: 'netgain_' + lapsNow, priority: 35, cooldownMs: 2500, dedupe: true },
            expLap: lapsNow + 3,
            value: net
          };
          lastNetGainValue = net;
        }
      }
      // MANGA: cronmetro por piloto (salida escalonada)
      if (isManga) {
        updateMangaPilotStartsFromClassification((raceData && raceData.classification) ? raceData.classification : []);
      } else {
        if (mangaClockTimer) stopMangaClock();
      }
// Best lap (evento)
      if (voiceSettings.bestlap && lapMsNow && lapsNow > 0 && lapsNow !== lastBestAnnouncedLap) {
        const isNewBest = (lastBestAnnouncedMs == null) ? true : (lapMsNow < (lastBestAnnouncedMs - 30));
        if (isNewBest) {
          pendingBestLap = {
            text: 'Best lap ' + tiempoATexto(lapMsNow),
            opts: { key: 'bestlap_' + lapsNow, priority: 75, cooldownMs: 1500, dedupe: true },
            expLap: lapsNow + 2,
            ms: lapMsNow
          };
          lastBestAnnouncedMs = lapMsNow;
        }
        lastBestAnnouncedLap = lapsNow;
      }

      // Estimacin (evento, no spamea)
      if (voiceSettings.estlap) {
        const est = Number(p.estLap) || 0;
        if (est > 0) {
          // Solo si cambi contra la última estimacin hablada (no contra la vista)
          const estInt = Math.floor(est);
          const lastInt = (lastSpokenEstLap == null) ? null : Math.floor(lastSpokenEstLap);
          const changedEnough = (lastInt == null) ? true : (Math.abs(estInt - lastInt) >= 2);
          const spaced = (lapsNow - lastEstLapSpokenLap) >= 8;
          if ((changedEnough && spaced) || (spaced && (lapsNow - lastEstLapSpokenLap) >= 12)) {
            const palabra = est === 1 ? 'vuelta' : 'vueltas';
            pendingEstLap = {
              text: `Estimacin ${estInt} ${palabra}`,
              opts: { dedupe: true },
              expLap: lapsNow + 6,
              est: est
            };
          }
        }
      }

      // Bandera azul (pendiente que ya arma el detector por pasos de meta)
      if (voiceSettings.blueflag) {
        updateBlueFlagFromPassEvents();
      }

      // Expira pendientes viejas
      if (pendingPosChange && pendingPosChange.expLap != null && lapsNow > pendingPosChange.expLap) pendingPosChange = null;
      if (pendingNetGain && pendingNetGain.expLap != null && lapsNow > pendingNetGain.expLap) pendingNetGain = null;
      if (pendingBestLap && pendingBestLap.expLap != null && lapsNow > pendingBestLap.expLap) pendingBestLap = null;
      if (pendingEstLap && pendingEstLap.expLap != null && lapsNow > pendingEstLap.expLap) pendingEstLap = null;

      // MANGA: ventana de asentamiento de posicion (ranking por tiempo)
      if (isManga && voiceSettings.pos) {
        tickMangaPosSettle(lapsNow, (p && p.pos != null) ? p.pos : null);
      }

      // =========================
      // 2) Laps siempre primero (bloqueado)
      // =========================
      const lapCrossed = (voiceSettings.laps && lapsNow > 0 && lapsNow !== lastAnnouncedLapcount);

      if (lapCrossed) {
        // Beep SIEMPRE en seguimiento al cerrar vuelta:
        // - Agudo si mejoras vs tu vuelta anterior
        // - Grave si empeoras
        // - Si no hay referencia, agudo (marca cierre de vuelta)
        let __didLapBeep = false;
        if (lapMsNow) {
          if (lastSpokenLastTime && lastSpokenLastTime > 0) {
            if (lapMsNow < (lastSpokenLastTime - 20)) { playBeep('lapUp'); __didLapBeep = true; }
            else if (lapMsNow > (lastSpokenLastTime + 20)) { playBeep('lapDown'); __didLapBeep = true; }
          }
          if (!__didLapBeep) { try { playBeep('lapUp'); } catch(e) {} }
          say(tiempoATexto(lapMsNow), { key: 'lap_' + lapsNow, priority: 90, dedupe: true });
          flashLastLap();
          lastSpokenLastTime = lapMsNow;
        } else {
          // Sin tiempo, igual marcamos cierre de vuelta con beep.
          try { playBeep('lapUp'); } catch(e) {}
        }
        lastAnnouncedLapcount = lapsNow;

        // MANGA: ventana de asentamiento para posición (ranking por tiempo)
        if (isManga && voiceSettings.pos) {
          startMangaPosSettle(lapsNow, p && p.pos != null ? p.pos : null);
        }

      } else {
        // Sin paso por meta: en MANGA normalmente nos quedamos callados (la tabla brinca por salida escalonada).
        // EXCEPCION: si ya vencio la ventana de asentamiento, podemos decir la posicion estable aun sin cruce.
        if (isManga && voiceSettings.pos && pendingPosChange && pendingPosChange.pos) {
          try {
            const sp = Math.floor(pendingPosChange.pos);
            say('P' + sp, (pendingPosChange.opts || { key: 'pos_manga_' + sp + '_' + lapsNow, priority: 65, cooldownMs: 1400, dedupe: true }));
            mangaPosStability.lastAnnouncedStablePos = sp;
          } catch(e) {}
          pendingPosChange = null;
        }

        // En FINAL podemos avisar breve si te mueven de posicion sin tu cruce.
        if (!isManga && !basicModeEnabled && posChangedTick && voiceSettings.pos) {
          handlePositionChangeNoLap(posFrom, posTo, posDelta);
        }
        return;
      }

      // =========================
      // 3) AI Director: elige 1 o 2 mensajes extra post-Laps (segn situacin)
      // =========================
      const candidates = [];

      const pushCand = (id, score, text, opts, onCommit) => {
        if (!text) return;
        candidates.push({ id, score, text, opts: (opts || {}), onCommit });
      };

      // Contexto front/back
      const ctx = (idx >= 0) ? getFrontBackContext(idx) : null;

      // Marca de batalla en Lap Chart (ATK/DEF/DUEL) - se marca SOLO en cruce de meta
try {
  if (lapCrossed && ctx && selectedPilotKey) {
    const isManga = (currentSessionInfo && currentSessionInfo.type === 'MANGA');
    const thr = isManga ? 0.55 : 0.60;

    const f = (ctx.sameFrontLap && ctx.frontSec != null && isFinite(ctx.frontSec)) ? Number(ctx.frontSec) : null;
    const b = (ctx.sameBackLap  && ctx.backSec  != null && isFinite(ctx.backSec))  ? Number(ctx.backSec)  : null;

    const atk = (f != null && f <= thr);
    const def = (b != null && b <= thr);

    let tag = null;
    if (atk && def) tag = 'DUEL';
    else if (atk) tag = 'ATK';
    else if (def) tag = 'DEF';

    if (tag) setLastLapMark(selectedPilotKey, tag);
  }
} catch (e) {}

      // Azul (si hay pendiente para este piloto)
      if (voiceSettings.blueflag &&
          pendingBlueFlagForPilotKey &&
          pendingBlueFlagForPilotKey === selectedPilotKey &&
          pendingBlueFlagMessage) {
        pushCand('blueflag', isFinal ? 100 : 90, pendingBlueFlagMessage,
          { key: 'blueflag_' + lapsNow, priority: 80, cooldownMs: 4000, dedupe: true, interrupt: false },
          () => {
            pendingBlueFlagForPilotKey = '';
            pendingBlueFlagMessage = '';
            lastBlueFlagPilotLap = lapsNow;
          }
        );
      }

      // Pendientes (eventos)
      if (voiceSettings.bestlap && pendingBestLap) {
        pushCand('bestlap', isManga ? 98 : 75, pendingBestLap.text, pendingBestLap.opts, () => {
          pendingBestLap = null;
        });
      }

      if (pendingPosChange && voiceSettings.pos) {
        // Posición con nombres (adelante/atrs) para que sea realmente til
        const ppos = (pendingPosChange.pos != null) ? pendingPosChange.pos : (p && p.pos ? Math.floor(p.pos) : 0);
        let extra = '';
        if (ctx && !basicModeEnabled) {
          const fn = ctx.frontName ? safeRacerName(ctx.frontName) : '';
          const bn = ctx.backName ? safeRacerName(ctx.backName) : '';
          if (fn && bn) extra = `. Adelante ${fn}, atrs ${bn}`;
          else if (fn) extra = `. Adelante ${fn}`;
          else if (bn) extra = `. Atrs ${bn}`;
        }
        const text = ppos ? (`P${ppos}${extra}`) : (pendingPosChange.text || '');
        pushCand('pos', isFinal ? 92 : 35, text, (pendingPosChange.opts || { key:'pos_'+lapsNow, priority:75, cooldownMs:900, dedupe: true }), () => {
          if (isManga && pendingPosChange && pendingPosChange._mangaStablePos != null) {
            mangaPosStability.lastAnnouncedStablePos = pendingPosChange._mangaStablePos;
          }
          pendingPosChange = null;
        });
      }

      if (voiceSettings.netgain && pendingNetGain) {
        pushCand('netgain', isFinal ? 45 : 25, pendingNetGain.text, pendingNetGain.opts, () => {
          pendingNetGain = null;
          lastNetGainSpokenLap = lapsNow;
        });
      }

      if (voiceSettings.estlap && pendingEstLap) {
        pushCand('estlap', isManga ? 55 : 30, pendingEstLap.text, pendingEstLap.opts, () => {
          lastSpokenEstLap = pendingEstLap.est;
          lastEstLapSpokenLap = lapsNow;
          pendingEstLap = null;
        });
      }

      // Adelante y atras < 0.6 (con latch)
      if (ctx && voiceSettings.front06 && ctx.sameFrontLap && ctx.frontSec != null) {
        const sec = ctx.frontSec;
        const otherKey = ctx.frontKey || 'front';
        if (ahead06Latch.active) {
          if (ahead06Latch.otherKey !== otherKey || sec >= 0.80 || !ctx.sameFrontLap) {
            ahead06Latch.active = false;
          }
        }
        if (!ahead06Latch.active && sec < 0.6) {
          const secStr = toFixedFloor(sec, decimalPrecision);
          const nm = ctx.frontName || '';
          const txt = nm ? ('Adelante a tiro. ' + nm + ' a ' + secStr + ' segundos') : ('Adelante a tiro. A ' + secStr + ' segundos');
          pushCand('front06', isFinal ? 70 : 18, txt,
            { key: 'front06_' + otherKey, priority: 55, cooldownMs: 2500, dedupe: true },
            () => {
              ahead06Latch.active = true;
              ahead06Latch.otherKey = otherKey;
              ahead06Latch.lap = lapsNow;
              lastAheadAlertMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
            }
          );
        }
      }

      if (ctx && voiceSettings.back06 && ctx.sameBackLap && ctx.backSec != null) {
        const sec = ctx.backSec;
        const otherKey = ctx.backKey || 'back';
        if (behind06Latch.active) {
          if (behind06Latch.otherKey !== otherKey || sec >= 0.80 || !ctx.sameBackLap) {
            behind06Latch.active = false;
          }
        }
        if (!behind06Latch.active && sec < 0.6) {
          const secStr = toFixedFloor(sec, decimalPrecision);
          const nm = ctx.backName || '';
          const txt = nm ? ('Atras presin. ' + nm + ' a ' + secStr + ' segundos') : ('Atras presin. A ' + secStr + ' segundos');
          pushCand('back06', isFinal ? 70 : 18, txt,
            { key: 'back06_' + otherKey, priority: 55, cooldownMs: 2500, dedupe: true },
            () => {
              behind06Latch.active = true;
              behind06Latch.otherKey = otherKey;
              behind06Latch.lap = lapsNow;
              lastBehindAlertMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
            }
          );
        }
      }

      // Ataque / Defensa / DUEL (EMA + histeresis)
      // - Usa ctx.duelActive + ctx.duelKind (ATTACK/DEFEND)
      // - Gap suavizado: ctx.frontSecEma / ctx.backSecEma
      if (ctx && (voiceSettings.attack || voiceSettings.defense) && ctx.duelActive) {
        // ATTACK
        if (voiceSettings.attack && ctx.duelKind === 'ATTACK' && ctx.sameFrontLap && ctx.frontSecEma != null) {
          const sec = ctx.frontSecEma;
          const otherKey = ctx.frontKey || 'front';
          if (attackLatch.active) {
            if (attackLatch.otherKey !== otherKey || !ctx.duelActive || ctx.duelKind !== 'ATTACK') {
              attackLatch.active = false;
            }
          }
          if (!attackLatch.active) {
            const secStr = gapToSpeech(sec, 'attack');
            const nm = ctx.frontName || '';
            const txt = nm ? ('Ataque. ' + nm + ' a ' + secStr) : ('Ataque. Adelante a ' + secStr);
            pushCand('attack', isFinal ? 88 : 22, txt,
              { key: 'attack_' + Math.floor(lapsNow/2), priority: 70, cooldownMs: 4200, dedupe: true },
              () => {
                attackLatch.active = true;
                attackLatch.otherKey = otherKey;
                attackLatch.lap = lapsNow;
              }
            );
          }
        } else {
          attackLatch.active = false;
        }

        // DEFEND
        if (voiceSettings.defense && ctx.duelKind === 'DEFEND' && ctx.sameBackLap && ctx.backSecEma != null) {
          const sec = ctx.backSecEma;
          const otherKey = ctx.backKey || 'back';
          if (defenseLatch.active) {
            if (defenseLatch.otherKey !== otherKey || !ctx.duelActive || ctx.duelKind !== 'DEFEND') {
              defenseLatch.active = false;
            }
          }
          if (!defenseLatch.active) {
            const secStr = gapToSpeech(sec, 'defense');
            const nm = ctx.backName || '';
            const txt = nm ? ('Defensa. ' + nm + ' viene ' + secStr) : ('Defensa. Atras viene ' + secStr);
            pushCand('defense', isFinal ? 88 : 22, txt,
              { key: 'defense_' + Math.floor(lapsNow/2), priority: 70, cooldownMs: 4200, dedupe: true },
              () => {
                defenseLatch.active = true;
                defenseLatch.otherKey = otherKey;
                defenseLatch.lap = lapsNow;
              }
            );
          }
        } else {
          defenseLatch.active = false;
        }
      } else {
        attackLatch.active = false;
        defenseLatch.active = false;
      }

      // Pelea cerrada (encajonado) - usa gaps suavizados cuando esten disponibles
      if (ctx && voiceSettings.pelea && ctx.sameFrontLap && ctx.sameBackLap) {
        const f = (ctx.frontSecEma != null ? ctx.frontSecEma : ctx.frontSec);
        const b = (ctx.backSecEma  != null ? ctx.backSecEma  : ctx.backSec);
        const inFight = (f != null && b != null && f < 0.70 && b < 0.70);
        if (fightLatch.active) {
          if (!inFight || (f != null && f >= 1.10) || (b != null && b >= 1.10)) {
            fightLatch.active = false;
          }
        }
        if (!fightLatch.active && inFight) {
          pushCand('fight', isFinal ? 78 : 18, 'Pelea cerrada',
            { key: 'fight_' + Math.floor(lapsNow/2), priority: 66, cooldownMs: 5200, dedupe: true },
            () => {
              fightLatch.active = true;
              fightLatch.lap = lapsNow;
            }
          );
        }
      } else {
        fightLatch.active = false;
      }

      // Podio (solo si tiene sentido)
      if (voiceSettings.podium && isFinal && lapsNow > 0 && p.pos && p.pos > 3) {
        if (lapsNow % 3 === 0 && (!lastPodiumSpokenLap || (lapsNow - lastPodiumSpokenLap) >= 3)) {
          const third = raceData.classification.find(r => r.pos === 3);
          if (third && third.time != null && p.time != null) {
            const meLaps = (p.lapcount != null) ? p.lapcount : 0;
            const thirdLaps = (third.lapcount != null) ? third.lapcount : 0;
            const lapDiff = thirdLaps - meLaps;

            if (lapDiff !== 0) {
              const v = Math.abs(lapDiff);
              const palabra = (v === 1) ? 'una vuelta' : (v + ' vueltas');
              pushCand('podium', 55, 'Podio mas ' + palabra,
                { key: 'podio_laps_' + lapsNow, priority: 60, cooldownMs: 2500, dedupe: true },
                () => { lastPodiumSpokenLap = lapsNow; }
              );
            } else {
              const diffMs = p.time - third.time;
              if (diffMs && diffMs > 0) {
                const sec = diffMs / 1000;
                if (sec <= 3.0) {
                  const secStr = gapToSpeech(sec, 'podium');
                  pushCand('podium', 65, 'Podio ' + secStr,
                    { key: 'podio_' + Math.floor(lapsNow/3), priority: 60, cooldownMs: 2500, dedupe: true },
                    () => { lastPodiumSpokenLap = lapsNow; }
                  );
                }
              }
            }
          }
        }
      }

      // Diferencia adelante/atrs (cada 3 vueltas)
      if (voiceSettings.gaps && idx >= 0 && lapsNow > 0 && ((isManga && (lapsNow % 4 === 0)) || (!isManga && (lapsNow % 3 === 0)))) {
        const msg = buildGapSummaryForPilotIndex(idx);
        if (msg) {
          pushCand('gaps', isFinal ? 40 : 15, msg,
            { key: 'gaps_' + Math.floor(lapsNow/3), priority: 40, cooldownMs: 1800, dedupe: true },
            () => { lastGapInfoLap = lapsNow; }
          );
        }
      }

      // Referencia al líder (cada 3 vueltas)
      if (voiceSettings.leadergap && lapsNow > 0 && ((isManga && (lapsNow % 5 === 0)) || (!isManga && (lapsNow % 3 === 0)))) {
        const leader = raceData.classification.find(r => r.pos === 1);
        if (leader && leader.time != null && p.time != null) {
          const meLaps = (p.lapcount != null) ? p.lapcount : 0;
          const lLaps  = (leader.lapcount != null) ? leader.lapcount : 0;
          const lapDiff = lLaps - meLaps;

          let msg = '';
          if (lapDiff !== 0) {
            const v = Math.abs(lapDiff);
            msg = (v === 1) ? 'Lider mas una vuelta' : ('Lider mas ' + v + ' vueltas');
          } else {
            const diffMs = p.time - leader.time;
            if (diffMs && diffMs > 0) {
              const sec = diffMs / 1000;
              const secStr = gapToSpeech(sec, 'leader');
              msg = 'Lider ' + secStr;
            }
          }
          if (msg) {
            pushCand('leader', isFinal ? 38 : 12, msg,
              { dedupe: true },
              () => { lastLeaderGapSpokenLap = lapsNow; }
            );
          }
        }
      }

      // Ritmo (cada 3 vueltas, sin palabreria)
      if (voiceSettings.ritmo && lapsNow > 0 && lapsNow % 3 === 0) {
        const t = (hist.times || []).filter(isLapPlausible);
        const last3 = t.slice(-3);
        const prev3 = t.slice(-6, -3);
        if (last3.length === 3 && prev3.length === 3) {
          const avgLast = last3.reduce((a,b)=>a+b,0) / 3;
          const avgPrev = prev3.reduce((a,b)=>a+b,0) / 3;
          const diff = avgPrev - avgLast; // positivo = mejoraste
          if (diff > 120) {
            pushCand('ritmo_up', isManga ? 72 : 28, 'Ritmo subiendo',
              { key: 'ritmo_up_' + Math.floor(lapsNow/3), priority: 30, cooldownMs: 2500, dedupe: true },
              () => { lastTrendSpokenLap = lapsNow; }
            );
          } else if (diff < -120) {
            pushCand('ritmo_down', isManga ? 72 : 28, 'Ritmo bajando',
              { key: 'ritmo_down_' + Math.floor(lapsNow/3), priority: 30, cooldownMs: 2500, dedupe: true },
              () => { lastTrendSpokenLap = lapsNow; }
            );
          }
        }
      }

      // Total (cada 1 minuto)
      if (voiceSettings.total && p.time && p.time > 0) {
        const totalSeconds = Math.floor(p.time / 1000);
        if (totalSeconds - lastTotalTimeAnnouncedSeconds >= 60) {
          const texto = tiempoATexto(p.time);
          pushCand('total', isManga ? 32 : 18, 'Total ' + texto,
            { key: 'total_' + Math.floor(totalSeconds/60), priority: 20, dedupe: true },
            () => { lastTotalTimeAnnouncedSeconds = totalSeconds; }
          );
        }
      }

      // Consistencia (cada 10 vueltas)
      if (voiceSettings.cons10 && lapsNow >= 10 && (lapsNow % 10 === 0) && (lapsNow !== lastConsistencySpokenLap)) {
        const pct = getConsistencyFromFirebase(p);
        if (pct) {
          pushCand('cons10', isManga ? 60 : 24, 'Consistencia ' + pct + ' por ciento',
            { key: 'cons10_' + lapsNow, priority: 28, cooldownMs: 2500, dedupe: true },
            () => { lastConsistencySpokenLap = lapsNow; }
          );
        }
      }

      // Box (cada 20 vueltas o cada 2 min, lo que llegue primero)
      if (voiceSettings.box) {
        const totalSeconds = p.time ? Math.floor(p.time / 1000) : 0;
        const byTime = totalSeconds && (totalSeconds - lastAutoSummaryAnnouncedSeconds >= 120);
        const byLap  = lapsNow > 0 && (lapsNow % 20 === 0);

        if (byTime || byLap) {
          const posTxt = (p.pos && p.pos > 0) ? ('P ' + Math.floor(p.pos)) : '';
          const gapTxt = formatoGapVueltas(p.gap) ? ('Gap ' + formatoGapVueltas(p.gap)) : '';
          const bestTxt = p.best ? msToMinSec(p.best) : '';
          let msg = '';
          if (posTxt) msg += posTxt + '. ';
          if (gapTxt) msg += gapTxt + '. ';
          if (bestTxt) msg += 'Best lap ' + bestTxt + '. ';
          msg = msg.trim();
          if (msg) {
            pushCand('box', isFinal ? 22 : 40, msg,
              { key: 'box_' + Math.floor(totalSeconds/120) + '_' + Math.floor(lapsNow/20), priority: 18, cooldownMs: 2500, dedupe: true },
              () => { lastAutoSummaryAnnouncedSeconds = totalSeconds; }
            );
          }
        }
      }

      // Si no hay nada, listo
      if (!candidates.length) return;

      
      // RD anti-repeat penalty: baja score si acaba de decir lo mismo (sin bloquear crticos)
      const rdModeLocal = (raceDirectorMode === 'minimal' || raceDirectorMode === 'stratega' || raceDirectorMode === 'coach') ? raceDirectorMode : 'stratega';
      const ttlId = (rdModeLocal === 'minimal') ? 4 : 2;
      const ttlTxt = (rdModeLocal === 'minimal') ? 4 : 3;
      const criticalIds = isManga
        ? new Set(['blueflag','podium'])
        : new Set(['blueflag','pos','back06','front06','fight','attack','defense','podium','leader']);
      for (const c of candidates) {
        if (!c) continue;
        if (!criticalIds.has(c.id)) {
          const lastId = rdLastIdLap.get(c.id) || 0;
          if (lapsNow > 0 && (lapsNow - lastId) > 0 && (lapsNow - lastId) < ttlId) c.score -= 12;
          const lastTx = rdLastTextLap.get(c.text) || 0;
          if (lapsNow > 0 && (lapsNow - lastTx) > 0 && (lapsNow - lastTx) < ttlTxt) c.score -= 10;
        }
      }

// Orden: mayor score, luego mayor prioridad
      candidates.sort((a,b) => (b.score - a.score) || (((b.opts && b.opts.priority) ? b.opts.priority : 0) - ((a.opts && a.opts.priority) ? a.opts.priority : 0)));

      // =========================
      // Manual (RD OFF): habla lo encendido, con lmite para no spamear
      // =========================
      const rdOn = !!raceDirectorEnabled;

      if (!rdOn) {
        // MANGA: no hablar entre metas (salida escalonada + 1 sensor)
        if (isManga && !lapCrossed) return;
        const maxSpoken = 1;// Arbiter: 1 extra max
        let spoken = 0;
        for (const c of candidates) {
          if (!c || !c.text) continue;
          if (c.score < 18) continue;

          const tTry = rdTrimWords(c.text, 16);

          // MANGA: anti-repeat por TEXTO aunque el evento cambie
          if (isManga) {
            const lastTxtLap = rdLastTextLap.get(tTry) || 0;
            if (lastTxtLap && (lapsNow - lastTxtLap) > 0 && (lapsNow - lastTxtLap) < 4) continue;
          }

          say(tTry, c.opts || {});
          rdLastIdLap.set(c.id, lapsNow);
          rdLastTextLap.set(tTry, lapsNow);

          try { if (typeof c.onCommit === 'function') c.onCommit(); } catch (e) {}
          spoken++;
          if (spoken >= maxSpoken) break;
        }
        return;
      }

      // =========================
      
      // =========================
      // RD ON: elige 1 o 2 mensajes segn situacin (humano, no metralleta)
      // MANGA: solo hablar en tu cruce por meta
      if (isManga && !lapCrossed) return;

      // =========================
      const posNowRD = Number(p.position) || 0;
      const tierRD = (posNowRD > 0 && posNowRD <= 3) ? 'front' : ((posNowRD > 0 && posNowRD <= 10) ? 'mid' : 'back');

      // Anti-repeticin dura (por id y por texto). No bloquea crticos.
      const ttlById = (id) => (id === 'estlap' ? 10 : (id === 'pos' ? 2 : ttlId));
      const ttlByTxt = (id) => (id === 'estlap' ? 10 : ttlTxt);

      const tooSoonId = (id) => {
        const last = rdLastIdLap.get(id) || 0;
        const ttl = ttlById(id);
        return last && (lapsNow - last) > 0 && (lapsNow - last) < ttl;
      };
      const tooSoonTxt = (id, text) => {
        const last = rdLastTextLap.get(text) || 0;
        const ttl = ttlByTxt(id);
        return last && (lapsNow - last) > 0 && (lapsNow - last) < ttl;
      };

      // Pick 1
      let pick1 = null;
      let t1 = '';
      for (const c of candidates) {
        if (!c || !c.text) continue;
        const tTry = rdTrimWords(rdMakeText(c.id, c.text, rdBuildCtx({ tier: tierRD, isManga, ...ctx }, p)), 12);
        if (!criticalIds.has(c.id)) {
          if (tooSoonId(c.id)) continue;
          if (tooSoonTxt(c.id, tTry)) continue;
        }
        pick1 = c;
        t1 = tTry;
        break;
      }

      if (pick1) {
        say(t1, pick1.opts || {});
        rdLastIdLap.set(pick1.id, lapsNow);
        rdLastTextLap.set(t1, lapsNow);
        try { if (typeof pick1.onCommit === 'function') pick1.onCommit(); } catch (e) {}
        // Arbitro: 1 solo mensaje extra por cruce (ademas del lap time).
        return;
      }
      return;
    }

speakBtn.addEventListener('click', () => {
      if (!raceData || !Array.isArray(raceData.classification) || !selectedPilotKey) return;
      const p = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey);
      if (!p) return;

      // Beep tenue al primer detect del piloto seleccionado
      if (!selectedPilotFirstDetectBeeped) {
        selectedPilotFirstDetectBeeped = true;
        try { if (selectedPilotKey) firstDetectBeepedByPilot.set(selectedPilotKey, true); } catch(e) {}

        try { if (voiceMasterEnabled) playBeep('soft'); } catch(e) {}
      }
      const pos = p.pos || '-';
      const laps = p.lapcount != null ? p.lapcount : 0;
      const key = getPilotKey(p);
      const hist = lapHistory.get(key) || { lastLapcount: 0, times: [] };
      const times = (hist.times || []).filter(isLapPlausible);
      const computed = statsFromTimes(times);
      const consPct = getConsistencyFromFirebase(p);

      // Mostrar consistencia (feed) y  (historial lap chart)
      try {
        if (consistencyValEl) consistencyValEl.textContent = consPct ? (consPct + '%') : '--%';
      } catch(e) {}
      try {
        const sig = (computed && computed.sigma && isFinite(computed.sigma)) ? (computed.sigma / 1000) : NaN;
        if (sigmaValEl) sigmaValEl.textContent = (isFinite(sig) && sig > 0) ? sig.toFixed(3) : '-.---';
      } catch(e) {}

      let bestMsFinal = isLapPlausible(p.best) ? p.best : (computed.best || 0);
      if (computed.best && (!bestMsFinal || computed.best < bestMsFinal)) bestMsFinal = computed.best;

      const meanMsFinal = isLapPlausible(p.mean) ? p.mean : (computed.mean || 0);

      const bestTxt = bestMsFinal ? tiempoATexto(bestMsFinal) : '';
      const meanTxt = meanMsFinal ? tiempoATexto(meanMsFinal) : '';
      const gapTxt = formatoGapVueltas(p.gap);
      let msg = `Posición ${pos}. `;
      if (bestTxt) msg += `Best lap ${bestTxt}. `;
      if (meanTxt) msg += `Promedio ${meanTxt}. `;
      if (gapTxt) msg += `Diferencia ${gapTxt}. `;
      if (consPct) msg += `Consistencia ${consPct} por ciento.`;
      speakText(msg);
    });

        // =========================
    // Modo de sesin (AUTO desde raceName)
    // =========================
    var currentSessionInfo = { type: 'UNKNOWN', main: '', durationMs: 0, label: 'MODO -' };
    // =========================
    // LapChart scale preset por modo (MANGA vs FINAL A vs Finales bajas)
    // =========================
    var _lapChartPresetKey = '';
    function getLapChartPreset(){
      const info = currentSessionInfo || {};
      const type = String(info.type || '').toUpperCase();
      const main = String(info.main || '').toUpperCase();

      // Defaults
      let N = 40;         // ventana de vueltas en la grafica
      let pad = 2200;     // margen vertical (ms) para escala
      let maxCap = 130000;// cap maximo de escala vertical (ms)
      let cssH = 120;     // alto visual del canvas (px)

      if (type === 'MANGA') {
        // Qualy: zoom mas apretado y ventana mas corta (cambios rapidos)
        N = 28;
        pad = 2000;
        maxCap = 130000;
        cssH = 120;
      } else if (type === 'FINAL') {
        if (main === 'A') {
          // Final A: mas vueltas, grafica mas alta
          N = 55;
          pad = 3200;
          maxCap = 150000;
          cssH = 140;
        } else {
          // Finales bajas (B/C/D): mas variacion, margen mas amplio
          N = 45;
          pad = 4200;
          maxCap = 160000;
          cssH = 132;
        }
      }
      return { N, pad, maxCap, cssH };
    }

    // LapChart - Eje X por TIEMPO (no por vueltas)
    // - Manga: 3:00 + fraccion
    // - Finales bajas: 4:00 + fraccion
    // - Final A: 6:00 + fraccion
    // Nota: usamos currentSessionInfo.durationMs como base y agregamos un margen para cubrir la "fraccion".
    function getLapChartXMaxMs(lastElapsedMs){
      const info = currentSessionInfo || {};
      const type = String(info.type || '').toUpperCase();
      const main = String(info.main || '').toUpperCase();
      const base = Number(info.durationMs) || 0;

      let extra = 0;
      if (type === 'MANGA') extra = 15000;                 // +15s
      else if (type === 'FINAL') extra = (main === 'A') ? 25000 : 20000; // +25s A, +20s bajas

      let xMax = base ? (base + extra) : 0;

      const last = Number(lastElapsedMs) || 0;
      if (!xMax) xMax = Math.max(120000, last + 2000); // fallback 2:00 min
      else if (last > xMax) xMax = Math.max(xMax, last + 2000);

      return xMax;
    }


    function applyLapChartPreset(){
      try{
        const p = getLapChartPreset();
        const key = `${p.N}|${p.pad}|${p.maxCap}|${p.cssH}`;
        if (key === _lapChartPresetKey) return;
        _lapChartPresetKey = key;
        // Ajusta alto del canvas via CSS var (sin tocar layout global)
        document.documentElement.style.setProperty('--lapchart-h', `${p.cssH}px`);
      } catch(e){}
    }


    function parseSessionFromRaceName(raceName) {
      const name = String(raceName || '').toUpperCase();
      const isManga = /MANGA/.test(name) || /Q\d/.test(name) || /QUALY|QUALI|CLASIF|CLASIFIC/.test(name) || /HEAT|ROUND/.test(name);
      const isFinal = /FINAL/.test(name) || /A\s*MAIN|B\s*MAIN|C\s*MAIN/.test(name) || /\bMAIN\b/.test(name);

      let main = '';
      // Busca "MANGA A" o "FINAL A" o "A MAIN" (soporta tambien D)
      const m1 = name.match(/\bMANGA\s*([A-D])\b/);
      const m2 = name.match(/\bFINAL\s*([A-D])\b/);
      const m3 = name.match(/\b([A-D])\s*MAIN\b/);
      if (m1 && m1[1]) main = m1[1];
      else if (m2 && m2[1]) main = m2[1];
      else if (m3 && m3[1]) main = m3[1];

      let type = 'UNKNOWN';
      if (isManga && !isFinal) type = 'MANGA';
      else if (isFinal && !isManga) type = 'FINAL';
      else if (isFinal && isManga) type = 'FINAL'; // preferimos FINAL si viene mezclado
      else if (isManga) type = 'MANGA';

      let durationMs = 0;
      if (type === 'MANGA') durationMs = 3 * 60 * 1000;
      if (type === 'FINAL') {
        // Final A = 6:00, Finales B/C/D... = 4:00
        const m = String(main || '').toUpperCase();
        durationMs = (m === 'A') ? (6 * 60 * 1000) : (4 * 60 * 1000);
      }

let label = 'MODO -';
      if (type === 'MANGA') label = 'MODO MANGA 3:00';
      if (type === 'FINAL') {
        const m = String(main || '').toUpperCase();
        const d = (m === 'A') ? '6:00' : '4:00';
        label = m ? ('MODO FINAL ' + m + ' ' + d) : ('MODO FINAL ' + d);
      }

      // Spoken title (para TTS)
      let spokenTitle = '';
      const serieM = name.match(/\bSERIE\s*(\d+)\b/);
      const serie = (serieM && serieM[1]) ? String(serieM[1]) : '';

      // Qx y Manga X (para TTS en titulo)
      const qM = name.match(/\bQ\s*(\d+)\b/);
      const q = (qM && qM[1]) ? String(qM[1]) : '';
      // MANGA 1 / HEAT 1 / ROUND 1 (fallback numerico)
      const mangaM = name.match(/\bMANGA\s*(\d+)\b/) || name.match(/\bHEAT\s*(\d+)\b/) || name.match(/\bROUND\s*(\d+)\b/);
      const mangaNo = (mangaM && mangaM[1]) ? String(mangaM[1]) : '';

      // Spoken title (TTS) - sin acentos (mejor compat iOS/Android)
      if (type === 'MANGA') {
        const parts = ['Clasificacion'];
        if (q) parts.push('Q' + q);
        if (main) parts.push('Manga ' + main);
        else if (mangaNo) parts.push('Manga ' + mangaNo);
        if (serie) parts.push('Serie ' + serie);
        spokenTitle = parts.join(', ');
      } else if (type === 'FINAL') {
        const parts = [main ? ('Final ' + main) : 'Final'];
        if (serie) parts.push('Serie ' + serie);
        spokenTitle = parts.join(', ');
      } else {
        spokenTitle = '';
      }

      return { type, main, durationMs, label, spokenTitle, serie, q, mangaNo };
    }

// =========================
// FIN DE SESIN (por duracin)
// - MANGA: 3:00 -> "Termin la clasificacin"
// - FINAL: segn modo (A=6:00, otras=4:00) -> "Carrera terminada" + posición + resumen
// Dispara SOLO cuando tu tiempo total cruza el lmite EN UNA NUEVA VUELTA.
// =========================
let sessionFinishSig = '';
let sessionFinishAnnounced = false;
let sessionFinishPrevByKey = new Map(); // key -> { laps, totalMs }

function getRowTotalMs(row) {
  try {
    return parseTimeToMs(
      (typeof row.time !== 'undefined' ? row.time :
       (typeof row.totalTime !== 'undefined' ? row.totalTime :
        (typeof row.totalMs !== 'undefined' ? row.totalMs :
         (typeof row.totalTimeMs !== 'undefined' ? row.totalTimeMs :
          (typeof row.estTime !== 'undefined' ? row.estTime : 0)))))
    ) || 0;
  } catch(e) { return 0; }
}

function getBestMsForRow(row) {
  let bestMs = 0;
  try {
    if (row && isLapPlausible(row.best)) bestMs = row.best;
  } catch(e) {}
  try {
    const k = getPilotKey(row);
    const hist = k ? lapHistory.get(k) : null;
    const hb = hist && hist.bestMs ? hist.bestMs : 0;
    if (isLapPlausible(hb) && (!bestMs || hb < bestMs)) bestMs = hb;
  } catch(e) {}
  return bestMs || 0;
}

function buildSessionFinishMessage(row) {
  const info = currentSessionInfo || {};
  const type = String(info.type || '').toUpperCase();
  const isManga = (type === 'MANGA');
  const isFinal = (type === 'FINAL');

  const posNum = row && row.pos ? Number(row.pos) : 0;
  const laps = Number(row && (row.lapcount ?? row.laps ?? 0)) || 0;
  const totalMs = getRowTotalMs(row) || 0;

  let msg = isManga ? 'Termin la clasificacin.' : 'Carrera terminada.';

  // Resultado (si sabemos posición)
  if (posNum > 0) msg += ' P' + posNum + '.';

  // Vueltas y tiempo total (si existen)
  if (laps > 0) msg += ' ' + laps + ' vueltas.';
  if (totalMs > 0) msg += ' Tiempo total ' + formatClockMs(totalMs) + '.';

  // Resumen extra para finales cuando hay podio
  if (isFinal && posNum > 0) {
    if (posNum === 1) msg += ' Felicidades, campeón.';
    else if (posNum === 2) msg += ' Segundo lugar. Podio.';
    else if (posNum === 3) msg += ' Tercer lugar. Podio.';
    else if (posNum <= 10) msg += ' Top 10. Buen cierre.';
  }

  // Best lap si existe
  const bestMs = getBestMsForRow(row);
  if (bestMs) msg += ' Mejor vuelta ' + tiempoATexto(bestMs) + '.';

  return msg;
}

function checkSessionFinishOnLap() {
  try {
    if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) return;

    const rn = String(raceData.raceName || '');
    if (rn !== sessionFinishSig) {
      sessionFinishSig = rn;
      sessionFinishAnnounced = false;
      sessionFinishPrevByKey = new Map();
    }

    const info = currentSessionInfo || {};
    const dur = Number(info.durationMs) || 0;
    if (!dur) return;

    // Elegimos piloto seleccionado; si no hay, usamos líder
    let row = null;
    if (selectedPilotKey) {
      row = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey) || null;
    }
    if (!row) row = raceData.classification.find(r => r.pos === 1) || raceData.classification[0];
    if (!row) return;

    const key = getPilotKey(row) || '__';
    const laps = Number(row.lapcount) || 0;
    const totalMs = getRowTotalMs(row) || 0;

    const prev = sessionFinishPrevByKey.get(key) || { laps: 0, totalMs: 0 };
    sessionFinishPrevByKey.set(key, { laps, totalMs });

    if (sessionFinishAnnounced) return;
    if (!isFinite(totalMs) || totalMs <= 0) return;

    // Solo disparar cuando sube una vuelta
    if (laps <= (prev.laps || 0)) return;

    // Condicin: cruz el lmite en la última vuelta
    if (totalMs < dur) return;

    const msg = buildSessionFinishMessage(row);
    enqueueSpeech(msg, {
      key: 'session_finish_' + sessionFinishSig,
      priority: 97,
      cooldownMs: 0,
          dedupe: true
    });

    sessionFinishAnnounced = true;
  } catch(e) {
    console.error('checkSessionFinishOnLap', e);
  }
}

    function updateSessionInfo(r) {
      const rn = (r && r.raceName) ? String(r.raceName) : '';
      currentSessionInfo = parseSessionFromRaceName(rn);

      try { applyLapChartPreset(); } catch(e) {}
// AI Spotter: aplica perfil automatico SIEMPRE (tambien en Auto Locutor)
      try { maybeAutoApplySessionPreset(currentSessionInfo); } catch(e) {}

      // Reset de referencias (mejora/best) cuando cambia la sesin
      if (rn && rn !== lastSessionSigForBest) {
        prevBestByKey.clear();
        try { lapDiffSpeakGuard.clear(); } catch(e) {}
        lastSessionSigForBest = rn;
      }
    }

    function updateHeaderFromRace(r) {
      if (!r) return;

      updateSessionInfo(r);

      // Auto Locutor: al cambiar carrera, anunciar nombre + participantes
      try { __maybeAnnounceAutoIntro(r); } catch(e) {}

      function __formatRaceTitleForHeader(name) {
        let s = (name == null) ? '' : String(name);
        // Sanitiza saltos de linea/tabs del feed (a veces llegan con \n y rompen el header)
        s = s.replace(/[\r\n\t]+/g, ' ');
        s = s.replace(/\s{2,}/g, ' ').trim();
        if (!s) return '';
        // 1) Evita que el guion quede al inicio de linea (pega el guion al texto anterior)
        //    "A - B" => "A\u00A0- B"
        s = s.replace(/\s-\s/g, '\u00A0- ');
        // 2) Evita que "SERIE 1" se parta dejando el "1" huerfano
        s = s.replace(/\b(SERIE)\s+(\d+)\b/ig, '$1\u00A0$2');
        return s;
      }

      function __escapeHtml(str){
        const s = (str==null) ? '' : String(str);
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
      }
      function __normForCountry(str){
        let s = (str==null) ? '' : String(str);
        try { s = s.normalize('NFD').replace(/[-]/g,''); } catch(e) {}
        s = s.toUpperCase();
        // homogeniza guiones y separadores
        s = s.replace(/[-]/g,'-');
        return s;
      }
      function __detectFlagSvgCode(title){
        const n = __normForCountry(title);
        // Twemoji SVG codes (regional indicators)
        const pairs = [
          ['REINO UNIDO','1f1ec-1f1e7'], ['UK','1f1ec-1f1e7'], ['UNITED KINGDOM','1f1ec-1f1e7'],
          ['MÉXICO','1f1f2-1f1fd'],
          ['COSTA RICA','1f1e8-1f1f7'],
          ['ITALIA','1f1ee-1f1f9'],
          ['EUA','1f1fa-1f1f8'], ['USA','1f1fa-1f1f8'], ['ESTADOS UNIDOS','1f1fa-1f1f8'], ['UNITED STATES','1f1fa-1f1f8'],
          ['BRASIL','1f1e7-1f1f7'], ['BRAZIL','1f1e7-1f1f7'],
          ['PERU','1f1f5-1f1ea'],
          ['POLONIA','1f1f5-1f1f1'], ['POLAND','1f1f5-1f1f1'],
          ['SUIZA','1f1e8-1f1ed'], ['SWITZERLAND','1f1e8-1f1ed'],
          ['ESPANA','1f1ea-1f1f8'], ['SPAIN','1f1ea-1f1f8'],
          ['FRANCIA','1f1eb-1f1f7'], ['FRANCE','1f1eb-1f1f7'],
          ['ALEMANIA','1f1e9-1f1ea'], ['GERMANY','1f1e9-1f1ea'],
          ['ARGENTINA','1f1e6-1f1f7'],
          ['COLOMBIA','1f1e8-1f1f4'],
          ['CHILE','1f1e8-1f1f1']
        ];
        for (const [k,code] of pairs){
          if (n.includes(k)) return code;
        }
        return '';
      }

      const __TWEMOJI_FLAG_BASE = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/';

      const rawTitle = r.raceName || 'Spotter_5.0.1';
      const fmtTitle = __formatRaceTitleForHeader(rawTitle) || rawTitle;
      const flagSvg = __detectFlagSvgCode(rawTitle);
      const safeTitle = __escapeHtml(fmtTitle);
      const htmlTitle = flagSvg ? (`<img class="flagImg" alt="" src="${__TWEMOJI_FLAG_BASE}${flagSvg}.svg"/>` + safeTitle) : safeTitle;

      if (raceTitleText) {
        raceTitleText.innerHTML = htmlTitle;
      } else if (raceTitleMain) {
        // fallback: si no existe el span interno, usa el contenedor
        raceTitleMain.textContent = fmtTitle;
      }

      if (raceModeBadge) {
        // Texto compacto para el botn MODO (siempre visible y sin depender del label largo)
        let modeTxt = 'MODO -';
        const t0 = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
        if (t0 === 'TRAIN' || t0 === 'PRACTICE' || t0 === 'PRUEBA' || t0 === 'LIBRE' || t0 === 'WARMUP') {
          modeTxt = 'Train';
        } else if (t0 === 'MANGA' || t0 === 'QUALI') {
          modeTxt = 'Manga 3m';
        } else if (t0.startsWith('FINAL')) {
          const mins = Math.round(((currentSessionInfo && currentSessionInfo.durationMs) || 0) / 60000) || 0;
          modeTxt = mins ? (`Final ${mins}m`) : 'Final';
        }
        raceModeBadge.textContent = modeTxt;
// Colorea el badge por tipo de sesin
        raceModeBadge.classList.remove('mode-train','mode-manga','mode-final','mode-finalA','mode-finalB');
        if (currentSessionInfo && currentSessionInfo.type) {
          const t = String(currentSessionInfo.type).toUpperCase();
          if (t === 'TRAIN' || t === 'PRACTICE' || t === 'PRUEBA' || t === 'LIBRE' || t === 'WARMUP') {
            raceModeBadge.classList.add('mode-train');
          } else if (t === 'MANGA' || t === 'QUALI') {
            raceModeBadge.classList.add('mode-manga');
          } else if (t === 'FINAL_A') {
            raceModeBadge.classList.add('mode-finalA');
          } else if (t === 'FINAL_B' || t === 'FINAL_C' || t === 'FINAL_D') {
            raceModeBadge.classList.add('mode-finalB');
          } else if (t.startsWith('FINAL')) {
            raceModeBadge.classList.add('mode-final');
          }
        }
      }
    }

    function setLastUpdateNow() {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      if (lastUpdateInfo) {
        lastUpdateInfo.textContent = `Actualizado ${hh}:${mm}:${ss}`;
      }
    }

    async function loadRaceFromFirebase(_snapDataOverride) {
      // iOS/WebView a veces reporta document.hidden erroneamente; no bloquees la lectura del feed.
      if (!__firebaseOk || !db) { setLiveStatus(false); return; }

      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      if (isLoading) {
        // Si una lectura se colg por red, no dejes el spotter muerto.
        if (now - loadingSince < 4500) return;
        console.warn('Lectura anterior tard demasiado, reseteando isLoading');
        isLoading = false;
      }

      isLoading = true;
      loadingSince = now;

      try {        let data = _snapDataOverride || null;

        if (!data) {
          const ref = doc(db, 'races', 'currentRace');

          // Timeout duro para que getDoc no congele el loop (iOS/red chueca)
          const snap = await Promise.race([
            getDoc(ref),
            new Promise((_, rej) => setTimeout(() => rej(new Error('timeout getDoc')), 3500))
          ]);
          if (!snap.exists()) {
            setLiveStatus(false);
            isLoading = false;
            return;
          }
          data = snap.data() || {};
        }

        setLiveStatus(true);

        let rawRace = null;
        if (data.parsed && Array.isArray(data.parsed.classification)) {
          rawRace = data.parsed;
        } else if (data.rawJson) {
          try {
            rawRace = JSON.parse(data.rawJson);
          } catch (e) {
            console.error('Error parseando rawJson', e);
          }
        }

        if (!rawRace || !Array.isArray(rawRace.classification)) {
          try { if (raceInfo) raceInfo.textContent = 'Sin datos (feed sin parsed/rawJson valido)'; } catch(e) {}
          isLoading = false;
          return;
        }

        const newRaceName = rawRace.raceName || '';
        if (newRaceName !== lastRaceName) {
          previousClassification = null;
          lastSpokenLastTime = null; 
      lastAnnouncedLapcount = 0;
          lastKnownPos = null;
          lastTotalTimeAnnouncedSeconds = 0;
          lastBestAnnouncedMs = null;
          lastBestAnnouncedLap = 0;
          lastTrendSpokenLap = 0;
          lastAheadAlertMs = 0;
          behind06Latch = { active:false, otherKey:'', lap:-1 };
          ahead06Latch  = { active:false, otherKey:'', lap:-1 };

          attackLatch  = { active:false, otherKey:'', lap:-1 };
          defenseLatch = { active:false, otherKey:'', lap:-1 };
          fightLatch   = { active:false, lap:-1 };
          startPosForSelected = null;
          lastNetGainValue = null;
          lastNetGainSpokenLap = 0;
          lastLeaderGapSpokenLap = 0;
          lastPodiumSpokenLap = 0;
          lastAutoSummaryAnnouncedSeconds = 0;
          resetAutoCommentatorState();
          // Reset fin de sesin
          sessionFinishSig = newRaceName;
          sessionFinishAnnounced = false;
          sessionFinishPrevByKey = new Map();
          lastRaceName = newRaceName;

          // Auto-skin por sesion (MANGA vs FINAL)
          try { maybeApplyAutoThemeByRaceName(newRaceName); } catch(e) {}

          stopMangaClock();
          if (lastPassEvents && typeof lastPassEvents.clear === 'function') {
            lastPassEvents.clear();
          }
          if (lapHistory && typeof lapHistory.clear === 'function') { lapHistory.clear(); }
          pendingBlueFlagForPilotKey = '';
          pendingBlueFlagMessage = '';
          lastBlueFlagPilotLap = 0;
        }

        
        // Guard anti-parpadeo: a veces el feed manda un "paquete cero" (laps=0, time=0) por un tick.
        // No reseteamos UI a ceros si la carrera NO cambi y ya tenamos datos reales.
        try {
          const sameRace = (String(newRaceName||'') === String(lastRaceName||''));
          const cls0 = (rawRace && Array.isArray(rawRace.classification)) ? rawRace.classification : [];
          const looksZero = cls0.length > 0 && cls0.every(rr => {
            const lap0 = (Number(rr && (rr.lapcount ?? rr.laps ?? 0)) || 0) === 0;
            const tm = (typeof rr.timeMs === 'number') ? rr.timeMs : parseTimeToMs(rr.time);
            const t0 = (Number(tm)||0) === 0;
            const best = parseTimeToMs(rr.best ?? rr.bestMs ?? rr.bestLapTime ?? rr.bestLapTimeMs ?? rr.bestTime ?? 0);
            const mean = parseTimeToMs(rr.mean ?? rr.meanMs ?? rr.meanLapTime ?? rr.meanLapTimeMs ?? 0);
            const est  = parseTimeToMs(rr.estTime ?? 0);
            return lap0 && t0 && ((best||0)===0) && ((mean||0)===0) && ((est||0)===0);
          });

          const hadReal = (previousClassification && Array.isArray(previousClassification) && previousClassification.some(pp => {
            const l = Number(pp && (pp.lapcount ?? pp.laps ?? 0)) || 0;
            const tm = Number(pp && pp.time) || 0;
            return l > 0 || tm > 0;
          }));

          if (sameRace && looksZero && hadReal) {
            isLoading = false;
            return; // ignorar tick cero
          }
        } catch(e) {}
        // Q TABLA: snapshot de clasificacin (UI only)
        try { recordQualiSnapshotIfNeeded(rawRace); } catch(e) {}
raceData = normalizeRaceData(rawRace);
        updateLapHistoryAll();
        refreshSessionBestCache();
        updateRecordCarreraUI();
        updateHeaderFromRace(raceData);

        // Activity signature: detecta si el estado realmente cambia
        try {
          const cls = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
          cls.sort((a,b) => (Number(a.pos||999)-Number(b.pos||999)));
          const top3 = cls.slice(0,3).map(p => {
            const pk = getPilotKey(p);
            const laps = Number(p.lapcount ?? p.laps ?? 0) || 0;
            const gap = String(p.gap ?? p.diff ?? p.interval ?? '').trim();
            return [pk, Number(p.pos||0)||0, laps, gap];
          });
          const leader = cls[0] || null;
          const leaderLaps = leader ? (Number(leader.lapcount ?? leader.laps ?? 0) || 0) : 0;
          let selPos = null, selLaps = null;
          if (selectedPilotKey) {
            const sp = cls.find(r => getPilotKey(r) === selectedPilotKey) || null;
            if (sp) {
              selPos = Number(sp.pos||0)||0;
              selLaps = Number(sp.lapcount ?? sp.laps ?? 0) || 0;
            }
          }
          const sigObj = { rn: String(newRaceName||''), leaderLaps, top3, selPos, selLaps };
          __setActivitySig(JSON.stringify(sigObj));
        } catch(e) {}

        try { restoreLastPilotSelectionIfNeeded(); } catch(e) {}
        setLastUpdateNow();
        __lastGoodTickMs = Date.now();
        __feedTickCount = (__feedTickCount||0) + 1;
        try { if (lastUpdateInfo) lastUpdateInfo.textContent = 'tick ' + __feedTickCount + ' - ' + new Date().toLocaleTimeString(); } catch(e) {}
        __lastReadErr = '';
        if (!isSelectingPilot) {
          updatePilotOptions();
        }
        if (selectedPilotKey) {
          let p = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey) || null;

          // Si el piloto guardado ya no existe en esta carrera, volvemos a Auto Locutor
          if (!p) {
            try { selectPilotByKey('', { announce:true, source:'auto-clear' }); } catch(e) {}
            p = null;
          }

          renderPilotCard(p || null);
          try { renderAutoTop3MiniGrid(); } catch(e) {}
          try { checkSessionFinishOnLap(); } catch(e) {}
      if (p && p.pos && p.pos > 0 && (startPosForSelected == null)) { startPosForSelected = p.pos; lastNetGainValue = 0; }
        } else {
          renderPilotCard(null);
        try { renderAutoTop3MiniGrid(); } catch(e) {}
        try { checkSessionFinishOnLap(); } catch(e) {}
        }
handleVoiceAndBeeps();
        handleAutoCommentator();
      } catch (e) {
        console.error('Error leyendo Firebase', e);
        __lastReadErr = (e && e.message) ? String(e.message) : String(e);
        try { if (raceInfo) raceInfo.textContent = 'Sin datos (error leyendo): ' + __lastReadErr; } catch(x) {}
        setLiveStatus(false);
      } finally {
        isLoading = false;
      }
    }

    

    // =========================
    // Realtime listener (onSnapshot) - mejora background en Chrome/Android/Safari
    // =========================
    let __raceUnsub = null;
    let __pendingSnapData = null;
    let __snapScheduled = false;

    function startRaceRealtime() {
      try {
        if (!__firebaseOk || !db || typeof onSnapshot !== 'function' || typeof doc !== 'function') return false;
        const ref = doc(db, 'races', 'currentRace');
        try { if (__raceUnsub) __raceUnsub(); } catch(e) {}

        __raceUnsub = onSnapshot(ref, (snap) => {
          try {
            if (!snap || !snap.exists()) {
              setLiveStatus(false);
              return;
            }
            // Coalesce: si llegan muchos updates por segundo, procesamos el uúltimo en un tick
            __pendingSnapData = snap.data() || {};
            if (__snapScheduled) return;
            __snapScheduled = true;
            setTimeout(() => {
              __snapScheduled = false;
              const d = __pendingSnapData;
              __pendingSnapData = null;
              try { loadRaceFromFirebase(d); } catch(e) {}
            }, 0);
          } catch(e) {}
        }, (err) => {
          try {
            console.warn('onSnapshot error', err);
            // fallback: el watchdog/polling resolvera
          } catch(e) {}
        });

        return true;
      } catch(e) {
        console.warn('startRaceRealtime fallo', e);
        return false;
      }
    }
// =========================
    // Bootstrap (arranque)
    // =========================
    window.addEventListener('unhandledrejection', (ev) => {
      console.error('UnhandledRejection', ev.reason);
    });

    (async () => {
      const ok = await initFirebaseRuntime();
      if (!ok) {
        setLiveStatus(false);
        if (raceInfo) raceInfo.textContent = 'Firebase OFF - revisa conexin, CSP o bloqueadores.';
        return;
      }
      loadRaceFromFirebase();
      const __rtOk = startRaceRealtime();
      if (!__rtOk) {
        setInterval(loadRaceFromFirebase, 500);
      }
      // Watchdog: si pasan 6s sin actualizacin, marca OFF y fuerza un refresh
      setInterval(() => {
        try {
          const now = Date.now();
          if (__lastGoodTickMs && (now - __lastGoodTickMs > 6000)) {
            setLiveStatus(false);
            if (raceInfo) raceInfo.textContent = 'Sin actualizaciones. Revisando conexin...';
            // intenta un refresh inmediato
            try { loadRaceFromFirebase(); } catch(e) {}
          }
        } catch(e) {}
      }, 1500);

    })();

// Best lap global: actualizado desde raceData.classification (ver refreshSessionBestCache)
    // =========================
    // Q TABLA (Clasificación) - UI only (NO toca lgica de carrera)
    // =========================
    const QUALI_STORE_KEY = 'trm_quali_store_v1';

    // =========================
    // Q TABLA - Leader callouts (TRM)
    // - Anuncia cambios de P1 provisional durante mangas/clasificación
    // - Usa la tabla general (bestByPilot) como fuente de verdad
    // =========================
    let __qualiLeaderState = {
      leaderKey: '',
      leaderName: '',
      leaderLaps: 0,
      leaderTimeMs: 0,
      lastAnnounceTs: 0,
      lastImproveTs: 0,
      lastCloseTs: 0
    };

    function __qualiRankTuple(it){
      const laps = Number((it && it.laps) || 0) || 0;
      const tmsRaw = Number(it && it.timeMs);
      const timeMs = (isFinite(tmsRaw) && tmsRaw > 0 && tmsRaw < Number.MAX_SAFE_INTEGER) ? tmsRaw : Number.MAX_SAFE_INTEGER;
      return { laps, timeMs };
    }

    function __qualiIsValidLeader(it){
      if (!it) return false;
      const t = __qualiRankTuple(it);
      return (t.laps > 0) && (t.timeMs < Number.MAX_SAFE_INTEGER);
    }

    function __fmtGapMs(ms){
      try{
        const v = Number(ms);
        if (!isFinite(v) || v <= 0) return '';
        const s = v / 1000;
        return s.toFixed(2) + ' segundos';
      }catch(e){ return ''; }
    }

    function __maybeAnnounceQualiLeaderFromStore(raw, store){
      try{
        if (!raw || !store) return;
        if (!voiceMasterEnabled) return;

        // Solo mangas/clasificación
        if (!isMangaRaceName(raw.raceName)) return;

        const info = parseSessionFromRaceName(raw.raceName) || {};
        if (String(info.type || '').toUpperCase() !== 'MANGA') return;

        const list = computeQualiList(store);
        if (!list || list.length < 1) return;

        const leader = list[0];
        if (!__qualiIsValidLeader(leader)) return;

        const leaderName = String(leader.racerName || '').trim();
        if (!leaderName) return;

        const nk = normalizeNameKey(leaderName);
        const leaderKey = nk ? ('P' + nk) : String(leader.pilotKey || leader.racerNumber || leaderName).trim();

        const lT = __qualiRankTuple(leader);
        const lLaps = lT.laps;
        const lTimeMs = lT.timeMs;

        const now = Date.now();

        // Cooldowns (anti-spam)
        const changeCooldown = 9000;
        const improveCooldown = 14000;
        const closeCooldown = 18000;

        const prevKey = String(__qualiLeaderState.leaderKey || '');
        const prevTime = Number(__qualiLeaderState.leaderTimeMs || 0) || 0;
        const prevLaps = Number(__qualiLeaderState.leaderLaps || 0) || 0;

        const firstTime = (!prevKey);

        // 2do lugar para comentarios de pelea
        const second = (list.length >= 2) ? list[1] : null;
        const secondName = second ? String(second.racerName || '').trim() : '';
        const sT = second ? __qualiRankTuple(second) : { laps: 0, timeMs: Number.MAX_SAFE_INTEGER };

        // Update state ya, para evitar dobles anuncios por tormenta de snapshots
        __qualiLeaderState.leaderKey = leaderKey;
        __qualiLeaderState.leaderName = leaderName;
        __qualiLeaderState.leaderLaps = lLaps;
        __qualiLeaderState.leaderTimeMs = lTimeMs;

        // Primera vez: no grites al boot
        if (firstTime){
          __qualiLeaderState.lastAnnounceTs = now;
          return;
        }

        // Cambio de P1 provisional
        const changed = (prevKey && prevKey !== leaderKey);
        if (changed && (now - (Number(__qualiLeaderState.lastAnnounceTs || 0)) > changeCooldown)){
          const t = msToMinSec(lTimeMs);
          enqueueSpeech(
            `Atención, nueva pole provisional. ${leaderName} se pone líder con ${lLaps} vueltas en ${t}.`,
            { key: 'quali_leader_change', cooldownMs: changeCooldown, semanticCategory: 'leader', priority: 30 }
          );
          __qualiLeaderState.lastAnnounceTs = now;

          // Follow: pelea cerrada si aplica (misma cantidad de vueltas y gap muy chico)
          if (second && secondName && sT.laps === lLaps){
            const gap = sT.timeMs - lTimeMs;
            if (isFinite(gap) && gap > 0 && gap <= 90 && (now - (Number(__qualiLeaderState.lastCloseTs || 0)) > closeCooldown)){
              enqueueSpeech(
                `Y ojo, ${secondName} está a ${__fmtGapMs(gap)} del líder.`,
                { key: 'quali_close', cooldownMs: closeCooldown, semanticCategory: 'quali', priority: 12 }
              );
              __qualiLeaderState.lastCloseTs = now;
            }
          }
          return;
        }

        // Mismo líder: mejora (baja tiempo o sube vueltas)
        const lapGain = (lLaps > prevLaps);
        const timeDrop = (prevTime > 0 && lTimeMs < prevTime);
        const dropMs = timeDrop ? (prevTime - lTimeMs) : 0;

        if ((lapGain || (dropMs >= 40)) && (now - (Number(__qualiLeaderState.lastImproveTs || 0)) > improveCooldown)){
          if (lapGain){
            enqueueSpeech(
              `El líder aprieta. ${leaderName} sube a ${lLaps} vueltas.`,
              { key: 'quali_leader_improve', cooldownMs: improveCooldown, semanticCategory: 'leader', priority: 18 }
            );
          } else {
            enqueueSpeech(
              `El líder mejora. ${leaderName} baja su tiempo.`,
              { key: 'quali_leader_improve', cooldownMs: improveCooldown, semanticCategory: 'leader', priority: 18 }
            );
          }
          __qualiLeaderState.lastImproveTs = now;
        }

        // Comentario de pelea cerrada (sin cambio de líder)
        if (second && secondName && sT.laps === lLaps){
          const gap = sT.timeMs - lTimeMs;
          if (isFinite(gap) && gap > 0 && gap <= 90 && (now - (Number(__qualiLeaderState.lastCloseTs || 0)) > closeCooldown)){
            enqueueSpeech(
              `Esto está apretado. ${secondName} a ${__fmtGapMs(gap)} del líder.`,
              { key: 'quali_close', cooldownMs: closeCooldown, semanticCategory: 'quali', priority: 10 }
            );
            __qualiLeaderState.lastCloseTs = now;
          }
        }
      }catch(e){}
    }


    function qSafeJsonParse(s){
      try { return JSON.parse(s); } catch(e) { return null; }
    }
    function qEscapeHtml(s){
      const str = (s === null || s === undefined) ? '' : String(s);
      return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;');
    }
    function getLocalDateKey(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function getRaceBaseFromRaceName(raceName){
      // Objetivo: llave estable para guardar Qs (Q1/Q2/Q3...) sin que se resetee por cambios menores del raceName.
      // NO toca lgica de carrera: solo normaliza texto para el storage de Q TABLA.
      const raw = (raceName == null) ? '' : String(raceName);
      let s = raw.trim();
      if (!s) return '';

      // Si viene con separadores tipo " - ", a veces el prefijo es el EVENTO (OK),
      // pero otras veces el prefijo es "CLASIFICACION" (malo). Solo recortamos si el prefijo
      // NO parece ser un tipo de sesion.
      const dashIdx = s.indexOf(' - ');
      if (dashIdx > 2){
        const pref = s.slice(0, dashIdx).trim();
        if (!/^(CLASIFIC|MANGA|FINAL)\b/i.test(pref)) s = pref;
      }

      // Q / Manga / Serie suelen cambiar: quitarlos para que la key permanezca estable
      let k = s;
      k = k.replace(/\bQ\s*[-:]?\s*\d+\b/ig, ' ');
      k = k.replace(/\b(MANGA|HEAT|ROUND|RND)\s*[-:]?\s*\d+\b/ig, ' ');
      k = k.replace(/\bSERIE\s*[-:]?\s*\d+\b/ig, ' ');

      // Limpieza de separadores comunes
      k = k.replace(/[|,]+/g, ' ');
      k = k.replace(/\s+/g, ' ').trim();

      // Fallback si qued vaco
      return k || raw.trim();
    }
    function getQualiIdFromRaceName(raceName){
      // Key para Q TABLA:
      // - Siempre incluye Q#
      // - Si la carrera trae "Manga A/B/C/D" lo agrega para NO pisar Q1A vs Q1B
      // - Si trae "Serie #" lo agrega para NO pisar series diferentes
      try{
        const info = parseSessionFromRaceName(raceName) || {};
        const q = String(info.q || '').trim();
        if (q){
          let key = 'Q' + q;
          const type = String(info.type || '').toUpperCase();
          const main = String(info.main || '').toUpperCase();
          const serie = String(info.serie || '').trim();
          if (type === 'MANGA' && main && /^[A-D]$/.test(main)) key += main;
          if (serie && /^\d+$/.test(serie)) key += ('S' + serie);
          return key;
        }
      }catch(e){}

      // Fallback simple por regex
      const s = String(raceName||'').toUpperCase();
      const qm = s.match(/\bQ\s*(\d+)\b/);
      if (!qm) return '';
      let key = 'Q' + qm[1];

      const mm = s.match(/\bMANGA\s*([A-D])\b/);
      if (mm && mm[1]) key += String(mm[1]).toUpperCase();

      const sm = s.match(/\bSERIE\s*(\d+)\b/);
      if (sm && sm[1]) key += ('S' + sm[1]);

      return key;
    }


    function normalizeNameKey(v){
      if (v == null) return '';
      let s = String(v).trim().toLowerCase();
      s = s.replace(/\s+/g, ' ');
      try { s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch(e) {}
      s = s.replace(/[^a-z0-9 ]+/g, '');
      s = s.replace(/\s+/g, ' ').trim();
      return s;
    }

    function pickBetterQuali(a,b){
      if (!a) return b;
      if (!b) return a;
      const al = Number(a.laps || 0);
      const bl = Number(b.laps || 0);
      if (bl > al) return b;
      if (bl < al) return a;
      const at = Number(a.timeMs || Number.MAX_SAFE_INTEGER);
      const bt = Number(b.timeMs || Number.MAX_SAFE_INTEGER);
      return (bt < at) ? b : a;
    }

    function getQualiNameKey(r){
      const nm = normalizeNameKey(r && (r.racerName ?? r.name));
      return nm || '';
    }
    function getQualiNumberKey(r){
      try{
        const num = (r && r.racerNumber != null) ? String(r.racerNumber).trim() :
                    (r && r.number != null) ? String(r.number).trim() : '';
        if (num && num !== '0' && num !== '-') return 'N' + num;
      }catch(e){}
      return '';
    }

    function getQualiPilotKey(r, store){
      // IMPORTANTE:
      // En el feed, racerNumber puede reiniciarse por Manga/Grupo (Q1A vs Q1B),
      // si lo usamos como llave se "pisan" pilotos y la tabla queda incompleta.
      // Para Q TABLA usamos SOLO racerName (normalizado) como llave estable.
      const nameKey = getQualiNameKey(r);
      if (!nameKey) return '';
      if (store){
        if (!store.bestByPilot || typeof store.bestByPilot !== 'object') store.bestByPilot = {};
      }
      return 'P' + nameKey;
    }

    function loadQualiStoreFor(raceName){
      const today = getLocalDateKey();
      const raceBase = getRaceBaseFromRaceName(raceName);
      let store = qSafeJsonParse((typeof lsGet === 'function' ? lsGet(QUALI_STORE_KEY) : localStorage.getItem(QUALI_STORE_KEY)) || '');
      if (!store || typeof store !== 'object') store = null;

      if (!store || store.date !== today || store.raceBase !== raceBase) {
        store = { date: today, raceBase, sessions: {}, bestByPilot: {}, aliasByName: {}, _pilotKeyMode: 'name' };
        try {
          if (typeof lsSet === 'function') lsSet(QUALI_STORE_KEY, JSON.stringify(store));
          else localStorage.setItem(QUALI_STORE_KEY, JSON.stringify(store));
        } catch(e) {}
      } else {
        if (!store.sessions || typeof store.sessions !== 'object') store.sessions = {};
        if (!store.bestByPilot || typeof store.bestByPilot !== 'object') store.bestByPilot = {};
        if (!store.aliasByName || typeof store.aliasByName !== 'object') store.aliasByName = {};

        // MIGRACION: antes se usaba racerNumber como llave (se pisaban pilotos entre mangas).
        // Re-construimos bestByPilot desde sessions usando SOLO racerName.
        const km = String(store._pilotKeyMode || '');
        if (km !== 'name') {
          const rebuilt = {};
          try{
            const keys = Object.keys(store.sessions || {});
            for (const qid of keys){
              const sess = store.sessions[qid];
              const rows = (sess && Array.isArray(sess.rows)) ? sess.rows : [];
              for (const row of rows){
                if (!row) continue;
                const nm = String(row.racerName || '').trim();
                const nk = normalizeNameKey(nm);
                if (!nk) continue;
                const k = 'P' + nk;
                const cand = {
                  pilotKey: k,
                  q: qid,
                  racerNumber: row.racerNumber ?? '',
                  racerName: nm,
                  laps: Number(row.laps || 0) || 0,
                  timeMs: Number(row.timeMs || Number.MAX_SAFE_INTEGER),
                  timeRaw: String(row.timeRaw ?? ''),
                  bestMs: Number(row.bestMs || 0) || 0,
                  bestRaw: String(row.bestRaw ?? '')
                };
                rebuilt[k] = pickBetterQuali(rebuilt[k], cand);
              }
            }
          }catch(e){}
          store.bestByPilot = rebuilt;
          store._pilotKeyMode = 'name';
          try{
            if (typeof lsSet === 'function') lsSet(QUALI_STORE_KEY, JSON.stringify(store));
            else localStorage.setItem(QUALI_STORE_KEY, JSON.stringify(store));
          }catch(e){}
        }
      }
      return store;
    }
    function saveQualiStore(store){
      try {
        if (typeof lsSet === 'function') lsSet(QUALI_STORE_KEY, JSON.stringify(store));
        else localStorage.setItem(QUALI_STORE_KEY, JSON.stringify(store));
      } catch(e) {}
    }

    // Guarda un snapshot por Q cuando detecta que estamos en MANGA + Qx.
    function isMangaRaceName(raceName){
      // Q TABLA debe guardar SOLO mangas / clasificación (nunca finales).
      const s = String(raceName || '').toUpperCase();
      if (!s) return false;
      // Si dice FINAL/A MAIN/B MAIN/C MAIN, no es manga.
      if (/(\bFINAL\b|\bA\s*MAIN\b|\bB\s*MAIN\b|\bC\s*MAIN\b)/.test(s)) return false;
      // Señales típicas de manga/clasificación
      if (/(\bMANGA\b|\bQUALI\b|\bCLASIF\b|\bCLASIFIC\b|\bQ\s*\d+\b|\bHEAT\b|\bROUND\b|\bRND\b)/.test(s)) return true;
      return false;
    }

    function recordQualiSnapshotIfNeeded(raw){
      try{
        if (!raw || !raw.raceName || !Array.isArray(raw.classification)) return;

        // Solo mangas/clasificación
        if (!isMangaRaceName(raw.raceName)) return;

        const info = parseSessionFromRaceName(raw.raceName) || {};
        if (String(info.type || '').toUpperCase() !== 'MANGA') return;

        const qid = getQualiIdFromRaceName(raw.raceName);
        if (!qid) return;

        const store = loadQualiStoreFor(raw.raceName);

        // IMPORTANT: siempre actualizar bestByPilot (aunque el Q ya exista).
        // Guardamos "rows" al storage con throttle para no escribir 60 veces por segundo.
        const already = !!(store.sessions[qid] && store.sessions[qid].raceName);
        const now = Date.now();
        const lastSave = (store.sessions[qid] && store.sessions[qid].savedAt) ? Number(store.sessions[qid].savedAt) : 0;
        const shouldSaveRows = (!already) || (now - lastSave > 1200);

        const rows = [];
        let anyReal = false;

        for (const r of raw.classification){
          if (!r) continue;

          const laps = Number(r.lapcount ?? r.laps ?? r.lapCount ?? 0) || 0;

          const timeRaw = (r.time ?? r.total ?? r.totalTime ?? r.total_time ?? r.totalTimeMs ?? r.totalMs ?? '');
          let timeMsParsed = 0;
          if (typeof timeRaw === 'number') timeMsParsed = timeRaw;
          else timeMsParsed = parseTimeToMs(timeRaw);
          const timeMs = (isFinite(timeMsParsed) && timeMsParsed > 0) ? timeMsParsed : Number.MAX_SAFE_INTEGER;

          const bestRaw =
            (r.bestLapTimeMs != null ? r.bestLapTimeMs :
             (r.bestLapTime != null ? r.bestLapTime :
              (r.bestLapMs != null ? r.bestLapMs :
               (r.bestMs != null ? r.bestMs :
                (r.best != null ? r.best : '')))));
          let bestMsParsed = 0;
          if (typeof bestRaw === 'number') {
            // Guard: a veces 'best' viene como NUMERO DE VUELTA (indice), no tiempo.
            // Si es entero y cae dentro de [1..laps], lo ignoramos y buscamos otros campos.
            const isInt = Math.abs(bestRaw - Math.round(bestRaw)) < 1e-9;
            const isLikelyLapIndex = isInt && laps > 0 && bestRaw > 0 && bestRaw <= laps && bestRaw <= 200;
            if (isLikelyLapIndex) {
              bestMsParsed = 0;
            } else {
              // En algunos feeds el best lap viene como segundos (ej. 9.103) y no como ms.
              // Regla: si es numero menor a 1000, lo tratamos como segundos y lo convertimos a ms.
              if (bestRaw > 0 && bestRaw < 1000) bestMsParsed = Math.round(bestRaw * 1000);
              else bestMsParsed = Math.round(bestRaw);
            }
          } else {
            bestMsParsed = parseTimeToMs(bestRaw);
          }
          const bestMs = (isFinite(bestMsParsed) && bestMsParsed > 0 && bestMsParsed < 600000) ? bestMsParsed : 0;

          const pilotKey = getQualiPilotKey(r, store);
          if (!pilotKey) continue;

          const isRowReal = (laps > 0) || (timeMs < Number.MAX_SAFE_INTEGER) || (bestMs > 0);
          if (!isRowReal) continue;
          anyReal = true;

          // Snapshot rows (throttled)
          if (shouldSaveRows){
            rows.push({
              pilotKey,
              racerNumber: r.racerNumber ?? r.number ?? '',
              racerName: r.racerName ?? r.name ?? '',
              laps,
              timeMs,
              timeRaw: String(timeRaw ?? ''),
              bestRaw: String(bestRaw ?? ''),
              bestMs
            });
          }

          // Best-per-pilot (solo si hay datos reales)
          const prev = store.bestByPilot[pilotKey];
          const candidate = {
            pilotKey,
            q: qid,
            racerNumber: r.racerNumber ?? r.number ?? '',
            racerName: r.racerName ?? r.name ?? '',
            laps,
            timeMs,
            timeRaw: String(timeRaw ?? ''),
            bestMs,
            bestRaw: String(bestRaw ?? '')
          };
          store.bestByPilot[pilotKey] = pickBetterQuali(prev, candidate);
        }

        // Persistencia (throttle)
        const lastPersist = Number(store._lastPersist || 0) || 0;
        const allowPersist = (now - lastPersist > 1200);

        if (shouldSaveRows && anyReal){
          store.sessions[qid] = {
            raceName: raw.raceName,
            savedAt: now,
            rows
          };
        }

        if ((allowPersist || shouldSaveRows) && anyReal){
          store._lastPersist = now;
          saveQualiStore(store);
        }

        // TRM: anuncio de cambio de P1 usando la tabla general
        try{ __maybeAnnounceQualiLeaderFromStore(raw, store); }catch(e){}

        try{
          const bd = document.getElementById('qualiBackdrop');
          if (bd && bd.classList.contains('open')) renderQualiTable();
        }catch(e){}
      }catch(e){}
    }

    function computeQualiList(store){
      if (!store || !store.bestByPilot) return [];
      const rawAll = Object.values(store.bestByPilot).map(x => ({...x}));
      const raw = rawAll.filter(it => {
        if (!it) return false;
        const laps = Number(it.laps || 0) || 0;
        const tms = Number(it.timeMs || 0);
        const bms = Number(it.bestMs || 0) || 0;
        return (laps > 0) || (isFinite(tms) && tms < Number.MAX_SAFE_INTEGER) || (bms > 0);
      });
      const grouped = {};
      for (const it of raw){
        if (!it) continue;
        const nk = normalizeNameKey(it.racerName || '');
        const gk = nk ? ('P' + nk) : (String(it.pilotKey || it.racerNumber || '').trim());
        if (!gk) continue;
        grouped[gk] = pickBetterQuali(grouped[gk], it);
      }
      const arr = Object.values(grouped).map(x => ({...x}));
      arr.sort((a,b)=>{
        const al = Number(a.laps || 0);
        const bl = Number(b.laps || 0);
        if (bl !== al) return bl - al;
        return Number(a.timeMs || Number.MAX_SAFE_INTEGER) - Number(b.timeMs || Number.MAX_SAFE_INTEGER);
      });
      return arr;
    }
    function msToLapStr(ms){
      const m = Number(ms || 0);
      if (!isFinite(m) || m <= 0) return '-';
      const mm = Math.round(m);
      // Para lap times, si es menor a 1 minuto mostramos solo segundos.mmm (ej. 9.103)
      if (mm < 60000){
        const s = Math.floor(mm / 1000);
        const rem = mm - s * 1000;
        return `${s}.${String(rem).padStart(3,'0')}`;
      }
      return msToMinSec(mm);
    }



    function cellHtml(r){
      if (!r) return '<span class="qcell-empty">-</span>';
      const laps = Number(r.laps || 0);
      const tms = Number(r.timeMs || 0);
      const bms = Number(r.bestMs || 0);
      const tmsOk = (isFinite(tms) && tms > 0 && tms < Number.MAX_SAFE_INTEGER);
      if ((!laps || laps <= 0) && !tmsOk && (!bms || bms <= 0)) return '<span class="qcell-empty">-</span>';
      const t = (isFinite(tms) && tms < Number.MAX_SAFE_INTEGER) ? msToMinSec(tms) : '-';
      const b = (bms > 0) ? msToLapStr(bms) : '-';
      return `<div class="qmain">${laps}v - ${qEscapeHtml(t)}</div><div class="qbest">${qEscapeHtml(b)}</div>`;
    }

    function renderQualiTable(){
      const qualiMeta = document.getElementById('qualiMeta');
      const thead = document.getElementById('qualiThead');
      const tbody = document.getElementById('qualiTbody');
      const viewSel = document.getElementById('qualiViewSel');
      const metaEvent = document.getElementById('qualiMetaEvent');
      const metaDate = document.getElementById('qualiMetaDate');
      const metaSessions = document.getElementById('qualiMetaSessions');

      if (!qualiMeta || !thead || !tbody) return;

      const rn = (raceData && raceData.raceName) ? raceData.raceName : (lastRaceName || '');
      const store = loadQualiStoreFor(rn);

      const sessions = (store && store.sessions) ? store.sessions : {};
      const sessionKeys = Object.keys(sessions || {})
        .filter((k)=> isMangaRaceName((sessions && sessions[k] && sessions[k].raceName) ? sessions[k].raceName : ''))
        .sort((a,b)=>{
          const parseKey = (k)=>{
            const s = String(k||'').toUpperCase();
            const qn = parseInt((s.match(/\d+/)||['0'])[0],10) || 0;
            const mainM = s.match(/Q\d+([A-D])\b/);
            const main = (mainM && mainM[1]) ? mainM[1] : '';
            const serieM = s.match(/S(\d+)\b/);
            const serie = (serieM && serieM[1]) ? (parseInt(serieM[1],10)||0) : 0;
            return { qn, main, serie };
          };
          const pa = parseKey(a);
          const pb = parseKey(b);

          if (pa.qn !== pb.qn) return pa.qn - pb.qn;

          // Orden A,B,C,D (vacío al final)
          const ord = (c)=> c ? (('ABCD'.indexOf(c) + 1) || 99) : 99;
          const oa = ord(pa.main);
          const ob = ord(pb.main);
          if (oa !== ob) return oa - ob;

          if (pa.serie !== pb.serie) return pa.serie - pb.serie;

          return String(a).localeCompare(String(b));
        });

      const raceBase = (store && store.raceBase) ? store.raceBase : '';
      const dateKey  = (store && store.date) ? store.date : getLocalDateKey();

      if (metaEvent) metaEvent.textContent = `Evento: ${raceBase || '-'}`;
      if (metaDate) metaDate.textContent = `Fecha: ${dateKey || '-'}`;
      if (metaSessions) metaSessions.textContent = `Sesiones: ${sessionKeys.length ? sessionKeys.join(', ') : '-'}`;

      const view = viewSel ? String(viewSel.value || 'best') : 'best';

      if (view === 'byq'){
        // Armar mapa piloto -> por Q
        const pilots = {};
        for (const qid of sessionKeys){
          const sess = sessions[qid];
          const rows = (sess && Array.isArray(sess.rows)) ? sess.rows : [];
          for (const row of rows){
            if (!row) continue;
            const nm = (row.racerName ?? '');
            const nk = normalizeNameKey(nm);
            if (!nk) continue;

            if (!pilots[nk]){
              pilots[nk] = { name: nm, byQ: {}, bestQ: '', bestRow: null };
            } else {
              if (String(nm).length > String(pilots[nk].name || '').length) pilots[nk].name = nm;
            }
            pilots[nk].byQ[qid] = row;
          }
        }

        // Mejor global por piloto
        const list = [];
        for (const k in pilots){
          const p = pilots[k];
          let bestRow = null;
          let bestQ = '';
          for (const qid of sessionKeys){
            const r = p.byQ[qid];
            if (!r) continue;
            bestRow = pickBetterQuali(bestRow, { laps:r.laps, timeMs:r.timeMs, racerName:r.racerName, racerNumber:r.racerNumber, bestMs:r.bestMs });
            if (bestRow && bestRow.timeMs === r.timeMs && Number(bestRow.laps||0) === Number(r.laps||0)) bestQ = qid;
          }
          p.bestRow = bestRow;
          p.bestQ = bestQ;
          list.push(p);
        }

        list.sort((a,b)=>{
          const al = Number(a.bestRow && a.bestRow.laps || 0);
          const bl = Number(b.bestRow && b.bestRow.laps || 0);
          if (bl !== al) return bl - al;
          return Number(a.bestRow && a.bestRow.timeMs || Number.MAX_SAFE_INTEGER) - Number(b.bestRow && b.bestRow.timeMs || Number.MAX_SAFE_INTEGER);
        });

        // Thead
        let th = `<tr><th class="qcol-pos">Pos</th><th class="qcol-name">Piloto</th><th class="qcol-q">Mejor</th><th class="qcol-time">Mejor (laps-tiempo)</th>`;
        for (const qid of sessionKeys){
          th += `<th>${qid}</th>`;
        }
        th += `</tr>`;
        thead.innerHTML = th;

        // Rows
        let out = '';
        for (let i=0;i<list.length;i++){
          const p = list[i];
          const bestQ = p.bestQ || '';
          const br = p.bestRow || null;
          const bestMain = br ? `${Number(br.laps||0)}v - ${qEscapeHtml(msToMinSec(Number(br.timeMs||0)))}` : '-';
          out += `<tr><td>${i+1}</td><td>${qEscapeHtml(p.name||'')}</td><td>${qEscapeHtml(bestQ||'-')}</td><td class="qcell-best">${bestMain}</td>`;
          for (const qid of sessionKeys){
            const r = p.byQ[qid];
            const cls = (qid === bestQ) ? 'qcell-best' : '';
            const empty = (!r) ? 'qcell-empty' : '';
            out += `<td class="${cls} ${empty}">${cellHtml(r)}</td>`;
          }
          out += `</tr>`;
        }
        tbody.innerHTML = out || `<tr><td colspan="${4+sessionKeys.length}" class="qcell-empty">Sin datos aun</td></tr>`;
        return;
      }

      // Vista: mejor por piloto
      const list = computeQualiList(store);

      thead.innerHTML = `<tr>
        <th class="qcol-pos">Pos</th>
        <th class="qcol-name">Piloto</th>
        <th class="qcol-q">Q</th>
        <th class="qcol-laps">Vueltas</th>
        <th class="qcol-time">Tiempo</th>
        <th class="qcol-time">Best Lap</th>
      </tr>`;

      let out = '';
      for (let i=0;i<list.length;i++){
        const r = list[i];
        const laps = Number(r.laps || 0);
        const t = (isFinite(r.timeMs) && r.timeMs < Number.MAX_SAFE_INTEGER) ? msToMinSec(Number(r.timeMs)) : '-';
        const b = (Number(r.bestMs||0) > 0) ? msToLapStr(Number(r.bestMs||0)) : '-';
        out += `<tr>
          <td>${i+1}</td>
          <td>${qEscapeHtml(r.racerName || '')}</td>
          <td><span class="qtag">${qEscapeHtml(r.q || '-')}</span></td>
          <td>${laps}</td>
          <td class="qcell-best">${qEscapeHtml(t)}</td>
          <td>${qEscapeHtml(b)}</td>
        </tr>`;
      }
      tbody.innerHTML = out || `<tr><td colspan="6" class="qcell-empty">Sin datos aun</td></tr>`;
    }

    function openQuali(){
      const bd = document.getElementById('qualiBackdrop');
      if (!bd) return;
      try { renderQualiTable(); } catch(e) {}
      bd.classList.add('open');
      bd.setAttribute('aria-hidden','false');
    }
    function closeQuali(){
      const bd = document.getElementById('qualiBackdrop');
      if (!bd) return;
      bd.classList.remove('open');
      bd.setAttribute('aria-hidden','true');
    }

    // Bind UI (una sola vez)
    (function initQualiUI(){
      try{
        const btn = document.getElementById('qTableBtn');
        const bd  = document.getElementById('qualiBackdrop');
        const closeBtn = document.getElementById('qualiCloseBtn');
        const viewSel  = document.getElementById('qualiViewSel');

        if (btn) btn.addEventListener('click', openQuali);
        if (closeBtn) closeBtn.addEventListener('click', closeQuali);
        if (viewSel) viewSel.addEventListener('change', ()=>{ try{ renderQualiTable(); }catch(e){} });

        if (bd) bd.addEventListener('click', (ev)=>{
          if (ev && ev.target === bd) closeQuali();
        });
        document.addEventListener('keydown', (ev)=>{
          if (ev && ev.key === 'Escape'){
            const bdx = document.getElementById('qualiBackdrop');
            if (bdx && bdx.classList.contains('open')) closeQuali();
          }
        });
      }catch(e){}
    })();

/* ---- merged script ---- */

/* LayoutGuard - shows a small badge if the header overflows (useful for iOS Pro/Max and large-text settings) */
(function(){
  try {
    const html = document.documentElement;
    const header = document.querySelector('.app-header');
    if (!header) return;

    const badge = document.createElement('div');
    badge.id = 'layoutGuardBadge';
    badge.style.cssText = [
      'position:absolute',
      'right:8px',
      'bottom:6px',
      'z-index:9999',
      'padding:3px 6px',
      'border-radius:999px',
      'font-size:11px',
      'font-weight:800',
      'letter-spacing:0.2px',
      'background:rgba(255,0,0,0.85)',
      'color:#fff',
      'box-shadow:0 2px 10px rgba(0,0,0,0.45)',
      'display:none',
      'pointer-events:none'
    ].join(';');
    badge.textContent = 'HDR OVERFLOW';
    header.appendChild(badge);

    const check = () => {
      const overW = (header.scrollWidth - header.clientWidth) > 1;
      const overH = (header.scrollHeight - header.clientHeight) > 1;
      if (overW || overH) {
        html.classList.add('layout-overflow');
        badge.style.display = 'inline-block';
        badge.textContent = overW && overH ? 'HDR OVR W+H' : (overW ? 'HDR OVR W' : 'HDR OVR H');
      } else {
        html.classList.remove('layout-overflow');
        badge.style.display = 'none';
      }
    };

    const rafCheck = () => requestAnimationFrame(check);
    window.addEventListener('resize', rafCheck, { passive: true });
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', rafCheck, { passive: true });
      window.visualViewport.addEventListener('scroll', rafCheck, { passive: true });
    }
    document.addEventListener('DOMContentLoaded', () => setTimeout(check, 200));
    setTimeout(check, 500);
    setInterval(check, 2500);
  } catch(e) {
    // no-op
  }
})();

}

</script>

</body>
</html>