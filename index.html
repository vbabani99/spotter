

<!--
vics_Smart_Spotter_v0.3.82 - Vic Skin PRO (volumen, sombras, bordes 3D) -
v0.3.05: FIX TTS en primer plano (A+B) - start-guard menos agresivo (3.5s), auto-recupera sin pedir tap si ya se desbloqueo, reset de fallos al iniciar voz.
Fecha: 2026-02-11
Origen: Spotter_5.0.1.html

Changelog:
- v0.3.82: TTS SMART v3 - memoria narrativa ampliada: rival recurrente, presion sostenida, defensa heroica y tren de tres con continuidad real.
- v0.3.79: TTS SMART v2 - memoria narrativa corta y remates contextuales: el motor sigue historias de duelo, detecta cuando la presion crece, se enfria o se concreta, y ajusta la locucion al vuelo.
- v0.3.78: TTS SMART - motor contextual de locucion que decide al vuelo que decir segun evento, gap, continuidad, sesion y tono.
- v0.3.77: TTS GEN - motor generativo de frases para Follow + Auto Locutor, con plantillas, variantes y combinaciones dinamicas para miles de textos.
- v0.3.76: Pit wall PRO - bitacora TTS visible, perfiles runtime (Evento/Ahorro/iPhone/Auto), timers centrales para watchdog/diag/TTS y recovery mas ordenado.
- v0.3.75: Pit wall tecnico en vivo - panel de diagnostico TTS/Firebase/Wake Lock/Realtime/Polling/iOS unlock, semaforos de estado y errores recientes visibles.
- v0.3.74: Hardening web stable build - Wake Lock y Background vuelven a ser toggles reales, rawJson validado, fallback Firebase con backoff, mejor deteccion Chromium/iPadOS y menos listeners frágiles de voces.
- v0.3.63: TTS v2 por bloques (anti-repetición), frases más naturales en Follow (ataque/defensa/ritmo/azul/best lap), y sin 'Best lap' en locución.
- v0.3.55: Desktop Chrome auto-activa VOZ al detectar carrera nueva (limpia needs-unlock y recupera TTS). Además: AUTO usa qualiBest/record + mezcla estilos; RD alinea gaps->trend y estlap->est; bancos RD para cons10/netgain/ritmo/total/box.
- v0.3.60: Auto Locutor en PC rota solo voces Microsoft es-MX (si existen) para claridad (Raul/Sabina). Fallback seguro.
- v0.3.59: FIX dicción TTS: 'línea' ya sale bien (antes se colaba como 'l nea').
- v0.3.49: FIX SyntaxError (isMS redeclared) + Auto Locutor rota Google/Microsoft es-MX/es-ES + indicador VOZ estable.
- v0.3.46: FIX anti-perico en Clasificación - anuncios de "pole provisional" solo en AUTO (sin piloto). En FOLLOW se calla.
- v0.3.44: FIX banderas país (Mexico/México, acentos y ñ) - mapeo Twemoji estable.
- v0.3.43: FIX BÁSICO en AUTO (ya no se queda mudo) - canta P1: vueltas + última vuelta + 'Nuevo líder' si cambia. Manual alineado.
- v0.3.37: FIX SyntaxError (try/catch cerrado + cierre init-guard) - vuelve a cargar sin errores.
- v0.3.36: FIX pageshow/pagehide consolidado (no perder reenganche al volver) + audit TTS/Q TABLA/manual/doc.
- v0.3.82: Speech Arbiter editorial. La cola ya no escupe backlog viejo: prioridad real + caducidad por tipo de mensaje + supresión por categoría + cap de cola + filtro anti-ruido para FOLLOW/AUTO.
- v0.3.36: AUDIT general (dedupe listeners, declara timers TTS, resume duplicado eliminado) + Q TABLA Best Lap usa SOLO bestMs/bestLapMs del feed (sin indices) + manual alineado + doc.
- v0.3.33: FIX SyntaxError (token inesperado) + Q TABLA - Best Lap ahora SIEMPRE conserva el mejor valor plausible del feed aunque no cambie el tiempo total (anti valores locos) + tooltip con fuente de BL -
- v0.3.29: Q TABLA - Best Lap ahora toma el valor mas confiable del feed (anti 0:00.xxx, soporte ms/seg/us) + mas color por columnas + blindaje extra TTS (anti 'ghost speaking' en primer plano) -
- v0.3.28: Q TABLA - Best Lap arreglado (usa valor del feed, fix segundos vs ms) + color/contraste en tabla.
- v0.3.27: Manual rehecho (Q TABLA: Mejor por piloto / Por Q + tips iPhone/PC + troubleshooting).
- v0.0.2.21: Q TABLA (FIX guardado) (clasificacin) - mejor resultado por piloto (best-per-pilot) guardado por da/evento. UI only.
- v0.0.2.23: Fix UX: VOZ responde al primer toque (iOS/Android), debounced LIVE (sin parpadeo), header altura estable (sin salto). UI/TTS only.
- v0.0.2.17: LapChart watermark restaurada (logo Vic) en fondo del canvas. UI only.
- v0.0.1.99: Logo header ajustado -5% (reduce height de 88px a 84px) manteniendo 'cover' para recorte del aire.
- v0.0.1.91: Limpieza editorial de textos del locutor (acentos y palabras recortadas) en RD_PHRASES y AUTO_PHRASES_PRO. Solo texto/UI.
- v0.0.1.87: TTS PRO (ms -> segundos/dcimas/centsimas/milsimas; +V como 'ms una vuelta'; correccin de recortes en normalizador).
- v0.0.1.79: LIVE como radio-button (solo punto verde) + MODO legible sin recortes y con color por estado.
- v0.0.1.86: Fix TTS (P# en espaol, +V como 'ms 1 vuelta', tildes, HobbyShop México, Italia, Messina).
- v0.0.1.38: Auto Locutor lifecycle: actividad robusta (tiempo sube o baja) + debug strip (solo ?debug=1).
- v0.0.1.02: Fix iPhone/pequenas pantallas - header responsivo (sin recortes) + safe-area top + logo always-fit.
- v0.0.1.08: Fix ReferenceError (miniGridExpanded/miniGridLimit + voiceToggleBtns). Mantiene Top grid expanded como rows estilo scoreboard con INT vs anterior.
- v0.0.1.11: Pulido Top20 expanded (rows): columnas mas compactas, mejor alineacion y truncado, INT mas legible.
- v0.0.1.10: Lap Chart meta (chips P1/P2/P3) ancho fijo 390px con scroll horizontal.
- v0.0.1.00: controls-section reducido 50% (tipografia/padding/botones) y oculto por defecto (solo visible en modo debug).
- v0.0.0.99: extras-section reducido 33% (zoom 0.67) para compactar controles.
- v0.0.0.98: Header-right a 200x123 px (centrado interno preservado).
- v0.0.0.97: Header-right centrado (logo, acciones y version) + header-version centrada (100% width).
- v0.0.0.92: UI header - fija header-left y header-right a 224x123 px (bloques simetricos).
- v0.0.0.94: Badge LIVE igualado a botones del header-actions-row (misma altura/tamano), texto corto OFF/LIVE, alineado.
- v0.0.0.89: UI header - reduce tamano de botones en header-actions-row (sin cambiar layout base v0.0.0.82) + raceTitleText contenedor 240x56 + raceSubtitle hasta 50px (2 lineas).
- v0.0.0.36: Fix TTS palabra 'Clasificacion' (sin acento en voz) en anuncio de carrera nueva.
- v0.0.0.37: Fix selector de piloto consistente (dark forms + no update mientras seleccionas) y mejora anti-parpadeo iOS/Android/Chrome/Safari.
- v0.0.0.38: Anuncio de carrera nueva: formato TTS "Clasificacion - Qx - Manga X - Serie X" y anuncios de Finales por A/B/C con frases PRO/divertidas.
- v0.0.0.39: Fix anuncio de carrera nueva (reintentos si falla TTS, sin bloquear 10 min por error) y estabilidad al reenviar mismo raceName.
- v0.0.0.42: Parsing de titulo de MANGA/Clasificacion desde raceName tipo "Q1.Manga B - Serie 1" => TTS "Clasificacion, Q1, Manga, B, Serie 1".
- v0.0.0.44: UI - oculta botones RD Sarca/Engineer/Hype (algoritmo decide en background).
- v0.0.0.49: UI header - mueve LiveIndicator al renglon de abajo junto a MANUAL, y appVersion al renglon inferior.
- v0.0.0.50: UI header - aumenta header-logo 50% (alto y max-width).
- v0.0.0.51: UI header - baja botones + version para alinear (logo arriba, acciones abajo).
- v0.0.0.57: UI header - aumenta header-logo 15% adicional.
- v0.0.0.58: Nuevo tema "Vic's Pulse" basado en colores del logo (rojo/blanco/negro), acentos y header ajustados.
- v0.0.0.71: Fix raceTitleText (wrap pro: evita guion al inicio de linea y evita el "1" huerfano).
- v0.0.0.72: raceTitleText 33% mas chico (evita cortes en header).
- v0.0.0.79: Bandera en raceTitleText (fix emoji font) + raceTitleText +2px.
- v0.0.0.79: Paquete de temas T1-T8 (orden A: VIC, CARB, BLUE, LIME, PURP, AMBR, ICE, OLED).
- v0.0.0.80: Detalles premium: header "vivo" solo en Live (breath + led sweep) y linea sutil tipo LED bajo botones.

- v0.0.0.59: Guard rails TTS: si falta dato (nombre/gap/tiempo), el spotter se calla (evita "undefined" y frases incompletas).
- v0.0.0.60: Auto Locutor: reintenta 1 vez (re-roll) si una frase queda incompleta; si el segundo intento falla, se calla.
- v0.0.0.62: Bandera azul: menciona nombre del lapeador en P1/P2/P3 (seguimiento y auto locutor).
- v7.5: Fix Auto Locutor: ya no depende de RD, usa POS para top3/peleas por defecto, umbral ajustado para evitar silencio, y no resetea tus voiceSettings.
- v7.4: Auto Locutor PRO narrativo: seguimiento de pelea (focus) con contexto, tendencia de gap, y modo MANGA mejorado (pole/best lap) con menos 'robot'.
- v7.3: Locutor mejorado: frases tipo shuffle-bag (anti repeticin real), manga batalla con nombres+gaps, y micro-variacin en Auto Locutor.
- v7.2: UI piloto + voz: pilotSelect 2x, color por posición, gapInfo blanco grande, extras ms compacto, y clon mini de botn de voz junto al piloto.
- v7.1: TTS (Web Speech API) reforzado: selector de voz visible, botn de prueba, carga de voces con reintentos, y respeto a la voz elegida en la cola.
- v7.0: Nuevo toggle "Modo background" (no pausa al quedar oculta la pestaña/ventana) + reenganche al volver (visibilitychange) + wake lock se reintenta al regresar.
Nota: En iPhone/iOS, el sistema puede pausar TTS cuando la app se va a background real (pantalla apagada o cambiar de app). En Windows/Chrome, si la ventana queda tapada, a veces hay throttling del navegador.-->
<!DOCTYPE html>

<html lang="es">
<head>
<meta charset="utf-8"/>
<title>vics_Smart_Spotter_v0.3.82</title>
<meta content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" name="viewport"/>
<style id="appStyles">


/* ============================================================
   CONSOLIDATED CSS (v0.3.05)
   - Original style blocks merged in source order (no behavior change intended).
   ============================================================ */

html{ color-scheme: dark; -webkit-text-size-adjust: 100%; }
    body{ color-scheme: dark; }

    :root{
      --bg-dark: #040406;
      --card-dark: #080a0f;
      --card-dark-2: #05070c;
      --text-main: #f2f5ff;
      --text-muted: #a3adbd;

      --accent-red: #ff2b2b;
      --accent-red-soft: rgba(255,43,43,0.55);

      --accent-orange: #ff3b3b;
      --accent-orange-soft: rgba(255,59,59,0.55);

      --accent-blue: #cbd5e1;
      --accent-blue-soft: rgba(203,213,225,0.18);

      --accent-cyan: #ff2b2b;
      --border-soft: rgba(148,163,184,0.38);

      --radius-lg: 16px;
      --radius-pill: 999px;

      --shadow-strong: 0 0 18px rgba(255,43,43,0.46);
      --shadow-soft: 0 0 12px rgba(255,255,255,0.08);
      /* Header (app-header) theme */
      --hdr-grad-a: rgba(255,43,43,0.18);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #0b1220;
      --hdr-stripe-b: #05070d;
      --hdr-border: rgba(255,43,43,0.28);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(255,43,43,0.16);

      /* Badge MODO theme (auto por sesin) */
      --mode-bg-neutral: rgba(0,0,0,0.25);
      --mode-brd-neutral: rgba(255,255,255,0.14);
      --mode-bg-manga: linear-gradient(135deg, rgba(255,60,60,.86), rgba(120,0,0,.70));
      --mode-bg-final: linear-gradient(135deg, rgba(255,60,60,.95), rgba(255,255,255,.12));
      --mode-bg-finalA: linear-gradient(135deg, rgba(255,215,0,.96), rgba(255,140,0,.80));

    }

    /* === SKIN: Vic's Pulse Timing (logo palette) === */
    body.skin-vicpulse{
      /* Oscuros (carbon) */
      --bg-dark: #060507;
      --card-dark: #0b090c;
      --card-dark-2: #07060a;
      /* Texto (blanco suave del logo) */
      --text-main: #EAEAEC;
      --text-muted: #C7B3B3;

      /* Acentos (rojo + rojo secundario del logo) */
      --accent-red: #DD1413;
      --accent-red-soft: rgba(221,20,19,0.55);
      --accent-orange: #C14A46;
      --accent-orange-soft: rgba(193,74,70,0.45);

      /* Highlights neutrales */
      --accent-blue: #EAEAEC;
      --accent-blue-soft: rgba(234,234,236,0.18);
      --accent-cyan: #EAEAEC;
      --border-soft: rgba(234,234,236,0.28);

      /* Glow rojo (Pulse) */
      --shadow-strong: 0 0 18px rgba(221,20,19,0.46);
      --shadow-soft: 0 0 12px rgba(234,234,236,0.08);

      /* Header theme */
      --hdr-grad-a: rgba(221,20,19,0.22);
      --hdr-grad-b: rgba(234,234,236,0.06);
      --hdr-stripe-a: #120d10;
      --hdr-stripe-b: #07060a;
      --hdr-border: rgba(221,20,19,0.32);
      --hdr-border-2: rgba(234,234,236,0.10);
      --hdr-glow: 0 0 18px rgba(221,20,19,0.18);

      /* Badge MODO theme */
      --mode-bg-manga: linear-gradient(135deg, rgba(221,20,19,.86), rgba(90,26,31,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(221,20,19,.95), rgba(234,234,236,.10));
      /* finalA se queda dorado (bandera de campeón) */
    }

    

    /* === THEME PACK (T1-T8) - orden A === */
    /* Nota: todos los temas usan el mismo "Skin PRO" (volumen, sombras, bordes 3D) via .skin-pro */

    /* T2 - Carbon Redline */
    body.skin-carbon{
      --accent-rgb: 255, 45, 45;
      --accent2-rgb: 255, 255, 255;
      --bg-dark: #050506;
      --card-dark: #0a0b0f;
      --card-dark-2: #07080c;
      --text-main: #f4f6fb;
      --text-muted: rgba(244,246,251,0.72);
      --accent-red: #ff2d2d;
      --accent-red-soft: rgba(255,45,45,0.52);
      --accent-orange: #ffffff;
      --accent-orange-soft: rgba(255,255,255,0.18);
      --accent-blue: #d6dde8;
      --accent-blue-soft: rgba(214,221,232,0.18);
      --border-soft: rgba(244,246,251,0.16);
      --hdr-grad-a: rgba(255,45,45,0.22);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #0f0f12;
      --hdr-stripe-b: #07070b;
      --hdr-border: rgba(255,45,45,0.30);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(255,45,45,0.18);
      --mode-bg-manga: linear-gradient(135deg, rgba(255,45,45,.88), rgba(80,0,0,.74));
      --mode-bg-final: linear-gradient(135deg, rgba(255,45,45,.95), rgba(255,255,255,.10));
    }

    /* T3 - Stealth Blue */
    body.skin-blue{
      --accent-rgb: 47, 140, 255;
      --accent2-rgb: 140, 215, 255;
      --bg-dark: #05070e;
      --card-dark: #0a1020;
      --card-dark-2: #070c18;
      --text-main: #eef6ff;
      --text-muted: rgba(238,246,255,0.70);
      --accent-red: #2f8cff;
      --accent-red-soft: rgba(47,140,255,0.50);
      --accent-orange: #8cd7ff;
      --accent-orange-soft: rgba(140,215,255,0.22);
      --accent-blue: #d6e7ff;
      --accent-blue-soft: rgba(214,231,255,0.18);
      --border-soft: rgba(238,246,255,0.16);
      --hdr-grad-a: rgba(47,140,255,0.22);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #0b1428;
      --hdr-stripe-b: #070c18;
      --hdr-border: rgba(47,140,255,0.30);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(47,140,255,0.18);
      --mode-bg-manga: linear-gradient(135deg, rgba(47,140,255,.86), rgba(0,35,80,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(47,140,255,.94), rgba(255,255,255,.10));
    }

    /* T4 - Neon Lime */
    body.skin-lime{
      --accent-rgb: 167, 255, 59;
      --accent2-rgb: 220, 255, 190;
      --bg-dark: #050705;
      --card-dark: #0a140a;
      --card-dark-2: #071007;
      --text-main: #f3fff1;
      --text-muted: rgba(243,255,241,0.70);
      --accent-red: #a7ff3b;
      --accent-red-soft: rgba(167,255,59,0.46);
      --accent-orange: #dcffbe;
      --accent-orange-soft: rgba(220,255,190,0.20);
      --accent-blue: #e9ffe1;
      --accent-blue-soft: rgba(233,255,225,0.16);
      --border-soft: rgba(243,255,241,0.16);
      --hdr-grad-a: rgba(167,255,59,0.18);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #0b1a0b;
      --hdr-stripe-b: #071007;
      --hdr-border: rgba(167,255,59,0.28);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(167,255,59,0.16);
      --mode-bg-manga: linear-gradient(135deg, rgba(167,255,59,.82), rgba(10,60,10,.70));
      --mode-bg-final: linear-gradient(135deg, rgba(167,255,59,.90), rgba(255,255,255,.10));
    }

    /* T5 - Purple Night */
    body.skin-purple{
      --accent-rgb: 190, 74, 255;
      --accent2-rgb: 255, 105, 230;
      --bg-dark: #06050a;
      --card-dark: #110b1a;
      --card-dark-2: #0c0714;
      --text-main: #f6f0ff;
      --text-muted: rgba(246,240,255,0.70);
      --accent-red: #be4aff;
      --accent-red-soft: rgba(190,74,255,0.50);
      --accent-orange: #ff69e6;
      --accent-orange-soft: rgba(255,105,230,0.22);
      --accent-blue: #eadbff;
      --accent-blue-soft: rgba(234,219,255,0.18);
      --border-soft: rgba(246,240,255,0.16);
      --hdr-grad-a: rgba(190,74,255,0.20);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #1a0f2a;
      --hdr-stripe-b: #0c0714;
      --hdr-border: rgba(190,74,255,0.28);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(190,74,255,0.16);
      --mode-bg-manga: linear-gradient(135deg, rgba(190,74,255,.84), rgba(50,0,80,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(190,74,255,.92), rgba(255,255,255,.10));
    }

    /* T6 - Amber Heat */
    body.skin-amber{
      --accent-rgb: 255, 176, 0;
      --accent2-rgb: 255, 75, 75;
      --bg-dark: #070504;
      --card-dark: #120b07;
      --card-dark-2: #0c0705;
      --text-main: #fff6ea;
      --text-muted: rgba(255,246,234,0.72);
      --accent-red: #ffb000;
      --accent-red-soft: rgba(255,176,0,0.46);
      --accent-orange: #ff4b4b;
      --accent-orange-soft: rgba(255,75,75,0.22);
      --accent-blue: #ffe3bf;
      --accent-blue-soft: rgba(255,227,191,0.16);
      --border-soft: rgba(255,246,234,0.16);
      --hdr-grad-a: rgba(255,176,0,0.18);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #23110a;
      --hdr-stripe-b: #0c0705;
      --hdr-border: rgba(255,176,0,0.26);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 18px rgba(255,176,0,0.14);
      --mode-bg-manga: linear-gradient(135deg, rgba(255,176,0,.82), rgba(90,30,0,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(255,176,0,.90), rgba(255,255,255,.10));
    }

    /* T7 - Ice White */
    body.skin-ice{
      --accent-rgb: 140, 215, 255;
      --accent2-rgb: 255, 255, 255;
      --bg-dark: #06080b;
      --card-dark: #0c141c;
      --card-dark-2: #091019;
      --text-main: #f1fbff;
      --text-muted: rgba(241,251,255,0.70);
      --accent-red: #8cd7ff;
      --accent-red-soft: rgba(140,215,255,0.42);
      --accent-orange: #ffffff;
      --accent-orange-soft: rgba(255,255,255,0.18);
      --accent-blue: #dff6ff;
      --accent-blue-soft: rgba(223,246,255,0.18);
      --border-soft: rgba(241,251,255,0.16);
      --hdr-grad-a: rgba(140,215,255,0.18);
      --hdr-grad-b: rgba(255,255,255,0.08);
      --hdr-stripe-a: #0b1a24;
      --hdr-stripe-b: #091019;
      --hdr-border: rgba(140,215,255,0.24);
      --hdr-border-2: rgba(255,255,255,0.12);
      --hdr-glow: 0 0 18px rgba(140,215,255,0.14);
      --mode-bg-manga: linear-gradient(135deg, rgba(140,215,255,.78), rgba(10,35,55,.70));
      --mode-bg-final: linear-gradient(135deg, rgba(140,215,255,.86), rgba(255,255,255,.12));
    }

    /* T8 - OLED Minimal */
    body.skin-oled{
      --accent-rgb: 255, 255, 255;
      --accent2-rgb: 255, 45, 45;
      --bg-dark: #000000;
      --card-dark: #050505;
      --card-dark-2: #020202;
      --text-main: #ffffff;
      --text-muted: rgba(255,255,255,0.68);
      --accent-red: #ffffff;
      --accent-red-soft: rgba(255,255,255,0.22);
      --accent-orange: #ff2d2d;
      --accent-orange-soft: rgba(255,45,45,0.26);
      --accent-blue: #e5e7eb;
      --accent-blue-soft: rgba(229,231,235,0.16);
      --border-soft: rgba(255,255,255,0.14);
      --hdr-grad-a: rgba(255,255,255,0.12);
      --hdr-grad-b: rgba(255,255,255,0.06);
      --hdr-stripe-a: #050505;
      --hdr-stripe-b: #000000;
      --hdr-border: rgba(255,255,255,0.18);
      --hdr-border-2: rgba(255,255,255,0.10);
      --hdr-glow: 0 0 16px rgba(255,255,255,0.10);
      --mode-bg-manga: linear-gradient(135deg, rgba(255,255,255,.78), rgba(30,30,30,.72));
      --mode-bg-final: linear-gradient(135deg, rgba(255,255,255,.86), rgba(255,45,45,.12));
    }
body.skin-vicpulse #manualBtn{
      background: linear-gradient(135deg, rgba(221,20,19,.28), rgba(234,234,236,.10));
      border-color: rgba(234,234,236,.18);
    }

    body.skin-vicpulse .header-skin.active{
      background: linear-gradient(135deg, rgba(221,20,19,.92), rgba(193,74,70,.78));
      color: #12060a;
      border-color: rgba(234,234,236,.20);
      box-shadow: 0 0 14px rgba(221,20,19,.35);
    }

    /* Vic Skin PRO - volumen, bordes 3D y botones premium */
    body.skin-vicpulse{
      --bg-dark: #050507;
      --card-dark: #090a0e;
      --card-dark-2: #06070b;
      --text-main: #f4f5f7;
      --text-muted: rgba(234,234,236,0.72);

      --accent-red: #dd1413;
      --accent-red-soft: rgba(221,20,19,0.52);
      --accent-orange: #c14a46;
      --accent-orange-soft: rgba(193,74,70,0.45);

      --border-soft: rgba(234,234,236,0.16);
      --edge-hi: rgba(255,255,255,0.12);
      --edge-lo: rgba(0,0,0,0.55);
      --shadow-elev: 0 14px 32px rgba(0,0,0,0.55);
      --shadow-elev2: 0 10px 22px rgba(0,0,0,0.42);
      --shadow-inset: inset 0 1px 0 rgba(255,255,255,0.10), inset 0 -12px 18px rgba(0,0,0,0.55);

      /* Fondo: maroon + carbono sutil */
      background-color: var(--bg-dark) !important;
      background-image:
        radial-gradient(circle at 18% 12%, rgba(221,20,19,0.18), transparent 56%),
        radial-gradient(circle at 82% 6%, rgba(234,234,236,0.06), transparent 58%),
        radial-gradient(circle at 60% 92%, rgba(90,26,31,0.18), transparent 62%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.028) 0, rgba(255,255,255,0.028) 2px, rgba(0,0,0,0.0) 2px, rgba(0,0,0,0.0) 7px),
        repeating-linear-gradient(45deg, rgba(255,255,255,0.020) 0, rgba(255,255,255,0.020) 1px, rgba(0,0,0,0.0) 1px, rgba(0,0,0,0.0) 6px ) !important;
      background-blend-mode: screen, screen, screen, overlay, overlay !important;
    }

    /* Panels con glass + borde doble */
    body.skin-vicpulse .app-header,
    body.skin-vicpulse .spotter-section,
    body.skin-vicpulse .pilot-card,
    body.skin-vicpulse .controls-section,
    body.skin-vicpulse .top3-mini{
      border: 1px solid rgba(234,234,236,0.16) !important;
      box-shadow: var(--shadow-elev2), 0 0 0 1px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.06) !important;
      background-image:
        radial-gradient(120% 180% at 0% 0%, rgba(221,20,19,0.14), transparent 55%),
        radial-gradient(120% 180% at 100% 0%, rgba(234,234,236,0.05), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.22));
      background-blend-mode: screen, screen, normal;
      backdrop-filter: blur(7px);
      -webkit-backdrop-filter: blur(7px);
    }

    /* Botones premium: relieve + brillo */
    body.skin-vicpulse .btn-primary,
    body.skin-vicpulse .btn-secondary,
    body.skin-vicpulse .spotter-btn,
    body.skin-vicpulse .header-help,
    body.skin-vicpulse .spotter-master-btn,
    body.skin-vicpulse .btn-mini,
    body.skin-vicpulse .btn-grid,
    body.skin-vicpulse .session-preset-card{
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(234,234,236,0.16) !important;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22)) !important;
      box-shadow: var(--shadow-elev2), var(--shadow-inset) !important;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      transform: translateZ(0);
    }

    body.skin-vicpulse .btn-primary::before,
    body.skin-vicpulse .btn-secondary::before,
    body.skin-vicpulse .spotter-btn::before,
    body.skin-vicpulse .header-help::before,
    body.skin-vicpulse .spotter-master-btn::before,
    body.skin-vicpulse .btn-mini::before,
    body.skin-vicpulse .btn-grid::before,
    body.skin-vicpulse .session-preset-card::before{
      content: "";
      position: absolute;
      inset: -2px -2px auto -2px;
      height: 58%;
      background: radial-gradient(120% 140% at 15% 0%, rgba(255,255,255,0.22), rgba(255,255,255,0.08), transparent 70%);
      pointer-events: none;
      opacity: 0.85;
    }

    body.skin-vicpulse .btn-primary:hover,
    body.skin-vicpulse .btn-secondary:hover,
    body.skin-vicpulse .spotter-btn:hover,
    body.skin-vicpulse .header-help:hover,
    body.skin-vicpulse .spotter-master-btn:hover,
    body.skin-vicpulse .btn-mini:hover,
    body.skin-vicpulse .btn-grid:hover,
    body.skin-vicpulse .session-preset-card:hover{
      filter: brightness(1.10);
    }

    body.skin-vicpulse .btn-primary:active,
    body.skin-vicpulse .btn-secondary:active,
    body.skin-vicpulse .spotter-btn:active,
    body.skin-vicpulse .header-help:active,
    body.skin-vicpulse .spotter-master-btn:active,
    body.skin-vicpulse .btn-mini:active,
    body.skin-vicpulse .btn-grid:active,
    body.skin-vicpulse .session-preset-card:active{
      transform: translateY(1px) scale(0.99) !important;
      box-shadow: 0 8px 18px rgba(0,0,0,0.50), inset 0 1px 0 rgba(255,255,255,0.08), inset 0 -10px 16px rgba(0,0,0,0.60) !important;
    }

    /* Estados activos: rojo Vic con glow */
    body.skin-vicpulse .btn-secondary.active,
    body.skin-vicpulse .spotter-btn.active,
    body.skin-vicpulse .spotter-master-btn.active,
    body.skin-vicpulse .session-preset-card.active{
      background: linear-gradient(135deg, rgba(221,20,19,0.92), rgba(193,74,70,0.74)) !important;
      color: rgba(18,6,10,0.98) !important;
      border-color: rgba(234,234,236,0.22) !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 22px rgba(221,20,19,0.22), 0 16px 32px rgba(0,0,0,0.55) !important;
      text-shadow: none;
    }

    /* Header botones un poco mas agresivos */
    body.skin-vicpulse .header-help{
      letter-spacing: 0.08em;
      font-weight: 900;
    }

    /* Contornos finos con relieve en elementos clave */
    body.skin-vicpulse .badge-mode,
    body.skin-vicpulse .badge-live,
    body.skin-vicpulse .manga-clock{
      box-shadow: 0 10px 22px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.10) !important;
    }


        * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      color-scheme: dark;
    }

body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Roboto", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif;
      background-color: var(--bg-dark);
      color: var(--text-main);
      background-image:
        radial-gradient(circle at 20% 10%, rgba(255,43,43,0.12), transparent 55%),
        radial-gradient(circle at 80% 0%, rgba(255,122,24,0.14), transparent 55%),
        radial-gradient(circle at 70% 95%, rgba(255,43,43,0.14), transparent 60%),
        repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0, rgba(255,255,255,0.02) 2px, rgba(0,0,0,0.0) 2px, rgba(0,0,0,0.0) 6px);
      background-blend-mode: screen;
      min-height: 100vh;
    }

    body.no-scroll {
      overflow: hidden !important;
    }

    .app {
      max-width: 480px;
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: calc(10px + env(safe-area-inset-top, 0px)) 12px 12px;
      padding-top: calc(10px + env(safe-area-inset-top));
      padding-left: calc(12px + env(safe-area-inset-left));
      padding-right: calc(12px + env(safe-area-inset-right));
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      gap: 8px;
    }

    .app-header {
      flex-shrink: 0;
      padding: 10px 14px;
      padding-bottom: 34px;
      position: relative;
      border-radius: var(--radius-lg);
      border: 1px solid var(--hdr-border);
      box-shadow: var(--shadow-soft), var(--hdr-glow);
      background-image:
        radial-gradient(120% 180% at 0% 0%, rgba(255,43,43,0.22), transparent 55%),
        radial-gradient(120% 180% at 100% 0%, rgba(255,255,255,0.08), transparent 55%),
        linear-gradient(135deg, var(--hdr-grad-a), var(--hdr-grad-b)),
        repeating-linear-gradient(45deg, var(--hdr-stripe-a) 0, var(--hdr-stripe-a) 2px, var(--hdr-stripe-b) 2px, var(--hdr-stripe-b) 4px),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 6px);
      background-blend-mode: screen, screen, normal, normal, overlay;
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .header-left{
      height: 123px;
      max-height: 123px;
      min-height: 123px;
      flex: 1 1 224px;
      max-width: 224px;
      min-width: 0;
      box-sizing: border-box;
      overflow: hidden;
    }

.header-title-main {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      flex-wrap: wrap;
      min-width: 0;
    }

    .badge-mode {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      border: 1px solid var(--mode-brd-neutral);
      background: var(--mode-bg-neutral);
      white-space: nowrap;
      box-shadow: 0 0 10px rgba(0,0,0,0.25);
    
      /* FORCE_VISIBLE_DEFAULT */
      background: linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06));
      color: rgba(255,255,255,0.92);
      border-color: rgba(255,255,255,0.22);
      text-shadow: 0 2px 10px rgba(0,0,0,0.55);
    
    }
    .badge-mode.mode-manga{
      background: var(--mode-bg-manga);
      border-color: rgba(255,255,255,0.14);
      color: #071018;
      box-shadow: 0 0 12px rgba(0,229,255,0.25);
   
      /* SIZE_70 */
      font-size: 11px;
      line-height: 1;
      padding: 1px 3px;
      gap: 2px;
    }
    .badge-mode.mode-final{
      background: var(--mode-bg-final);
      border-color: rgba(255,255,255,0.14);
      color: #0b0f14;
      box-shadow: 0 0 12px rgba(255,140,0,0.22);
    }
    .badge-mode.mode-finalA{
      background: var(--mode-bg-finalA);
      border-color: rgba(255,255,255,0.16);
      color: #101015;
      box-shadow: 0 0 14px rgba(255,215,0,0.22);
    }

    .header-title-sub {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent-orange-soft);
      width:225px;

  max-width:225px;
}

    .header-subline {
      font-size: 10px;
      color: var(--text-muted);
    
      line-height: 1.1;
      margin-top: 0;
      margin-bottom: 0;}

    .header-mini {
      font-size: 9px;
      color: var(--text-muted);
    
      line-height: 1.1;
      margin-top: -2px;
      margin-bottom: 0;}
    .header-right{
      height: 123px;
      max-height: 123px;
      min-height: 123px;
      flex: 0 1 200px;
      max-width: 200px;
      min-width: 160px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      text-align: center;
    }

@media (max-width: 520px){
  .app-header{ flex-wrap: wrap; padding: 10px 12px; gap: 10px; }
  .header-left{ flex: 1 1 100%; max-width: none; height: auto; min-height: 0; }
  .header-right{ flex: 1 1 100%; max-width: none; width: 100%; height: auto; min-height: 0; }
  .header-right-inner{ height: auto; min-height: 0; }

  /* Titulo: que respire en movil */
  #raceTitleMain{ justify-content: flex-start; flex-wrap: wrap; gap: 8px; }

  #raceTitleText{
    max-width: 100%;
    width: auto;
    flex: 1 1 auto;
    font-size: clamp(12px, 3.6vw, 16px);
    max-height: none;
    -webkit-line-clamp: 3;
  }

  #raceSubtitle{
    max-width: 100%;
    width: auto;
    font-size: clamp(11px, 3.0vw, 12px);
  }


  /* v0.0.1.47: Reduce secondary header info only (keep logo + main title big) */
  :root{
    --hdrSubTextScale: 0.40; /* 40% size for info lines */
    --hdrControlsScale: 0.70; /* keep controls usable */
  }

  /* Info lines smaller (race subtitle/info/tick + version) */
  .app-header .header-title-sub,
  .app-header .header-subline,
  .app-header .header-mini,
  .app-header .header-version{
    position: absolute;
    left: 0; right: 0;
    bottom: 8px;
    text-align: center;
    font-size: 11px;
    line-height: 1.1;
    letter-spacing: .6px;
    opacity: 0.88;
    pointer-events: none;
  }

  /* Mode badge: slightly reduced but still readable */
  .app-header .header-mode-row{
    transform: scale(0.78);
    transform-origin: top center;
    margin-top: -2px;
    margin-bottom: -2px;
  }

  /* Controls row smaller but clickable */
  .app-header .header-controls{
    transform: scale(var(--hdrControlsScale));
    transform-origin: top center;
    margin-top: -2px;
  }

  /* Keep header stack spacing tighter since subtext shrank */
  .app-header .header-stack{
    gap: 2px;
  }

  .header-subline{ font-size: 12px; }
}

  .header-left{ max-width: none; }
}


.header-right-bottom{
      margin-top: auto;
      display:flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      width: 100%;
    }

    .header-actions-row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: var(--hdrCtrlGap);
      width: 100%;
    }
    /* Badge de MODO dentro de controles - mismo tamao que botones */
    .header-actions-row #raceModeRow{
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .header-actions-row #raceModeBadge.badge-mode{
      height: var(--hdrCtrlH) !important;
      min-width: var(--hdrCtrlW) !important;
      width: var(--hdrCtrlW) !important;
      padding: 0 var(--hdrCtrlPadX) !important;
      font-size: var(--hdrCtrlFont) !important;
      font-weight: 800;
      letter-spacing: 0.06em;
      line-height: 1;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      border-radius: 12px !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }

    .header-logo{
      display:flex;
      align-items:center;
      justify-content:center;
      width: 100%;
      align-self: stretch;
      overflow: visible;
    }
    .header-logo img{
      width: 400px;
      height: 70px;
      max-width: 100%;
      max-height: 70px;
      object-fit: contain;
      image-rendering: auto;
      filter: drop-shadow(0 0 10px rgba(0,255,163,0.25));
    }

.badge-live {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 9px;
      border-radius: var(--radius-pill);
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 0 10px rgba(34,197,94,0.8);
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .badge-live-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background-color: #bbf7d0;
    }

    .badge-voice-dot{
      width: 8px;
      height: 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.35);
      background: #ef4444;
      box-shadow: 0 0 10px rgba(239,68,68,0.65);
    }
    .badge-voice-dot.voice-on{
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34,197,94,0.85);
    }
    .badge-voice-dot.voice-off{
      background: #ef4444;
      box-shadow: 0 0 10px rgba(239,68,68,0.65);
    }


    
    .badge-voice-dot.voice-warn{
      background: #f59e0b;
      box-shadow: 0 0 10px rgba(245,158,11,0.75);
    }
    .badge-voice-dot.voice-speaking{
      outline: 1px solid rgba(255,255,255,0.35);
    }

.badge-live.live-off {
      background: #4b5563;
      box-shadow: none;
    }

    .badge-live.live-off .badge-live-dot {
      background-color: #9ca3af;
    }

    .header-version {
      font-size: 10px;
      color: var(--text-muted);
      width: 100%;
      text-align: center;
    }

    .app-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
    }

    .pilot-card {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background-image:
        linear-gradient(145deg, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      border: 1px solid rgba(249,115,22,0.7);
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .pilot-card-top-strip {
      height: 4px;
      border-radius: 999px;
      background-image:
        linear-gradient(90deg, #b91c1c, var(--accent-orange), #b91c1c),
        repeating-linear-gradient(45deg, #111827 0, #111827 2px, #020617 2px, #020617 4px);
      background-blend-mode: overlay;
    }

    .pilot-row-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .pilot-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .pilot-name {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      flex: 1;
      min-width: var(--hdrCtrlW) !important;
    }

    .pilot-name-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      width:100%;
      min-width: var(--hdrCtrlW) !important;
    }

    .pilot-laps-big{
      margin-left:auto;
      font-size: 23px;
      line-height: 1;
      font-weight: 900;
      letter-spacing: -0.02em;
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
      text-shadow: 0 10px 20px rgba(0,0,0,0.55);
    }

    .pilot-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    .pilot-select {
      flex: 1;
      margin-top: 4px;
    }

    .pilot-select select {
      width: 100%;
      padding: 12px 34px 12px 14px; /* right space for arrow */
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      font-size: 18px;
      font-weight: 800;
      outline: none;

      /* Cross-browser consistency */
      color-scheme: dark;
      -webkit-appearance: none;
      appearance: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;

      /* Custom arrow (stable on Chrome/Safari/Android) */
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(242,245,255,0.72) 50%),
        linear-gradient(135deg, rgba(242,245,255,0.72) 50%, transparent 50%);
      background-position: calc(100% - 18px) 50%, calc(100% - 12px) 50%;
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;

      transition: border-color 0.12s ease, box-shadow 0.12s ease, color 0.12s ease;
    }

    .pilot-select select:focus {
      border-color: rgba(45,107,255,0.50);
      box-shadow: 0 0 0 3px rgba(255,43,43,0.14);
    }
    /* Mejor esfuerzo: algunos navegadores respetan estilos de option */
    .pilot-select select option {
      background-color: #0b1220;
      color: #ffffff;
    }

    .pilot-select select option:checked {
      background-color: rgba(45,107,255,0.55);
      color: #ffffff;
    }


    .pilot-select-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 6px;
    }

    .btn-voice-mini {
      flex: 0 0 50%;
      padding: 6px 8px;
      font-size: 11px;
      letter-spacing: 0.06em;
    }

    .btn-basic-mini {
      flex: 0 0 38%;
      padding: 6px 8px;
      font-size: 11px;
      letter-spacing: 0.06em;
      opacity: 0.95;
      border: 1px solid rgba(239,68,68,0.85);
      background: linear-gradient(135deg, rgba(239,68,68,0.38), rgba(127,29,29,0.18));
      color: rgba(255,255,255,0.94);
      box-shadow: 0 0 12px rgba(239,68,68,0.18);
    }
    .btn-basic-mini.active{
      opacity: 1.0;
      border: 1px solid rgba(34,197,94,0.92);
      background: linear-gradient(135deg, rgba(34,197,94,0.60), rgba(21,128,61,0.22));
      color: rgba(255,255,255,0.98);
      box-shadow: 0 0 14px rgba(34,197,94,0.26);
    }
    .btn-basic-mini[disabled]{
      opacity: 0.35;
      cursor: not-allowed;
      filter: grayscale(0.35);
    }

/* Checkbox - Prefijo de vueltas (FOLLOW) */
    .saylaps-toggle{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
      flex: 0 0 18%;
      padding: 6px 8px;
      font-size: 11px;
      letter-spacing: 0.06em;
      opacity: 0.95;
      border: 1px solid rgba(56,189,248,0.70);
      background: linear-gradient(135deg, rgba(56,189,248,0.22), rgba(30,58,138,0.14));
      color: rgba(255,255,255,0.94);
      box-shadow: 0 0 12px rgba(56,189,248,0.12);
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .saylaps-toggle input{
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: rgba(56,189,248,0.95);
    }
    .saylaps-toggle.disabled{
      opacity: 0.35;
      cursor: not-allowed;
      filter: grayscale(0.35);
    }


/* Color del selector por posición */
    #pilotSelect.pos-none {
      border-color: var(--border-soft);
      box-shadow: none;
    }
    #pilotSelect.pos-1 {
      background: linear-gradient(135deg, rgba(255,215,0,0.96), rgba(255,140,0,0.82));
      border-color: rgba(255,215,0,0.55);
      box-shadow: 0 0 14px rgba(255,215,0,0.18);
      color: #0b0f14;
    }
    #pilotSelect.pos-2 {
      background: linear-gradient(135deg, rgba(229,231,235,0.96), rgba(156,163,175,0.74));
      border-color: rgba(229,231,235,0.46);
      box-shadow: 0 0 14px rgba(229,231,235,0.12);
      color: #0b0f14;
    }
    #pilotSelect.pos-3 {
      background: linear-gradient(135deg, rgba(251,146,60,0.96), rgba(180,83,9,0.78));
      border-color: rgba(251,146,60,0.46);
      box-shadow: 0 0 14px rgba(251,146,60,0.14);
      color: #0b0f14;
    }
    #pilotSelect.pos-top5 {
      border-color: rgba(34,197,94,0.42);
      box-shadow: 0 0 14px rgba(34,197,94,0.12);
      background: linear-gradient(135deg, rgba(34,197,94,0.20), rgba(16,185,129,0.14));
    }
    #pilotSelect.pos-other {
      border-color: rgba(45,107,255,0.40);
      box-shadow: 0 0 12px rgba(45,107,255,0.10);
    }
    #pilotSelect.is-loading{ opacity:0.92; filter:saturate(0.85); }


    @media (max-width: 430px){
      .btn-voice-mini { flex-basis: 58%; }
      .btn-basic-mini { flex-basis: 38%; }
      .pilot-select select { font-size: 16px; padding: 10px 12px; }
    }

    .pilot-pos-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 4px;
    }

    .pos-pill {
      padding: 4px 12px;
      border-radius: var(--radius-pill);
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      box-shadow: var(--shadow-strong);
    }

    .pos-info {
      font-size: 14px;
      color: #ffffff;
      font-weight: 700;
      text-align: right;
    }

    .pilot-timings {
      margin-top: 6px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .timing-item {
      padding: 6px 6px 7px;
            border-radius: 10px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.95), rgba(3,7,18,0.98));
      border: 1px solid rgba(15,23,42,0.9);
    }

    .timing-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-muted);
      margin-bottom: 2px;
    }

    .timing-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent-cyan);
      transition: transform 0.2s ease, text-shadow 0.2s ease;
    }

    .timing-value.flash {
      transform: scale(1.22);
      text-shadow: 0 0 12px rgba(34,211,238,0.9);
    }

    .controls-section {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .controls-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .controls-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    .voice-speed-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .voice-speed-value {
      font-size: 11px;
      color: var(--accent-orange-soft);
      min-width: var(--hdrCtrlW) !important;
      text-align: right;
    }

    .voice-select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.55);
      color: var(--text-main);
      font-size: 12px;
      outline: none;
    }
    .voice-select option {
      background: #0b1120;
      color: var(--text-main);
    }

    input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(90deg, #111827, var(--accent-orange), #b91c1c);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-orange);
      box-shadow: 0 0 10px rgba(249,115,22,0.9);
      border: 2px solid #fee2e2;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-orange);
      box-shadow: 0 0 10px rgba(249,115,22,0.9);
      border: 2px solid #fee2e2;
      cursor: pointer;
    }

    .buttons-row {
      display: flex;
      gap: 8px;
    }

    .rate-row {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.08);
            border-radius: 10px;
      background: rgba(255,255,255,0.03);
    }
    .rate-label {
      min-width: var(--hdrCtrlW) !important;
      font-weight: 700;
      letter-spacing: 0.2px;
      opacity: 0.95;
    }
    #rateRange {
      flex: 1;
      accent-color: #ff5a1f;
    }
    .rate-display {
      min-width: var(--hdrCtrlW) !important;
      text-align: right;
      font-variant-numeric: tabular-nums;
      opacity: 0.95;
    }

    .btn-primary,
    .btn-secondary {
      flex: 1;
      padding: 8px 10px;
      border-radius: var(--radius-pill);
      border: none;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: transform 0.06s ease, box-shadow 0.06s ease, background 0.06s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      box-shadow: var(--shadow-strong);
    }

    .btn-secondary {
      background: transparent;
      color: var(--accent-orange-soft);
      border: 1px solid rgba(248,113,113,0.7);
    }

    .btn-primary:active,
    .btn-secondary:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 0 4px rgba(15,15,15,0.8);
    }

    .btn-primary.voice-on {
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 0 12px rgba(34,197,94,0.9);
    }

    .spotter-section {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background: linear-gradient(160deg, rgba(15,23,42,0.98), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .spotter-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
    }

    .spotter-btn {
  padding: 4px 6px;
  border-radius: var(--radius-pill);
  font-size: 11px;
  border: 1px solid var(--border-soft);
  background: rgba(15,23,42,0.96);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: pointer;
  transition: background 0.08s ease, box-shadow 0.08s ease, color 0.08s ease, border 0.08s ease;
  user-select: none;

  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;

  white-space: nowrap;
  overflow: visible;
  text-overflow: clip;
  min-height: 30px;
}

    .spotter-btn span {
  font-size: 12px;
  flex: 0 0 auto;
}

    .spotter-btn.active {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      border-color: rgba(254,242,242,0.85);
      box-shadow: var(--shadow-soft);
    }

    

    /* Categorias de mensajes */
    .spotter-cat {
      border-radius: 14px;
      padding: 6px 6px 8px;
      border: 1px solid rgba(148,163,184,0.30);
      background: rgba(2,6,23,0.35);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .spotter-cat-head {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: var(--radius-pill);
      font-size: 10px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(148,163,184,0.25);
      user-select: none;
    }

    .spotter-cat .cat-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 0 10px rgba(255,255,255,0.15);
      flex: 0 0 auto;
    }

    .spotter-btn.lock::after {
      content: "";
      font-size: 12px;
      margin-left: 6px;
      opacity: 0.95;
    }

    
    .spotter-cat[data-cat="essential"] {
      border-color: rgba(255,70,70,0.48);
    }
    .spotter-cat[data-cat="essential"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(255,70,70,0.18), rgba(255,140,0,0.14));
      border-color: rgba(255,70,70,0.32);
      color: rgba(255,230,230,0.95);
    }
    .spotter-cat[data-cat="essential"] .cat-dot {
      background: rgba(255,70,70,0.95);
      box-shadow: 0 0 12px rgba(255,70,70,0.55);
    }
    .spotter-cat[data-cat="essential"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(255,70,70,0.95), rgba(255,140,0,0.78));
      box-shadow: 0 0 14px rgba(255,70,70,0.22);
      color: #0b0f14;
      border-color: rgba(255,255,255,0.10);
    }

    .spotter-cat[data-cat="battle"] {
      border-color: rgba(255,170,0,0.46);
    }
    .spotter-cat[data-cat="battle"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(255,170,0,0.18), rgba(255,90,0,0.10));
      border-color: rgba(255,170,0,0.30);
      color: rgba(255,245,220,0.95);
    }
    .spotter-cat[data-cat="battle"] .cat-dot {
      background: rgba(255,170,0,0.95);
      box-shadow: 0 0 12px rgba(255,170,0,0.55);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,140,0,0.80));
      box-shadow: 0 0 14px rgba(255,170,0,0.20);
      color: #0b0f14;
      border-color: rgba(255,255,255,0.10);
    }

    .spotter-cat[data-cat="summary"] {
      border-color: rgba(0,255,140,0.42);
    }
    .spotter-cat[data-cat="summary"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(0,255,140,0.14), rgba(0,170,90,0.10));
      border-color: rgba(0,255,140,0.26);
      color: rgba(220,255,240,0.95);
    }
    .spotter-cat[data-cat="summary"] .cat-dot {
      background: rgba(0,255,140,0.92);
      box-shadow: 0 0 12px rgba(0,255,140,0.50);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(0,255,140,0.92), rgba(0,170,90,0.80));
      box-shadow: 0 0 14px rgba(0,255,140,0.18);
      color: #06110c;
      border-color: rgba(255,255,255,0.10);
    }
.extras-section {
      zoom: 0.67;

      border-radius: var(--radius-lg);
      padding: 2px 4px 4px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.96), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 1px;
    }

    .precision-row {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .precision-buttons {
      display: flex;
      gap: 4px;
    }

    .precision-badge {
      flex: 1;
      padding: 4px 0;
      border-radius: var(--radius-pill);
      font-size: 10px;
      border: 1px solid var(--border-soft);
      background: rgba(15,23,42,0.96);
      color: var(--text-muted);
      text-align: center;
      cursor: default;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      transition: background 0.08s ease, color 0.08s ease, border 0.08s ease;
    }

    .precision-badge.active {
      background: linear-gradient(135deg, var(--accent-orange), var(--accent-red));
      color: var(--text-main);
      border-color: rgba(254,242,242,0.85);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-top: 1px;
    }

    .toggle-label {
      font-size: 9px;
      color: var(--text-muted);
    }

    .toggle-pill {
      width: 30px;
      height: 15px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid var(--border-soft);
      position: relative;
      cursor: pointer;
      transition: background 0.08s ease, border 0.08s ease;
    }

    .toggle-thumb {
      width: 11px;
      height: 11px;
      border-radius: 999px;
      background: #9ca3af;
      position: absolute;
      top: 1px;
      left: 1px;
      transition: transform 0.12s ease, background 0.12s ease, box-shadow 0.12s ease;
    }

    .toggle-pill.active {
      background: linear-gradient(135deg, var(--accent-orange), var(--accent-red));
      border-color: rgba(254,242,242,0.85);
    }

    .toggle-pill.active .toggle-thumb {
      transform: translateX(18px);
      background: #fef2f2;
      box-shadow: 0 0 8px rgba(248,113,113,0.9);
    }

    .wake-status {
      font-size: 9px;
      color: var(--text-muted);
      text-align: right;
    }

    .grid-button-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 2px;
    }

    .btn-grid {
      flex: 1;
      padding: 8px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(248,113,113,0.7);
      background: rgba(15,23,42,0.96);
      color: var(--accent-orange-soft);
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      cursor: pointer;
    }

    .hint-text {
      font-size: 10px;
      color: var(--text-muted);
      text-align: right;
    }

    .grid-sheet-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: flex-end;
      justify-content: center;
      z-index: 30;
    }

    .grid-sheet-backdrop.open {
      display: flex;
    }

    
.grid-sheet {
      width: min(980px, 96vw);
      max-width: 980px;
      max-height: 92vh;
      height: 92vh;
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      border-radius: 18px;
      border: 1px solid rgba(248,113,113,0.45);
      box-shadow: 0 18px 40px rgba(0,0,0,0.80);
      padding: 8px 12px 12px;
      overflow: hidden;                 /* el scroll vive en la lista */
      display: flex;
      flex-direction: column;
    }

    /* Si el alto disponible es chico (cel), ancla abajo estilo sheet */
    @media (max-width: 560px) {
      .grid-sheet {
        width: 100%;
        max-width: 560px;
        height: 92vh;
        border-radius: 18px 18px 0 0;
        border-left: 0;
        border-right: 0;
        border-bottom: 0;
      }
    }
.grid-sheet-handle {
      width: 40px;
      height: 4px;
      border-radius: 999px;
      background: rgba(148,163,184,0.7);
      margin: 4px auto 8px;
    }

    
    .grid-sheet-header {
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px 8px;
      margin-bottom: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,140,0,0.22);
      box-shadow: 0 10px 18px rgba(0,0,0,0.55);
      background-image:
        radial-gradient(120% 160% at 0% 0%, rgba(0,229,255,0.18), transparent 55%),
        radial-gradient(120% 160% at 100% 0%, rgba(255,140,0,0.18), transparent 55%),
        linear-gradient(135deg, rgba(255,40,40,0.10), rgba(255,140,0,0.12)),
        repeating-linear-gradient(45deg, rgba(11,18,32,0.85) 0, rgba(11,18,32,0.85) 2px, rgba(5,7,13,0.85) 2px, rgba(5,7,13,0.85) 4px);
      background-blend-mode: screen, screen, normal, normal;
    }

    .grid-sheet-title-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .grid-sheet-title {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      font-weight: 900;
      color: rgba(255,190,120,0.95);
      line-height: 1.05;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .grid-sheet-sub {
      font-size: 10px;
      color: rgba(226,232,240,0.78);
      letter-spacing: 0.04em;
      opacity: 0.95;
    }

    .grid-sheet-hud {
      margin-top: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,140,0,0.14);
    }

    .grid-hud-left {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      min-width: 0;
    }

    .grid-hud-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border-radius: 999px;
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      background: rgba(2,6,23,0.60);
      border: 1px solid rgba(148,163,184,0.28);
      color: rgba(226,232,240,0.92);
      box-shadow: 0 0 10px rgba(0,0,0,0.30);
      white-space: nowrap;
    }

    .grid-hud-chip-mode {
      border-color: rgba(34,211,238,0.22);
      color: rgba(34,211,238,0.95);
      background: rgba(2,6,23,0.55);
    }

    .grid-hud-chip.mode-manga {
      border-color: rgba(0,229,255,0.30);
      color: rgba(0,229,255,0.95);
      background: rgba(0,229,255,0.12);
    }

    .grid-hud-chip.mode-final {
      border-color: rgba(255,140,0,0.32);
      color: rgba(255,180,90,0.96);
      background: rgba(255,140,0,0.12);
    }

    .grid-hud-chip.mode-finalA {
      border-color: rgba(255,215,0,0.35);
      color: rgba(255,215,0,0.96);
      background: rgba(255,215,0,0.12);
    }

    .grid-meta-right {
      font-size: 11px;
      font-weight: 800;
      color: var(--accent-cyan);
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 52%;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(2,6,23,0.45);
      border: 1px solid rgba(34,211,238,0.20);
    }

    .btn-sheet-close {
      width: 34px;
      height: 34px;
      flex: 0 0 auto;
            border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.28);
      background: rgba(2,6,23,0.55);
      color: rgba(226,232,240,0.90);
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0,0,0,0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .btn-sheet-close:hover {
      border-color: rgba(255,140,0,0.30);
      box-shadow: 0 0 12px rgba(255,140,0,0.18);
    }
    
    .grid-list {
      --grid-cols: 1;
 
      min-height: 0;
      display: grid;
      grid-template-columns: repeat(var(--grid-cols), minmax(220px, 1fr));
      gap: 8px;
      padding-bottom: 8px;
      overflow-y: auto;                 /* si no cabe, desliza */
      overscroll-behavior: contain;

      scrollbar-width: none;            /* Firefox */
      -ms-overflow-style: none;         /* IE/Edge legacy */
    }
    .grid-list::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }
.grid-row {
            border-radius: 10px;
      padding: 5px 8px;
      background: rgba(15,23,42,0.96);
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 11px;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    .grid-row-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .grid-pos {
      font-weight: 700;
      font-size: 12px;
    }

    .grid-name {
      flex: 1;
      font-size: 12px;
    }

    .grid-tags {
      font-size: 10px;
      color: var(--text-muted);
    }

    .grid-row.p1 {
      border-color: #facc15;
    }
    .grid-row.p2 {
      border-color: #e5e7eb;
    }
    .grid-row.p3 {
      border-color: var(--accent-orange);
    }

    .grid-row.selected {
      border-color: var(--accent-cyan);
      box-shadow: 0 0 10px rgba(34,211,238,0.7);
    }

    /* GRID COMPLETO - UI PRO (v5.0.0) */
    .grid-sheet-headleft {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
      flex: 1;
    }

    .grid-row {
      cursor: pointer;
      padding: 9px 10px;
    }
    .grid-row:hover {
      transform: translateY(-1px);
      border-color: rgba(34,211,238,0.35);
      box-shadow: 0 10px 18px rgba(0,0,0,0.45);
    }
    .grid-row-top {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .grid-pos-pill {
      min-width: 42px;
      height: 26px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      font-size: 12px;
      background: rgba(2,6,23,0.70);
      border: 1px solid rgba(148,163,184,0.35);
      color: rgba(226,232,240,0.95);
      flex: 0 0 auto;
    }
    .grid-name-wrap {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .grid-name {
      font-size: 12px;
      font-weight: 900;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      letter-spacing: 0.02em;
    }
    .grid-sub {
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.95;
    }

    .grid-metrics {
      display: flex;
      gap: 6px;
      align-items: stretch;
      justify-content: flex-end;
      flex-wrap: wrap;
      flex: 0 0 auto;
    }
    .grid-kpi {
      min-width: 70px;
      padding: 4px 6px;
      border-radius: 10px;
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(34,211,238,0.12);
      text-align: right;
    }
    .grid-kpi .k {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.9;
    }
    .grid-kpi .v {
      font-size: 11px;
      font-weight: 900;
      color: rgba(226,232,240,0.96);
      letter-spacing: 0.02em;
    }
    .grid-kpi.best .v { color: var(--accent-cyan); }
    .grid-kpi.last .v { color: var(--accent-orange-soft); }
    .grid-kpi.mean .v { color: rgba(226,232,240,0.96); }

    .grid-row-bottom {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }
    .grid-chip {
      font-size: 10px;
      color: rgba(226,232,240,0.78);
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.45);
      border: 1px solid rgba(55,65,81,0.75);
    }
    .grid-chip strong {
      color: rgba(226,232,240,0.96);
      font-weight: 800;
    }

    @media (max-width: 420px) {
      .grid-kpi { min-width: 66px; }
      .grid-meta-right { max-width: 64%; }
    }

    
    .lap-chart-wrap {
      margin-top: 8px;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid rgba(251, 146, 60, 0.22);
      background: linear-gradient(180deg, rgba(2, 6, 23, 0.55), rgba(2, 6, 23, 0.25));
      box-shadow: inset 0 0 0 1px rgba(34,211,238,0.08);
    }
    .lap-chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }
    .lap-chart-title {
      font-size: 12px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.85);
    }
    .lap-chart-meta {
      font-size: 11px;
      color: rgba(148,163,184,0.95);
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 6px;
      flex: 0 0 390px;
      width: 390px;
      max-width: 390px;
      min-width: 0;
      white-space: nowrap;
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
    }
    .lap-chart-meta::-webkit-scrollbar { display: none; }
    
    .lap-pos-chip{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.22);
      background: rgba(2,6,23,0.28);
      margin-left:6px;
      line-height: 1.05;
    }
    .lap-pos-chip:first-child{ margin-left:0; }
    .lap-pos-chip .lp{
      font-weight:800;
      letter-spacing:0.02em;
      opacity:0.96;
    }
    .lap-pos-chip .nm{
      opacity:0.92;
      max-width:110px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      display:inline-block;
    }
.lap-pos-chip.pos1{ border-color: rgba(251,191,36,0.45); color: rgba(255,240,200,0.96); }
    .lap-pos-chip.pos2{ border-color: rgba(255,255,255,0.35); color: rgba(255,255,255,0.92); }
    .lap-pos-chip.pos3{ border-color: rgba(249,115,22,0.45); color: rgba(255,230,210,0.94); }

    .lap-pos-chip.active.pos1{ background: rgba(251,191,36,0.12); border-color: rgba(251,191,36,0.75); }
    .lap-pos-chip.active.pos2{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.70); }
    .lap-pos-chip.active.pos3{ background: rgba(249,115,22,0.12); border-color: rgba(249,115,22,0.78); }

    .top3-mini-grid{
      margin-top: 8px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }
.top3-mini-grid.expanded{ max-height: none; overflow: visible; }
@media (max-width: 380px){
  .top3-mini-grid.expanded{ max-height: none; overflow: visible; }
}
.top3-mini-grid.expanded .top3-mini-row{
  padding: 6px 8px;
  gap: 8px;
}
.top3-mini-grid.expanded .top3-mini-name{
  max-width: 34vw;
}
.top3-mini-grid.expanded .top3-mini-stats{
  max-width: 40vw;
  gap: 6px;
}
    .top3-mini-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 7px 10px;
            border-radius: 10px;
      background: rgba(2,6,23,0.28);
      border: 1px solid rgba(148,163,184,0.22);
      box-shadow: 0 6px 14px rgba(0,0,0,0.20);
    }
    .top3-mini-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .top3-mini-pos{
      width: 34px;
      height: 22px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      font-size: 12px;
      letter-spacing: 0.02em;
      border: 1px solid rgba(148,163,184,0.28);
      flex: 0 0 auto;
    }
    .top3-mini-name{
      font-weight: 750;
      font-size: 12px;
      color: rgba(226,232,240,0.95);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 52vw;
    }
    .top3-mini-right{
      font-weight: 650;
      font-size: 11px;
      color: rgba(148,163,184,0.95);
      flex: 0 0 auto;
      display:flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
      line-height: 1.05;
    }
    .top3-mini-num{
      font-weight: 800;
      font-size: 11px;
      color: rgba(226,232,240,0.92);
    }
    .top3-mini-stats{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
      font-size: 10px;
      color: rgba(148,163,184,0.92);
      flex-wrap: wrap;
      max-width: 46vw;
    }
    .top3-mini-stat{
      display:flex;
      align-items: baseline;
      gap: 3px;
      white-space: nowrap;
    }
    .top3-mini-k{
      font-weight: 900;
      font-size: 9px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.78);
    }
    .top3-mini-row.pos1{ border-color: rgba(251,191,36,0.28); }
    .top3-mini-row.pos2{ border-color: rgba(255,255,255,0.20); }
    .top3-mini-row.pos3{ border-color: rgba(249,115,22,0.26); }

    .top3-mini-pos.pos1{ background: rgba(251,191,36,0.14); border-color: rgba(251,191,36,0.55); color: rgba(255,245,210,0.98); }
    .top3-mini-pos.pos2{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.45); color: rgba(255,255,255,0.96); }
    .top3-mini-pos.pos3{ background: rgba(249,115,22,0.14); border-color: rgba(249,115,22,0.55); color: rgba(255,235,220,0.96); }
.top3-mini-row.posN{ border-color: rgba(148,163,184,0.16); }
.top3-mini-pos.posN{ background: rgba(148,163,184,0.10); border-color: rgba(148,163,184,0.30); color: rgba(226,232,240,0.92); }

    /* =========================
       TIMING MINI GRID (v6.5)
       Objetivo: Top3/Top20 con jerarqua de INT, nmeros tabulares, DUEL y barra de gap.
       ========================= */

    /* Dgitos parejitos (broadcast vibe) */
    .tgrid-nums{
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1, "ss01" 1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .top3-mini-row{
      padding: 6px 10px;
      gap: 10px;
    }

    /* Caja del # (auto) */
    .tgrid-numbox{
      min-width: 34px;
      height: 18px;
      padding: 0 8px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(148,163,184,0.10);
      border: 1px solid rgba(148,163,184,0.24);
      color: rgba(226,232,240,0.92);
      font-weight: 900;
      font-size: 11px;
      line-height: 1;
    }

    /* Estructura principal */
    .tgrid-main{
      width: 100%;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      min-width: 0;
    }

    .tgrid-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
      flex: 1 1 auto;
    }

    .tgrid-namewrap{ min-width: 0; flex: 1 1 auto; }

    .tgrid-name{
      font-weight: 850;
      font-size: 12px;
      color: rgba(226,232,240,0.96);
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      line-height: 1.15;
      word-break: break-word;
    }

    .tgrid-sub{
      margin-top: 2px;
      display:flex;
      align-items:baseline;
      justify-content:flex-start;
      gap: 10px;
      color: rgba(148,163,184,0.92);
      font-size: 10px;
      line-height: 1.05;
      flex-wrap: nowrap;
      white-space: nowrap;
    }

    .tgrid-sub .k{
      font-weight: 900;
      font-size: 9px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.78);
      margin-right: 4px;
    }

    /* Columnas fijas tipo timing screen */
    .tgrid-col{
      display:inline-flex;
      align-items:baseline;
      justify-content:flex-end;
      text-align:right;
      white-space: nowrap;
    }
    .tgrid-col.v{ min-width: 38px; }
    .tgrid-col.bl{ min-width: 96px; }
    .tgrid-col.int{ min-width: 96px; }

    .tgrid-right{
      display:flex;
      flex-direction: column;
      align-items:flex-end;
      justify-content:center;
      gap: 4px;
      flex: 0 0 auto;
    }

    /* INT protagonista */
    .tgrid-intwrap{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
    }

    /* INT block (line + bar) */
    .tgrid-intblock{
      display:flex;
      flex-direction: column;
      align-items:flex-end;
      gap: 4px;
    }

    .tgrid-intline{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
    }

    /* Compacto: que sea 1 línea real (Nombre + INT + #) */
    .top3-mini-row.compact .tgrid-right{
      flex-direction: row;
      align-items:center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-intblock{
      flex-direction: row;
      align-items:center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-bar{
      width: 34px;
    }

    .tgrid-int{
      font-weight: 950;
      font-size: 14px;
      letter-spacing: 0.01em;
      line-height: 1;
      color: rgba(226,232,240,0.98);
      min-width: 72px;
      text-align:right;
    }

    .tgrid-int.muted{ color: rgba(148,163,184,0.92); }
    .tgrid-int.lapped{ color: rgba(148,163,184,0.78); }

    .top3-mini-row.duel{
      border-color: rgba(45,107,255,0.42);
      box-shadow: 0 0 16px rgba(255,43,43,0.12);
    }
    .top3-mini-row.duel .tgrid-int{
      color: rgba(45,107,255,0.98);
      text-shadow: 0 0 10px rgba(45,107,255,0.26);
    }

    /* Badge DUEL/ATK/DEF */
    .tgrid-badge{
      height: 16px;
      padding: 0 8px;
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight: 950;
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(148,163,184,0.18);
      background: rgba(148,163,184,0.08);
      color: rgba(226,232,240,0.90);
    }
    .tgrid-badge.duel{ border-color: rgba(45,107,255,0.45); background: rgba(255,43,43,0.10); }
    .tgrid-badge.atk{ border-color: rgba(255,122,24,0.55); background: rgba(255,122,24,0.12); }
    .tgrid-badge.def{ border-color: rgba(255,43,43,0.55); background: rgba(255,43,43,0.12); }

    /* Mini barra de gap */
    .tgrid-bar{
      width: 42px;
      height: 6px;
      border-radius: 999px;
      background: rgba(148,163,184,0.16);
      border: 1px solid rgba(148,163,184,0.14);
      overflow:hidden;
    }
    .tgrid-bar > i{
      display:block;
      height: 100%;
      width: 0%;
      background: rgba(226,232,240,0.85);
      border-radius: 999px;
    }
    .top3-mini-row.duel .tgrid-bar{ border-color: rgba(255,43,43,0.28); background: rgba(255,43,43,0.10); }
    .top3-mini-row.duel .tgrid-bar > i{ background: rgba(255,43,43,0.90); }

    /* Compacto P4-P20 (1 línea pro) */
    .top3-mini-grid.expanded .top3-mini-row.compact{ padding: 5px 10px; }
    .top3-mini-row.compact .tgrid-sub{ display:none; }
    .top3-mini-row.compact .tgrid-name{ max-width: 46vw; }
    .top3-mini-row.compact .tgrid-int{ font-size: 12px; min-width: 70px; }

    /* Trend   */
    .tgrid-trend{
      font-weight: 900;
      font-size: 11px;
      opacity: 0.95;
      margin-left: 6px;
    }

    #lapChart {
      width: 100%;
      height: var(--lapchart-h, 120px);
      display: block;
            border-radius: 10px;
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(255,43,43,0.18);
    }

@media (min-height: 750px) {
      .app {
        padding-top: 12px;
      }
    }
  

    /* ULTRA COMPACT THEME OVERRIDES (v5.0.0) */
    :root {
      --radius-lg: 14px;
      --shadow-strong: none;
      --shadow-soft: none;
      --border-soft: rgba(148,163,184,0.28);
    }

    body {
      background-image: radial-gradient(circle at 25% 15%, rgba(255,43,43,0.10), transparent 55%), radial-gradient(circle at 85% 0%, rgba(255,255,255,0.04), transparent 55%) !important;
      background-color: #050508 !important;
      color-scheme: dark;
    }

    .app {
      max-width: 460px;
      padding: 8px 10px 10px;
      gap: 8px;
    }

    .app-header {
      padding: 8px 10px;
    }

    .pilot-section {
      padding: 8px 10px 10px;
    }

    .pilot-timings {
      gap: 5px;
      margin-top: 5px;
    }

    .timing-item {
      padding: 5px 6px 6px;
            border-radius: 10px;
      background: rgba(2,6,23,0.78);
    }

    .timing-label {
      font-size: 9px;
      letter-spacing: 0.12em;
      margin-bottom: 1px;
    }

    .timing-value {
      font-size: 12px;
    }

    .lap-chart-wrap {
      margin-top: 6px;
      padding: 6px 8px;
            border-radius: 10px;
      background: rgba(2,6,23,0.62);
    }

    .controls-section {
      padding: 8px 10px 10px;
      gap: 8px;
      background: rgba(2,6,23,0.82);
    }

    .buttons-row {
      gap: 6px;
    }

    .btn-primary, .btn-secondary, .btn-grid {
      padding: 10px 10px;
      border-radius: 14px;
      font-size: 12px;
      letter-spacing: 0.08em;
      box-shadow: none !important;
    }

    .rate-row {
      gap: 8px;
    }

    input[type="range"] {
      height: 3px;
      background: linear-gradient(90deg, #111827, var(--accent-orange), var(--accent-red));
    }

    input[type="range"]::-webkit-slider-thumb {
      width: 14px;
      height: 14px;
      box-shadow: none;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      box-shadow: none;
    }

    .spotter-section {
      padding: 0;
      background: transparent;
      border: none;
    }

    .spotter-cat {
      padding: 6px 6px 7px;
      gap: 6px;
      background: rgba(2,6,23,0.58);
      border: 1px solid rgba(148,163,184,0.22);
    }

    .spotter-cat-head {
      padding: 4px 8px;
      font-size: 9px;
      letter-spacing: 0.12em;
            border-radius: 10px;
      background: rgba(15,23,42,0.68);
    }

    .spotter-cat .cat-dot {
      width: 7px;
      height: 7px;
      box-shadow: none;
    }

    .spotter-grid {
      gap: 4px;
    }

    .spotter-btn {
      min-height: 26px;
      padding: 5px 6px;
      font-size: 10px;
      letter-spacing: 0.07em;
            border-radius: 10px;
      background: rgba(10,18,32,0.92);
      border-color: rgba(148,163,184,0.22);
      color: rgba(226,232,240,0.72);
    }

    .spotter-btn span {
      font-size: 11px;
    }

    .spotter-btn.active {
      background: rgba(15,23,42,0.92) !important;
      color: rgba(255,255,255,0.96) !important;
      box-shadow: none !important;
    }

    .spotter-cat[data-cat="essential"] .spotter-btn.active {
      border-color: rgba(45,107,255,0.80) !important;
    }

    .spotter-cat[data-cat="battle"] .spotter-btn.active {
      border-color: rgba(255,122,24,0.88) !important;
    }

    .spotter-cat[data-cat="summary"] .spotter-btn.active {
      border-color: rgba(255,43,43,0.78) !important;
    }

    .extras-section {
      zoom: 0.67;

      padding: 8px 10px 10px;
      gap: 8px;
      background: rgba(2,6,23,0.82);
    }

    .precision-buttons {
      gap: 5px;
    }

    .precision-badge {
      padding: 6px 0;
      font-size: 10px;
      letter-spacing: 0.06em;
            border-radius: 10px;
      box-shadow: none !important;
    }

    .precision-badge.active {
      background: rgba(15,23,42,0.92) !important;
      border-color: rgba(255,122,24,0.88) !important;
      color: rgba(255,255,255,0.96) !important;
    }

    .toggle-row {
      padding: 8px 10px;
            border-radius: 10px;
    }

    .grid-button-row {
      gap: 6px;
    }

    .hint-text {
      display: none;
    }

    /* Small screens: 2 columns for buttons */
    @media (max-width: 420px) {
      .spotter-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

  
    .btn-secondary.off{opacity:0.65;filter:grayscale(0.2);}
  /* Race Director modes */
    .rd-mode-row{
      display:flex;
      gap:10px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .rd-mode{
      flex:1 1 110px;
      min-width:110px;
      text-transform:none;
      letter-spacing:.2px;
      opacity:.82;
    }
    .rd-mode.active{
      opacity:1;
      outline:2px solid rgba(255,255,255,.22);
      box-shadow: 0 0 0 2px rgba(0,0,0,.35) inset;
    }

    /* Botones activos con color fuerte (tipo VOZ ACTIVA) */
    .btn-secondary.active,
    .btn-pill.active,
    .spotter-btn.active,
    .rd-mode.active{
      opacity: 1 !important;
      filter: none !important;
      transform: translateY(-1px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      border-color: rgba(255,255,255,.22);
    }

    /* RD ON/OFF */
    #rdToggleBtn.active{ background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75)); color:#0b0f14; border-color: rgba(255,255,255,.18); }
    #rdToggleBtn:not(.active){ background: rgba(255,255,255,.06); color: rgba(255,255,255,.82); }

    /* Modos - colores por personalidad */
    #rdModeMinimal.active { background: linear-gradient(135deg, rgba(0,229,255,.95), rgba(0,140,255,.75)); color:#071018; }
    #rdModeStratega.active{ background: linear-gradient(135deg, rgba(255,215,0,.95), rgba(255,140,0,.80)); color:#101015; }
    #rdModeCoach.active   { background: linear-gradient(135deg, rgba(255,0,140,.92), rgba(160,80,255,.78)); color:#0b0f14; }

    /* Modos extra - colores por personalidad */
    #rdModeSarca.active    { background: linear-gradient(135deg, rgba(255,40,40,.95), rgba(255,140,0,.80)); color:#101015; }
    #rdModeEngineer.active { background: linear-gradient(135deg, rgba(34,197,94,.92), rgba(0,229,255,.75)); color:#071018; }
    #rdModeHype.active     { background: linear-gradient(135deg, rgba(160,80,255,.92), rgba(255,0,140,.78)); color:#0b0f14; }

    /* Auto Locutor - colores por estilo */
    #autoLocutorPro.active { background: linear-gradient(135deg, rgba(0,229,255,.95), rgba(0,140,255,.75)); color:#071018; }
    #autoLocutorPicante.active { background: linear-gradient(135deg, rgba(255,40,40,.95), rgba(255,140,0,.80)); color:#101015; }
    #autoLocutorEngineer.active { background: linear-gradient(135deg, rgba(34,197,94,.92), rgba(0,229,255,.75)); color:#071018; }
    #autoLocutorNarrativo.active { background: linear-gradient(135deg, rgba(255,0,229,.92), rgba(0,229,255,.65)); color:#071018; }

    /* Botn Leer resumen */
    #speakBtn.active{ background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,170,0,.70)); color:#0b0f14; }

    /* Desplegables */
    .select-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-top:10px;
      padding:10px 12px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
    }
    .select-label{
      font-weight:700;
      letter-spacing:.2px;
      color: rgba(255,255,255,.92);
    }
    select.spotter-select{
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      border-radius:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.95);
      font-weight:800;
      min-width: 180px;
      outline:none;
    }
    select.spotter-select:focus{
      border-color: rgba(0,229,255,.55);
      box-shadow: 0 0 0 3px rgba(0,229,255,.15);
    }
    #precisionSelect{ display:none !important; }

    /* Controles superiores - botones tipo "Activar voz" (compactos) */
    .controls-section .btn-secondary{
      padding: 7px 10px;
      font-size: 12px;
      letter-spacing: 0.06em;
    }
    .btn-hot{
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: var(--shadow-soft);
    }
    .btn-hot:hover{
      background: rgba(255,255,255,0.09);
    }

    /* Voz: OFF (naranja) / ON (verde) */
    .btn-voice{
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      box-shadow: var(--shadow-strong);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .btn-voice.voice-on{
      background: linear-gradient(135deg, rgba(0,255,140,.92), rgba(0,170,90,.80));
      color:#06110c;
      box-shadow: var(--shadow-strong);
      border: 1px solid rgba(255,255,255,0.10);
    }

    /* Leer resumen: se ilumina al presionar */
    .btn-speak{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    .btn-speak.active{
      background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,170,0,.75));
      color:#0b0f14;
      box-shadow: var(--shadow-strong);
    }

    /* RD: OFF (gris) / ON (naranja) */
    .btn-rd{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    .btn-rd.active{
      background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75));
      color:#0b0f14;
      box-shadow: var(--shadow-strong);
    }

    /* Modos: base discreta, activo con color por modo */
    .btn-mode{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    #rdModeMinimal.active { background: linear-gradient(135deg, rgba(0,229,255,.92), rgba(0,140,255,.75)); color:#071018; box-shadow: var(--shadow-strong); }
    #rdModeStratega.active{ background: linear-gradient(135deg, rgba(255,215,0,.95), rgba(255,140,0,.80)); color:#101015; box-shadow: var(--shadow-strong); }
    #rdModeCoach.active   { background: linear-gradient(135deg, rgba(255,0,140,.92), rgba(160,80,255,.78)); color:#0b0f14; box-shadow: var(--shadow-strong); }

    /* Mensajes del spotter - color por grupo */
    .spotter-cat[data-cat="essential"] .spotter-btn{ border-color: rgba(255,70,70,0.34); }
    .spotter-cat[data-cat="battle"]    .spotter-btn{ border-color: rgba(255,170,0,0.32); }
    .spotter-cat[data-cat="summary"]   .spotter-btn{ border-color: rgba(0,255,140,0.28); }

    /* === Mensajes del spotter: colores por seccin + botones pintados al encender === */
    :root{
      --cat-ess: rgba(255,60,60,1);      /* rojo */
      --cat-bat: rgba(255,170,0,1);      /* mbar */
      --cat-res: rgba(0,220,120,1);      /* verde */
    }

    /* Bordes base por seccin (apagado) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{ border-color: rgba(255,60,60,.55); }
    .spotter-cat[data-cat="battle"]     .spotter-btn{ border-color: rgba(255,170,0,.55); }
    .spotter-cat[data-cat="summary"]    .spotter-btn{ border-color: rgba(0,220,120,.55); }

    /* Texto base (apagado) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{ color: rgba(255,235,235,.92); }
    .spotter-cat[data-cat="battle"]     .spotter-btn{ color: rgba(255,245,225,.92); }
    .spotter-cat[data-cat="summary"]    .spotter-btn{ color: rgba(230,255,242,.92); }

    /* Encendido: pintado completo */
    .spotter-cat[data-cat="essentials"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,60,60,.95), rgba(255,110,60,.75));
      border-color: rgba(255,255,255,.14);
      color:#140606;
      box-shadow: var(--shadow-strong);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,170,0,.95), rgba(255,90,0,.75));
      border-color: rgba(255,255,255,.14);
      color:#141006;
      box-shadow: var(--shadow-strong);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(0,220,120,.92), rgba(0,170,90,.75));
      border-color: rgba(255,255,255,.14);
      color:#04110a;
      box-shadow: var(--shadow-strong);
    }

    /* LAPS siempre encendido: que se vea "bloqueado" pero pintado como su seccin */
    .spotter-btn.locked{
      opacity: .95;
      cursor: default;
    }

    /* Match botones con su seccin (apagado tambin) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{
      background: rgba(255,60,60,0.10);
      border-color: rgba(255,60,60,0.60);
      color: rgba(255,240,240,0.95);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn{
      background: rgba(255,170,0,0.10);
      border-color: rgba(255,170,0,0.60);
      color: rgba(255,248,235,0.95);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn{
      background: rgba(0,220,120,0.10);
      border-color: rgba(0,220,120,0.60);
      color: rgba(235,255,245,0.95);
    }

    /* Hover con ms presencia, sin cambiar de seccin */
    .spotter-cat[data-cat="essentials"] .spotter-btn:hover{ background: rgba(255,60,60,0.14); }
    .spotter-cat[data-cat="battle"] .spotter-btn:hover{ background: rgba(255,170,0,0.14); }
    .spotter-cat[data-cat="summary"] .spotter-btn:hover{ background: rgba(0,220,120,0.14); }

    /* Cuando est locked (LAPS), que se vea firme */
    .spotter-btn.locked{
      outline: 2px solid rgba(255,255,255,0.06);
    }

    /* FIX: data-cat values (essential/battle/summary) + colores por seccin */
    .spotter-cat[data-cat="essential"] .spotter-btn{
      background: rgba(255,60,60,0.10) !important;
      border-color: rgba(255,60,60,0.60) !important;
      color: rgba(255,240,240,0.95) !important;
    }
    .spotter-cat[data-cat="battle"] .spotter-btn{
      background: rgba(255,170,0,0.10) !important;
      border-color: rgba(255,170,0,0.60) !important;
      color: rgba(255,248,235,0.95) !important;
    }
    .spotter-cat[data-cat="summary"] .spotter-btn{
      background: rgba(0,220,120,0.10) !important;
      border-color: rgba(0,220,120,0.60) !important;
      color: rgba(235,255,245,0.95) !important;
    }

    .spotter-cat[data-cat="essential"] .spotter-btn:hover{ background: rgba(255,60,60,0.14) !important; }
    .spotter-cat[data-cat="battle"] .spotter-btn:hover{ background: rgba(255,170,0,0.14) !important; }
    .spotter-cat[data-cat="summary"] .spotter-btn:hover{ background: rgba(0,220,120,0.14) !important; }

    /* Encendido pintado por seccin (corrige essential) */
    .spotter-cat[data-cat="essential"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,60,60,.95), rgba(255,110,60,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#140606 !important;
      box-shadow: var(--shadow-strong) !important;
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,170,0,.95), rgba(255,90,0,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#141006 !important;
      box-shadow: var(--shadow-strong) !important;
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(0,220,120,.92), rgba(0,170,90,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#04110a !important;
      box-shadow: var(--shadow-strong) !important;
    }

    /* Precisin - botones como el resto (compactos y con "ON" pintado) */
    .precision-badge{
      padding: 7px 10px !important;
      font-size: 12px !important;
      letter-spacing: 0.06em !important;
      border-radius: 12px !important;
      background: rgba(255,255,255,0.07) !important;
      border: 1px solid rgba(255,255,255,0.14) !important;
      color: rgba(255,255,255,0.92) !important;
      box-shadow: var(--shadow-soft) !important;
      min-width: 108px;
    }
    .precision-badge:hover{
      background: rgba(255,255,255,0.10) !important;
    }
    .precision-badge.active{
      background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75)) !important;
      color: #0b0f14 !important;
      border-color: rgba(255,255,255,0.14) !important;
      box-shadow: var(--shadow-strong) !important;
    }

    .app-header{ position: relative; overflow:hidden; }
    .app-header::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      border-radius: inherit;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    .app-header::after{
      content:"";
      position:absolute;
      left:0; right:0; top:0;
      height:2px;
      background: linear-gradient(90deg, rgba(255,40,40,0.0), rgba(255,40,40,0.55), rgba(255,140,0,0.55), rgba(255,140,0,0.0));
      opacity:.75;
      pointer-events:none;
    }





    /* Premium - Header vivo solo cuando esta LIVE (sin casino) */
    @keyframes headerBreath {
      0%, 100% { box-shadow: 0 10px 28px rgba(0,0,0,0.55), inset 0 0 0 1px rgba(255,255,255,0.06); }
      50% { box-shadow: 0 12px 34px rgba(0,0,0,0.62), 0 0 18px rgba(var(--accent-rgb), 0.22), inset 0 0 0 1px rgba(255,255,255,0.08); }
    }
    @keyframes ledSweep {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }
    .app-header.live-on{
      animation: headerBreath 3.6s ease-in-out infinite;
    
      height:200px;
      min-height:200px;
    }
    .app-header.live-on::after{
      opacity: .98;
      background-size: 200% 100%;
      animation: ledSweep 2.8s linear infinite;
    }
    .header-actions-row{ position: relative; }
    .app-header.live-on .header-actions-row::after{
      content: "";
      position: absolute;
      left: 0; right: 0;
      bottom: -4px;
      height: 1px;
      background: linear-gradient(90deg, rgba(0,0,0,0), rgba(var(--accent-rgb), .70), rgba(var(--accent2-rgb), .45), rgba(0,0,0,0));
      opacity: .85;
      pointer-events: none;
      filter: blur(.2px);
    }
    /* Header layout - ttulo manda */
    .header-left{ gap: 3px; }
    .header-title-main{
      font-size: 20px;
      letter-spacing: 0.06em;
      line-height: 1.12;
      gap: 10px;
      align-items: baseline;
    }
    #raceTitleText{
      /* Wrap PRO: evita guion al inicio de linea y reduce cortes feos */
      font-size: calc(0.67em + 0px);
      display:block;
      min-width: 0;
      max-width: 240px;
      width: 240px;
      flex: 0 0 240px;
      white-space: normal;
      word-break: keep-all;
      overflow-wrap: break-word;
      text-wrap: balance;
      /* Max 3 lineas, altura tope 60px */
      max-height: 56px;
      line-height: 1.15;
      overflow: hidden;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
    }

    #raceSubtitle{
      /* Subtitle: 1 linea, ancho fijo, ellipsis */
      max-width: 215px;
      width: 215px;
      font-size: 12px;
      line-height: 1.15;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: block;
    }

    #raceTitleText .flagImg{
      width: 20px;
      height: 20px;
      margin-right: 8px;
      vertical-align: -3px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.65));
      border-radius: 3px;
    }


    .badge-mode{
      font-size: 10px;
      padding: 3px 9px;
      letter-spacing: 0.08em;
    }
    .header-title-sub{
      font-size: 11px;
      letter-spacing: 0.08em;
      opacity: .95;
    }
    .header-subline{
      font-size: 10px;
      color: rgba(255,255,255,0.86);
    }
    .header-mini{
      font-size: 9px;
      opacity: .9;
    }
        .badge-live{
      padding: 4px 10px;
      font-size: 11px;
    }
    .header-version{
      font-size: 9px;
      opacity: .85;
    }
    .header-version-row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      flex-wrap: wrap;
      width:100%;
    }

    /* Timing colors (F1 style) */
    .timing-value.lap-purple{ color: rgb(192,132,252); }
    .timing-value.lap-green{  color: rgb(34,197,94); }
    .timing-value.lap-yellow{ color: rgb(251,191,36); }
    .timing-value.lap-neutral{ color: rgba(255,255,255,0.92); }
    .timing-value.lap-avg{ color: rgba(186,230,253,0.92); }

    /* LTIMA ms grande */
    #lastLap{
      font-size: 18px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    /* Flash solo en la última vuelta (pop) - con glow por color */
    #lastLap.flash{ transform: scale(1.28); }
    #lastLap.flash.lap-purple{ text-shadow: 0 0 14px rgba(192,132,252,0.85); }
    #lastLap.flash.lap-green{  text-shadow: 0 0 14px rgba(34,197,94,0.85); }
    #lastLap.flash.lap-yellow{ text-shadow: 0 0 14px rgba(251,191,36,0.85); }
    #lastLap.flash.lap-neutral{ text-shadow: 0 0 12px rgba(255,255,255,0.25); }

    /* Timing KPI sizes */
    #lastLap{ font-size: 22px; letter-spacing: 0.02em; }
    #bestLap, #meanLap{ font-size: 18px; letter-spacing: 0.01em; }
    /* Pop ms evidente en LTIMA */
    #lastLap.flash{ transform: scale(1.28); text-shadow: 0 0 14px rgba(255,90,0,0.35); }

    /* RD modos - permitir wrap en pantallas chicas */
    .rd-mode-row{ flex-wrap: wrap; }

    /* v0.0.0.44 - ocultar botones RD avanzados (se decide en background) */
    #rdModeSarca, #rdModeEngineer, #rdModeHype{ display:none !important; }

    /* PATCH v5.0.0 - RD ON verde + consistencia UI */
    #rdToggleBtn.active{
      background: linear-gradient(135deg, #16a34a, #22c55e) !important;
      color: #07120a !important;
      border-color: rgba(34,197,94,.55) !important;
      box-shadow: 0 0 12px rgba(34,197,94,.85) !important;
    }
    #rdToggleBtn.off{
      background: rgba(255,255,255,.06) !important;
      color: rgba(255,255,255,.82) !important;
      box-shadow: none !important;
    }

    /* Manual - modal ayuda (single-file friendly) */
    .header-help{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      padding: 4px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      user-select: none;
    }
    .header-help:hover{ filter: brightness(1.15); }
    .header-auto{ min-width: 62px; padding: 8px 10px; font-size: 12px; letter-spacing: 0.06em; }
    @media (max-width: 560px){ .header-auto{ min-width: 56px; padding: 7px 8px; font-size: 11px; } }

    .header-help:active{ transform: translateY(1px); }

    /* Skin button (toggle look) */
    .header-skin{
      min-width: 54px;
    }
    .header-skin.active{
      background: linear-gradient(135deg, rgba(255,43,43,.92), rgba(255,59,59,.72));
      color: #12060a;
      border-color: rgba(255,255,255,0.18);
      box-shadow: 0 0 14px rgba(255,43,43,.35);
    }

    .manual-backdrop{
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .manual-backdrop.open{ display:flex; }
    .manual-panel *{ max-width: 100%; }
    .manual-panel{
      width: min(450px, 100%);
      max-height: 92vh;
      overflow-y: auto;
      overflow-x: hidden; -webkit-overflow-scrolling: touch;
      border-radius: 18px;
      border: 1px solid rgba(249,115,22,0.55);
      background: linear-gradient(145deg, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      box-shadow: 0 0 0 1px rgba(0,0,0,0.65), 0 20px 60px rgba(0,0,0,0.65);
      padding: 14px;
    }
    .manual-top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .manual-title{
      font-size: 16px;
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .manual-sub{
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    .manual-title, .manual-sub{ word-break: normal; overflow-wrap: break-word; }

    .manual-close{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
            border-radius: 10px;
      padding: 6px 10px;
      font-weight: 900;
      cursor: pointer;
    }
    .manual-close:hover{ filter: brightness(1.15); }

    /* Manual tabs (v0.0.2.12) */
    .manual-tabs{
      display:flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: flex-start;
      margin: 8px 0 10px;
      padding: 8px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
      position: sticky;
      top: 0;
      z-index: 2;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .manual-tab{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.90);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      user-select: none;
    }
    .manual-tab:hover{ filter: brightness(1.12); }
    .manual-tab:active{ transform: translateY(1px); }
    .manual-tab.active{
      background: linear-gradient(135deg, rgba(34,197,94,.92), rgba(34,197,94,.55));
      color: rgba(7,18,10,0.98);
      border-color: rgba(34,197,94,.55);
      box-shadow: 0 0 12px rgba(34,197,94,.35);
    }

    .manual-sections{ display:block; }
    .manual-section{ display:none; }
    .manual-section.active{ display:block; }

    .manual-section h3{
      margin: 4px 0 8px;
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .manual-section ol, .manual-section ul{
      margin: 0 0 10px 18px;
      padding: 0;
      color: rgba(255,255,255,0.92);
      font-size: 12px;
      line-height: 1.35;
    }
    .manual-details{
      margin: 10px 0 0;
      padding: 0;
    }
    .manual-details summary{
      cursor: pointer;
      user-select: none;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.92);
      font-weight: 800;
      outline: none;
    }
    .manual-details[open] summary{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.16);
    }
    .manual-code{
      margin: 10px 0 6px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.35;
      white-space: pre-wrap;
      overflow: auto;
    }
    .manual-note{
      margin-top: 6px;
      font-size: 11px;
      color: rgba(255,255,255,0.78);
      border-left: 3px solid rgba(249,115,22,0.65);
      padding-left: 10px;
    }
    .manual-grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    
    /* Manual table */
    .manual-wide{ grid-column: 1 / -1; }
    .manual-table-wrap{ overflow-x: hidden; -webkit-overflow-scrolling: touch; border:1px solid rgba(255,255,255,.08); border-radius:12px; }
    .manual-table{ width:100%; border-collapse: collapse; min-width: 0; table-layout: fixed; }
    .manual-table th, .manual-table td{ text-align:left; padding:10px 10px; border-bottom:1px solid rgba(255,255,255,.07); vertical-align: top; word-break: break-word; overflow-wrap: anywhere; }
    .manual-table th{ font-weight:800; opacity:.95; }
    .manual-table td code{ background: rgba(0,0,0,.35); padding:1px 6px; border-radius:8px; }
    .manual-tip{ margin-top:10px; opacity:.92; font-size:13px; }
    .manual-panel code{ word-break: break-word; overflow-wrap:anywhere; }
    .manual-panel a{ word-break: break-word; overflow-wrap:anywhere; }

@media (max-width: 860px){
      .manual-grid{ grid-template-columns: 1fr; }
    }
    .manual-card{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 10px;
    }
    .manual-card h3{
      margin: 0 0 6px 0;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .manual-card ul,
    .manual-card ol{
      margin: 0;
      padding-left: 18px;
      padding-right: 6px;
      color: rgba(255,255,255,0.88);
      font-size: 12px;
      line-height: 1.35;
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .manual-card li{
      overflow-wrap: anywhere;
      word-break: break-word;
    }
    .manual-card p{ margin: 6px 0 0 0; color: rgba(255,255,255,0.88); font-size: 12px; line-height: 1.35; overflow-wrap:anywhere; word-break:break-word; }
    .manual-section{ margin-top: 10px; padding-top: 10px; border-top: 1px dashed rgba(255,255,255,0.10); }
    .manual-section:first-child{ margin-top: 0; padding-top: 0; border-top: none; }
    .manual-shotgrid{ display: grid; grid-template-columns: 1fr; gap: 10px; }
    .code-inline{ display:inline-block; padding: 1px 6px; border-radius: 8px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.10); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 11px; word-break: break-all; overflow-wrap:anywhere; }
    .manual-card ol li, .manual-card ul li{ margin: 0 0 6px 0; }
    .manual-top > div{ min-width: 0; }
    .manual-title{ max-width: 300px; overflow-wrap:anywhere; word-break:break-word; }
    .manual-shot{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.25);
      overflow: hidden;
    }
        .manual-shot figcaption{
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.8);
      border-top: 1px solid rgba(255,255,255,0.08);
    }
.manual-shot img{
      display:block;
      width:100%;
      height:auto;
    }
    .manual-shot figcaption{
      padding: 8px 10px;
      font-size: 11px;
      color: var(--text-muted);
    }
    .manual-foot{
      margin-top: 10px;
      font-size: 11px;
      color: var(--text-muted);
    }

    /* MANGA UX: flash verde en contenedor del piloto seguido */
    .pilot-card.flash-green{
      border-color: #2eea7a !important;
      box-shadow: 0 0 0 2px rgba(46,234,122,.25), 0 0 18px rgba(46,234,122,.22) !important;
    }
    .pilot-card.flash-green .pilot-card-top-strip{
      background: linear-gradient(90deg, rgba(46,234,122,.9), rgba(46,234,122,.15)) !important;
    }
    
    .timing-item.timer-only{ display:none; }

    /* MANGA reloj (mismo feeling que badges) */
    .manga-clock{
      --clock-hue: 120;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.06em;
      border: 1px solid hsla(var(--clock-hue), 95%, 60%, .55);
      color: hsl(var(--clock-hue), 95%, 62%);
      background: hsla(var(--clock-hue), 95%, 20%, .18);
      box-shadow: 0 0 0 2px hsla(var(--clock-hue), 95%, 55%, .12), 0 0 18px hsla(var(--clock-hue), 95%, 55%, .12);
      font-variant-numeric: tabular-nums;
    }

    /* Pilot-timings: tipografa consistente (última se queda igual) */
    .pilot-timings .manga-clock{
      font-size: inherit;
      font-weight: inherit;
      letter-spacing: inherit;
    }

    .manga-clock.flash{
      animation: clockFlash .35s ease-in-out 0s 2;
    }

    @keyframes clockFlash{
      0%{ transform: scale(1); filter:none; }
      50%{ transform: scale(1.12); filter: drop-shadow(0 0 10px rgba(46,234,122,.55)); }
      100%{ transform: scale(1); filter:none; }
    }

    /* Manual button - ms visible */
    #manualBtn{
      background: linear-gradient(135deg, rgba(34,197,94,.22), rgba(0,229,255,.18));
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 8px 22px rgba(0,0,0,.32);
    }
    #manualBtn:hover{ filter: brightness(1.06); }
    #manualBtn:active{ transform: translateY(1px); }

    /* Master toggle */
    .spotter-master{
      padding: 8px 10px 2px 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .spotter-master-btn{
      flex: 1 1 120px;
      width: auto;
      padding: 10px 12px;
            border-radius: 10px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.90);
      font-weight: 800;
      letter-spacing: .4px;
      cursor: pointer;
      user-select: none;
    }
    .spotter-master-btn.preset{
      background: rgba(255,255,255,.05);
    }
    .spotter-master-btn.active{
      background: linear-gradient(135deg, rgba(251,191,36,.92), rgba(249,115,22,.75));
      color: rgba(10,14,18,.92);
      border-color: rgba(255,255,255,.20);
    }

    /* Top3 mini grid - anim y flash */
    .top3-mini-row{ will-change: transform; }
    .top3-mini-row.lap-flash{
      background: rgba(34,197,94,.22);
      box-shadow: 0 0 0 1px rgba(34,197,94,.35) inset, 0 10px 24px rgba(0,0,0,.28);
    }

    /* =========================
       TIMING MINI GRID - layout fix (v6.5)
       Alineacin tipo timing screen: columnas fijas, 1 columna en Top20, lapeados cortos.
       ========================= */

    .tgrid-main{
      width: 100%;
      display: grid;
      grid-template-columns: 40px 1fr 176px 46px;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .tgrid-namewrap{ min-width: 0; }
    .tgrid-name{ max-width: none; }

    .tgrid-sub{
      display: grid;
      grid-template-columns: 34px 92px 92px 66px;
      gap: 10px;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
    }
    .tgrid-sub .tgrid-col{
      min-width: 0 !important;
    }
    .tgrid-col{ justify-content: flex-end; }
    .tgrid-col.v{ justify-content: flex-start; text-align: left; }

    .tgrid-intblock{
      justify-self: end;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
      min-width: 176px;
    }

    .top3-mini-row.compact .tgrid-intblock{
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-bar{ width: 34px; margin-left: 6px; }

    .tgrid-int{ min-width: 88px; text-align: right; }

    .tgrid-numbox{
      justify-self: end;
      min-width: 38px;
      padding: 0 10px;
    }

    /* iPhone / pantallas angostas - FIX nombre vertical en Grid Completo */
    @media (max-width: 430px){
      /* Dar mas aire al nombre y recortar con ellipsis (no letras en columna) */
      .tgrid-main{
        grid-template-columns: 38px minmax(140px, 1fr) minmax(92px, 34vw) 44px;
        gap: 8px;
      }
      .tgrid-name{
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        word-break: normal;
      }
      .tgrid-int{ min-width: 58px; }
    }

    /* === Mini Grid v2 (TOP 3 / TOP 20) - clean table style === */
    .btn-mini{
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(2,6,23,0.30);
      color: rgba(226,232,240,0.92);
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      line-height: 1;
      user-select: none;
    }
    .btn-mini:hover{ filter: brightness(1.10); }
    .btn-mini:active{ transform: translateY(1px); }

    .lap-chart-header{ display:block; }
    .lap-chart-header-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 8px;
    }
    .lap-chart-meta{ margin-top: 4px; }

    .top3-mini-grid{
      margin-top: 8px !important;
      display:block !important;
      border-radius: 14px;
      overflow:hidden;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(2,6,23,0.22);
    }
    .tgrid-head,
    .tgrid-row{
      display:grid;
      grid-template-columns: 38px 1fr 52px 76px 76px 64px;
      gap: 6px;
      align-items:center;
      padding: 7px 10px;
    }
    .tgrid-head{
      background: rgba(15,23,42,0.55);
      border-bottom: 1px solid rgba(148,163,184,0.16);
      font-size: 10px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.75);
      font-weight: 900;
    }
    .tgrid-row{
      font-size: 12px;
      border-top: 1px solid rgba(148,163,184,0.10);
    }
    .tgrid-row.pos1{ background: rgba(251,191,36,0.08); }
    .tgrid-row.pos2{ background: rgba(255,255,255,0.06); }
    .tgrid-row.pos3{ background: rgba(249,115,22,0.08); }

    .tgrid-cell{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .tgrid-pos{
      width: 34px;
      text-align:center;
      border-radius: 999px;
      padding: 4px 0;
      font-weight: 950;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(148,163,184,0.08);
      color: rgba(226,232,240,0.92);
    }
    .tgrid-name{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width:0;
    }
    .tgrid-num{
      opacity: 0.70;
      font-weight: 800;
      font-size: 11px;
    }
    .tgrid-driver{
      min-width:0;
      font-weight: 900;
    }
    .tgrid-mono{
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      text-align:right;
    }
    @media (max-width: 420px){
      .tgrid-head,
      .tgrid-row{
        grid-template-columns: 34px 1fr 48px 68px 68px 58px;
        padding: 7px 8px;
      }
      .tgrid-row{ font-size: 11px; }
    }

    /* Mini timing screen (Top3/Top20) - Opcin A */
    .top3-mini-grid{ width: 100%; }
    .top3-mini-grid.expanded{ max-height: none; overflow: visible; }
    .top3-mini-grid .mini-timing{
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    .top3-mini-grid .mini-timing thead th{
      position: sticky;
      top: 0;
      z-index: 2;
      background: rgba(10,15,25,0.96);
      color: rgba(226,232,240,0.92);
      font-size: 12px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      border-bottom: 1px solid rgba(148,163,184,0.20);
      padding: 6px 8px;
    }
    .top3-mini-grid .mini-timing tbody td{
      border-bottom: 1px solid rgba(148,163,184,0.10);
      padding: 4px 6px;
      font-size: 12px;
      color: rgba(226,232,240,0.92);
      vertical-align: middle;
    }
    .top3-mini-grid .mini-timing tbody tr.pos1{ background: rgba(251,191,36,0.08); }
    .top3-mini-grid .mini-timing tbody tr.pos2{ background: rgba(255,255,255,0.05); }
    .top3-mini-grid .mini-timing tbody tr.pos3{ background: rgba(249,115,22,0.07); }
    .top3-mini-grid .mini-timing tbody tr:hover{ background: rgba(255,43,43,0.08); }
    .top3-mini-grid .mini-timing tbody tr.pos1 .mt-p{ color: rgba(251,191,36,0.95); font-weight: 900; }
    .top3-mini-grid .mini-timing tbody tr.pos2 .mt-p{ color: rgba(203,213,225,0.95); font-weight: 900; }
    .top3-mini-grid .mini-timing tbody tr.pos3 .mt-p{ color: rgba(205,127,50,0.95); font-weight: 900; }

    /* Mini rows estilo scoreboard (solo cuando expanded) */
    .top3-mini-grid.expanded .mini-rows{
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .top3-mini-grid.expanded .mini-head{
      display: grid;
      grid-template-columns: 28px minmax(0,1fr) 34px 70px 58px 48px;
      column-gap: 6px;
      gap: 0;
      padding: 2px 6px 6px 6px;
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.80);
    }
    .top3-mini-grid.expanded .mini-head > div{
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .top3-mini-grid.expanded .mini-head > div:nth-child(n+3),
    .top3-mini-grid.expanded .mini-row > div:nth-child(n+3){
      justify-self: end;
    }

    .top3-mini-grid.expanded .mini-row > div:nth-child(5){
      font-weight: 900;
      letter-spacing: 0.02em;
    }

    .top3-mini-grid.expanded .mini-row{
      display: grid;
      grid-template-columns: 28px minmax(0,1fr) 34px 70px 58px 48px;
      column-gap: 6px;
      align-items: center;
            border-radius: 10px;
            padding: 5px 6px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(10,15,25,0.55);
      box-shadow: 0 8px 22px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.08);
    }
    .top3-mini-grid.expanded .mini-row.pos1{ background: rgba(251,191,36,0.08); }
    .top3-mini-grid.expanded .mini-row.pos2{ background: rgba(255,255,255,0.05); }
    .top3-mini-grid.expanded .mini-row.pos3{ background: rgba(249,115,22,0.07); }
    .top3-mini-grid.expanded .mini-row:hover{ background: rgba(255,43,43,0.08); }

    .top3-mini-grid.expanded .mr-pos{
      width: 26px;
      height: 20px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      font-weight: 900;
      color: rgba(255,255,255,0.95);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.12);
      margin-left: 2px;
    }
    .top3-mini-grid.expanded .mini-row.pos1 .mr-pos{ color: rgba(251,191,36,0.98); }
    .top3-mini-grid.expanded .mini-row.pos2 .mr-pos{ color: rgba(203,213,225,0.98); }
    .top3-mini-grid.expanded .mini-row.pos3 .mr-pos{ color: rgba(205,127,50,0.98); }

    .top3-mini-grid.expanded .mr-name{
      display: block;
      line-height: 1.06;
      padding-right: 6px;
    }
    .top3-mini-grid.expanded .mr-line{
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: rgba(226,232,240,0.95);
      font-size: 12px;
    }
    .top3-mini-grid.expanded .mr-line2{
      font-size: 11px;
      color: rgba(226,232,240,0.78);
    }
    .top3-mini-grid.expanded .mr-mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: rgba(226,232,240,0.92);
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .top3-mini-grid.expanded .mr-st{
      text-align: right;
    }
    .top3-mini-grid.expanded .st-atk{ color: rgba(34,197,94,0.95); font-weight: 900; }
    .top3-mini-grid.expanded .st-def{ color: rgba(239,68,68,0.95); font-weight: 900; }
    .top3-mini-grid.expanded .st-duel{ color: rgba(168,85,247,0.95); font-weight: 900; }
    .top3-mini-grid.expanded .st-na{ color: rgba(226,232,240,0.70); }


    .top3-mini-grid .mt-pos{ width: 30px; }
    .top3-mini-grid .mt-laps{ width: 36px; }
    .top3-mini-grid .mt-last{ width: 76px; }
    .top3-mini-grid .mt-gap{ width: 66px; }
    .top3-mini-grid .mt-st{ width: 56px; text-align: right; }

    .top3-mini-grid .mt-name{ width: auto; }
    .top3-mini-grid .mt-driver{
      display: block;
      max-width: 100%;
      white-space: normal;
      line-height: 1.08;
    }
    .top3-mini-grid .mt-line{
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .top3-mini-grid .mt-num{
      display: inline-block;
      margin-left: 6px;
      font-size: 11px;
      opacity: 0.85;
    }
    .top3-mini-grid .mt-mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-variant-numeric: tabular-nums;
      text-align: right;
    }
    .top3-mini-grid .mt-p{
      display: inline-flex;
      min-width: 22px;
      justify-content: center;
      font-weight: 900;
    }
    .top3-mini-grid .mt-badge{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 44px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 0.05em;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(148,163,184,0.10);
      color: rgba(226,232,240,0.95);
    }
    .top3-mini-grid .mt-atk{ border-color: rgba(255,122,24,0.55); background: rgba(255,122,24,0.12); }
    .top3-mini-grid .mt-def{ border-color: rgba(255,43,43,0.55); background: rgba(255,43,43,0.12); }
    .top3-mini-grid .mt-duel{ border-color: rgba(45,107,255,0.45); background: rgba(255,43,43,0.10); }

    /* ===== Configuracin activa + Presets por sesin ===== */
    .config-status-card{
      margin: 10px 0 14px;
      padding: 12px 12px 10px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 10px 22px rgba(0,0,0,0.25);
    }
    .config-status-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .config-status-title{
      font-weight: 800;
      letter-spacing: 0.4px;
      font-size: 12px;
      opacity: 0.96;
    }
    .config-status-badges{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    .cfg-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 5px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 800;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
    }
    .cfg-pill-session{border-color: rgba(0, 255, 163, 0.25);}
    .cfg-pill-auto{border-color: rgba(255, 166, 0, 0.30);}
    .config-status-line{
      font-size: 12px;
      opacity: 0.95;
      display:flex;
      flex-wrap:wrap;
      gap:6px 8px;
      align-items:center;
    }
    .cfg-label{opacity:0.70; font-weight:700;}
    .cfg-value{font-weight:900;}
    .cfg-sep{opacity:0.35; padding: 0 4px;}
    .diag-panel{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(255,255,255,0.10);
    }
    .diag-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
      font-size:11px;
      font-weight:900;
      letter-spacing:0.04em;
      opacity:0.92;
    }
    .diag-note{
      font-size:10px;
      font-weight:700;
      opacity:0.62;
    }
    .diag-grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:8px;
    }
    .diag-item{
      min-width:0;
      border-radius:12px;
      padding:8px 9px;
      background: rgba(0,0,0,0.26);
      border:1px solid rgba(255,255,255,0.08);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }
    .diag-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:4px;
    }
    .diag-name{
      display:flex;
      align-items:center;
      gap:7px;
      min-width:0;
      font-size:11px;
      font-weight:900;
      letter-spacing:0.03em;
    }
    .diag-dot{
      width:10px;
      height:10px;
      flex:0 0 10px;
      border-radius:999px;
      background:#64748b;
      box-shadow:0 0 0 1px rgba(255,255,255,0.08);
    }
    .diag-item.good .diag-dot{
      background:#00d26a;
      box-shadow:0 0 10px rgba(0,210,106,0.42);
    }
    .diag-item.warn .diag-dot{
      background:#ffb020;
      box-shadow:0 0 10px rgba(255,176,32,0.42);
    }
    .diag-item.bad .diag-dot{
      background:#ff4d4f;
      box-shadow:0 0 10px rgba(255,77,79,0.42);
    }
    .diag-item.off .diag-dot{
      background:#667085;
      box-shadow:none;
    }
    .diag-state{
      font-size:10px;
      font-weight:900;
      letter-spacing:0.04em;
      opacity:0.8;
      text-transform:uppercase;
      white-space:nowrap;
    }
    .diag-text{
      font-size:10.5px;
      line-height:1.25;
      opacity:0.88;
      min-height:26px;
      word-break:break-word;
    }
    .diag-error{
      margin-top:8px;
      padding:7px 9px;
      border-radius:10px;
      font-size:10.5px;
      line-height:1.25;
      background:rgba(255,77,79,0.10);
      border:1px solid rgba(255,77,79,0.20);
      color:rgba(255,240,240,0.95);
      display:none;
    }
    .diag-error.show{display:block;}
    .diag-subpanel{
      margin-top:8px;
      padding:8px 9px;
      border-radius:12px;
      background: rgba(0,0,0,0.22);
      border:1px solid rgba(255,255,255,0.08);
    }
    .diag-subhead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:6px;
      font-size:10.5px;
      font-weight:900;
      letter-spacing:0.04em;
      opacity:0.9;
    }
    .diag-subnote{font-size:10px; opacity:0.62; font-weight:700;}
    .ttslog-list{display:grid; gap:6px;}
    .ttslog-item{
      border-radius:10px;
      padding:6px 7px;
      background:rgba(255,255,255,0.04);
      border:1px solid rgba(255,255,255,0.06);
    }
    .ttslog-meta{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:3px;}
    .ttslog-type{font-size:10px; font-weight:900; letter-spacing:0.04em; opacity:0.88;}
    .ttslog-time{font-size:10px; opacity:0.58; font-weight:700; white-space:nowrap;}
    .ttslog-text{font-size:10.5px; line-height:1.25; opacity:0.90; word-break:break-word;}
    .ttslog-empty{font-size:10.5px; opacity:0.55;}
    .runtime-profiles{margin-top:10px;}
    .runtime-profiles-header{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;}
    .runtime-profiles-title{font-size:12px; font-weight:900; opacity:0.9;}
    .runtime-profiles-note{font-size:11px; opacity:0.65; font-weight:700;}
    .runtime-profile-grid{display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px;}
    .runtime-profile-card{
      text-align:left;
      padding:9px 9px 8px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(0,0,0,0.26);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      min-height:92px;
    }
    .runtime-profile-card:hover{transform:translateY(-1px); border-color: rgba(255,255,255,0.18);}
    .runtime-profile-card.active{
      border-color: rgba(0,255,163,0.40);
      background: rgba(0,255,163,0.09);
      box-shadow: 0 10px 18px rgba(0,0,0,0.22);
    }
    .rpc-head{display:flex; align-items:center; justify-content:space-between; gap:8px;}
    .rpc-name{font-size:11px; font-weight:900;}
    .rpc-tag{font-size:10px; font-weight:900; opacity:0.72; padding:3px 7px; border-radius:999px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.10);}
    .rpc-sub{font-size:10px; line-height:1.2; opacity:0.72; margin-top:4px;}
    .rpc-specs{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px;}
    .rpc-pill{font-size:9.5px; font-weight:900; padding:3px 6px; border-radius:999px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.08); opacity:0.78;}
    @media (max-width: 760px){
      .diag-grid{ grid-template-columns: 1fr; }
      .runtime-profile-grid{grid-template-columns:repeat(2,minmax(0,1fr));}
    }
    @media (max-width: 520px){
      .runtime-profile-grid{grid-template-columns:1fr;}
    }
    .session-presets{margin-top:10px;}
    .session-presets-header{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;}
    .session-presets-title{font-size: 12px; font-weight: 900; opacity:0.9;}
    .session-presets-note{font-size: 11px; opacity:0.65; font-weight:700;}
    .session-preset-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 10px;
    }
    .session-preset-card{
      text-align:left;
      padding: 10px 10px 8px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.28);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      min-height: 108px;
    }
    .session-preset-card:hover{transform: translateY(-1px); border-color: rgba(255,255,255,0.18);}
    .session-preset-card.active{
      border-color: rgba(255, 166, 0, 0.55);
      background: rgba(255, 166, 0, 0.10);
      box-shadow: 0 10px 18px rgba(0,0,0,0.25);
    }
    .spc-head{display:flex; justify-content:space-between; align-items:center; gap:8px;}
    .spc-name{font-size:12px; font-weight:900;}
    .spc-tag{
      font-size: 10px;
      font-weight: 900;
      opacity:0.75;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .spc-sub{font-size: 10.5px; opacity:0.70; margin-top:4px; line-height:1.2;}
    .spc-toggles, .session-now-toggles{
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
      margin-top: 8px;
    }
    .toggle-pill{
      font-size: 10px;
      font-weight: 900;
      padding: 4px 7px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      opacity: 0.55;
    }
    .toggle-pill.on{
      opacity: 0.95;
      border-color: rgba(0, 255, 163, 0.28);
      background: rgba(0, 255, 163, 0.12);
    }
    .toggle-pill.off{
      opacity: 0.35;
      border-style: dashed;
    }
    .session-now{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed rgba(255,255,255,0.12);
    }
    .session-now-title{
      font-size: 11px;
      font-weight: 900;
      opacity: 0.80;
      margin-bottom: 6px;
    }
    @media (max-width: 520px){
      .session-preset-grid{grid-template-columns: 1fr;}
      .session-preset-card{min-height: auto;}
    }

    /* === UI simplificada: por defecto escondemos paneles "expert" === */
    body:not(.debug) .expert-only{display:none !important;}
    body.debug .expert-only{display:block !important;}

    /* v0.0.1.00: controls-section compacto (50%) - oculto por defecto, visible solo en debug */
    body.debug #controlsSection{
      padding: 4px 6px 6px !important;
      gap: 5px !important;
    }
    body.debug #controlsSection .buttons-row{ gap: 4px !important; }
    body.debug #controlsSection .btn-secondary,
    body.debug #controlsSection .btn-primary,
    body.debug #controlsSection .btn-grid{
      padding: 5px 6px !important;
      font-size: 10px !important;
      letter-spacing: 0.06em !important;
      border-radius: 10px !important;
      min-height: 0 !important;
    }
    body.debug #controlsSection .controls-label{ font-size: 9px !important; }
    body.debug #controlsSection .config-status-card{ padding: 6px 8px !important; }
    body.debug #controlsSection .cfg-pill{ font-size: 9px !important; padding: 2px 6px !important; }
    body.debug #controlsSection .session-presets-title{ font-size: 10px !important; }
    body.debug #controlsSection .spc-name{ font-size: 10px !important; }
    body.debug #controlsSection .spc-sub{ font-size: 9px !important; }
    body.debug #controlsSection .precision-badge{ font-size: 9px !important; padding: 3px 6px !important; border-radius: 9px !important; }


    
    /* Debug strip (solo body.debug) */
    .debugstrip{
      display:none;
      position: sticky;
      top: 0;
      z-index: 50;
      margin: 8px 10px 0;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: 11px;
      letter-spacing: .2px;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    body.debug .debugstrip{ display:flex; }
    .debugstrip .dbg-item{ display:flex; gap:6px; align-items:center; }
    .debugstrip .dbg-k{
      font-weight:800;
      padding:2px 6px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
    }
    .debugstrip .dbg-v{ font-weight:700; opacity: .95; }


    /* Debug speech log (solo body.debug) */
    .speechlog { display:none; position:fixed; left:10px; right:10px; bottom:10px;
      background: rgba(0,0,0,.78); border:1px solid rgba(255,255,255,.12);
      border-radius:12px; padding:10px 10px 8px; z-index:9999; backdrop-filter: blur(6px);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      max-height: 38vh; overflow:auto;
    }
    body.debug .speechlog { display:block; }
    .speechlog-title { font-weight:700; font-size:12px; letter-spacing:.6px; opacity:.9; margin-bottom:6px; }
    .speechlog-list { font-size:12px; line-height:1.25; }
    .speechlog-item { padding:4px 0; border-top:1px solid rgba(255,255,255,.08); }
    .speechlog-item:first-child { border-top:0; }
    .speechlog-meta { opacity:.65; font-size:11px; margin-bottom:2px; }
    .speechlog-hint { opacity:.55; font-size:11px; margin-top:6px; }


    

    /* === SKIN PRO (aplica a TODOS los temas) === */
    @keyframes proSheenMove{
      0%{ transform: translateX(-140%) skewX(-18deg); opacity: 0; }
      18%{ opacity: 0.0; }
      28%{ opacity: 0.24; }
      58%{ opacity: 0.16; }
      82%{ opacity: 0.0; }
      100%{ transform: translateX(140%) skewX(-18deg); opacity: 0; }
    }

    @keyframes proHdrBreath{
      0%,100%{ filter: drop-shadow(0 0 8px rgba(var(--accent-rgb,221,20,19),0.10)); }
      50%{ filter: drop-shadow(0 0 16px rgba(var(--accent-rgb,221,20,19),0.22)); }
    }

    @keyframes proHdrLine{
      0%,100%{ opacity: 0.55; }
      50%{ opacity: 0.95; }
    }

    body.skin-pro{
      --edge-hi: rgba(255,255,255,0.12);
      --edge-lo: rgba(0,0,0,0.55);
      --shadow-elev: 0 14px 32px rgba(0,0,0,0.55);
      --shadow-elev2: 0 10px 22px rgba(0,0,0,0.42);
      --shadow-inset: inset 0 1px 0 rgba(255,255,255,0.10), inset 0 -12px 18px rgba(0,0,0,0.55);

      background-color: var(--bg-dark) !important;
      background-image:
        radial-gradient(circle at 18% 12%, rgba(var(--accent-rgb,221,20,19),0.18), transparent 56%),
        radial-gradient(circle at 82% 6%, rgba(255,255,255,0.06), transparent 58%),
        radial-gradient(circle at 60% 92%, rgba(var(--accent-rgb,221,20,19),0.14), transparent 62%),
        repeating-linear-gradient(135deg, rgba(255,255,255,0.028) 0, rgba(255,255,255,0.028) 2px, rgba(0,0,0,0.0) 2px, rgba(0,0,0,0.0) 7px),
        repeating-linear-gradient(45deg, rgba(255,255,255,0.020) 0, rgba(255,255,255,0.020) 1px, rgba(0,0,0,0.0) 1px, rgba(0,0,0,0.0) 6px ) !important;
      background-blend-mode: screen, screen, screen, overlay, overlay !important;
    }

    body.skin-pro .app-header{
      animation: proHdrBreath 4.8s ease-in-out infinite;
    }
    body.skin-pro .app-header::after{
      animation: proHdrLine 3.6s ease-in-out infinite;
    }

    body.skin-pro .app-header,
    body.skin-pro .spotter-section,
    body.skin-pro .pilot-card,
    body.skin-pro .controls-section,
    body.skin-pro .top3-mini{
      border: 1px solid rgba(255,255,255,0.16) !important;
      box-shadow: var(--shadow-elev2), 0 0 0 1px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.06) !important;
      background-image:
        radial-gradient(120% 180% at 0% 0%, rgba(var(--accent-rgb,221,20,19),0.14), transparent 55%),
        radial-gradient(120% 180% at 100% 0%, rgba(255,255,255,0.05), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.22));
      background-blend-mode: screen, screen, normal;
      backdrop-filter: blur(7px);
      -webkit-backdrop-filter: blur(7px);
    }

    body.skin-pro .btn-primary,
    body.skin-pro .btn-secondary,
    body.skin-pro .spotter-btn,
    body.skin-pro .header-help,
    body.skin-pro .spotter-master-btn,
    body.skin-pro .btn-mini,
    body.skin-pro .btn-grid,
    body.skin-pro .session-preset-card{
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.16) !important;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22)) !important;
      box-shadow: var(--shadow-elev2), var(--shadow-inset) !important;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      transform: translateZ(0);
    }

    body.skin-pro .btn-primary::before,
    body.skin-pro .btn-secondary::before,
    body.skin-pro .spotter-btn::before,
    body.skin-pro .header-help::before,
    body.skin-pro .spotter-master-btn::before,
    body.skin-pro .btn-mini::before,
    body.skin-pro .btn-grid::before,
    body.skin-pro .session-preset-card::before{
      content: "";
      position: absolute;
      inset: -2px -2px auto -2px;
      height: 58%;
      background: radial-gradient(120% 140% at 15% 0%, rgba(255,255,255,0.22), rgba(255,255,255,0.08), transparent 70%);
      pointer-events: none;
      opacity: 0.85;
    }

    body.skin-pro .btn-primary:hover,
    body.skin-pro .btn-secondary:hover,
    body.skin-pro .spotter-btn:hover,
    body.skin-pro .header-help:hover,
    body.skin-pro .spotter-master-btn:hover,
    body.skin-pro .btn-mini:hover,
    body.skin-pro .btn-grid:hover,
    body.skin-pro .session-preset-card:hover{
      filter: brightness(1.10);
    }

    body.skin-pro .btn-primary:active,
    body.skin-pro .btn-secondary:active,
    body.skin-pro .spotter-btn:active,
    body.skin-pro .header-help:active,
    body.skin-pro .spotter-master-btn:active,
    body.skin-pro .btn-mini:active,
    body.skin-pro .btn-grid:active,
    body.skin-pro .session-preset-card:active{
      transform: translateY(1px) scale(0.99) !important;
      box-shadow: 0 8px 18px rgba(0,0,0,0.50), inset 0 1px 0 rgba(255,255,255,0.08), inset 0 -10px 16px rgba(0,0,0,0.60) !important;
    }

    /* ON pintado completo (tema) */
    body.skin-pro .btn-secondary.active,
    body.skin-pro .btn-pill.active,
    body.skin-pro .spotter-btn.active,
    body.skin-pro .spotter-master-btn.active,
    body.skin-pro .session-preset-card.active,
    body.skin-pro .precision-badge.active,
    body.skin-pro .btn-basic-mini.active,
    body.skin-pro .btn-speak.active,
    body.skin-pro .btn-rd.active,
    body.skin-pro #rdToggleBtn.active,
    body.skin-pro .toggle-pill.on,
    body.skin-pro .toggle-pill.active{
      background: linear-gradient(135deg, rgba(var(--accent-rgb,221,20,19),0.96), rgba(var(--accent2-rgb,193,74,70),0.86)) !important;
      color: rgba(18,6,10,0.98) !important;
      border-color: rgba(255,255,255,0.22) !important;
      opacity: 1 !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 26px rgba(var(--accent-rgb,221,20,19),0.26), 0 18px 34px rgba(0,0,0,0.58) !important;
      text-shadow: none !important;
    }

    /* Sheen SOLO cuando esta ON */
    body.skin-pro .btn-secondary.active::after,
    body.skin-pro .btn-pill.active::after,
    body.skin-pro .spotter-btn.active::after,
    body.skin-pro .spotter-master-btn.active::after,
    body.skin-pro .session-preset-card.active::after,
    body.skin-pro .precision-badge.active::after,
    body.skin-pro .btn-basic-mini.active::after,
    body.skin-pro .btn-speak.active::after,
    body.skin-pro .btn-rd.active::after,
    body.skin-pro #rdToggleBtn.active::after,
    body.skin-pro .toggle-pill.on::after,
    body.skin-pro .btn-primary.voice-on::after,
    body.skin-pro .btn-voice.voice-on::after{
      content: "";
      position: absolute;
      top: -10%;
      bottom: -10%;
      width: 42%;
      left: -60%;
      background: linear-gradient(90deg, rgba(255,255,255,0.00), rgba(255,255,255,0.32), rgba(255,255,255,0.00));
      transform: skewX(-18deg);
      pointer-events: none;
      mix-blend-mode: screen;
      animation: proSheenMove 3.8s ease-in-out infinite;
      opacity: 0.0;
    }

    @media (prefers-reduced-motion: reduce){
      body.skin-pro .app-header,
      body.skin-pro .app-header::after{ animation: none !important; }
      body.skin-pro .btn-secondary.active::after,
      body.skin-pro .btn-pill.active::after,
      body.skin-pro .spotter-btn.active::after,
      body.skin-pro .spotter-master-btn.active::after,
      body.skin-pro .session-preset-card.active::after,
      body.skin-pro .precision-badge.active::after,
      body.skin-pro .btn-basic-mini.active::after,
      body.skin-pro .btn-speak.active::after,
      body.skin-pro .btn-rd.active::after,
      body.skin-pro #rdToggleBtn.active::after,
      body.skin-pro .toggle-pill.on::after,
      body.skin-pro .btn-primary.voice-on::after,
      body.skin-pro .btn-voice.voice-on::after{
        animation: none !important;
        display: none !important;
      }
    }
/* === Vic Skin PRO+ (sheen + breathing glow + ON fully painted) === */
    @keyframes vicSheenMove{
      0%{ transform: translateX(-140%) skewX(-18deg); opacity: 0; }
      10%{ opacity: 0.0; }
      22%{ opacity: 0.26; }
      55%{ opacity: 0.16; }
      80%{ opacity: 0.0; }
      100%{ transform: translateX(140%) skewX(-18deg); opacity: 0; }
    }

    @keyframes vicHdrBreath{
      0%,100%{ filter: drop-shadow(0 0 8px rgba(221,20,19,0.10)); }
      50%{ filter: drop-shadow(0 0 16px rgba(221,20,19,0.22)); }
    }

    @keyframes vicHdrLine{
      0%,100%{ opacity: 0.55; }
      50%{ opacity: 0.95; }
    }

    /* Header: micro glow respirando (sutil, no arbol de navidad) */
    body.skin-vicpulse .app-header{
      animation: vicHdrBreath 4.8s ease-in-out infinite;
    }
    body.skin-vicpulse .app-header::after{
      animation: vicHdrLine 3.6s ease-in-out infinite;
    }

    /* ON = pintado completo (cubre TODOS los botones/toggles relevantes) */
    body.skin-vicpulse .btn-secondary.active,
    body.skin-vicpulse .btn-pill.active,
    body.skin-vicpulse .spotter-btn.active,
    body.skin-vicpulse .spotter-master-btn.active,
    body.skin-vicpulse .session-preset-card.active,
    body.skin-vicpulse .precision-badge.active,
    body.skin-vicpulse .btn-basic-mini.active,
    body.skin-vicpulse .btn-speak.active,
    body.skin-vicpulse .btn-rd.active,
    body.skin-vicpulse #rdToggleBtn.active,
    body.skin-vicpulse .toggle-pill.on,
    body.skin-vicpulse .toggle-pill.active{
      background: linear-gradient(135deg, rgba(221,20,19,0.96), rgba(193,74,70,0.86)) !important;
      color: rgba(18,6,10,0.98) !important;
      border-color: rgba(234,234,236,0.22) !important;
      opacity: 1 !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 26px rgba(221,20,19,0.26), 0 18px 34px rgba(0,0,0,0.58) !important;
      text-shadow: none !important;
    }

    /* VOZ ON (verde) tambien pintado completo */

    /* VOZ ON: verde solido en TODOS los temas (btn-voice / btn-voice-mini) */
    .btn-voice.voice-on,
    .btn-voice-mini.voice-on,
    .btn-secondary.btn-hot.btn-voice.voice-on,
    .btn-secondary.btn-hot.btn-voice-mini.voice-on,
    .btn-secondary.btn-hot.btn-voice.voice-on,
    .btn-secondary.btn-hot.voice-on{
      background: rgba(34,197,94,0.95) !important;
      color: rgba(255,255,255,0.96) !important;
      border-color: rgba(255,255,255,0.18) !important;
      text-shadow: none !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 18px rgba(34,197,94,0.22), 0 14px 28px rgba(0,0,0,0.55) !important;
      opacity: 1 !important;
    }

    body.skin-vicpulse .btn-primary.voice-on,
    body.skin-vicpulse .btn-voice.voice-on,
    body.skin-vicpulse .btn-speak.voice-on{
      background: rgba(34,197,94,0.95) !important;
      color: rgba(255,255,255,0.96) !important;
      border-color: rgba(255,255,255,0.18) !important;
      opacity: 1 !important;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.55), 0 0 18px rgba(34,197,94,0.22), 0 14px 28px rgba(0,0,0,0.55) !important;
      text-shadow: none !important;
    }

    /* Asegura que el sheen se vea en chips/toggles */
    body.skin-vicpulse .toggle-pill,
    body.skin-vicpulse .precision-badge,
    body.skin-vicpulse .btn-basic-mini,
    body.skin-vicpulse .btn-speak,
    body.skin-vicpulse .btn-rd,
    body.skin-vicpulse #rdToggleBtn{
      position: relative;
      overflow: hidden;
    }

    /* Sheen: brillo que cruza SOLO cuando esta ON */
    body.skin-vicpulse .btn-secondary.active::after,
    body.skin-vicpulse .btn-pill.active::after,
    body.skin-vicpulse .spotter-btn.active::after,
    body.skin-vicpulse .spotter-master-btn.active::after,
    body.skin-vicpulse .session-preset-card.active::after,
    body.skin-vicpulse .precision-badge.active::after,
    body.skin-vicpulse .btn-basic-mini.active::after,
    body.skin-vicpulse .btn-speak.active::after,
    body.skin-vicpulse .btn-rd.active::after,
    body.skin-vicpulse #rdToggleBtn.active::after,
    body.skin-vicpulse .toggle-pill.on::after,
    body.skin-vicpulse .btn-primary.voice-on::after,
    body.skin-vicpulse .btn-voice.voice-on::after{
      content: "";
      position: absolute;
      top: -10%;
      bottom: -10%;
      width: 42%;
      left: -60%;
      background: linear-gradient(90deg, rgba(255,255,255,0.00), rgba(255,255,255,0.32), rgba(255,255,255,0.00));
      transform: skewX(-18deg);
      pointer-events: none;
      mix-blend-mode: screen;
      animation: vicSheenMove 3.8s ease-in-out infinite;
      opacity: 0.0;
    }

    /* Reduce motion: no animaciones */
    @media (prefers-reduced-motion: reduce){
      body.skin-vicpulse .app-header,
      body.skin-vicpulse .app-header::after{
        animation: none !important;
      }
      body.skin-vicpulse .btn-secondary.active::after,
      body.skin-vicpulse .btn-pill.active::after,
      body.skin-vicpulse .spotter-btn.active::after,
      body.skin-vicpulse .spotter-master-btn.active::after,
      body.skin-vicpulse .session-preset-card.active::after,
      body.skin-vicpulse .precision-badge.active::after,
      body.skin-vicpulse .btn-basic-mini.active::after,
      body.skin-vicpulse .btn-speak.active::after,
      body.skin-vicpulse .btn-rd.active::after,
      body.skin-vicpulse #rdToggleBtn.active::after,
      body.skin-vicpulse .toggle-pill.on::after,
      body.skin-vicpulse .btn-primary.voice-on::after,
      body.skin-vicpulse .btn-voice.voice-on::after{
        animation: none !important;
        display: none !important;
      }
    }

    /* v0.0.0.92 - header-actions-row: reducir botones al 50% (tamano + letra) y forzar texto blanco */
/* v0.0.0.90 - header-logo: alinear logo a la izquierda */
.header-actions-row .header-help{
  font-size: 9px !important;
  padding: 0 16px !important;
  height: 20px;
  min-width: 72px;
  width: auto !important;
  max-width: none !important;
  box-sizing: border-box;
  border-radius: 999px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  white-space: nowrap;
  overflow: hidden;
  line-height: 1;
  color: #ffffff !important;
}
.header-actions-row .header-auto{
  min-width: 33px !important;
}
.header-actions-row .header-skin{
  min-width: 32px !important;
}
@media (max-width: 560px){
  .header-actions-row .header-help{
    font-size: 6px !important;
    padding: 4px 6px !important;
    min-height: 17px;
    color: #ffffff !important;
  }
  .header-actions-row .header-auto{ min-width: 30px !important; }
  .header-actions-row .header-skin{ min-width: 29px !important; }
}

/* v0.0.0.94 - badge-live: mismo tamano que botones del header-actions-row + alineado */
.header-actions-row .badge-live{
  font-size: 6px !important;
  padding: 4px 6px !important;
  min-height: 17px;
  min-width: 33px;
  line-height: 1;
  color: #ffffff !important;
  letter-spacing: 0.06em;
  font-weight: 900;
  text-transform: uppercase;
  border-radius: var(--radius-pill);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.header-actions-row .badge-live-dot{
  width: 5px;
  height: 5px;
}



    
/* v0.0.1.78 - header-actions-row: botones racing legibles (colores + brillo) */
.header-actions-row{
  gap: 8px !important;
}

/* altura y legibilidad uniforme (badge + botones) */
.header-actions-row .header-help,
.header-actions-row .badge-live,
.header-actions-row .badge-mode{
  height: 22px !important;
  min-height: 22px !important;
  line-height: 1 !important;
}

/* Botones del header: look premium racing */
.header-actions-row .header-help{
  --btn1: 255,255,255;
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 0 12px !important;
  min-width: 54px;
  font-size: 9px !important;
  font-weight: 950;
  letter-spacing: 0.11em;
  text-transform: uppercase;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.18) !important;
  background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.03)) !important;
  color: #ffffff !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.42), inset 0 1px 0 rgba(255,255,255,0.22) !important;
  text-shadow: 0 1px 0 rgba(0,0,0,0.45);
  overflow: hidden;
  user-select: none;
}

/* Indicador tipo LED */
.header-actions-row .header-help::before{
  content: "";
  width: 6px;
  height: 6px;
  border-radius: 999px;
  background: rgba(var(--btn1), 0.95);
  box-shadow: 0 0 10px rgba(var(--btn1), 0.55);
}

/* Sheen al hover */
.header-actions-row .header-help::after{
  content:"";
  position:absolute;
  inset:0;
  background: linear-gradient(120deg, rgba(255,255,255,0.00), rgba(255,255,255,0.18), rgba(255,255,255,0.00));
  transform: translateX(-120%) skewX(-18deg);
  opacity: 0;
  transition: transform .45s ease, opacity .45s ease;
  pointer-events:none;
}
.header-actions-row .header-help:hover::after{
  transform: translateX(120%) skewX(-18deg);
  opacity: .90;
}
.header-actions-row .header-help:active{
  transform: translateY(1px);
  filter: brightness(1.05);
}

/* Colores por accion */
#autoSkinBtn{
  --btn1: 0,220,255;
  border-color: rgba(0,220,255,0.55) !important;
  background: linear-gradient(180deg, rgba(0,220,255,0.28), rgba(0,0,0,0.38)) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.42), 0 0 14px rgba(0,220,255,0.22), inset 0 1px 0 rgba(255,255,255,0.22) !important;
}
#skinBtn{
  --btn1: 176, 38, 255;
  border-color: rgba(176,38,255,0.55) !important;
  background: linear-gradient(180deg, rgba(176,38,255,0.26), rgba(0,0,0,0.40)) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.42), 0 0 14px rgba(176,38,255,0.20), inset 0 1px 0 rgba(255,255,255,0.22) !important;
}
#manualBtn{
  --btn1: 255, 180, 0;
  border-color: rgba(255,180,0,0.62) !important;
  background: linear-gradient(180deg, rgba(255,180,0,0.28), rgba(0,0,0,0.40)) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.42), 0 0 14px rgba(255,180,0,0.18), inset 0 1px 0 rgba(255,255,255,0.22) !important;
}

/* Badge LIVE: mismo look que botones */
.header-actions-row .badge-live{
  padding: 0 12px !important;
  font-size: 9px !important;
  font-weight: 950;
  letter-spacing: 0.11em;
  border: 1px solid rgba(255,255,255,0.18);
  box-shadow: 0 10px 20px rgba(0,0,0,0.40), inset 0 1px 0 rgba(255,255,255,0.18);
}
.header-actions-row .badge-live-dot{
  width: 6px !important;
  height: 6px !important;
}

/* MODO badge: ms pro y legible */
.header-actions-row .badge-mode{
  height: 22px !important;
  padding: 0 12px !important;
  font-size: 9px !important;
  font-weight: 950 !important;
  letter-spacing: 0.12em !important;
  border-radius: 999px !important;
  border: 1px solid rgba(var(--accent-rgb), 0.55) !important;
  background: linear-gradient(180deg, rgba(var(--accent-rgb), 0.24), rgba(0,0,0,0.42)) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.40), 0 0 16px rgba(var(--accent-rgb), 0.12), inset 0 1px 0 rgba(255,255,255,0.16) !important;
  color: #ffffff !important;
}

/* Compacto extremo en pantallas chicas */
@media (max-width: 520px){
  .header-actions-row{ gap: 6px !important; }
  .header-actions-row .header-help,
  .header-actions-row .badge-live,
  .header-actions-row .badge-mode{
    height: 21px !important;
    min-height: 21px !important;
  }
  .header-actions-row .header-help{ padding: 0 10px !important; font-size: 8px !important; }
  .header-actions-row .badge-live{ padding: 0 10px !important; font-size: 8px !important; }
  .header-actions-row .badge-mode{ padding: 0 10px !important; font-size: 8px !important; }
}


/* SOLID GREEN VOICE-ON OVERRIDE (all themes) */
    .btn-voice.voice-on,
    .btn-primary.voice-on,
    .btn-speak.voice-on,
    .btn-secondary.btn-hot.btn-voice.btn-voice-mini.voice-on{
      background: #22c55e !important;
      border-color: #16a34a !important;
      color: #ffffff !important;
      box-shadow: 0 10px 24px rgba(34,197,94,0.22), inset 0 1px 0 rgba(255,255,255,0.20) !important;
      text-shadow: none !important;
      filter: none !important;
    }
    .btn-voice.voice-on::after,
    .btn-primary.voice-on::after,
    .btn-speak.voice-on::after{
      opacity: 0 !important;
    }


    /* v0.0.1.49 UI refinements: dedicated mode row + uniform bigger header buttons */
.header-mode-row{
  display:flex;
  align-items:center;
  justify-content:center;
  width: 100%;
  margin-top: 2px;
}
#raceModeBadge{
  display:inline-flex !important;
  align-items:center;
  justify-content:center;
  height: 28px;
  padding: 0 14px;
  border-radius: 999px;
  font-size: 12px;
  letter-spacing: 0.08em;
  font-weight: 800;
  text-transform: uppercase;
  white-space: nowrap;
  box-shadow: 0 10px 22px rgba(0,0,0,0.28);
}
/* make header action controls larger and uniform */
.header-actions-row{
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
}
.header-actions-row .header-help,
.header-actions-row .badge-live{
  height: 36px;
  min-width: 86px;
  padding: 0 14px;
  border-radius: 999px;
  font-size: 12px;
  line-height: 36px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
}
.header-actions-row .badge-live{
  padding: 0 16px;
}
.header-actions-row .badge-live span{
  line-height: 1;
}
/* mobile: keep readable, still uniform */
@media (max-width: 420px){
  #raceModeBadge{ height: 26px; font-size: 11px; padding: 0 12px; }
  .header-actions-row .header-help,
  .header-actions-row .badge-live{
    height: 34px;
    min-width: 78px;
    font-size: 11px;
    line-height: 34px;
  }
}


/* v0.0.1.55 - Compact race mode badge inside header-controls (prevent hiding other controls) */
#headerControls{ flex-wrap: wrap !important; justify-content: center !important; row-gap: 8px !important; column-gap: 10px !important; }
#headerControls .btn{ min-width: 74px !important; }
#raceModeBadge.badge-mode{
  height: 28px !important;
  line-height: 28px !important;
  padding: 0 10px !important;
  min-width: 0 !important;
  max-width: 140px !important;
  font-size: 10px !important;
  letter-spacing: .6px !important;
  border-radius: 14px !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
@media (max-width: 380px){
  #raceModeBadge.badge-mode{ max-width: 120px !important; font-size: 10.5px !important; padding: 0 9px !important; }
  #headerControls .btn{ min-width: 70px !important; }
}


/* v0.0.1.57 - UI tune: header buttons smaller (extra -50%) + meta lines -20% + latin1 charset */
.header-actions-row .header-help,
.header-actions-row .badge-live,
#raceModeBadge.badge-mode{
  font-size: 4.5px !important;
  padding: 2px 4px !important;
  height: 12px !important;
  min-height: 12px !important;
  line-height: 12px !important;
  min-width: 26px !important;
  border-radius: 10px !important;
  letter-spacing: .08em !important;
}
.header-actions-row .badge-live{ gap: 3px !important; }
.header-actions-row .badge-live-dot{ width: 6px !important; height: 6px !important; }
#raceModeBadge.badge-mode{ max-width: 92px !important; text-overflow: ellipsis !important; overflow: hidden !important; white-space: nowrap !important; }

/* Reduce secondary header text (Turbo Racing / raceInfo / tick) by ~20% */
#raceSubtitle{ font-size: 10px !important; }
#raceInfo{ font-size: 8px !important; }
    #lastUpdateInfo{ font-size: 9px !important; opacity: .85; }




/* ===== v0.0.1.62 Header PRO layout (solo look) ===== */
.app-header{
  display:flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 8px !important;
  height: 210px !important;
  min-height: 210px !important;
  max-height: 210px !important;
  padding: 8px 10px 16px !important;
  overflow: hidden !important;
}

/* Logo arriba con presencia */
.app-header .header-top{ width:100% !important; display:flex !important; align-items:center !important; justify-content:center !important; }
.app-header .header-logo img{
  max-height: 62px !important;
  filter: drop-shadow(0 10px 22px rgba(0,0,0,0.55)) drop-shadow(0 0 14px rgba(255,80,60,0.18)) !important;
}

/* Titulo jerarquico */
.app-header .header-stack{
  width: 100% !important;
  display:flex !important;
  flex-direction: column !important;
  align-items: center !important;
  text-align: center !important;
  gap: 6px !important;
}
#raceTitleMain{ width:100% !important; display:flex !important; justify-content:center !important; }
#raceTitleText{
  display:block !important;
  width: 100% !important;
  font-size: clamp(16px, 4.6vw, 24px) !important; /* 2pt menos + responsive */
  line-height: 1.05 !important;
  letter-spacing: 0.06em !important;
  text-transform: uppercase !important;
  font-weight: 900 !important;
  text-shadow: 0 10px 24px rgba(0,0,0,0.62) !important;
  -webkit-line-clamp: 2 !important;
  max-height: none !important;
}
#raceSubtitle{
  width: 100% !important;
  max-width: none !important;
  font-size: 10px !important;
  letter-spacing: 0.14em !important;
  opacity: 0.92 !important;
}

/* Panel info tipo broadcast */
.header-info-panel{
  width: 100% !important;
  max-width: 438px !important;
  padding: 6px 10px !important;
  border-radius: 12px !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.12)) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.08), 0 10px 22px rgba(0,0,0,0.35) !important;
}
.header-subline{
  font-size: 10px !important;
  color: rgba(255,255,255,0.85) !important;
  line-height: 1.15 !important;
}
.header-mini{
  font-size: 9px !important;
  color: rgba(255,255,255,0.70) !important;
  line-height: 1.15 !important;
  margin-top: 2px !important;
}

/* Barra de controles: una fila pro */
.header-controls{ width:100% !important; display:flex !important; justify-content:center !important; }
.header-actions-row{
  width: 100% !important;
  max-width: 460px !important;
  display:flex !important;
  align-items:center !important;
  justify-content: space-between !important;
  gap: 6px !important;
  padding: 6px 8px !important;
  border-radius: 14px !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  background: linear-gradient(180deg, rgba(0,0,0,0.18), rgba(0,0,0,0.06)) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06) !important;
  flex-wrap: nowrap !important;
}

/* Botones homogeneos compactos */
:root{
  --hdrCtrlH: 14px;
  --hdrCtrlW: 82px;
  --hdrCtrlPadX: 6px;
  --hdrCtrlFont: 8px;
  --hdrCtrlGap: 4px;
}

.header-actions-row > *{ flex: 0 0 auto !important; }
.badge-live,
.header-actions-row button,
.header-actions-row #raceModeBadge.badge-mode{
  height: var(--hdrCtrlH) !important;
  min-width: var(--hdrCtrlW) !important;
  width: var(--hdrCtrlW) !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 999px !important;
}
.badge-live{ justify-content:center !important; }

/* Fix: allow long PRO button labels (Q TABLA, MANUAL) without truncation */
.header-actions-row button.btn-pro{
  width:auto !important;
  min-width: var(--hdrCtrlW) !important;
  max-width:none !important;
}

.header-actions-row button.btn-pro .t{ white-space:nowrap; }
.badge-live span:last-child{ font-weight: 900 !important; letter-spacing: 0.08em !important; }
#raceModeRow{ display:flex !important; align-items:center !important; justify-content:center !important; }

/* Version abajo discreta */
.header-version{
  position: absolute !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 6px !important;
  text-align: center !important;
  font-size: 10px !important;
  opacity: 0.72 !important;
  pointer-events: none !important;
}

/* Movil: que no reviente */
@media (max-width: 430px){
  #raceTitleText{ font-size: clamp(16px, 5.6vw, 22px) !important; -webkit-line-clamp: 2 !important; }
  .header-actions-row{ max-width: 100% !important; }
  :root{ --hdrCtrlW: 82px; --hdrCtrlH: 14px; --hdrCtrlFont: 8px; }
}
/* ===== end header pro ===== */

/* === v0.0.1.65 Header PRO: control bar homognea + modo visible + versin sin encimarse === */
:root{
  --hdrCtrlH: 14px;
  --hdrCtrlW: 82px;
  --hdrCtrlPadX: 6px;
  --hdrCtrlFont: 8px;
  --hdrCtrlGap: 4px;
}

.header-actions-row{
  flex-wrap: nowrap !important;
  gap: var(--hdrCtrlGap) !important;
  padding: 0 2px !important;
}

.header-actions-row > *{ flex: 0 0 auto !important; }

.header-actions-row .header-help,
.header-actions-row #raceModeBadge.badge-mode,
.header-actions-row #liveIndicator.badge-live{
  height: var(--hdrCtrlH) !important;
  min-width: var(--hdrCtrlW) !important;
  width: var(--hdrCtrlW) !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 12px !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  letter-spacing: 0.06em !important;
}

.header-actions-row #liveIndicator.badge-live{
  gap: 6px !important;
}
.header-actions-row #liveIndicator .badge-live-dot{
  margin: 0 !important;
}

/* Badge MODO: siempre legible */
#raceModeBadge.badge-mode{
  border: 1px solid rgba(255,255,255,0.18) !important;
  background: rgba(255,255,255,0.08) !important;
  color: rgba(255,255,255,0.92) !important;
  text-transform: uppercase;
}

/* Colores por tipo */
#raceModeBadge.mode-train{
  background: rgba(59,130,246,0.18) !important;
  border-color: rgba(59,130,246,0.55) !important;
  color: rgba(219,234,254,0.98) !important;
}
#raceModeBadge.mode-manga{
  background: rgba(34,197,94,0.18) !important;
  border-color: rgba(34,197,94,0.55) !important;
  color: rgba(220,252,231,0.98) !important;
}
#raceModeBadge.mode-finalA{
  background: rgba(250,204,21,0.18) !important;
  border-color: rgba(250,204,21,0.55) !important;
  color: rgba(254,249,195,0.98) !important;
}
#raceModeBadge.mode-finalB{
  background: rgba(248,113,113,0.16) !important;
  border-color: rgba(248,113,113,0.55) !important;
  color: rgba(254,226,226,0.98) !important;
}
#raceModeBadge.mode-final{
  background: rgba(239,68,68,0.14) !important;
  border-color: rgba(239,68,68,0.45) !important;
  color: rgba(254,226,226,0.98) !important;
}

/* Versin: no encimar con controles */
.header-version{
  position: relative !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
  margin-top: 6px !important;
  padding-top: 2px !important;
  width: 100% !important;
  text-align: center !important;
  font-size: 9px !important;
  letter-spacing: 0.6px !important;
  opacity: 0.75 !important;
}


/* ====== v0.0.1.78 header live-on compact + no overlap (PRO) ====== */
.app-header.live-on{
  height:165px !important;
  min-height:165px !important;
  max-height:165px !important;
}

/* tighten vertical rhythm */
.app-header{
  padding-top: 8px !important;
  padding-bottom: 8px !important;
  overflow: hidden !important; /* keep rounded container clean */
}

.header-top{ padding: 0 !important; margin: 0 !important; }
.header-logo img{
  max-height: 46px !important;
  width: auto !important;
}

/* title block: ensure both lines visible, no weird clipping */
.header-stack{
  gap: 2px !important;
  margin-top: 4px !important;
  height: auto !important;
  overflow: visible !important;
}
#raceTitleText{
  font-size: clamp(16px, 3.8vw, 22px) !important;
  line-height: 1.06 !important;
  letter-spacing: 0.02em !important;
}
#raceSubtitle{
  font-size: 10px !important;
  line-height: 1.05 !important;
  opacity: 0.70 !important;
  margin-top: -1px !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  max-width: 92vw !important;
}

/* controls: remove scale transform (causes overlap) and make real compact sizes */
.header-controls{
  transform: none !important;
  margin-top: 6px !important;
}

/* single row, centered, no gaps weirdness */
.header-actions-row{
  justify-content: center !important;
  gap: 8px !important;
  flex-wrap: nowrap !important;
  width: 100% !important;
}

/* make all controls truly uniform */
.badge-live,
#raceModeBadge,
.header-help{
  height: 26px !important;
  min-height: 26px !important;
  padding: 0 10px !important;
  font-size: 11px !important;
  border-radius: 999px !important;
  white-space: nowrap !important;
}

/* LIVE should not dominate */
.badge-live{
  min-width: 78px !important;
  justify-content: center !important;
}
#raceModeBadge{
  min-width: 92px !important;
  justify-content: center !important;
}

/* buttons uniform widths */
.header-help{
  min-width: 74px !important;
  text-align: center !important;
}

/* tick panel compact and not stealing space */
.header-info-panel{
  max-width: 150px !important;
  padding: 2px 8px !important;
  margin: 0 !important;
}
.header-mini{
  font-size: 9px !important;
  line-height: 1.05 !important;
  margin: 0 !important;
  opacity: 0.85 !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

/* version anchored at bottom but not overlapping controls */
.header-version{
  margin-top: 6px !important;
  font-size: 10px !important;
  opacity: 0.55 !important;
  position: static !important;
}

/* v0.0.1.78: appVersion + lastUpdateInfo en la misma linea */
.header-version-row{
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  gap: 10px !important;
  flex-wrap: nowrap !important;
  width: 100% !important;
  margin-top: 6px !important;
}
.header-version-row .header-version{
  position: static !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
  display: inline-block !important;
  width: auto !important;
  margin: 0 !important;
  padding: 0 !important;
  line-height: 1.05 !important;
  white-space: nowrap !important;
}
#lastUpdateInfo{
  opacity: 0.72 !important;
  max-width: 48vw !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
/* v0.0.1.78: override responsive absolute version when inside row */
.app-header .header-version-row .header-version{
  pointer-events: none !important;
  text-align: left !important;
}

/* ====== end v0.0.1.78 ====== */


/* v0.0.1.79 - LIVE radio + MODO legible (restaurar look pro) */
.header-actions-row{
  gap: 8px !important;
  justify-content: center !important;
}

/* LIVE: solo radio button */
.header-actions-row #liveIndicator.badge-live{
  width: 16px !important;
  min-width: 16px !important;
  height: 16px !important;
  min-height: 16px !important;
  padding: 0 !important;
  border-radius: 999px !important;
  border: 1px solid rgba(255,255,255,0.26) !important;
  background: rgba(0,0,0,0.22) !important;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.10), 0 8px 18px rgba(0,0,0,0.35) !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 0 !important;
  letter-spacing: 0 !important;
}
.header-actions-row #liveIndicator .badge-live-dot{
  width: 8px !important;
  height: 8px !important;
  border-radius: 999px !important;
  background: rgba(255,255,255,0.14) !important;
  box-shadow: none !important;
}
.header-actions-row #liveIndicator:not(.live-off) .badge-live-dot{
  background: #22c55e !important;
  box-shadow: 0 0 14px rgba(34,197,94,0.60) !important;
}

/* MODO: no recortar, que se lea completo y con color segun clase */
.header-actions-row #raceModeRow{
  flex: 1 1 auto !important;
  min-width: 160px !important;
  max-width: 280px !important;
  justify-content: center !important;
}
.header-actions-row #raceModeBadge.badge-mode{
  width: 100% !important;
  height: 20px !important;
  min-height: 20px !important;
  padding: 0 10px !important;
  font-size: 9px !important;
  font-weight: 950 !important;
  letter-spacing: 0.10em !important;
  border-radius: 999px !important;
  white-space: nowrap !important;
  overflow: visible !important;
  text-overflow: visible !important;
}

/* Limpia overrides viejos que lo encogian demasiado */
.header-actions-row .header-help{
  height: 20px !important;
  min-height: 20px !important;
  font-size: 9px !important;
  padding: 0 10px !important;
}

/* Mobile: si falta espacio, baja un punto y permite un poco mas de compresion */
@media (max-width: 420px){
  .header-actions-row #raceModeRow{ min-width: 140px !important; max-width: 240px !important; }
  .header-actions-row #raceModeBadge.badge-mode{ font-size: 8px !important; }
}


/* Top banner (logo) */
.top-banner-placeholder{
  display:flex;
  flex-direction: column;
  align-items:center;
  justify-content:flex-start;
  gap: 6px;
  flex: 0 0 auto;
  width: min(438px, 92vw);
  margin: 6px auto 6px auto;
  background: transparent;
}

.top-banner-placeholder img.top-banner-logo{
  width: 100%;
  max-width: 438px;
  height: auto;
  max-height: 168px;
  aspect-ratio: 438 / 168;
  display: block;
  object-fit: contain;
  pointer-events: none;
}

/* Banner subtitle row (between logo block and app-header) */
.banner-subtitle-row{
  width: min(440px, 96vw);
  margin: 0 auto 8px auto;
  text-align: center;
  display:flex;
  justify-content:center;
  align-items:center;
  pointer-events:none;
}
.banner-subtitle-row .header-title-sub{
  height: auto !important;
  overflow: visible !important;
  white-space: nowrap;
  display:block;
  color: rgba(255,255,255,0.96);
  text-shadow: 0 2px 10px rgba(0,0,0,0.75);
  padding: 2px 6px;
  border-radius: 10px;
  background: rgba(0,0,0,0.42);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow: 0 8px 18px rgba(0,0,0,0.35);
}






/* Subtitle moved under logo */
.top-banner-placeholder .header-title-sub{
  width: 100%;
  max-width: min(440px, 96vw);
  text-align:center;
  margin: 0 !important;
  padding: 0 !important;

  /* override legacy 8px clamp (v0.0.1.78) */
  height: auto !important;
  min-height: 0 !important;
  line-height: 1.15 !important;
  overflow: visible !important;

  font-size: 11px !important;
  letter-spacing: 0.10em !important;
  opacity: 0.90 !important;
}
.top-banner-placeholder #raceSubtitle{
  margin-top: 2px !important;   /* no negative shove under the logo */
}

/* Main header height requirement */
.app-header.live-on{
  height: 165px !important;
  min-height: 165px !important;
}


    /* LapChart watermark (UI only) */
    :root{
      --lapchart-watermark-url: url('https://i.ibb.co/wFx8B4mW/logo-vics-PT.gif');
      --lapchart-watermark-opacity: 0.10;
      --lapchart-watermark-size: 78%;
      --lapchart-watermark-y: 52%;
      --lapchart-watermark-scale: 1.0;
    }
    .lap-chart-canvas-wrap{
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      background: transparent;
    }
    .lap-chart-canvas-wrap::before{
      content: "";
      position: absolute;
      inset: 0;
      background-image: var(--lapchart-watermark-url);
      background-repeat: no-repeat;
      background-position: 50% var(--lapchart-watermark-y);
      background-size: var(--lapchart-watermark-size) auto;
      opacity: var(--lapchart-watermark-opacity);
      filter: saturate(0.95) contrast(1.05);
      transform: scale(var(--lapchart-watermark-scale));
      pointer-events: none;
      z-index: 0;
    }
    .lap-chart-canvas-wrap canvas{
      position: relative;
      z-index: 1;
      display: block;
      width: 100%;
      height: auto;
      background: transparent;
    }

/* ---- merged block ---- */

/* Logo size override (keeps aspect ratio, fills header area) */
.header-top{ margin-bottom: 8px !important; }
.header-logo{ width: 100% !important; display:flex !important; justify-content:center !important; align-items:center !important; overflow: visible !important; }
.header-logo img{
  height: 96px !important;
  max-height: 96px !important;
  width: auto !important;
  max-width: min(560px, 92vw) !important;
  object-fit: contain !important;
}
@media (max-width: 520px){
  .header-logo img{
    height: 72px !important;
    max-height: 72px !important;
    max-width: min(420px, 92vw) !important;
  }
}

/* ---- merged block ---- */

/* FIX v0.0.2.41: version siempre visible en header */
.header-version-row{
  position:absolute !important;
  left:0 !important; right:0 !important; bottom:6px !important;
  z-index:50 !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
  gap:10px !important;
  margin:0 !important;
}
.header-version-row .header-version{
  position:static !important;
  display:inline-block !important;
  font-size:10px !important;
  letter-spacing:.6px !important;
  opacity:.86 !important;
  color: rgba(255,255,255,0.78) !important;
  text-shadow: 0 1px 0 rgba(0,0,0,0.45) !important;
  pointer-events:none !important;
}
#appVersion{
  font-weight:900 !important;
  opacity:.96 !important;
  color: rgba(255,255,255,0.90) !important;
}

/* ---- merged block ---- */

/* v0.0.2.99 - header compatibility hardening */
html { -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }

/* Avoid fixed-height traps (especially iOS with large text / dynamic viewport) */
.app-header { height: auto !important; max-height: none !important; }

/* Flex children must be allowed to shrink, otherwise text forces overflow */
.header-actions-row, .header-actions { flex-wrap: wrap !important; }
.header-actions-row > *, .header-actions > * { min-width: 0; }

/* Keep long subtitles from pushing out of the container */
.header-title-sub, .raceSubtitle, #raceSubtitle { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* Ensure header can position debug badge safely */
.app-header { position: relative; }

/* ---- merged block ---- */

/* HEADER CANON v0.0.2.99 - iOS Safari/Chrome consistent */
html, body {
  -webkit-text-size-adjust: 100% !important;
  text-size-adjust: 100% !important;
}

/* Never lock header height: allow it to grow */
.app-header, .app-header.live-on, .app-header.live-off {
  height: auto !important;
  max-height: none !important;
  min-height: 170px !important;
}

.header-actions-row {
  position: relative !important;
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  align-items: center !important;
  gap: 8px !important;
  row-gap: 8px !important;
  padding: 0 6px !important;
  width: 100% !important;
}

/* Live dot should not steal centering space */
.header-actions-row .badge-live {
  position: absolute !important;
  left: 10px !important;
  top: 0px !important;
  margin: 0 !important;
}

/* Force a clean line break: row 1 = mode pill, row 2 = buttons */
.header-actions-row .hdr-break {
  flex-basis: 100% !important;
  height: 0 !important;
}

.header-actions-row .header-mode-row {
  flex: 0 1 auto !important;
  margin: 0 auto !important;
}

/* Buttons: consistent sizing and wrapping */
.header-actions-row button {
  flex: 0 0 auto !important;
  min-width: 84px;
}

/* Subtitle truncation safety */
.header-title-sub {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
}

/* ---- merged block ---- */

.toast{ position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
    background: rgba(0,0,0,0.72); color: rgba(255,255,255,0.92);
    border:1px solid rgba(255,255,255,0.14); border-radius: 999px;
    padding: 8px 14px; font-weight: 800; letter-spacing: .04em;
    z-index: 99999; opacity:0; pointer-events:none; transition: opacity .18s ease, transform .18s ease;
  }
  .toast.on{ opacity:1; transform:translateX(-50%) translateY(-4px); }


    /* --- Header layout refresh (v0.0.1.43) --- */
    .app-header{
      display: flex !important;
      flex-direction: column !important;
      align-items: stretch !important;
      gap: 8px !important;
      padding: 10px 12px !important;
      height: auto !important;
      max-height: none !important;
      min-height: 0 !important;
      overflow: visible !important;
    }
    .app-header .header-left, .app-header .header-right { display: flex; align-items: center; gap: 8px; }

    /* Header PRO (logo arriba, titulo grande, jerarquia clara) */
    .app-header{
      padding: 14px 16px;
    }

    .header-top{
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 6px;
    }
    .header-logo{
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: auto;
    }
    .header-logo img{
      max-height: 110px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 6px 14px rgba(0,0,0,0.55)) drop-shadow(0 0 14px rgba(0,255,163,0.18));
    }

    .header-stack{
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 6px;
      min-width: 0;
    }

    .header-title-main{
      width: 100%;
      max-width: 980px;
      padding: 0 8px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #raceTitleText{
      max-width: 100%;
      width: auto;
      flex: 1 1 auto;
      font-size: clamp(20px, 6.2vw, 32px);
      line-height: 1.05;
      letter-spacing: 0.02em;
      text-shadow: 0 2px 12px rgba(0,0,0,0.55);
      max-height: none;
      -webkit-line-clamp: 3;
    }

    .header-mode-row{
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 2px;
    }
    .badge-mode{
      font-size: clamp(12px, 3.4vw, 14px);
      padding: 6px 12px;
      border-radius: 999px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
    }

    .app-header .header-title-sub{
      width: 100%;
      max-width: 980px;
      font-size: clamp(12px, 3.8vw, 16px);
      opacity: 0.92;
      white-space: normal;
      padding: 0 8px;
      letter-spacing: 0.08em;
    }
    #raceSubtitle{
      max-width: 100%;
      width: auto;
      font-size: inherit;
    }

    .header-subline{
      width: 100%;
      max-width: 980px;
      font-size: clamp(12px, 3.3vw, 14px);
      opacity: 0.92;
      white-space: normal;
      padding: 0 8px;
    }
    .header-mini{
      width: 100%;
      max-width: 980px;
      font-size: clamp(11px, 3.0vw, 12px);
      opacity: 0.72;
      padding: 0 8px;
    }

    .header-controls{
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      margin-top: 8px;
    }
    .header-actions-row{
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 8px;
      width: 100%;
      max-width: 980px;
    }

    .header-version{
      width: 100%;
      text-align: center;
      font-size: 11px;
      opacity: 0.70;
      padding-top: 6px;
    }

    @media (max-width: 420px){
      .app-header{ padding: 12px 10px !important; }
      .header-actions-row{ gap: 6px; }
      .header-logo img{ max-height: 96px; }
      #raceTitleText{ font-size: clamp(22px, 7.2vw, 30px); }
      .badge-mode{ padding: 6px 10px; }
      .app-header .header-title-sub{ letter-spacing: 0.06em; }
    }

    @media (max-width: 360px){
      #raceTitleText{ font-size: clamp(20px, 7.8vw, 28px); }
      .header-logo img{ max-height: 90px; }
    }

    @media (min-width: 900px){
      .header-logo img{ max-height: 124px; }
      #raceTitleText{ font-size: clamp(24px, 3.2vw, 34px); }
    }


/* v0.0.1.47 - Header compact: fixed height 250px (without breaking logic) */
.app-header{
  height: 250px !important;
  min-height: 250px !important;
  max-height: 250px !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 6px !important;
  overflow: hidden !important;
}

.header-top{ margin-bottom: 2px !important; }

.header-logo img{
  max-height: 80px !important;
  width: auto !important;
}

.header-stack{
  width: 100% !important;
  flex: 1 1 auto !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 6px !important;
  overflow: visible !important;
  z-index: 2 !important;
}

.header-title-main{
  margin: 0 !important;
  line-height: 1.05 !important;
}
#raceTitleText{
  font-size: clamp(14px, 4.0vw, 22px) !important;
  letter-spacing: 0.5px !important;
  -webkit-line-clamp: 2 !important;
}

.header-mode-row{ margin-top: 2px !important; }

#raceModeRow{ width: 100% !important; display:flex !important; justify-content:center !important; z-index: 3 !important; }
#raceModeBadge{ font-size: 12px !important; height: 28px !important; padding: 0 14px !important; background: rgba(0,0,0,0.35) !important; border-color: rgba(255,255,255,0.28) !important; color: rgba(255,255,255,0.96) !important; text-shadow: 0 2px 10px rgba(0,0,0,0.65) !important; }

.header-title-sub{
  margin-top: 0 !important;
  font-size: clamp(10px, 2.6vw, 12px) !important;
  line-height: 1.1 !important;
  max-width: 100% !important;
}

.header-subline{
  font-size: clamp(11px, 2.8vw, 13px) !important;
  line-height: 1.15 !important;
}

.header-mini{
  font-size: 10px !important;
  opacity: 0.85 !important;
}

.header-controls{
  width: 100% !important;
  display: flex !important;
  justify-content: center !important;
  margin-top: 8px !important;
  z-index: 1 !important;
}

.header-actions-row{
  gap: 6px !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
}

.header-version{
  margin-top: auto !important;
  padding-top: 4px !important;
  font-size: 10px !important;
  opacity: 0.75 !important;
  text-align: center !important;
}

/* v0.0.1.52 - Force race mode badge visibility and contrast */
#raceModeRow{
  display: flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  z-index: 5;
}
#raceModeBadge{
  display: inline-flex !important;
  min-height: 28px;
  padding: 6px 14px;
}


/* ===== Header controls: force single row (LIVE + MODO + buttons) ===== */
:root{
  --hdrCtrlH: 14px;
  --hdrCtrlW: 82px;
  --hdrCtrlPadX: 6px;
  --hdrCtrlFont: 8px;
  --hdrCtrlGap: 4px;
}

.header-controls{
  width: 100% !important;
  margin-top: 6px !important;
}
.header-actions-row{
  display: flex !important;
  flex-wrap: nowrap !important;
  justify-content: center !important;
  align-items: center !important;
  gap: var(--hdrCtrlGap) !important;
  width: 100% !important;
  overflow: hidden !important;
}
.header-actions-row > *{
  flex: 0 1 auto !important;
  min-width: 0 !important;
}
.header-actions-row button.header-help{
  height: var(--hdrCtrlH) !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 12px !important;
  white-space: nowrap !important;
  min-width: var(--hdrCtrlW) !important;
  width: var(--hdrCtrlW) !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
}
#raceModeRow{
  height: var(--hdrCtrlH) !important;
  display: inline-flex !important;
  align-items: center !important;
}
#raceModeBadge.badge-mode{
  height: var(--hdrCtrlH) !important;
  display: inline-flex !important;
  align-items: center !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 12px !important;
  white-space: nowrap !important;
}
#liveIndicator.badge-live{
  height: var(--hdrCtrlH) !important;
  display: inline-flex !important;
  align-items: center !important;
  padding: 0 var(--hdrCtrlPadX) !important;
  font-size: var(--hdrCtrlFont) !important;
  line-height: 1 !important;
  border-radius: 12px !important;
  white-space: nowrap !important;
  min-width: var(--hdrCtrlW) !important;
  width: var(--hdrCtrlW) !important;
  justify-content: center !important;
  justify-content: center !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

/* Kill any scaling that could hide controls */
.app-header .header-controls{ transform: none !important; }

@media (max-width: 420px){
  :root{
  --hdrCtrlH: 14px;
  --hdrCtrlW: 82px;
  --hdrCtrlPadX: 6px;
  --hdrCtrlFont: 8px;
  --hdrCtrlGap: 4px;
}

.header-actions-row{
    justify-content: flex-start !important;
    padding: 0 6px !important;
  }
}
/* ===== /Header controls ===== */


/* v0.0.1.69 tweak: header-stack 50px, keep subtitle visible */
.header-stack{height:50px !important; max-height:50px !important; overflow:visible !important;}
#raceTitleText{font-size: clamp(14px, 4.0vw, 22px) !important; line-height:1.05 !important;}
#raceSubtitle{font-size: 9px !important; line-height:1.0 !important; margin-top:-4px !important; opacity:0.78 !important;}
.header-controls{margin-top:6px !important;}
.header-actions-row{gap:6px !important;}


/* v0.0.1.78 - tighten header-title-sub to 8px height */
.header-title-sub{
  height:8px !important;
  min-height:8px !important;
  line-height:8px !important;
  overflow:hidden !important;
  margin:0 !important;
  padding:0 !important;
  display:block !important;
}

/* ---- LOGO OVERRIDE (v0.0.1.96) ---- */
.header-logo img{
  width: auto !important;
  height: 96px !important;
  max-height: 96px !important;
  max-width: 95% !important;
  object-fit: contain !important;
}
@media (max-width: 520px){
  .header-logo img{
    height: 72px !important;
    max-height: 72px !important;
    max-width: 96% !important;
  }
}


/* ====== v0.0.2.12 logo fit (no crop, bigger, moved down) ====== */
.app-header .header-logo{
  height: 110px !important;
  min-height: 110px !important;
  overflow: visible !important; /* allow full logo, no clipping */
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding-top: 6px !important;
}
.app-header .header-logo img{
  width: min(620px, 96%) !important;
  height: 100% !important;
  max-height: none !important;
  max-width: none !important;
  object-fit: contain !important; /* never crop */
  transform: translateY(10px) scale(1.00) !important; /* move down 10px */
  transform-origin: center center !important;
  filter: drop-shadow(0 0 10px rgba(0,0,0,0.35)) !important;
}
@media (max-width: 520px){
  .app-header .header-logo{
    height: 84px !important;
    min-height: 84px !important;
    padding-top: 4px !important;
  }
  .app-header .header-logo img{
    width: 96% !important;
    transform: translateY(8px) scale(1.00) !important;
  }
}

/* v0.0.2.12 - Header: altura estable (sin salto al cambiar LIVE) */
.app-header{
  height: 165px !important;
  min-height: 165px !important;
  max-height: 165px !important;
  padding: 12px 14px !important;
}
.app-header.live-on,
.app-header.live-off{
  height: 165px !important;
  min-height: 165px !important;
  max-height: 165px !important;
}
.header-stack{ flex: 0 0 auto !important; }
.header-controls{ margin-top: 6px !important; }
.header-version{ padding-top: 4px !important; }


/* =========================
   Q TABLA (Clasificación) - UI only
   ========================= */
.header-help.header-qtable{ letter-spacing: .35px; font-weight: 900; }

#qualiBackdrop .manual-panel{
  width: min(880px, 100%);
  padding: 10px;
  border-radius: 16px;
}
#qualiBackdrop .manual-title{ font-size: 15px; }
#qualiBackdrop .manual-sub{ font-size: 10.5px; }

#qualiBackdrop .qmeta{ display:flex; flex-wrap:wrap; gap:6px; margin: 0 0 8px 0; }
#qualiBackdrop .qchip{
  display:inline-flex; align-items:center; gap:6px;
  padding: 4px 8px; font-size: 10.5px;
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.22);
  background: rgba(0,0,0,0.18);
  color: var(--text-main);
  font-weight: 900;
}
#qualiBackdrop .qsel{
  padding: 4px 6px; font-size: 10.5px;
  border-radius: 10px;
  border: 1px solid rgba(148,163,184,0.22);
  background: rgba(0,0,0,0.22);
  color: var(--text-main);
  outline: none;
}
#qualiBackdrop .qtable-wrap{
  overflow:auto;
  max-height: 60vh;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,0.14);
  background: rgba(0,0,0,0.14);
}
#qualiBackdrop .qtable{
  font-size: 10.5px;
  min-width: 660px;
  border-collapse: separate;
  border-spacing: 0;
}
#qualiBackdrop .qtable th, #qualiBackdrop .qtable td{
  padding: 4px 6px;
  vertical-align: top;
}
#qualiBackdrop .qtable th{
  position: sticky;
  top: 0;
  z-index: 2;
  background: rgba(8,10,15,0.96);
  backdrop-filter: blur(6px);
  border-bottom: 1px solid rgba(148,163,184,0.18);
}
#qualiBackdrop .qtable tbody tr:nth-child(even) td{
  background: rgba(255,255,255,0.015);
}
#qualiBackdrop .qcol-pos{ width: 46px; }
#qualiBackdrop .qcol-name{ width: 180px; }
#qualiBackdrop .qcol-q{ width: 54px; }
#qualiBackdrop .qcol-laps{ width: 72px; }
#qualiBackdrop .qcol-time{ width: 116px; }
#qualiBackdrop .qmain{ white-space: nowrap; }
#qualiBackdrop .qtag{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 2px 7px;
  border-radius: 999px;
  font-size: 10px;
  font-weight: 900;
  letter-spacing: .3px;
  border: 1px solid rgba(255,122,24,0.35);
  background: rgba(255,122,24,0.10);
  color: rgba(242,245,255,0.95);
  margin-bottom: 3px;
}
#qualiBackdrop .qtable th.qcol-q1{ box-shadow: inset 0 -2px 0 rgba(56,189,248,0.65); }
#qualiBackdrop .qtable td.qcol-q1{ background: rgba(56,189,248,0.045); }
#qualiBackdrop .qtag.qtag-q1{ border-color: rgba(56,189,248,0.50); background: rgba(56,189,248,0.12); }

#qualiBackdrop .qtable th.qcol-q2{ box-shadow: inset 0 -2px 0 rgba(34,197,94,0.65); }
#qualiBackdrop .qtable td.qcol-q2{ background: rgba(34,197,94,0.040); }
#qualiBackdrop .qtag.qtag-q2{ border-color: rgba(34,197,94,0.50); background: rgba(34,197,94,0.12); }

#qualiBackdrop .qtable th.qcol-q3{ box-shadow: inset 0 -2px 0 rgba(251,191,36,0.70); }
#qualiBackdrop .qtable td.qcol-q3{ background: rgba(251,191,36,0.040); }
#qualiBackdrop .qtag.qtag-q3{ border-color: rgba(251,191,36,0.55); background: rgba(251,191,36,0.12); }

#qualiBackdrop .qtable th.qcol-q4{ box-shadow: inset 0 -2px 0 rgba(216,170,255,0.75); }
#qualiBackdrop .qtable td.qcol-q4{ background: rgba(216,170,255,0.045); }
#qualiBackdrop .qtag.qtag-q4{ border-color: rgba(216,170,255,0.55); background: rgba(216,170,255,0.12); }

#qualiBackdrop .qtable th.qcol-q5{ box-shadow: inset 0 -2px 0 rgba(244,114,182,0.75); }
#qualiBackdrop .qtable td.qcol-q5{ background: rgba(244,114,182,0.040); }
#qualiBackdrop .qtag.qtag-q5{ border-color: rgba(244,114,182,0.55); background: rgba(244,114,182,0.12); }

#qualiBackdrop .qtable th.qcol-q6{ box-shadow: inset 0 -2px 0 rgba(59,130,246,0.75); }
#qualiBackdrop .qtable td.qcol-q6{ background: rgba(59,130,246,0.040); }
#qualiBackdrop .qtag.qtag-q6{ border-color: rgba(59,130,246,0.55); background: rgba(59,130,246,0.12); }

#qualiBackdrop .qtable th.qcol-q7{ box-shadow: inset 0 -2px 0 rgba(20,184,166,0.75); }
#qualiBackdrop .qtable td.qcol-q7{ background: rgba(20,184,166,0.040); }
#qualiBackdrop .qtag.qtag-q7{ border-color: rgba(20,184,166,0.55); background: rgba(20,184,166,0.12); }

#qualiBackdrop .qtable th.qcol-q8{ box-shadow: inset 0 -2px 0 rgba(239,68,68,0.75); }
#qualiBackdrop .qtable td.qcol-q8{ background: rgba(239,68,68,0.040); }
#qualiBackdrop .qtag.qtag-q8{ border-color: rgba(239,68,68,0.55); background: rgba(239,68,68,0.12); }


#qualiBackdrop .qtable th.qcol-q9{ box-shadow: inset 0 -2px 0 rgba(56,189,248,0.65); }
#qualiBackdrop .qtable td.qcol-q9{ background: rgba(56,189,248,0.045); }
#qualiBackdrop .qtag.qtag-q9{ border-color: rgba(56,189,248,0.50); background: rgba(56,189,248,0.12); }

#qualiBackdrop .qtable th.qcol-q10{ box-shadow: inset 0 -2px 0 rgba(34,197,94,0.65); }
#qualiBackdrop .qtable td.qcol-q10{ background: rgba(34,197,94,0.040); }
#qualiBackdrop .qtag.qtag-q10{ border-color: rgba(34,197,94,0.50); background: rgba(34,197,94,0.12); }

#qualiBackdrop .qtable th.qcol-q11{ box-shadow: inset 0 -2px 0 rgba(251,191,36,0.70); }
#qualiBackdrop .qtable td.qcol-q11{ background: rgba(251,191,36,0.040); }
#qualiBackdrop .qtag.qtag-q11{ border-color: rgba(251,191,36,0.55); background: rgba(251,191,36,0.12); }

#qualiBackdrop .qtable th.qcol-q12{ box-shadow: inset 0 -2px 0 rgba(216,170,255,0.75); }
#qualiBackdrop .qtable td.qcol-q12{ background: rgba(216,170,255,0.045); }
#qualiBackdrop .qtag.qtag-q12{ border-color: rgba(216,170,255,0.55); background: rgba(216,170,255,0.12); }
#qualiBackdrop td.qcell-bestlap{
  background: rgba(216,170,255,0.05);
}
#qualiBackdrop td.qcell-best{
  background: rgba(216,170,255,0.09);
  box-shadow: inset 2px 0 0 rgba(216,170,255,0.55);
}
#qualiBackdrop td.qcell-laps{
  background: rgba(56,189,248,0.06);
  box-shadow: inset 2px 0 0 rgba(56,189,248,0.45);
}
#qualiBackdrop td.qcell-time{
  background: rgba(251,191,36,0.05);
  box-shadow: inset 2px 0 0 rgba(251,191,36,0.35);
}
#qualiBackdrop .qtable th:nth-child(4){ color: rgba(56,189,248,0.95); }
#qualiBackdrop .qtable th:nth-child(5){ color: rgba(251,191,36,0.95); }
#qualiBackdrop .qtable th:nth-child(6){ color: rgba(216,170,255,0.96); }
#qualiBackdrop td.qcell-empty{
  color: rgba(163,173,189,0.65);
}


#qualiBackdrop .qtable td{
  border-bottom: 1px solid rgba(148,163,184,0.08);
}
#qualiBackdrop .qtable tbody tr:hover td{
  background: rgba(255,255,255,0.03);
}
#qualiBackdrop .qtable tbody tr:nth-child(1) td:nth-child(-n+2){
  background: rgba(255, 215, 0, 0.06);
}
#qualiBackdrop .qtable tbody tr:nth-child(2) td:nth-child(-n+2){
  background: rgba(220, 220, 220, 0.045);
}
#qualiBackdrop .qtable tbody tr:nth-child(3) td:nth-child(-n+2){
  background: rgba(205, 127, 50, 0.05);
}
#qualiBackdrop .qtable tbody tr:nth-child(-n+3) td:first-child{
  font-weight: 950;
}
#qualiBackdrop .qtable tbody tr:nth-child(1) td:first-child{ color: rgba(255,215,0,0.95); }
#qualiBackdrop .qtable tbody tr:nth-child(2) td:first-child{ color: rgba(230,230,230,0.95); }
#qualiBackdrop .qtable tbody tr:nth-child(3) td:first-child{ color: rgba(205,127,50,0.95); }

#qualiBackdrop .qbest{
  margin-top: 2px;
  font-weight: 950;
  letter-spacing: .2px;
  color: rgba(216, 170, 255, 0.96);
  text-shadow: 0 0 10px rgba(216,170,255,0.12);
}


/* =========================
   HARD OVERRIDES v0.0.2.26
   - Corrige "brinco" del header y recortes en iPhone 12
   - Ajusta header-mode-row sin scale (wrap responsive)
   - Top banner siempre responsivo (no desaparece)
========================= */
.top-banner-placeholder{
  width: min(438px, 96vw) !important;
  max-width: 438px !important;
  min-width: 0 !important;
  height: 168px !important;
  margin: 10px auto 8px auto !important;
  background: rgba(8,10,15,0.55) !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  border-radius: 18px !important;
  box-shadow: 0 12px 34px rgba(0,0,0,0.55), inset 0 0 0 1px rgba(255,255,255,0.05) !important;
  overflow: hidden !important;
  backdrop-filter: blur(6px) !important;
}

@media (max-width: 460px){
  .top-banner-placeholder{
    width: min(438px, 96vw) !important;
    max-width: 100% !important;
    min-width: 0 !important;
  }
}

.top-banner-placeholder .top-banner-logo{
  width: 100% !important;
  height: 100% !important;
  object-fit: contain !important;
  display:block !important;
}

/* Header: misma altura siempre (evita que abra grande y luego se encoja) */
.app-header,
.app-header.live-on,
.app-header.live-off{
  height: 165px !important;
  min-height: 165px !important;
  max-height: 165px !important;
}

/* El modo/controles se adaptan al ancho real, sin transform que recorta */
.app-header .header-mode-row{
  transform: none !important;
  margin: 0 !important;
  width: 100% !important;
  display:flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  gap: 6px 8px !important;
  overflow: visible !important;
}

/* En pantallas chicas: reduce gap y permite 2 renglones sin cortar */
@media (max-width: 420px){
  .app-header .header-mode-row{ gap: 5px 6px !important; }
  .app-header .header-mode-row .btn-pill,
  .app-header .header-mode-row .spotter-btn{
    padding: 7px 10px !important;
    min-width: 64px !important;
  }
}


/* ===== HOTFIX v0.0.2.41: responsive header rows (no scale, no cut) ===== */
.app-header .header-mode-row{
  transform: none !important;
  margin: 0 !important;
  padding: 0 !important;
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  gap: 6px 8px !important;
}
.app-header .header-controls{
  transform: none !important;
  margin-top: 0 !important;
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: center !important;
  gap: 6px 8px !important;
}
.app-header .header-actions-row{
  flex-wrap: wrap !important;
  row-gap: 6px !important;
}
@media (max-width: 420px){
  .app-header .header-controls .btn{ padding: 6px 10px !important; }
  .app-header .header-mode-row .badge-mode{ font-size: 10px !important; }
}


/* v0.0.2.99 - HEADER BULLETPROOF (iOS Pro/Max + texto grande) */
html{ -webkit-text-size-adjust: 100%; text-size-adjust: 100%; }
.app-header,
.app-header.live-on,
.app-header.live-off{
  height: auto !important;
  min-height: 170px !important;
  max-height: none !important;
  padding-top: calc(10px + env(safe-area-inset-top)) !important;
  overflow: visible !important;
}
@supports not (overflow: clip){
  .app-header{ overflow: visible !important; }
}

.app-header .header-controls,
.app-header .header-stack,
.app-header .header-title-main,
.app-header .header-title-sub,
.app-header .header-version-row{
  min-width: 0 !important;
}

.app-header .header-actions-row{
  display: flex !important;
  flex-wrap: wrap !important;
  align-items: center !important;
  gap: 6px !important;
  row-gap: 6px !important;
}

.app-header .header-title-sub{
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

.app-header .header-version-row{
  display: flex !important;
  flex-wrap: wrap !important;
  align-items: center !important;
  gap: 6px !important;
}

@media (max-width: 420px){
  .app-header .header-actions-row{ gap: 5px !important; row-gap: 5px !important; }
  .app-header .header-title-main{ font-size: 18px !important; }
}


/* --- FINAL HEADER OVERRIDES (iOS Safari stability) --- */
html, body{
  -webkit-text-size-adjust: 100% !important;
  text-size-adjust: 100% !important;
}

/* Center button rows always (Safari was forcing flex-start somewhere) */
.app-header .header-actions-row{
  justify-content: center !important;
  align-content: center !important;
  flex-wrap: wrap !important;
  padding: 0 !important;
  row-gap: 8px !important;
}

/* Buttons: never stretch, never wrap text */
.app-header .header-actions-row button.header-help{
  flex: 0 0 auto !important;
  white-space: nowrap !important;
}

/* Make sure the version row never overlaps controls */
.app-header .header-controls{ margin-bottom: 2px !important; }
.app-header .header-version-row{ margin-top: 2px !important; }


/* =========================
   PRO HEADER BUTTONS - UI ONLY
   (No cambia JS, voz, unlock iOS ni dedupe)
   ========================= */
:root{
  --proBtnH: 34px;
  --proBtnR: 12px;
  --proBtnPadX: 10px;
  --proBtnFont: 12px;

  --proBgA: #0b0f16;
  --proBgB: #121a26;

  --proStrokeA: rgba(255,255,255,.14);
  --proStrokeB: rgba(255,255,255,.06);

  --proTxt: rgba(255,255,255,.92);
  --proTxtDim: rgba(255,255,255,.75);

  --proShadow: 0 10px 24px rgba(0,0,0,.55);
  --proGlow: 0 0 0 3px rgba(255,255,255,.06);

  --proAccentCyan: #00e5ff;
  --proAccentPurple: #a855f7;
  --proAccentRed: #ff355d;
  --proAccentAmber: #ffb020;
  --proAccentGreen: #35ff7a;
}


/* PRO header buttons sizing (fit all on mobile) */
@media (max-width: 520px){
  .app-header .header-actions-row{ gap: 6px !important; }
  .app-header .header-actions-row .btn-pro{ padding: 8px 10px !important; font-size: 12px !important; }
  .app-header .header-actions-row .btn-pro .ico{ width: 11px !important; height: 11px !important; margin-right: 6px !important; }
}
.app-header .header-actions-row .btn-pro{
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;

  height: var(--proBtnH);
  padding: 0 var(--proBtnPadX);
  border-radius: var(--proBtnR);

  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap: 7px;

  font-size: var(--proBtnFont);
  line-height: 1;
  letter-spacing: .7px;
  text-transform: uppercase;
  font-weight: 800;

  color: var(--proTxt);
  border: 1px solid var(--proStrokeA);
  background: linear-gradient(180deg, var(--proBgB), var(--proBgA));
  box-shadow: var(--proShadow);

  position: relative;
  transform: translateZ(0);
  user-select: none;
  cursor: pointer;
  will-change: transform, filter;
}

.app-header .header-actions-row .btn-pro:active{
  transform: translateY(1px);
  filter: brightness(1.05);
}

.app-header .header-actions-row .btn-pro::before{
  content:"";
  position:absolute;
  inset: 1px;
  border-radius: calc(var(--proBtnR) - 1px);
  border: 1px solid var(--proStrokeB);
  pointer-events:none;
}

.app-header .header-actions-row .btn-pro::after{
  content:"";
  position:absolute;
  left: 8px;
  right: 8px;
  top: 6px;
  height: 10px;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(255,255,255,.20), rgba(255,255,255,0));
  opacity: .55;
  pointer-events:none;
}

@media (hover:hover){
  .app-header .header-actions-row .btn-pro:hover{
    filter: brightness(1.10);
  }
}

/* Mini "dot" de acento (sin emojis, iOS safe) */
.app-header .header-actions-row .btn-pro .ico{
  width: 12px;
  height: 12px;
  border-radius: 999px;
  background: rgba(255,255,255,.25);
  box-shadow: 0 0 10px rgba(255,255,255,.10);
  flex: 0 0 auto;
}

/* Acentos por boton */
.app-header .header-actions-row .btn-pro[data-kind="auto"] .ico{ background: var(--proAccentPurple); }
.app-header .header-actions-row .btn-pro[data-kind="vic"] .ico{ background: var(--proAccentRed); }
.app-header .header-actions-row .btn-pro[data-kind="qtabla"] .ico{ background: var(--proAccentCyan); }
.app-header .header-actions-row .btn-pro[data-kind="manual"] .ico{ background: var(--proAccentAmber); }
.app-header .header-actions-row .btn-pro[data-kind="man"] .ico{ background: var(--proAccentGreen); }

/* ON/ACTIVE (respeta clases existentes y aria-pressed si ya se usa) */
.app-header .header-actions-row .btn-pro.active,
.app-header .header-actions-row .btn-pro.on,
.app-header .header-actions-row .btn-pro.is-on,
.app-header .header-actions-row .btn-pro[aria-pressed="true"]{
  border-color: rgba(255,255,255,.20);
  box-shadow: var(--proShadow), var(--proGlow);
}

/* Reduce motion */
@media (prefers-reduced-motion: reduce){
  .app-header .header-actions-row .btn-pro{
    transition: none !important;
  }
}



/* =========================
   PATCH v0.0.2.99
   Fix: raceSubtitle under logo visible
   Cause: HARD OVERRIDES forced logo to 100% height and overflow hidden
   Scope: UI only, no JS changes
========================= */
.top-banner-placeholder{
  display:flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 6px !important;
  height: auto !important;
  min-height: 110px !important;
  padding: 10px 12px 8px 12px !important;
  overflow: visible !important;
}
.top-banner-placeholder .top-banner-logo,
.top-banner-placeholder img.top-banner-logo{
  width: min(438px, 96vw);
  height: auto;
  max-height: 168px;
  aspect-ratio: 438 / 168;
  margin: 0 auto 12px;
  display: block;
  object-fit: contain;
  pointer-events: none;
}

.top-banner-placeholder #raceSubtitle{
  display:block !important;
  height:auto !important;
  min-height: 0 !important;
  line-height: 1.15 !important;
  margin-top: 2px !important;
  padding: 0 !important;
  color: rgba(255,255,255,0.92) !important;
  text-shadow: 0 2px 10px rgba(0,0,0,0.65) !important;
}


/* responsive header-left/right */
@media (max-width: 520px){
  .app-header .header-left, .app-header .header-right { display: none !important; }
}

/* v0.0.2.99 - FIX: evitar recorte de texto en botones del header (Q TABLA / MANUAL) */
.header-actions-row .header-help{
  width: auto !important;
  max-width: none !important;
  min-width: 74px !important;
  padding: 0 16px !important;
  white-space: nowrap !important;
  overflow: visible !important;
  box-sizing: border-box !important;
}


/* v0.3.09 - Header buttons: remove legacy pseudo-element overlays (no ghost, no sheen, no hover movement) */
.header-actions-row .btn-pro::before,
.header-actions-row .btn-pro::after,
.header-actions-row .header-help::before,
.header-actions-row .header-help::after{
  content:none !important;
  display:none !important;
}
.header-actions-row .btn-pro:hover,
.header-actions-row .header-help:hover{
  filter:none !important;
  transform:none !important;
}
</style>
</head>
<body class="skin-pro skin-vicpulse">
<div class="app">
<div aria-hidden="false" class="top-banner-placeholder"><img alt="Vic's Pulse Timing" class="top-banner-logo" src="https://i.ibb.co/wFx8B4mW/logo-vics-PT.gif"/>
</div>
<div class="banner-subtitle-row"><div class="header-title-sub" id="raceSubtitle">Turbo Racing México - x-vic!</div></div>
<header class="app-header live-off">
<div class="header-stack">
<div class="header-title-main" id="raceTitleMain"><span id="raceTitleText">AI Spotter TRM</span></div>
</div>
<div class="header-controls">
<div class="header-actions-row">
<div class="badge-live live-off" id="liveIndicator" title="LIVE / VOZ">
<span class="badge-live-dot"></span>
<span aria-label="Voz OFF" class="badge-voice-dot voice-off" id="voiceStatusDot" title="Voz OFF"></span>
</div>
<div class="header-mode-row" id="raceModeRow"><span class="badge-mode" id="raceModeBadge">MODO -</span></div>
<div class="hdr-break"></div>
<button class="header-help header-auto btn-pro" data-kind="auto" id="autoSkinBtn" title="Auto-skin" type="button"><span class="ico"></span>🤖<span class="lbl" id="autoSkinLbl">AUTO</span></button>
<button class="header-help header-skin btn-pro" data-kind="vic" id="skinBtn" title="Tema: VIC [AUTO]" type="button">VIC</button>
<button class="header-help header-qtable btn-pro" data-kind="qtabla" id="qTableBtn" title="Q TABLA (clasificación)" type="button"><span class="ico"></span>📊</button>
<button class="header-help btn-pro" data-kind="manual" id="manualBtn" title="Manual y ayuda" type="button"><span class="ico"></span>📖</button>
</div>
</div>
<div class="header-version-row">
<div class="header-version" id="appVersion">vics_Smart_Spotter_v0.3.82</div>
<div class="header-version" id="lastUpdateInfo"></div>
</div>
</header>
<!-- Debug strip (solo en modo debug) -->
<div aria-hidden="true" class="debugstrip expert-only" id="debugStrip">
<div class="dbg-item"><span class="dbg-k">AUTO</span> <span class="dbg-v" id="dbgAutoPhase">-</span></div>
<div class="dbg-item"><span class="dbg-k">LAP</span> <span class="dbg-v" id="dbgAutoLap">0</span></div>
<div class="dbg-item"><span class="dbg-k">T</span> <span class="dbg-v" id="dbgAutoT">0</span></div>
<div class="dbg-item"><span class="dbg-k">DUR</span> <span class="dbg-v" id="dbgAutoDur">0</span></div>
<div class="dbg-item"><span class="dbg-k">FINAL</span> <span class="dbg-v" id="dbgAutoFinal">0</span></div>
<div class="dbg-item"><span class="dbg-k">IDLE</span> <span class="dbg-v" id="dbgAutoIdle">0</span></div>
<div class="dbg-item"><span class="dbg-k">TIME</span> <span class="dbg-v" id="dbgAutoTrend">?</span></div>
</div>
<main class="app-main">
<section class="pilot-card">
<div class="pilot-card-top-strip"></div>
<div class="pilot-row-heading">
<div style="width:100%; min-width:0;">
<div class="pilot-label">Piloto seguido</div>
<div class="pilot-name-row">
<div class="pilot-name" id="pilotName">Auto Locutor</div>
<div class="pilot-laps-big" id="pilotMeta">0 v</div>
</div>
</div>
</div>
<div class="pilot-select" style="margin-top:6px;">
<select id="pilotSelect">
<option value="">Sin piloto seleccionado</option>
</select>
</div>
<div class="pilot-select-actions">
<button class="btn-secondary btn-hot btn-voice btn-voice-mini" data-voice-toggle="" id="voiceToggleBtnMini" type="button">
             ACTIVAR VOZ
          </button>
<button class="btn-secondary btn-hot btn-basic-mini" id="basicToggleBtnMini" title="Modo básico: solo vueltas, lap time y posición (AUTO y FOLLOW)" type="button">BÁSICO</button>

<label class="btn-secondary btn-hot saylaps-toggle" id="sayLapsWrap" title="Decir vueltas (prefijo). Solo en FOLLOW y con BÁSICO OFF.">
  <input type="checkbox" id="sayLapsChk" />
  <span>VU</span>
</label>
</div>
<div class="pilot-pos-row">
<div class="pos-pill" id="posText">P -</div>
<div class="pos-info" id="gapInfo">Diferencia líder  vueltas  estado</div>
</div>
<div class="pilot-timings">
<div class="timing-item last-lap">
<div class="timing-label">última</div>
<div class="timing-value" id="lastLap">-:--.---</div>
</div>
<div class="timing-item">
<div class="timing-label">Mejor</div>
<div class="timing-value" id="bestLap">-:--.---</div>
</div>
<!-- Record carrera (mejor vuelta global) -->
<div class="timing-item">
<div class="timing-label">Record carrera</div>
<div class="timing-value" id="bestOverallLap">-:--.---</div>
<div class="timing-meta" id="bestLapHolder" style="font-size:10px; color:var(--text-muted);">-</div>
</div>
<div class="timing-item">
<div class="timing-label">Media</div>
<div class="timing-value" id="meanLap">-:--.---</div>
</div>
<div class="timing-item">
<div class="timing-label">Cons</div>
<div class="timing-value" id="consistencyVal">--%</div>
</div>
<div class="timing-item">
<div class="timing-label">Std Dev</div>
<div class="timing-value" id="sigmaVal">-.---</div>
</div>
<div class="timing-item timer-only" id="mangaClockItem">
<div class="timing-label">Reloj</div>
<div class="timing-value manga-clock" id="mangaClock">0:00.000</div>
</div>
</div>
<div class="lap-chart-wrap">
<div class="lap-chart-header">
<div class="lap-chart-header-row">
<div class="lap-chart-title">Lap chart</div>
<button class="btn-mini" id="top3ToggleBtn" title="Alternar Top 3 / Top 20" type="button">TOP 3</button>
</div>
<div class="lap-chart-meta" id="lapChartMeta">Sin datos</div>
</div>
<div class="lap-chart-canvas-wrap">
<canvas height="180" id="lapChart" width="600"></canvas>
</div>
<div aria-label="Top 3 grid" class="top3-mini-grid" id="top3MiniGrid"></div>
</div>
</section>
<section class="extras-section">
<div class="toggle-row expert-only">
<div class="toggle-label">Mantener pantalla despierta</div>
<div class="toggle-pill active" id="wakeLockToggle">
<div class="toggle-thumb"></div>
</div>
</div>
<div class="wake-status expert-only" id="wakeLockStatus"></div>
<div class="toggle-row expert-only">
<div class="toggle-label">Modo background</div>
<div class="toggle-pill" id="backgroundToggle" title="Si est ON, el spotter sigue leyendo datos aunque la pestaña no estál frente.">
<div class="toggle-thumb"></div>
</div>
</div>
<div class="wake-status expert-only" id="backgroundStatus"></div>
<div class="rate-row" style="margin-top:8px;">
<div class="rate-label">Velocidad voz</div>
<input id="rateRange" max="2.5" min="1.0" step="0.1" type="range" value="1.5"/>
<div class="rate-display" id="rateDisplay">1.5x</div>
</div>
<div class="select-row">
<div class="select-label">Voz</div>
<div style="display:flex;gap:8px;align-items:center;justify-content:flex-end;flex-wrap:wrap;">
<select class="spotter-select" id="voiceSelect" title="Selecciona voz del sistema (depende del dispositivo)"></select>
<button class="btn-secondary btn-hot" id="ttsTestBtn" title="Probar voz" type="button"> Test</button>
</div>
</div>
<div class="grid-button-row">
<button class="btn-grid" id="btnOpenGrid">
             TOP 3
          </button>
</div>
</section>
<section class="controls-section expert-only" id="controlsSection">
<div class="buttons-row">
<button class="btn-secondary btn-hot btn-voice" data-voice-toggle="" id="voiceToggleBtn">
             ACTIVAR VOZ
          </button>
<button class="btn-secondary btn-hot btn-speak expert-only" id="speakBtn">
             Leer resumen
          </button>
<button class="btn-secondary btn-hot btn-rd expert-only" id="rdToggleBtn" title="Prender o apagar el Race Director">
             RD ON
          </button>
</div>
<div aria-label="Configuracin activa" class="config-status-card" id="configStatusCard">
<div class="config-status-top">
<div class="config-status-title"> Configuracin activa</div>
<div class="config-status-badges">
<span class="cfg-pill cfg-pill-session" id="cfgSessionPill">Sesin: -</span>
<span class="cfg-pill cfg-pill-auto" id="cfgPresetPill">Preset: -</span>
<span class="cfg-pill cfg-pill-auto" id="modeBadge">Modo: -</span>
</div>
</div>
<div class="config-status-line">
<span class="cfg-label">RD:</span> <span class="cfg-value" id="cfgRdMode">-</span>
<span class="cfg-sep">|</span>
<span class="cfg-label">Auto Locutor:</span> <span class="cfg-value" id="cfgAutoMode">-</span>
<span class="cfg-sep">|</span>
<span class="cfg-label">Precisin:</span> <span class="cfg-value" id="cfgPrec">-</span>
<span class="cfg-sep">|</span>
<span class="cfg-label">Voces:</span> <span class="cfg-value" id="cfgVoices">ES</span>
</div>
<div class="diag-panel" id="diagPanel">
<div class="diag-header">
<span>Pit wall tecnico</span>
<span class="diag-note" id="diagPanelNote">Esperando telemetria...</span>
</div>
<div class="diag-grid">
<div class="diag-item off" id="diagVoice">
<div class="diag-top"><div class="diag-name"><span class="diag-dot"></span><span>Voz</span></div><div class="diag-state">OFF</div></div>
<div class="diag-text">Sin revisar</div>
</div>
<div class="diag-item off" id="diagUnlock">
<div class="diag-top"><div class="diag-name"><span class="diag-dot"></span><span>Unlock iOS</span></div><div class="diag-state">OFF</div></div>
<div class="diag-text">Sin revisar</div>
</div>
<div class="diag-item off" id="diagFirebase">
<div class="diag-top"><div class="diag-name"><span class="diag-dot"></span><span>Firebase</span></div><div class="diag-state">OFF</div></div>
<div class="diag-text">Sin revisar</div>
</div>
<div class="diag-item off" id="diagRealtime">
<div class="diag-top"><div class="diag-name"><span class="diag-dot"></span><span>Realtime</span></div><div class="diag-state">OFF</div></div>
<div class="diag-text">Sin revisar</div>
</div>
<div class="diag-item off" id="diagPolling">
<div class="diag-top"><div class="diag-name"><span class="diag-dot"></span><span>Polling</span></div><div class="diag-state">OFF</div></div>
<div class="diag-text">Sin revisar</div>
</div>
<div class="diag-item off" id="diagWake">
<div class="diag-top"><div class="diag-name"><span class="diag-dot"></span><span>Wake Lock</span></div><div class="diag-state">OFF</div></div>
<div class="diag-text">Sin revisar</div>
</div>
<div class="diag-item off" id="diagFeed">
<div class="diag-top"><div class="diag-name"><span class="diag-dot"></span><span>Feed</span></div><div class="diag-state">OFF</div></div>
<div class="diag-text">Sin revisar</div>
</div>
<div class="diag-item off" id="diagVisibility">
<div class="diag-top"><div class="diag-name"><span class="diag-dot"></span><span>Vista</span></div><div class="diag-state">OFF</div></div>
<div class="diag-text">Sin revisar</div>
</div>
</div>
<div class="diag-error" id="diagErrorBox"></div>
<div class="diag-subpanel" id="ttsDiagPanel">
<div class="diag-subhead">
<span>Motor de voz en vivo</span>
<span class="diag-subnote" id="ttsDiagNote">Sin eventos todavia</span>
</div>
<div class="ttslog-list" id="ttsEventList">
<div class="ttslog-empty">Esperando eventos TTS...</div>
</div>
</div>
</div>
<div class="runtime-profiles expert-only" id="runtimeProfilesPanel">
<div class="runtime-profiles-header">
<div class="runtime-profiles-title"> Perfiles runtime</div>
<div class="runtime-profiles-note" id="runtimeProfileNote">Auto</div>
</div>
<div class="runtime-profile-grid" role="group" aria-label="Perfiles runtime">
<button class="runtime-profile-card" data-runtime-profile="AUTO" id="runtimeProfileAuto" type="button">
<div class="rpc-head"><span class="rpc-name">Auto</span><span class="rpc-tag">AUTO</span></div>
<div class="rpc-sub">Se adapta segun iPhone, Android o desktop.</div>
<div class="rpc-specs"><span class="rpc-pill">smart</span><span class="rpc-pill">seguro</span></div>
</button>
<button class="runtime-profile-card" data-runtime-profile="EVENTO" id="runtimeProfileEvento" type="button">
<div class="rpc-head"><span class="rpc-name">Evento</span><span class="rpc-tag">PRO</span></div>
<div class="rpc-sub">Mas insistente para pista y narracion continua.</div>
<div class="rpc-specs"><span class="rpc-pill">rapido</span><span class="rpc-pill">mas consumo</span></div>
</button>
<button class="runtime-profile-card" data-runtime-profile="AHORRO" id="runtimeProfileAhorro" type="button">
<div class="rpc-head"><span class="rpc-name">Ahorro</span><span class="rpc-tag">ECO</span></div>
<div class="rpc-sub">Baja timers y polling para descansar bateria.</div>
<div class="rpc-specs"><span class="rpc-pill">eco</span><span class="rpc-pill">suave</span></div>
</button>
<button class="runtime-profile-card" data-runtime-profile="IPHONE" id="runtimeProfileIphone" type="button">
<div class="rpc-head"><span class="rpc-name">iPhone</span><span class="rpc-tag">iOS</span></div>
<div class="rpc-sub">Mas prudente con background y recovery en Safari.</div>
<div class="rpc-specs"><span class="rpc-pill">tap-safe</span><span class="rpc-pill">Safari</span></div>
</button>
</div>
</div>
<div class="session-presets expert-only" id="sessionPresetsPanel">
<div class="session-presets-header">
<div class="session-presets-title"> Presets por sesin</div>
<div class="session-presets-note" id="sessionPresetNote">Auto: ON</div>
</div>
<div aria-label="Presets por sesin" class="session-preset-grid" role="group">
<button class="session-preset-card" data-session="TRAIN" id="presetCardTrain" type="button">
<div class="spc-head">
<span class="spc-name">Entrenamiento</span>
<span class="spc-tag">TRAIN</span>
</div>
<div class="spc-sub" id="presetTrainMeta">-</div>
<div class="spc-toggles" id="presetTrainToggles"></div>
</button>
<button class="session-preset-card" data-session="MANGA" id="presetCardManga" type="button">
<div class="spc-head">
<span class="spc-name">Manga</span>
<span class="spc-tag">MANGA</span>
</div>
<div class="spc-sub" id="presetMangaMeta">-</div>
<div class="spc-toggles" id="presetMangaToggles"></div>
</button>
<button class="session-preset-card" data-session="FINAL" id="presetCardFinal" type="button">
<div class="spc-head">
<span class="spc-name">Final</span>
<span class="spc-tag">FINAL</span>
</div>
<div class="spc-sub" id="presetFinalMeta">-</div>
<div class="spc-toggles" id="presetFinalToggles"></div>
</button>
</div>
<div class="session-now" id="sessionNowRow">
<div class="session-now-title">Ahora (lo que est prendido en voz)</div>
<div class="session-now-toggles" id="sessionNowToggles"></div>
</div>
</div>
</div>
<div aria-label="Modo del Race Director" class="rd-mode-row expert-only" role="group">
<button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeMinimal" title="Pro Minimal">A Minimal</button>
<button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeStratega" title="Pro Estratega">B Estratega</button>
<button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeCoach" title="Pro Coach">C Coach</button>
<button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeSarca" title="Sarcstico">D Sarcstico</button>
<button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeEngineer" title="Ingeniero">E Ingeniero</button>
<button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeHype" title="Hype">F Hype</button>
</div>
<div class="controls-label expert-only"> Auto Locutor (sin piloto)</div>
<div aria-label="Modo del Auto Locutor" class="rd-mode-row expert-only" role="group">
<button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorPro" title="Locutor PRO serio">PRO</button>
<button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorPicante" title="Picante light">Picante</button>
<button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorEngineer" title="Ingeniero de carrera">Ingeniero</button>
<button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorNarrativo" title="Narracin con hilo y contexto">Narrativo</button>
</div>
<div class="precision-row expert-only">
<div class="controls-label">Precisin de lectura del tiempo</div>
<div class="precision-buttons">
<div class="precision-badge active" data-precision="1">1 dcima</div>
<div class="precision-badge" data-precision="2">2 dcimas</div>
<div class="precision-badge" data-precision="3">3 dcimas</div>
</div>
<select class="spotter-select" id="precisionSelect" style="display:none">
<option selected="" value="1">1 dcima</option>
<option value="2">2 dcimas</option>
<option value="3">3 dcimas</option>
</select>
</div>
</section>
<section class="spotter-section expert-only" id="advancedMessagesPanel">
<div class="controls-label" style="margin-bottom:2px;">Mensajes del spotter</div>
<div class="spotter-master">
<button class="spotter-master-btn preset" id="presetRdProBtn" title="Preset: RD PRO limpio (habla lo importante, sin spam)" type="button">RD PRO</button>
<button class="spotter-master-btn preset" id="presetRdShowBtn" title="Preset: RD SHOW (ms emocin, ms narrativa)" type="button">RD SHOW</button>
<button class="spotter-master-btn" id="toggleAllMsgsBtn" title="Prender o apagar todos los mensajes (excepto Laps)" type="button">TODO</button>
</div>
<div class="spotter-cat" data-cat="essential">
<div class="spotter-cat-head"><span class="cat-dot"></span>Esenciales</div>
<div class="spotter-grid">
<div class="spotter-btn active lock" data-flag="laps"><span></span>Laps</div>
<div class="spotter-btn" data-flag="saylaps" title="Decir o no decir la palabra vueltas al leer Laps"><span></span>Vueltas</div>
<div class="spotter-btn active" data-flag="blueflag" title="Azul: avisa lapeos/trafico (bandera azul)"><span></span>Azul</div>
<div class="spotter-btn active" data-flag="ritmo" title="Ritmo: avisa si vienes mejorando o si te caes (comparado con tu promedio reciente)"><span></span>Ritmo +/-</div>
<div class="spotter-btn" data-flag="estlap" title="Est: tiempo estimado al final (si el feed lo trae)"><span></span>Est</div>
<div class="spotter-btn" data-flag="leadergap" title="Lider: gap al líder, cambios de líder y contexto de punta"><span></span>Lider</div>
<div class="spotter-btn" data-flag="podium" title="Podio: llamadas enfocadas al Top 3 (en Finales, suele ser lo mas caliente)"><span></span>Podio</div>
</div>
</div>
<div class="spotter-cat" data-cat="battle">
<div class="spotter-cat-head"><span class="cat-dot"></span>Batalla</div>
<div class="spotter-grid">
<div class="spotter-btn" data-flag="pos" title="Pos: cambios de posicion (ganas/pierdes), y pases importantes en Auto"><span></span>Pos</div>
<div class="spotter-btn" data-flag="gaps" title="Diferencia: gap con el de adelante y con el de atras (segundos o vueltas)"><span></span>Gap</div>
<div class="spotter-btn" data-flag="front06" title="Adel &lt;0.6: tienes a alguien adelante a menos de 0.6s (huele a pase)"><span></span>Adel &lt;0.6</div>
<div class="spotter-btn" data-flag="back06" title="Atras &lt;0.6: te vienen atacando a menos de 0.6s (defiende)"><span></span>Atras &lt;0.6</div>
<div class="spotter-btn" data-flag="attack" title="Ataque: narrativa cuando tu gap al de adelante cae y estas para intentarlo"><span></span>Ataque</div>
<div class="spotter-btn" data-flag="defense" title="Defensa: narrativa cuando te vienen recortando y toca aguantar"><span></span>Defensa</div>
</div>
</div>
<div class="spotter-cat" data-cat="summary">
<div class="spotter-cat-head"><span class="cat-dot"></span>Resumen</div>
<div class="spotter-grid">
<div class="spotter-btn" data-flag="total"><span></span>Total</div>
<div class="spotter-btn" data-flag="cons10"><span></span>Cons 10</div>
<div class="spotter-btn" data-flag="bestlap"><span></span>Best</div>
<div class="spotter-btn" data-flag="box"><span></span>Box</div>
<div class="spotter-btn" data-flag="pelea"><span></span>Pelea</div>
<div class="spotter-btn" data-flag="netgain"><span></span>NetGain</div>
</div>
</div>
<div style="display:none;">
<input checked="" id="chkLapBasic" type="checkbox"/>
<input id="chkPosChanges" type="checkbox"/>
<input id="chkExtraInfo" type="checkbox"/>
<input id="chkBehindAlert" type="checkbox"/>
<input id="chkTotalTime" type="checkbox"/>
<input checked="" id="chkBlueFlag" type="checkbox"/>
<input id="chkConsistency10" type="checkbox"/>
<input id="chkEstLap" type="checkbox"/>
<input id="chkBestLap" type="checkbox"/>
<input checked="" id="chkPaceTrend" type="checkbox"/>
<input id="chkAheadAlert" type="checkbox"/>
<input id="chkAutoSummary" type="checkbox"/>
</div>
</section>
</main>
</div>
<!-- Manual modal -->
<div aria-hidden="true" class="manual-backdrop" id="manualBackdrop">
<div aria-labelledby="manualTitle" aria-modal="true" class="manual-panel" role="dialog">
<div class="manual-top">
<div>
<div class="manual-title" id="manualTitle">Manual - Vic's Smart Spotter</div>
<div class="manual-sub">Guía rápida (v0.3.60). Activa voz, elige piloto y corre. El resto es opcional.</div>
</div>
<button aria-label="Cerrar" class="manual-close" id="manualCloseBtn" type="button">✕</button>
</div>
<div aria-label="Secciones del manual" class="manual-tabs" role="tablist">
<button aria-selected="true" class="manual-tab active" data-tab="inicio" role="tab" type="button">Inicio</button>
<button aria-selected="false" class="manual-tab" data-tab="botones" role="tab" type="button">Botones</button>
<button aria-selected="false" class="manual-tab" data-tab="voz" role="tab" type="button">Voz</button>
<button aria-selected="false" class="manual-tab" data-tab="qtabla" role="tab" type="button">Q Tabla</button>
<button aria-selected="false" class="manual-tab" data-tab="basico" role="tab" type="button">Básico</button>
<button aria-selected="false" class="manual-tab" data-tab="problemas" role="tab" type="button">Problemas</button>
</div>
<div class="manual-sections">
<div class="manual-section active" data-tab="inicio">
<h3>Arranque en 60 segundos</h3>
<div class="manual-card">
<ol style="margin:0; padding-left: 18px;">
<li>Abre el Spotter y espera 2-3 segundos a que llegue el primer dato.</li>
<li><b>PC/Mac</b>: la voz suele quedar en ON sola. Si el punto VOZ está rojo, toca <b>ACTIVAR VOZ</b>. <b>iPhone/Android</b>: toca <b>ACTIVAR VOZ</b> una vez para destrabar.</li>
<li>Si quieres seguimiento, <b>selecciona tu piloto</b>.</li>
<li>Si quieres menos ruido, en <b>FOLLOW</b> enciende <b>BÁSICO</b> (en <b>AUTO</b> queda apagado y bloqueado).</li>
<li>En clasificación, usa <b>Q TABLA</b> (botón 📊) para ver la tabla.</li>
</ol>
<div class="manual-note">El piloto seleccionado se guarda en tu navegador. Si recargas y el nombre existe, se auto-selecciona.</div>
</div>
<h3>Dos formas de usarlo</h3>
<div class="manual-card">
<b>Auto</b>: narra lo general (carrera nueva, cambios, avisos, peleas).<br/>
<b>Seguimiento</b>: se enfoca en tu piloto (posición, gaps, alertas).<br/><br/>
<div class="manual-tip">Regla simple: si seleccionas piloto, el spotter debe hablar menos y más directo.</div>
</div>
<h3>Reglas de oro</h3>
<div class="manual-card">
<ul style="margin:0; padding-left: 18px;">
<li>Una sola pestaña del Spotter. Dos pestañas = dos locutores peleando el micrófono.</li>
<li>Si estás en iPhone, no bloquees pantalla al inicio (primero activa la voz).</li>
<li>Si todo viene en ceros al arrancar, es normal: espera 1-2 vueltas reales.</li>
</ul>
</div>
</div>
<div class="manual-section" data-tab="botones">
<h3>Header: lo que sí se toca</h3>
<div class="manual-card">
<ul style="margin:0; padding-left: 18px;">
<li><b>🤖 AUTO</b> - modo automático (decide anuncios y ritmo de mensajes).</li>
<li><b>VIC</b> - cambia el skin/tema visual a Vic.</li>
<li><b>📊</b> - Q TABLA (clasificación guardada).</li>
<li><b>📖</b> - abre/cierra este manual.</li>
</ul>
<div class="manual-note">El punto LIVE (verde/gris) dice si el feed está vivo. El punto VOZ (verde/rojo) te dice si la voz está OK u OFF. El badge MODO muestra la sesión detectada.</div>
</div>
<h3>Controles principales</h3>
<div class="manual-card">
<ul style="margin:0; padding-left: 18px;">
<li><b>ACTIVAR VOZ</b> - desbloquea audio del navegador.</li>
<li><b>BÁSICO</b> - reduce mensajes (modo concentración).</li>
<li><b>Selector de piloto</b> - activa seguimiento.</li>
</ul>
<div class="manual-tip">Si algo se siente atorado, refresco controlado. Mejor eso que discutir con la app en plena final.</div>
</div>
</div>
<div class="manual-section" data-tab="voz">
<h3>Voz en iPhone (Safari/Chrome iOS)</h3>
<div class="manual-card">
          iOS solo permite audio si hay un gesto del usuario. Por eso existe <b>ACTIVAR VOZ</b>.
          <ol style="margin:8px 0 0; padding-left: 18px;">
<li>Sube volumen y quita Silencio.</li>
<li>Toca <b>ACTIVAR VOZ</b> una vez con la pantalla despierta.</li>
<li>Luego selecciona piloto (si aplica).</li>
<li>No bloquees pantalla justo al arrancar.</li>
</ol>
<div class="manual-note">Si estás con Bluetooth, revisa que el audio no esté saliendo por otro dispositivo. El punto VOZ junto al LIVE: verde = OK, rojo = OFF (o requiere toque).</div>
</div>
<h3>Voz en PC (Chrome/Brave/Edge)</h3>
<div class="manual-card">
<ul style="margin:0; padding-left: 18px;">
<li>Permite audio del sitio (candado del navegador).</li>
<li>Evita suspensión del sistema durante evento.</li>
<li>Si usas OBS, mejor cargar como Browser Source.</li>
</ul>
</div>
<h3>Segundo plano (background)</h3>
<div class="manual-card">
          En web puedes mantener actividad, pero si el sistema entra en suspensión, nadie salva eso.
          <ul style="margin:8px 0 0; padding-left: 18px;">
<li>Para evento: desactiva sleep y deja la pestaña viva.</li>
<li>Si sales y vuelves, dale 1 segundo para retomar.</li>
</ul>
</div>
</div>
<div class="manual-section" data-tab="qtabla">
<h3>Qué es Q TABLA</h3>
<p style="margin-top:8px; color: var(--text-muted);">
          Nota: el <b>Best Lap</b> que ves en Q TABLA viene directo del feed (por piloto, <code>bestMs</code>/<code>bestLapMs</code>). No se calcula.
        </p>
<div class="manual-card">
          Q TABLA es tu "race control" para <b>clasificación</b>. Guarda y muestra resultados por sesión (Q).
          <ul style="margin:8px 0 0; padding-left: 18px;">
<li><b>Vista: Mejor por piloto</b> - toma el mejor resultado guardado de cada piloto.</li>
<li><b>Vista: Por Q</b> - te deja revisar cada Q guardada (Q1, Q2, etc).</li>
</ul>
<div class="manual-note">Los chips de arriba muestran Evento, Fecha y cuántas sesiones guardó.</div>
</div>
<h3>Cuándo se guarda</h3>
<div class="manual-card">
          Se guarda cuando hay datos reales (vueltas o tiempos válidos). Se guarda en tu navegador (localStorage).
          <ul style="margin:8px 0 0; padding-left: 18px;">
<li>Si borras datos del sitio o usas incógnito, arrancas con Q TABLA limpia.</li>
<li>Si está vacía, es porque aún no llegó info válida.</li>
</ul>
</div>
<h3>Lectura rápida</h3>
<div class="manual-card">
<ul style="margin:0; padding-left: 18px;">
<li><b>Pos</b>: posición en clasificación.</li>
<li><b>Best</b>: mejor vuelta del piloto.</li>
<li><b>Gap</b>: diferencia contra el líder.</li>
</ul>
<div class="manual-tip">Si estás buscando "quién trae ritmo", mira Best y Gap. Lo demás es chisme, pero útil.</div>
</div>
</div>
<div class="manual-section" data-tab="basico">
<h3>Modo BÁSICO</h3>
<div class="manual-card">
          BÁSICO es para correr con casco puesto: menos choro, más vueltas.
          <ul style="margin:8px 0 0; padding-left: 18px;">
<li>En <b>AUTO</b>: solo P1 (vueltas + última vuelta). Si cambia el líder, lo dice.</li>
<li>En <b>FOLLOW</b>: solo tu piloto (vueltas + última vuelta + posición estable).</li>
<li>Sin peleas, sin gaps, sin azul, sin resúmenes largos.</li>
</ul>
<div class="manual-tip">Si quieres el show completo, apaga BÁSICO y deja que hable.</div>
</div>
</div>
<div class="manual-section" data-tab="problemas">
<h3>Soluciones rápidas</h3>
<div class="manual-card">
<ol style="margin:0; padding-left: 18px;">
<li><b>No habla</b> - toca ACTIVAR VOZ. En iPhone, toca con la pantalla despierta.</li>
<li><b>Habla raro o en loop</b> - refresca una vez. Si tienes dos pestañas abiertas, cierra una.</li>
<li><b>Q TABLA sin datos</b> - espera 1-2 vueltas reales o revisa que el feed esté vivo.</li>
<li><b>Se calla al volver del background</b> - dale 1 segundo. Si no regresa: refresco controlado.</li>
</ol>
<div class="manual-note">Consejo de veterano: lo importante es que hable cuando lo necesitas, no que platique bonito.</div>
</div>
<h3>Buenas prácticas</h3>
<div class="manual-card">
<ul style="margin:0; padding-left: 18px;">
<li>Antes de arrancar: piloto seleccionado + voz activa.</li>
<li>Prueba Q TABLA en clasificación para confirmar que guardó sesiones.</li>
<li>Si vas a grabar: haz una prueba de carrera nueva para confirmar anuncios.</li>
</ul>
</div>
</div>
</div>
<div class="manual-foot">
<span class="manual-tip">Meta: 0 fricción. Un toque para voz y listo. El resto es ventaja competitiva.</span>
</div>
</div>
</div>
<!-- Q TABLA modal -->
<div aria-hidden="true" class="manual-backdrop" id="qualiBackdrop">
<div aria-labelledby="qualiTitle" aria-modal="true" class="manual-panel" role="dialog">
<div class="manual-top">
<div>
<div class="manual-title" id="qualiTitle">Q TABLA</div>
<div class="manual-sub">Clasificación guardada por sesión (Q). Mejor por piloto o vista por Q.</div>
</div>
<button aria-label="Cerrar" class="manual-close" id="qualiCloseBtn" type="button">✕</button>
</div>
<div class="qmeta" id="qualiMeta">
<span class="qchip" id="qualiMetaEvent">Evento: -</span>
<span class="qchip" id="qualiMetaDate">Fecha: -</span>
<span class="qchip" id="qualiMetaSessions">Sesiones: -</span>
<label class="qsel" style="margin-left:auto;">
        Vista:
        <select id="qualiViewSel">
<option value="best">Mejor por piloto</option>
<option value="byq">Por Q</option>
</select>
</label>
</div>
<div class="qtable-wrap">
<table aria-label="Tabla de clasificación" class="qtable">
<thead id="qualiThead"></thead>
<tbody id="qualiTbody">
<tr><td class="qcell-empty" colspan="6">Sin datos aún</td></tr>
</tbody>
</table>
</div>
<div class="manual-foot">
<span class="manual-tip">Tip: si apenas arrancó la carrera y todo viene en ceros, espera 1-2 vueltas.</span>
</div>
</div>
</div>
<script id="appScript">


// ============================================================
// CONSOLIDATED JS (v0.3.05)
// - All inline scripts merged in source order.
// - Wrapped with init guard to avoid double-binding listeners.
// ============================================================

if (window.__AI_SPOTTER_TRM_INIT__) {
  console.warn('AI Spotter TRM: init already ran - skipping');
} else {
  window.__AI_SPOTTER_TRM_INIT__ = true;

/*
====================================================================
DOCUMENTACION TECNICA - AI Spotter TRM (v0.0.0.29)
====================================================================

Objetivo
- Spotter con UI simple y decisiones automaticas.
- 2 comportamientos principales:
  1) Seguimiento (Follow): hay piloto seleccionado.
  2) Auto Locutor (Auto): NO hay piloto seleccionado.

Principios de diseno
- El usuario no debe "configurar un avion". El spotter decide.
- Todo anuncio pasa por el motor de VOZ (cola + dedupe + prioridades).
- La tabla y el header siempre se alimentan del mismo raceData normalizado.

--------------------------------------------------------------------
0) Glosario rapido
- raceData: uúltimo snapshot de carrera (documento del feed) ya normalizado.
- classification: arreglo de pilotos (pos, nombre, lapcount, time, best, mean, gap/diff, etc).
- currentSessionInfo: tipo de sesion detectado desde raceName (MANGA / FINAL A / FINAL B+).
- selectedPilotKey: piloto elegido por el usuario. Si existe => modo Seguimiento.
- BASIC (Seguimiento): modo minimalista (solo last lap + posicion).
- speechQueue: cola de mensajes TTS. Se drena con pumpSpeechQueue().
- speechLog: bitacora de lo hablado (solo visible con ?debug=1).

--------------------------------------------------------------------
1) Flujo general de datos (pipeline)
1.1 Entrada
- Fuente: Firebase (Firestore) o feed equivalente.
- initFirebaseRuntime() carga SDK y crea listener/poll.
- Al recibir snapshot, se arma raceData y se llama a normalizacion.

1.2 Normalizacion (critico para que todo funcione)
- Se fuerza pos como numero.
- Se ordena classification por pos.
- Se calculan campos derivados (intervalos, laps, tiempo total en ms, etc).
- Resultado: raceData coherente. Si P1 esta mal, TODO se rompe (azul, top3, peleas).

1.3 Render UI
- updateHeaderFromRace(): titulo, modo, estado de feed.
- renderClassificationTable(): tabla principal.
- updateMangaClockDisplay(): reloj (en MANGA muestra "time" real del feed del piloto seleccionado).

1.4 Motor de voz (TTS)
- say(text, opts): entrada unica a voz.
- sanitizeTtsText(): limpia texto para evitar "undefined", dobles espacios, etc.
- enqueue + dedupe: evita repetir frases, y corta mensajes viejos si ya son obsoletos.
- unlockTTSOnce(): desbloqueo iOS (requiere gesto real).

--------------------------------------------------------------------
2) Modos: Seguimiento vs Auto Locutor

2.1 Seguimiento (hay piloto seleccionado)
Objetivo
- Narracion centrada en 1 piloto.
- En BASIC: solo "last lap" + "posicion" (y cambios de posicion).

Reglas
- selectedPilotKey existe => applySmartProfile(FOLLOW).
- Si BASIC esta ON:
  - Se apagan anuncios de pelea/gaps/azul/etc.
  - Se anuncian solo eventos minimos (last lap + posicion).

Eventos tipicos que dispara
- Cruce por meta del piloto: last lap.
- Cambio de posicion (estable, sin jitter): "P3" por ejemplo.
- (No BASIC) avisos: ataque/defensa, gaps por rango, bandera azul si aplica.

2.2 Auto Locutor (NO hay piloto seleccionado)
Objetivo
- Narrar la carrera completa, con enfasis en eventos importantes.
- Sin hablar antes de tiempo (silencio inteligente).

Ciclo de vida (state machine)
- IDLE: sin carrera valida.
- WAIT_START: llega raceName nuevo => anuncia titulo y espera arranque real.
- RUNNING: narracion activa (top3, cambios, cierres fuertes, azul).
- CLOSING: en finales, cuando se alcanza duracion objetivo => "finalizo" por piloto.
- FINISHED: silencio hasta que llegue nueva carrera (raceName cambia).

Deteccion de arranque
- No basta con "time". Se valida movimiento real:
  - lapcount > 0, o lastLapMs > 0, o bestLapMs > 0, o totalMs avanza de forma coherente.
- Evita hablar cuando el feed manda un "time" objetivo antes de arrancar.

--------------------------------------------------------------------
3) Bandera azul (blue flag)
Donde aplica
- Seguimiento (si no es BASIC) y Auto Locutor.

Deteccion
- Principal: diferencia de vueltas (lapDiff >= 1) o diff tipo "+1 V".
- Anti spam:
  - cooldown global y cooldown por piloto.
  - en Auto Locutor se puede repetir cada N vueltas del líder.

Fraseo
- Se usa "bandera azul" + nombre del piloto a ceder paso.
- (Se puede ajustar estilo: mandon vs fino).

--------------------------------------------------------------------
4) Lectura de gaps por rangos (narracion humana)
- Menor a 1 segundo: se habla en decimas con frases por rango ("a menos de tres decimas", "a medio segundo", etc).
- Mayor a 1 segundo: buckets a 0.5s y decide "a", "a menos de", "a mas de".
- 10+ segundos: simplifica para no aburrir.

Funcion clave
- gapToSpeech(sec): convierte segundos a frase (NO lee numeros crudos).

--------------------------------------------------------------------
5) Debug y soporte
- ?debug=1 habilita speechLog (uúúltimos mensajes hablados) para diagnostico.
- updateConfigStatusUI(): muestra estado Firebase/Feed y heartbeat.

--------------------------------------------------------------------
6) Inventario de funciones (por modulos)
Nota
- Abajo esta la lista completa de funciones detectadas. Esta pensada como indice rapido.
- Para cambios, ubica el modulo y entra por la funcion "publica" (update/render/say/auto).

BOOTSTRAP_IO (8)
  - ensureAudioCtx, ensureCanvasHiDpi, ensureFirebaseSdk, ensureMangaClockTicker, ensurePilotOptionExists, initFirebaseRuntime
  - loadRaceFromFirebase, loadVoiceSettings

PERSISTENCIA (8)
  - getCookie, lsGet, lsRemove, lsSet, prefGet, prefKey
  - prefSet, setCookie

TIEMPOS_FORMATO (6)
  - fmt, msToMinSec, parseDiff, parseInterval, parseSessionFromRaceName, parseTimeToMs

ANALITICA (4)
  - computeBattleTag, computeSessionBestMs, getTop3Rows, getTopRows

UI_RENDER (5)
  - renderAutoLapChartTop3, renderAutoTop3MiniGrid, renderPilotCard, renderPresetCards, renderSpeechLog

UI_UPDATE (14)
  - updateAutoCommentatorButtons, updateBlueFlagFromPassEvents, updateConfigStatusUI, updateHeaderFromRace, updateLapHistoryAll, updateLapRangeFromHistory
  - updateMangaClockDisplay, updateMangaPilotStartsFromClassification, updatePilotOptions, updateRdButton, updateRdModeButtons, updateRecordCarreraUI
  - updateSessionInfo, updateToggleAllMsgsBtn

VOZ_TTS (4)
  - enqueueSpeech, pumpSpeechQueue, say, unlockTTSOnce

AUTO_LOCUTOR (10)
  - __autoAnnounceFinishers, __autoBlueFlagCheck, __autoGetDurMs, __autoIsStarted, __autoNowMs, __autoParseLapDiff
  - __autoResetLifecycle, __autoSafeName, __autoScanProgress, __autoUpdateLifecycle

INTERNAL (5)
  - __buildParticipantsList, __maybeAnnounceAutoIntro, __modeBucket, __sessionBucket, __wlTry

UTILS (4)
  - clamp01, clampNum, htmlEsc, safeRacerName

OTROS (146)
  - _applyBasicOverride, _getVoiceToggleMap, _isAndroidRate, _isIOSWebKitRate, _pillHtml, _toggleMiniGrid
  - _unlock, _updateBasicBtnUI, addCand, announcePositionBrief, applyDecimalPrecision, applyMiniGridExpandedUI
  - applyPilotSelectPosTheme, applyPresetVoiceSettings, applySessionPreset, applySessionPresetFull, applySmartProfile, applyVoiceSettingsToButtons
  - autoBuildMessage, autoBuildStoryCandidate, autoCanSpeak, autoDecorate, autoFmtSec, autoFocusMsg
  - autoGapTextFromLapDiff, autoMarkPairMention, autoMarkSig, autoPairKey, autoPruneWindow, autoRaceProgress
  - autoRandPick, autoRememberPair, autoShuffleInPlace, autoSigOk, autoStageFromSec, bindSessionPresetCards
  - buildGapSummaryForPilotIndex, buildSessionFinishMessage, checkAheadAlertForPilotIndex, checkBehindAlertForPilotIndex, checkSessionFinishOnLap, classifyLapColor
  - clearWd, closeManual, consistencyPercent, detectDefaultTtsRate, diffTexto, drawDot
  - drawLabel, drawLapChartForKey, drawLapChartTop3Auto, fill, findFastestStint, findPilotIndexByKey
  - findWorstLap, flashLastLap, flashMangaClock, flashPilotCardGreen, floorTo, formatAnnouncer
  - formatClockMs, formatLaps3, formatoGapVueltas, gapDeltaSpeech, gapHalfLabel, gapLargeSpeech
  - gapNumWord, gapSmallSpeech, gapToSpeech, gapToSpeechBare, getAutoLapChartKey, getBestMsForRow
  - getConsistencyFromFirebase, getFrontBackContext, getPilotKey, getRowTotalMs, groupOf, handleAutoCommentator
  - handlePositionChangeNoLap, handleVoiceAndBeeps, handler, isAllMsgsOn, isIOSWebKit, isLapPlausible
  - lapDiffGuardAllow, maybeAutoApplySessionPreset, near2, nextAutoVoiceURI, normalizeIncomingLapValue, normalizeLapMs
  - normalizeRaceData, normalizeTtsText, numeroATexto0a999, onPilotSelectedManga, openManual, pick
  - pickDefaultVoice, playBeep, prosodyFromMood, pushCand, pushLap, rdBuildCtx
  - rdExtractPos, rdMakeMangaBattleText, rdMakeText, rdPick, rdSafeName, rdSec
  - rdShuffleInPlace, rdTrimWords, refreshSessionBestCache, refreshVoiceList, releaseWakeLock, requestWakeLock
  - resetAutoCommentatorState, resetAutoNarratorState, resetSelectedPilotTrackingState, roundRect, saveVoiceSettings, scheduleOneTapUnlock
  - selectPilotByKey, setActive, setAutoCommentatorMode, setBackgroundStatus, setLapClass, setLastLapMark
  - setLastUpdateNow, setLiveStatus, setMangaClockColorByRemaining, setMangaClockVisible, setPresetBtnActive, setRaceDirectorMode
  - setVoiceMaster, shortChipName, speakText, speakWithLaps, statsFromTimes, stopMangaClock
  - syncPrecisionBadges, tiempoATexto, toFixedFloor, tooSoonId, tooSoonTxt, ttlById
  - ttlByTxt, wordToNum

====================================================================
FIN DOCUMENTACION
====================================================================
*/

    // =========================
    // VERSION
    // =========================
const APP_NAME = "vics_Smart_Spotter_v0.3.82";
    const APP_LABEL = APP_NAME;

    const RUNTIME_PROFILES = {
      AUTO: { label:'Auto', diagMs:1000, watchdogMs:2500, watchdogStaleMs:6000, fallback:[1000,2000,5000,10000], safetyMs:3000, heartbeatMs:30000, frontKeepAliveMs:3000 },
      EVENTO: { label:'Evento', diagMs:900, watchdogMs:2200, watchdogStaleMs:5500, fallback:[1000,2000,4000,8000], safetyMs:2500, heartbeatMs:25000, frontKeepAliveMs:2600 },
      AHORRO: { label:'Ahorro', diagMs:1800, watchdogMs:4000, watchdogStaleMs:9000, fallback:[2500,5000,10000,15000], safetyMs:4500, heartbeatMs:45000, frontKeepAliveMs:4500 },
      IPHONE: { label:'iPhone', diagMs:1200, watchdogMs:3200, watchdogStaleMs:7500, fallback:[1500,3000,6000,12000], safetyMs:3800, heartbeatMs:0, frontKeepAliveMs:3600 }
    };
    let runtimeProfileKey = 'AUTO';
    let __diagUiTimer = 0;
    let __watchdogTimer = 0;
    let __diagUiIntervalMs = 1000;
    let __watchdogIntervalMs = 2500;
    let __watchdogStaleMs = 6000;
    let __ttsSafetyIntervalMs = 3000;
    let __ttsHeartbeatIntervalMs = 30000;
    let __ttsFrontKeepAliveIntervalMs = 3000;
    let __lastFallbackReason = '';
    const __ttsEventLog = [];
    const __TTS_EVENT_LIMIT = 12;

    function __resolveRuntimeProfileKey(key){
      const k = String(key || runtimeProfileKey || 'AUTO').toUpperCase();
      if (k !== 'AUTO') return (RUNTIME_PROFILES[k] ? k : 'AUTO');
      try {
        if (typeof isIOSWebKit === 'function' && isIOSWebKit()) return 'IPHONE';
      } catch(e) {}
      try {
        if (typeof isMobileDevice === 'function' && isMobileDevice()) return 'EVENTO';
      } catch(e) {}
      return 'EVENTO';
    }

    function __getRuntimeProfileConfig(key){
      const resolved = __resolveRuntimeProfileKey(key);
      return Object.assign({ key: resolved }, RUNTIME_PROFILES[resolved] || RUNTIME_PROFILES.EVENTO);
    }

    function pushTtsEvent(type, detail = '', meta = ''){
      try{
        const item = {
          t: Date.now(),
          type: String(type || 'info').trim() || 'info',
          detail: String(detail || '').replace(/\s+/g,' ').trim(),
          meta: String(meta || '').replace(/\s+/g,' ').trim()
        };
        __ttsEventLog.push(item);
        while (__ttsEventLog.length > __TTS_EVENT_LIMIT) __ttsEventLog.shift();
        if (/error|fail|unlock/i.test(item.type)) {
          try { __lastReadErr = __lastReadErr || ''; } catch(e) {}
        }
        try { renderTtsEventLog(); } catch(e) {}
      }catch(e){}
    }

    function renderTtsEventLog(){
      try{
        if (!ttsEventList) return;
        const list = __ttsEventLog.slice(-6).reverse();
        if (!list.length){
          ttsEventList.innerHTML = '<div class="ttslog-empty">Esperando eventos TTS...</div>';
          if (ttsDiagNote) ttsDiagNote.textContent = 'Sin eventos todavia';
          return;
        }
        const fmt = (t) => { const d = new Date(t); return String(d.getMinutes()).padStart(2,'0') + ':' + String(d.getSeconds()).padStart(2,'0'); };
        ttsEventList.innerHTML = list.map(it => {
          const ty = String(it.type || 'info').replace(/[<>]/g,'');
          const meta = String(it.meta || '').replace(/[<>]/g,'');
          const detail = String(it.detail || '').replace(/[<>]/g,'');
          return '<div class="ttslog-item">'
            + '<div class="ttslog-meta"><span class="ttslog-type">' + ty + (meta ? ' - ' + meta : '') + '</span><span class="ttslog-time">' + fmt(it.t) + '</span></div>'
            + '<div class="ttslog-text">' + (detail || '-') + '</div>'
            + '</div>';
        }).join('');
        const last = list[0];
        if (ttsDiagNote) ttsDiagNote.textContent = String(last.type || 'info').toUpperCase() + (last.meta ? ' - ' + last.meta : '');
      }catch(e){}
    }

    function startRuntimeDiagTicker(){
      try { if (__diagUiTimer) clearInterval(__diagUiTimer); } catch(e) {}
      __diagUiTimer = 0;
      try {
        __diagUiTimer = setInterval(() => {
          try { updateRuntimeDiagUI(); } catch(e) {}
          try { renderTtsEventLog(); } catch(e) {}
        }, Math.max(700, Number(__diagUiIntervalMs || 1000)));
      } catch(e) {}
      try { updateRuntimeDiagUI(); } catch(e) {}
      try { renderTtsEventLog(); } catch(e) {}
    }

    function startRuntimeWatchdog(){
      try { if (__watchdogTimer) clearInterval(__watchdogTimer); } catch(e) {}
      __watchdogTimer = 0;
      try {
        __watchdogTimer = setInterval(() => {
          try {
            const now = Date.now();
            if (__lastGoodTickMs && (now - __lastGoodTickMs > __watchdogStaleMs)) {
              setLiveStatus(false);
              if (raceInfo) raceInfo.textContent = 'Sin actualizaciones. Revisando conexion...';
              __bumpFallbackPolling('watchdog');
            }
          } catch(e) {}
        }, Math.max(1200, Number(__watchdogIntervalMs || 2500)));
      } catch(e) {}
    }

    function refreshRuntimeProfileUI(){
      try{
        const resolved = __resolveRuntimeProfileKey(runtimeProfileKey);
        const cfg = __getRuntimeProfileConfig(runtimeProfileKey);
        document.querySelectorAll('[data-runtime-profile]').forEach(btn => {
          const k = String(btn.getAttribute('data-runtime-profile') || '').toUpperCase();
          btn.classList.toggle('active', k === String(runtimeProfileKey || '').toUpperCase());
          btn.title = (k === 'AUTO') ? ('Auto -> ' + resolved) : (RUNTIME_PROFILES[k] ? RUNTIME_PROFILES[k].label : k);
        });
        if (runtimeProfileNote) runtimeProfileNote.textContent = 'Activo: ' + cfg.label + (String(runtimeProfileKey).toUpperCase() === 'AUTO' ? ' -> ' + resolved : '');
      }catch(e){}
    }

    function applyRuntimeProfile(key, opts = {}){
      try{
        const wanted = String(key || runtimeProfileKey || 'AUTO').toUpperCase();
        runtimeProfileKey = RUNTIME_PROFILES[wanted] ? wanted : 'AUTO';
        const cfg = __getRuntimeProfileConfig(runtimeProfileKey);
        __diagUiIntervalMs = cfg.diagMs;
        __watchdogIntervalMs = cfg.watchdogMs;
        __watchdogStaleMs = cfg.watchdogStaleMs;
        __ttsSafetyIntervalMs = cfg.safetyMs;
        __ttsHeartbeatIntervalMs = cfg.heartbeatMs;
        __ttsFrontKeepAliveIntervalMs = cfg.frontKeepAliveMs;
        __fallbackPollSchedule = Array.isArray(cfg.fallback) ? cfg.fallback.slice() : [1000,2000,5000,10000];
        try { prefSet('spotterRuntimeProfile', runtimeProfileKey); } catch(e) {}
        refreshRuntimeProfileUI();
        startRuntimeDiagTicker();
        startRuntimeWatchdog();
        try { stopFallbackPolling(); __fallbackPollStep = 0; } catch(e) {}
        try { stopTtsSafetyLoop(); if (voiceMasterEnabled) startTtsSafetyLoop(); } catch(e) {}
        try { stopTtsHeartbeat(); if (voiceMasterEnabled) startTtsHeartbeat(); } catch(e) {}
        if (!opts.silent) {
          try { pushTtsEvent('profile', 'Perfil runtime: ' + cfg.label, 'runtime'); } catch(e) {}
          try { showToast('Perfil ' + cfg.label, 900); } catch(e) {}
        }
      }catch(e){}
    }

    function bindRuntimeProfileCards(){
      try{
        document.querySelectorAll('[data-runtime-profile]').forEach(btn => {
          btn.addEventListener('click', () => {
            const k = btn.getAttribute('data-runtime-profile') || 'AUTO';
            applyRuntimeProfile(k);
            try { playBeep('up'); } catch(e) {}
          });
        });
      }catch(e){}
    }

    try {
      const savedRuntimeProfile = String(prefGet('spotterRuntimeProfile', 'AUTO') || 'AUTO').toUpperCase();
      runtimeProfileKey = RUNTIME_PROFILES[savedRuntimeProfile] ? savedRuntimeProfile : 'AUTO';
    } catch(e) { runtimeProfileKey = 'AUTO'; }

    // =========================
    // SILENCIO PRE-ARRANQUE (despues de practica)
    // - Si venimos de practica y ya estamos armando carrera, no comentes hasta que el reloj (elapsed) arranque.
    // =========================
    let __prevPracticeFlag = null; // 1 practica, 0 carrera
    let __silenceUntilClockRuns = false;


    // =========================
    // MENSAJES v2 (bloques) - menos repetitivo
    // - Solo cambia textos: NO toca la lógica de detección ni puntajes.
    // =========================
    const MSGV2_LAST = new Map(); // key -> last full text
    const MSGV2_LAST_OPEN = new Map(); // pilotKey -> {txt, at}
    const MSGV2_LAST_END  = new Map();
    const MSGV2_BLUE_SEQ = new Map(); // pilotKey -> counter
 // pilotKey -> {txt, at}


    function msgv2PilotKey(ctx) {
      try {
        if (ctx && ctx.pilotKey) return String(ctx.pilotKey);
        if (typeof selectedPilotKey !== 'undefined' && selectedPilotKey) return String(selectedPilotKey);
        return 'AUTO';
      } catch(e) { return 'AUTO'; }
    }

    function msgv2Key(type, ctx, part) {
      const pk = msgv2PilotKey(ctx);
      return String(type || 'x') + ':' + pk + ':' + String(part || 'full');
    }

    function msgv2Pick(arr, type, ctx, part) {
      try {
        if (!Array.isArray(arr) || !arr.length) return '';
        const key = msgv2Key(type, ctx, part);
        if (typeof autoRandPick === 'function') {
          const fn = autoRandPick(arr, 'msgv2:' + key);
          return (typeof fn === 'function') ? String(fn(ctx) || '') : String(fn || '');
        }

    function msgv2PickSalt(arr, type, ctx, part, salt) {
      try {
        if (!Array.isArray(arr) || !arr.length) return '';
        const key = msgv2Key(type, ctx, part) + ':' + String(salt || '0');
        if (typeof autoRandPick === 'function') {
          const fn = autoRandPick(arr, 'msgv2:' + key);
          return (typeof fn === 'function') ? String(fn(ctx) || '') : String(fn || '');
        }
        const v = arr[Math.floor(Math.random() * arr.length)];
        return (typeof v === 'function') ? String(v(ctx) || '') : String(v || '');
      } catch(e) { return ''; }
    }

        const v = arr[Math.floor(Math.random() * arr.length)];
        return (typeof v === 'function') ? String(v(ctx) || '') : String(v || '');
      } catch(e) { return ''; }
    }

    
    // =========================
    // SPOTTER - Sanitizador de texto (anti-inglés con excepciones)
    // - Evita spanglish en la locución (permite: "apex")
    // - Reemplaza términos típicos a español
    // - Corrige errores comunes (línea)
    // =========================
    function spotterSanitizeText(text) {
      try {
        let s = String(text || '');

        // Fix de acentos/typos comunes
        s = s.replace(/\bl\s*nea\b/ig, 'línea');

        // Reemplazos (NO tocar "apex")
        const rep = [
          { re: /\bbest\s*lap\b/ig, to: 'mejor vuelta' },
          { re: /\bbestlap\b/ig,     to: 'mejor vuelta' },
          { re: /\bpace\b/ig,        to: 'ritmo' },
          { re: /\bgap\b/ig,         to: 'brecha' },
          { re: /\bdelta\b/ig,       to: 'diferencia' },
          { re: /\bpush\b/ig,        to: 'aprieta' },
          { re: /\bclean\b/ig,       to: 'limpio' },
          { re: /\bstint\b/ig,       to: 'tanda' },
          { re: /\btrack\b/ig,       to: 'pista' },
          { re: /\bline\b/ig,        to: 'línea' },

          { re: /\bovertake\b/ig,    to: 'pase' },
          { re: /\bswap\b/ig,        to: 'cambio' },
          { re: /\bupdate\b/ig,      to: 'actualización' },
          { re: /\bcluster\b/ig,     to: 'grupo' },
          { re: /\battack\b/ig,      to: 'ataque' },
          { re: /\bdefend\b/ig,      to: 'defiende' },
          { re: /\bdefense\b/ig,     to: 'defensa' },
          { re: /\boff\s*track\b/ig,to: 'fuera de pista' },
          { re: /\bon\s*board\b/ig, to: 'a bordo' },
          { re: /\bposition\b/ig,    to: 'posición' },
          { re: /\bpos\b/ig,         to: 'posición' },
          { re: /\blaps\b/ig,        to: 'vueltas' },
          { re: /\blap\b/ig,         to: 'vuelta' },
        ];
        for (const r of rep) s = s.replace(r.re, r.to);

        // Limpieza final
        s = s.replace(/\s+/g, ' ').trim();
        s = s.replace(/\s+\./g, '.').replace(/\s+,/g, ',');
        s = s.replace(/,\s*,/g, ',').replace(/\s+,\s+/g, ', ');

        
        // Fixes de espaol natural (anti "acorta el brecha")
        s = s
          .replace(/\bacorta\s+el\s+brecha\b/ig, 'recorta la brecha')
          .replace(/\bacorta\s+la\s+brecha\b/ig, 'recorta la brecha')
          .replace(/\bel\s+brecha\b/ig, 'la brecha');

        return s;
      } catch(e) {
        try { return String(text || '').trim(); } catch(_) { return ''; }
      }
    }

function msgv2DecimasTxt(ms) {
      const abs = Math.abs(Number(ms) || 0);
      const dec = Math.max(1, Math.round(abs / 100));
      if (dec === 1) return 'una décima';
      return String(dec) + ' décimas';
    }

    // Bancos por tipo: combinación por bloques (apertura + dato + acción + cierre)
    const MSGV2 = {
      blueflag: {
        open: [
          (c) => (c && c.isFinal) ? 'Bandera azul.' : 'Bandera azul.',
          () => 'Azul.',
          () => 'Atento, azul.',
          () => 'Cuidado, azul.',
          () => 'Líder atrás.',
          () => 'Auto rápido detrás.',
          () => 'Tráfico atrás.',
          () => 'Azul, calma.',
          () => 'Respeta la azul.',
          () => 'Azul, mantén trazada.'
        ],
        info: [
          (c) => (c && c.who) ? ('Detrás viene ' + c.who + '.') : 'Detrás viene el líder.',
          (c) => (c && c.who) ? ('Te alcanza ' + c.who + '.') : 'Te alcanza el líder.',
          (c) => (c && c.who) ? ('Te llega ' + c.who + '.') : 'Te llega el líder.',
          (c) => (c && c.who) ? ('Viene cerrando ' + c.who + '.') : 'Viene cerrando el líder.',
          (c) => (c && c.who) ? ('Ya lo tienes en el espejo: ' + c.who + '.') : 'Ya lo tienes en el espejo: el líder.',
          (c) => (c && c.who) ? ('Te llega a la salida del apex: ' + c.who + '.') : 'Te llega a la salida del apex: el líder.'
        ],
        act: [
          () => 'Mantén tu línea.',
          () => 'Mantén la trazada.',
          () => 'Traza limpio.',
          () => 'Sin volantazos.',
          () => 'No cierres la puerta.',
          () => 'No frenes de golpe.',
          () => 'Abre espacio a la salida.',
          () => 'Deja el interior.',
          () => 'Deja el exterior.',
          () => 'Suelta la línea en recta.',
          () => 'No pelees esta.',
          () => 'Hazlo limpio.'
        ],
        end: [
          () => 'Dale paso en la recta.',
          () => 'En la próxima recta, dale paso.',
          () => 'En cuanto puedas, dale paso.',
          () => 'Al salir del apex, deja espacio.',
          () => 'En la salida, deja espacio.',
          () => 'Cuando lo tengas, déjalo pasar.',
          () => 'Sin perder ritmo, dale paso.',
          () => 'No lo bloquees, dale paso.',
          () => 'Respeta la bandera azul.',
          () => 'Hazlo limpio y sigue.'
        ]
      },

      bestlap: {
        open: [
          () => 'Nueva mejor vuelta.',
          () => 'Mejor vuelta.',
          () => 'Vuelta clavada.',
          () => 'Eso es ritmo.'
        ],
        info: [
          (c) => (c && c.best) ? ('Tiempo ' + c.best + '.') : '',
          (c) => (c && c.best) ? ('Marcaste ' + c.best + '.') : '',
          (c) => (c && c.best) ? ('Paraste el crono en ' + c.best + '.') : ''
        ],
        act: [
          () => 'Repite la trazada.',
          () => 'Ahora, consistencia.',
          () => 'Sin errores.',
          () => 'Cuida la salida.'
        ],
        end: [
          () => '',
          () => 'Sigue así.',
          () => 'No regales nada.'
        ]
      },

      ritmo_up: { // tiempos más altos (más lento)
        open: [
          () => 'Ojo, se cayó el ritmo.',
          () => 'Perdiste ritmo.',
          () => 'Se abrió el tiempo.',
          () => 'Cuidado con el ritmo.'
        ],
        info: [
          (c) => (c && c.deltaMs) ? ('Más lento por ' + msgv2DecimasTxt(c.deltaMs) + '.') : '',
          (c) => (c && c.deltaMs) ? ('Se te fue ' + msgv2DecimasTxt(c.deltaMs) + '.') : '',
          () => ''
        ],
        act: [
          () => 'Vuelve al apex.',
          () => 'Limpia la trazada.',
          () => 'Respira y enfócate.',
          () => 'Sin castigar llanta.'
        ],
        end: [
          () => '',
          () => 'Recupera en la siguiente.',
          () => 'Con calma.'
        ]
      },

      ritmo_down: { // tiempos más bajos (más rápido)
        open: [
          () => 'Bien, encontraste ritmo.',
          () => 'Ritmo mejorando.',
          () => 'Vas bajando el tiempo.',
          () => 'Eso, ritmo fino.'
        ],
        info: [
          (c) => (c && c.deltaMs) ? ('Bajaste ' + msgv2DecimasTxt(c.deltaMs) + '.') : '',
          (c) => (c && c.deltaMs) ? ('Ganaste ' + msgv2DecimasTxt(c.deltaMs) + '.') : '',
          () => ''
        ],
        act: [
          () => 'Repite esa trazada.',
          () => 'Ahora, a sostener.',
          () => 'Sin errores.',
          () => 'Sigue así.'
        ],
        end: [
          () => '',
          () => 'Buen trabajo.',
          () => 'Aguanta el ritmo.'
        ]
      },

      attack: {
        open: [
          () => 'Ataque.',
          () => 'A presionar.',
          () => 'Lo tienes a tiro.',
          () => 'Entra en pelea.'
        ],
        info: [
          (c) => {
            const nm = (c && c.otherName) ? String(c.otherName).trim() : '';
            const g  = (c && c.gapStr) ? String(c.gapStr).trim() : '';
            if (nm && g) return 'Adelante ' + nm + ' ' + g + '.';
            if (g) return 'Adelante ' + g + '.';
            if (nm) return 'Adelante ' + nm + '.';
            return '';
          },
          (c) => {
            const g  = (c && c.gapStr) ? String(c.gapStr).trim() : '';
            if (g) return 'Cerrando ' + g + '.';
            return '';
          }
        ],
        act: [
          () => 'Clava apex.',
          () => 'Salida limpia.',
          () => 'Sin contacto.',
          () => 'Freno corto y gira.'
        ],
        end: [
          () => '',
          () => 'Todo limpio.',
          () => 'Con paciencia.'
        ]
      },

      defense: {
        open: [
          () => 'Defensa.',
          () => 'Te vienen encima.',
          () => 'Cierra puertas.',
          () => 'A cuidar la línea.'
        ],
        info: [
          (c) => {
            const nm = (c && c.otherName) ? String(c.otherName).trim() : '';
            const g  = (c && c.gapStr) ? String(c.gapStr).trim() : '';
            if (nm && g) return 'Atrás viene ' + nm + ' ' + g + '.';
            if (g) return 'Atrás viene ' + g + '.';
            if (nm) return 'Atrás viene ' + nm + '.';
            return '';
          },
          (c) => {
            const g  = (c && c.gapStr) ? String(c.gapStr).trim() : '';
            if (g) return 'Están ' + g + '.';
            return '';
          }
        ],
        act: [
          () => 'Traza firme.',
          () => 'Sin volantazos.',
          () => 'Salida limpia.',
          () => 'No te pases de freno.'
        ],
        end: [
          () => '',
          () => 'Mantén calma.',
          () => 'Sin errores.'
        ]
      },

      fight: {
        open: [
          () => 'Pelea cerrada.',
          () => 'Carrera apretada.',
          () => 'Dos por décimas.',
          () => 'En la pelea.'
        ],
        info: [ () => '' ],
        act: [
          () => 'Ojos al apex.',
          () => 'Todo limpio.',
          () => 'Sin tocar.',
          () => 'Salida fina.'
        ],
        end: [
          () => '',
          () => 'Aguanta.',
          () => 'Con cabeza.'
        ]
      }
    };


    // =========================
    // TTS GEN v1 - motor generativo
    // - Plantillas con variantes [[a|b|c]]
    // - Placeholders {pilot}, {winner}, {gapStr}, etc.
    // - Multiplica frases sin escribirlas a mano una por una
    // =========================
    const __ttsGenBag = new Map();

    function __ttsGenPick(list, key) {
      try {
        if (!Array.isArray(list) || !list.length) return '';
        if (typeof autoRandPick === 'function') {
          const v = autoRandPick(list, key || 'ttsgen');
          return (v == null) ? '' : v;
        }
        const k = String(key || 'ttsgen');
        let st = __ttsGenBag.get(k);
        if (!st || !Array.isArray(st.bag) || st.srcLen !== list.length) st = { bag: [], srcLen: list.length };
        if (!st.bag.length) {
          st.bag = list.slice();
          for (let i = st.bag.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const t = st.bag[i]; st.bag[i] = st.bag[j]; st.bag[j] = t;
          }
        }
        const out = st.bag.shift();
        __ttsGenBag.set(k, st);
        return out;
      } catch(e) { return (Array.isArray(list) && list[0]) ? list[0] : ''; }
    }

    function __ttsGenClean(out) {
      try {
        let s = String(out || '');
        s = s.replace(/\s+/g, ' ').trim();
        s = s.replace(/\s+\./g, '.').replace(/\s+,/g, ',');
        s = s.replace(/,\s*,/g, ',').replace(/\.\s*\./g, '.');
        s = s.replace(/\s+:/g, ':').replace(/\s+;/g, ';');
        return spotterSanitizeText(s);
      } catch(e) { return String(out || '').trim(); }
    }

    function __ttsGenRender(template, ctx, scopeKey) {
      try {
        let s = String(template || '');
        let vi = 0;
        for (let pass = 0; pass < 6; pass++) {
          if (!/\[\[[^\]]+\]\]/.test(s)) break;
          s = s.replace(/\[\[([^\]]+)\]\]/g, function(_, body){
            vi += 1;
            const opts = String(body || '').split('|').map(x => String(x || '').trim()).filter(Boolean);
            return String(__ttsGenPick(opts, String(scopeKey || 'ttsgen') + ':v' + vi) || '');
          });
        }
        s = s.replace(/\{([a-zA-Z0-9_]+)\}/g, function(_, key){
          const v = (ctx && Object.prototype.hasOwnProperty.call(ctx, key)) ? ctx[key] : '';
          return (v == null) ? '' : String(v);
        });
        return __ttsGenClean(s);
      } catch(e) { return ''; }
    }

    function __ttsGenUse(templates, ctx, scopeKey, validator) {
      try {
        const arr = Array.isArray(templates) ? templates : [];
        if (!arr.length) return '';
        for (let attempt = 0; attempt < 3; attempt++) {
          const tpl = __ttsGenPick(arr, String(scopeKey || 'ttsgen') + ':tpl');
          const out = __ttsGenRender(tpl, ctx || {}, String(scopeKey || 'ttsgen') + ':a' + attempt);
          if (!out) continue;
          if (typeof validator === 'function' && !validator(out)) continue;
          return out;
        }
        return '';
      } catch(e) { return ''; }
    }

    const TTS_GEN_MSGV2 = {
      attack: [
        '[[Ataca|Presiona|Va encima|Lo trae en la mira]]. [[Atras viene|Encima esta|Al acecho viene]] {otherName}. [[Gap {gapStr}|Estan {gapStr}|A {gapStr}]]. [[Traza limpia|Sin regalar apex|Con calma|Sin tocar]].',
        '[[Presion real|Ojo atras|Hay amenaza]]. {otherName} [[pegado|muy cerca|metido en la pelea]]. [[{gapStr}|Gap {gapStr}|A {gapStr}]]. [[No abras la puerta|Cuida la salida|Fino en el volante|Todo limpio]].',
        '[[Radar prendido|Espejos alertas|No te relajes]]. {otherName} [[ya esta ahi|se vino encima|esta en rango]]. [[Separacion {gapStr}|A {gapStr}|Gap {gapStr}]]. [[Sin errores|Con cabeza|Respira y traza|No regales]].'
      ],
      defense: [
        '[[Defiende|Aguanta|Sostiene la plaza|Cubre la posicion]]. [[Detras viene|Pegado atras]] {otherName}. [[Gap {gapStr}|A {gapStr}|Estan {gapStr}]]. [[No dejes hueco|Salida limpia|Todo fino|Sin tocar]].',
        '[[Toca defender|Hay que cuidar el sitio|No regales la puerta]]. {otherName} [[presiona|viene apretando|esta pegado]]. [[{gapStr}|Gap {gapStr}|A {gapStr}]]. [[Con cabeza|Traza limpia|Freno fino|Nada de drama]].',
        '[[Posicion bajo presion|Momento de sangre fria|Hay que cerrar bien]]. {otherName} [[encima|al ataque|sin soltarte]]. [[A {gapStr}|Gap {gapStr}|Estan {gapStr}]]. [[Sin volantazos|Limpio|Calma|Sin abrir la puerta]].'
      ],
      fight: [
        '[[Pelea cerrada|Duelo apretado|Batalla viva|Estan a cuchillo]]. [[Todo limpio|Sin tocar|Con cabeza|Ojos al apex]].',
        '[[Dos por decimas|Mano a mano|Esto esta vivo|Hay duelo serio]]. [[Traza fina|Nada de regalos|Todo controlado|Salida limpia]].',
        '[[Batalla directa|Pelea de precision|Carrera apretada|Se cerro el asunto]]. [[Con calma|Sin errores|Sin panico|Todo limpio]].'
      ],
      ritmo_up: [
        '[[Buen ritmo|Sube el ritmo|Vas mejorando|Hay ganancia]]. [[Recortas {deltaMs} milisegundas|Recortas {deltaMs} milisegundos|Mejoras {deltaMs} milisegundos]]. [[Sigue asi|Mantelo|Repite eso|Esa linea sirve]].',
        '[[Ritmo arriba|Mejora clara|Paso adelante|Va mejor]]. [[Ganaste {deltaMs} milisegundos|Hay {deltaMs} milisegundos de mejora|Recorte de {deltaMs} milisegundos]]. [[A sostenerlo|Clavalo otra vez|Misma receta|Buena vuelta]].'
      ],
      ritmo_down: [
        '[[Se fue tiempo|Caida de ritmo|Ojo con el ritmo|Vuelta mas lenta]]. [[Perdiste {deltaMs} milisegundos|Cedes {deltaMs} milisegundos|Se fueron {deltaMs} milisegundos]]. [[Respira y corrige|Sin forzar de mas|Vuelve a la linea|Calma]].',
        '[[Hay perdida|Se abrio la vuelta|Ritmo abajo|No fue esa]]. [[{deltaMs} milisegundos mas|Se fueron {deltaMs} milisegundos|Pierdes {deltaMs} milisegundos]]. [[Recupera la trazada|Sin castigar llanta|Acomoda la entrada|Vuelve al plan]].'
      ],
      bestlap: [
        '[[Mejor vuelta|Gran vuelta|Vueltota|Tiempo top]]. [[{best}|Registro {best}|Marca {best}]]. [[Sigue empujando|Ahi esta el ritmo|Muy bien|Buena referencia]].',
        '[[Best lap|Referencia nueva|Ritmo premium|Tiempo fuerte]]. [[{best}|Con {best}|Parando el reloj en {best}]]. [[Eso sirve|Buen dato|Quedate ahi|Limpio]].'
      ],
      blueflag: [
        '[[Bandera azul|Cortesia de carrera|Atencion trafico]]. [[Viene {who}|Ya esta encima {who}|Se acerca {who}]]. [[Dale pista limpia|No lo amarres|Sin estorbar|Dejalo pasar limpio]].'
      ]
    };

    function ttsGenMsgv2Compose(type, ctx) {
      try {
        const t = String(type || '').trim();
        if (!t || t === 'blueflag') return '';
        const bank = TTS_GEN_MSGV2[t];
        if (!Array.isArray(bank) || !bank.length) return '';
        const pk = msgv2PilotKey(ctx);
        const out = __ttsGenUse(bank, ctx || {}, 'msgv2gen:' + t + ':' + pk, function(txt){ return !!String(txt || '').trim(); });
        return out || '';
      } catch(e) { return ''; }
    }

    const TTS_GEN_AUTO_BASE = {
      leaderChange: [
        '[[Cambio de lider|Nueva punta|Punta nueva|Se mueve la cabeza|Golpe arriba]]. {winner} [[toma|asegura|recupera|manda en|se queda con]] P1. [[{loser} queda P2|{loser} cae a segundo|{loser} responde desde P2|{loser} a perseguir]].',
        '[[Arriba hay cambio|Se altera el frente|La punta cambia de manos|Tenemos lider nuevo]]. [[P1 para {winner}|Lidera {winner}|{winner} pasa al frente]]. [[P2 {loser}|{loser} ahora segundo|{loser} en persecucion]].',
        '[[Golpe de autoridad|Movimiento serio|Cambio importante|Se mueve la carrera]]. {winner} [[desbanca|supera|deja atras|rebasa]] a {loser} y [[ya es lider|manda en P1|se pone primero]].'
      ],
      pass: [
        '[[Rebase confirmado|Cambio de posicion|Puesto ganado|Pase hecho]]. {winner} [[sube a|se mete en|asegura]] P{newPos}. [[{loser} cae a P{oldPos}|{loser} baja a P{oldPos}|{loser} pierde el sitio]].',
        '[[Movimiento limpio|Adelantamiento al conteo|Intercambio cerrado|Posicion nueva]]. [[P{newPos} para {winner}|{winner} toma P{newPos}|{winner} gana la plaza]]. [[{loser} ahora P{oldPos}|{loser} se reacomoda en P{oldPos}|{loser} a perseguir]].',
        '[[Se concreta el pase|Ya esta el cambio|Se mueve la tabla|Puesto que cambia]]. {winner} [[adelante|por delante|hace el trabajo]] y [[queda P{newPos}|se instala en P{newPos}|amarra P{newPos}]].'
      ],
      battle: [
        '[[Duelo en P{pos}|P{pos} en pelea|Atencion P{pos}|P{pos} caliente]]. {attacker} [[presiona|se viene encima|no suelta|aprieta]] a {defender}. [[Gap {sec}|{sec}|Separacion {sec}]].',
        '[[P{pos} sin aire|P{pos} al limite|P{pos} apretado|Camara a P{pos}]]. {attacker} [[pegado|muy cerca|en el espejo|en rango de pase]]. [[{sec}|Gap {sec}|A {sec}]].',
        '[[Batalla directa por P{pos}|Mano a mano en P{pos}|Hay historia en P{pos}|P{pos} en foco]]. {defender} [[aguanta|defiende|resiste]] y {attacker} [[insiste|vuelve a cargar|sigue encima|busca hueco]].'
      ],
      battlePodium: [
        '[[Podio en juego|Puesto grande en riesgo|Se pelea el podio|Podio bajo presion]]. {attacker} [[caza|persigue|acecha|aprieta]] a {defender} por P{pos}. [[{sec}|Gap {sec}|A {sec}]].',
        '[[La pelea buena esta en el podio|Hay humo en zona de trofeo|P{pos} vale trofeo|Zona podio encendida]]. {attacker} [[encima|en rango|muy cerca|metido]] de {defender}.',
        '[[Podio en el radar|Podio que no esta seguro|Trofeo todavia en disputa|Nadie puede pestañear]]. {defender} [[aguanta|resiste|cubre]] y {attacker} [[presiona|no perdona|viene fuerte|no afloja]].'
      ],
      closing: [
        '[[Se cierra la pelea|Cada vez mas cerca|Se aprieta el duelo|El gap viene abajo]]. {attacker} [[recorta|descuenta|se acerca|viene encima]] sobre {defender}. [[De {fromSec} a {toSec}|Ahora {toSec}|Gap {toSec}]].',
        '[[Ojo con esta tendencia|Lectura clara|Se esta cocinando|Esto cambia]]. {attacker} [[ya lo trae|ya lo tiene cerca|viene a la carga|va acortando]]. [[{toSec}|A {toSec}|Gap {toSec}]].',
        '[[La presion sube|La historia aprieta|Se prende el foco|Esto se mueve]]. {defender} [[ya lo siente|lo trae en espejos|no respira]] y {attacker} [[recorta|se mete|llega|amenaza]].'
      ],
      pressure: [
        '[[Presion real|No hay margen|Se juega fino|Momento delicado]]. {attacker} [[encima|a tiro|metido|apretando]] de {defender}. [[{sec}|A {sec}|Gap {sec}]].',
        '[[Sin aire adelante|Defensa en marcha|Todo bajo estres|Alta presion]]. {defender} [[tiene que cerrar|no puede fallar|debe trazar limpio|carga los espejos]].',
        '[[Se siente el ataque|Esto pide precision|No hay respiro|Viene la carga]]. {attacker} [[ya toca la puerta|esta muy cerca|huele sangre|no perdona]].'
      ],
      gap: [
        '[[Gap de referencia|Lectura del gap|Dato de separacion|Delta actual]]. {front} sobre {back}, [[{sec}|a {sec}|gap {sec}]].',
        '[[Numero en pista|La diferencia ahora|La pelicula del cronometro|Dato frio]]. {front} [[mantiene|lleva|conserva]] [[{sec}|a {sec}|gap {sec}]] sobre {back}.',
        '[[Separacion registrada|Ventana actual|Distancia de carrera|Margen ahora]]. [[{front} adelante|{front} controla|{front} sostiene]] y {back} [[sigue|persigue|responde]].'
      ],
      top3: [
        '[[Top 3 actual|Asi va el podio|Foto del frente|Referencia de punta]]. P1 {p1}, P2 {p2}, P3 {p3}.',
        '[[En punta|Orden del podio|Frente de la carrera|Tres primeros]]. {p1}, {p2}, {p3}.',
        '[[Podio provisional|Corte rapido|Estado del frente|Marcador al frente]]. [[Lider {p1}|P1 {p1}]]. [[Luego {p2} y {p3}|Detras {p2} y {p3}|P2 {p2}, P3 {p3}]].'
      ],
      train: [
        '[[Paquete compacto|Tren formado|Grupo cerrado|Fila apretada]]. P2 {p2}, P3 {p3}, P4 {p4}. [[Cualquier error cambia todo|Nadie sobra ahi|Todo esta vivo|Ventana de pase abierta]].',
        '[[P2 a P4 en rango|Tres autos en paquete|Grupo por el podio|Cluster caliente]]. {p2}, {p3} y {p4}. [[Sin espacio de sobra|Alta tension|Todo al filo|Precision total]].',
        '[[Hay tren por el podio|Se agrupan fuerte|No se despegan|Todo muy corto]]. [[{p2} delante|Manda {p2} en el grupo|Encabeza {p2}]]. [[{p3} y {p4} pegados|{p3} y {p4} sin aire|{p3} con {p4} encima]].'
      ],
      record: [
        '[[Mejor vuelta|Tiempo de referencia|Ritmo premium|Registro top]]. {pilot} [[marca|firma|clava|pone]] {best}.',
        '[[Se actualiza la referencia|Hay tiempo fuerte|Nueva marca buena|Vuelta de peso]]. {pilot} con {best}.',
        '[[Cronometro a favor|Tiempo serio|Vuelta importante|Dato fino]]. {pilot} [[se apunta|deja|registra|anota]] {best}.',
      ],
      qualiBest: [
        '[[En clasificacion|Modo quali|Tiempo de manga|En el reloj]]. {pilot} [[marca|pone|suelta|deja]] {best}.',
        '[[Queda el tiempo|Registro de quali|Referencia en clasificacion|Tiempo al tablero]]. {pilot} con {best}.',
        '[[Clasificacion se mueve|La quali cambia|Sube el liston|Hay vuelta buena]]. {pilot} [[firma|clava|registra]] {best}.',
      ],
      qualiPole: [
        '[[Pole en juego|Batalla por la pole|Se aprieta la pole|Clasificacion caliente]]. {p1} y {p2} [[separados por {sec}|a {sec}|con gap {sec}]].',
        '[[Nada decidido en la pole|La punta de quali sigue viva|La pole no esta cerrada|Ojo con la pole]]. {p1} contra {p2}. [[{sec}|A {sec}|Gap {sec}]].',
        '[[Quien se queda la pole|Se decide por nada|Esto va por milimetros|Clasificacion fina]]. {p1} [[aguanta|manda|sostiene]] y {p2} [[aprieta|recorta|viene cerca]].'
      ]
    };

    const TTS_GEN_AUTO = {
      pro: TTS_GEN_AUTO_BASE,
      picante: Object.assign({}, TTS_GEN_AUTO_BASE, {
        leaderChange: [
          '[[Se volteo la tortilla|Golpe en la punta|Se mueve el jefe|Cambio bravo arriba]]. {winner} [[se roba|toma|se queda con|agarra]] P1. [[{loser} a perseguir|{loser} baja a segundo|{loser} pierde la punta|{loser} a remar]].',
          '[[Nuevo patron en pista|Punta que cambia de dueño|Hay mano dura adelante|Se prende arriba]]. [[P1 para {winner}|Manda {winner}|{winner} al frente]]. [[{loser} ahora P2|{loser} en caceria|{loser} tiene que responder]].'
        ],
        pass: [
          '[[Rebase con colmillo|Pase con hambre|Movimiento filoso|Le mete el coche]]. {winner} [[sube a|amarra|se queda con]] P{newPos}. [[{loser} cae a P{oldPos}|{loser} se queda viendo|{loser} pierde el sitio]].',
          '[[Se la cobra|No perdona|Puesto robado|Golpe de carrera]]. {winner} [[adelante|por delante|hace la chamba]] y [[ya es P{newPos}|queda P{newPos}|se instala en P{newPos}]].'
        ],
        battle: [
          '[[P{pos} en modo cuchillo|Duelazo en P{pos}|P{pos} al rojo vivo|Se pico P{pos}]]. {attacker} [[respira en la nuca|va encima|ya toca la puerta|huele sangre]] de {defender}. [[{sec}|Gap {sec}|A {sec}]].',
          '[[Esto va a tronar|No hay paz en P{pos}|Se cocina un pase|Huele a cambio]]. {defender} [[aguanta|se defiende|no puede fallar]] y {attacker} [[no perdona|vuelve a cargar|sigue ahi|esta pegado]].'
        ],
        closing: [
          '[[Se viene la bronca|Esto se apreto sabroso|Ya lo tiene en la mira|La tijera viene cerrando]]. {attacker} [[recorta|se acerca|descuenta|ya esta ahi]] sobre {defender}. [[{toSec}|A {toSec}|Gap {toSec}]].',
          '[[Ahora si|Ya huele a pase|Esto esta calientito|Se puso bueno]]. {defender} [[ya lo siente|lo trae encima|mira espejos|no respira]].'
        ],
        battlePodium: [
          '[[Podio a cuchillo|Trofeo en la lumbre|Zona de podio que arde|Nadie afloja por el trofeo]]. {attacker} [[encima|pegado|ya encima|a la carga]] de {defender}.',
          '[[Ese podio no esta asegurado|Todavia se vende caro el trofeo|El podio sigue en juego|Hay humo por el trofeo]]. [[Gap {sec}|A {sec}|{sec}]].'
        ]
      }),
      engineer: Object.assign({}, TTS_GEN_AUTO_BASE, {
        gap: [
          '[[Lectura tecnica|Dato de referencia|Numero puro|Telemetria rapida]]. {front} sobre {back}, [[{sec}|a {sec}|gap {sec}]].',
          '[[Delta registrado|Margen operativo|Separacion medida|Gap trazable]]. {front} [[controla|mantiene|sostiene]] [[{sec}|a {sec}|gap {sec}]] sobre {back}.',
          '[[Ritmo contra posicion|Numero mata chisme|Corte tecnico|Lectura limpia]]. {front} [[sigue delante|esta delante|conserva el frente]] y {back} [[persigue|sigue el delta|responde]].'
        ],
        train: [
          '[[Paquete P2 a P4|Grupo de presion|Stack de posiciones|Cluster de ritmo]]. {p2}, {p3}, {p4}. [[Ventana de error minima|Todo en rango|Sin margen|Compacto total]].',
          '[[Tres autos en delta corto|Grupo comprimido|Cadena de ataque|Presion encadenada]]. {p2} [[tira del tren|encabeza el grupo|abre el paquete]], {p3} y {p4} [[en rango|sin aire|pegados]].'
        ],
        record: [
          '[[Referencia de ritmo|Vuelta de valor|Dato premium|Tiempo de referencia]]. {pilot} con {best}.',
          '[[Se actualiza el benchmark|Nueva referencia limpia|Tiempo a seguir|Lectura de velocidad]]. {pilot} [[marca|clava|pone]] {best}.'
        ]
      }),
      narrativo: Object.assign({}, TTS_GEN_AUTO_BASE, {
        record: [
          '[[El reloj habla|Queda escrita la vuelta|Se firma una referencia|La pista responde]]. {pilot} [[pone|deja|firma|anota]] {best}.',
          '[[Hay una vuelta que pesa|Momento de cronometro|Se mueve la historia del ritmo|La referencia cambia]]. {pilot} con {best}.',
          '[[No fue una vuelta cualquiera|Ese giro tiene mensaje|La carrera deja un dato fino|La vuelta queda en libreta]]. {pilot} [[marca|firma|registra]] {best}.'
        ],
        top3: [
          '[[Asi se cuenta la punta|Foto del frente|La historia arriba va asi|El frente de carrera]]. {p1}, luego {p2}, despues {p3}.',
          '[[En la cabeza del peloton|Arriba la novela va asi|La punta hoy dice|El relato del frente]]. {p1} manda, {p2} persigue, {p3} espera.'
        ],
        closing: [
          '[[La trama se aprieta|La historia se pone seria|Cada curva pesa mas|El aire se corta]]. {attacker} [[recorta|viene recortando|se pega|crece]] sobre {defender}.',
          '[[Esto no esta escrito|Todavia falta tinta|Nadie puede respirar tranquilo|La vuelta trae drama]]. [[Gap {toSec}|A {toSec}|{toSec}]].'
        ]
      })
    };

    function ttsGenAutoCompose(type, ctx, style) {
      try {
        const st = String(style || 'pro').trim() || 'pro';
        const dict = (TTS_GEN_AUTO[st] || TTS_GEN_AUTO.pro || {});
        const bank = dict[type] || ((TTS_GEN_AUTO.pro || {})[type]) || [];
        if (!Array.isArray(bank) || !bank.length) return '';
        const out = __ttsGenUse(bank, ctx || {}, 'autogen:' + st + ':' + type, function(txt){
          return (typeof autoIsUsableText === 'function') ? autoIsUsableText(txt, type) : !!String(txt || '').trim();
        });
        return out || '';
      } catch(e) { return ''; }
    }


    // =========================
    // TTS SMART v1 - motor contextual
    // - Decide al vuelo segun evento, gap, sesion, continuidad y tono
    // - No usa fuentes externas ni bancos externos
    // - Si no logra una frase usable, cae al motor generativo / clasico
    // =========================
    const __ttsSmartState = {
      follow: new Map(),
      auto: new Map()
    };
    const __ttsStoryState = {
      follow: new Map(),
      auto: new Map()
    };
    const __ttsRivalState = {
      follow: new Map(),
      auto: new Map()
    };

    function __ttsStoryBag(channel) {
      try {
        return (channel === 'follow') ? __ttsStoryState.follow : __ttsStoryState.auto;
      } catch(e) { return null; }
    }

    function __ttsStoryCleanup(channel) {
      try {
        const bag = __ttsStoryBag(channel);
        if (!bag || typeof bag.forEach !== 'function') return;
        const now = Date.now();
        bag.forEach((v, k) => {
          if (!v || (now - Number(v.at || 0)) > 90000) bag.delete(k);
        });
      } catch(e) {}
    }


    function __ttsRivalBag(channel) {
      try {
        return (channel === 'follow') ? __ttsRivalState.follow : __ttsRivalState.auto;
      } catch(e) { return null; }
    }

    function __ttsRivalCleanup(channel) {
      try {
        const bag = __ttsRivalBag(channel);
        if (!bag || typeof bag.forEach !== 'function') return;
        const now = Date.now();
        bag.forEach((v, k) => {
          if (!v || (now - Number(v.lastSeen || 0)) > 12 * 60 * 1000) bag.delete(k);
        });
      } catch(e) {}
    }

    function __ttsRivalTouch(channel, pairKey, type, ctx, storyLike) {
      try {
        if (!pairKey) return null;
        __ttsRivalCleanup(channel);
        const bag = __ttsRivalBag(channel);
        if (!bag) return null;
        const now = Date.now();
        const gapNum = Number(storyLike && storyLike.gapNum);
        const defender = __ttsSmartName(ctx && ctx.defender, __ttsSmartName(ctx && ctx.pilot, '')).trim();
        const attacker = __ttsSmartName(ctx && (ctx.attacker || ctx.otherName || ctx.who || ctx.winner), '').trim();
        const winner = __ttsSmartName(ctx && ctx.winner, '').trim();
        const loser = __ttsSmartName(ctx && ctx.loser, '').trim();
        let rec = bag.get(pairKey) || {
          pairKey: String(pairKey),
          encounters: 0,
          closeTicks: 0,
          pressureTicks: 0,
          heroDefenseTicks: 0,
          resolvedCount: 0,
          lastSeen: 0,
          lastEncounterAt: 0,
          lastDefender: '',
          lastAttacker: '',
          lastWinner: '',
          lastLoser: ''
        };
        const sameEncounter = rec.lastSeen && ((now - Number(rec.lastSeen || 0)) < 42000);
        if (!sameEncounter) {
          rec.encounters = Number(rec.encounters || 0) + 1;
          rec.lastEncounterAt = now;
        }
        if (isFinite(gapNum) && gapNum <= 0.35) rec.closeTicks = Math.min(12, Number(rec.closeTicks || 0) + 1);
        else rec.closeTicks = Math.max(0, Number(rec.closeTicks || 0) - 1);

        if (/^(attack|defense|fight|battle|battlePodium|closing|pressure)$/.test(String(type || '')) && String((storyLike && storyLike.trend) || '') !== 'opening') {
          rec.pressureTicks = Math.min(16, Number(rec.pressureTicks || 0) + 1);
        } else if (!/^(pass|leaderChange)$/.test(String(type || ''))) {
          rec.pressureTicks = Math.max(0, Number(rec.pressureTicks || 0) - 1);
        }

        if ((String(type || '') === 'defense' || String(type || '') === 'pressure') && defender) {
          if (rec.lastDefender === defender && !storyLike?.resolved && (!isFinite(gapNum) || gapNum <= 0.60)) rec.heroDefenseTicks = Math.min(12, Number(rec.heroDefenseTicks || 0) + 1);
          else rec.heroDefenseTicks = 1;
        } else if (/^(pass|leaderChange)$/.test(String(type || ''))) {
          rec.heroDefenseTicks = 0;
        } else {
          rec.heroDefenseTicks = Math.max(0, Number(rec.heroDefenseTicks || 0) - 1);
        }

        if (/^(pass|leaderChange)$/.test(String(type || ''))) {
          rec.resolvedCount = Math.min(12, Number(rec.resolvedCount || 0) + 1);
          rec.pressureTicks = 0;
          rec.closeTicks = 0;
          rec.heroDefenseTicks = 0;
        }

        rec.lastSeen = now;
        rec.lastDefender = defender || rec.lastDefender || '';
        rec.lastAttacker = attacker || rec.lastAttacker || '';
        rec.lastWinner = winner || rec.lastWinner || '';
        rec.lastLoser = loser || rec.lastLoser || '';
        bag.set(pairKey, rec);
        const encounters = Number(rec.encounters || 0);
        const pressureTicks = Number(rec.pressureTicks || 0);
        const closeTicks = Number(rec.closeTicks || 0);
        const heroDefenseTicks = Number(rec.heroDefenseTicks || 0);
        return {
          pairKey: String(pairKey),
          encounters,
          closeTicks,
          pressureTicks,
          heroDefenseTicks,
          resolvedCount: Number(rec.resolvedCount || 0),
          recurrent: encounters >= 3,
          relentless: pressureTicks >= 4,
          heroic: heroDefenseTicks >= 4,
          hot: (encounters >= 3 && pressureTicks >= 4) || closeTicks >= 5,
          attacker: rec.lastAttacker || attacker || '',
          defender: rec.lastDefender || defender || '',
          winner: rec.lastWinner || winner || '',
          loser: rec.lastLoser || loser || ''
        };
      } catch(e) { return null; }
    }

    function __ttsStoryPair(a, b) {
      try {
        const aa = __ttsSmartName(a, '').trim();
        const bb = __ttsSmartName(b, '').trim();
        if (!aa && !bb) return '';
        return [aa, bb].filter(Boolean).sort((x, y) => String(x).localeCompare(String(y), 'es')).join('|');
      } catch(e) { return ''; }
    }

    function __ttsStoryPairKeyFromCtx(channel, type, ctx) {
      try {
        const t = String(type || '').trim();
        if (channel === 'follow') {
          const other = __ttsSmartName(ctx && (ctx.otherName || ctx.who), '').trim();
          return other ? ('duel:' + other) : '';
        }
        const attacker = __ttsSmartName(ctx && ctx.attacker, '').trim();
        const defender = __ttsSmartName(ctx && ctx.defender, '').trim();
        const winner = __ttsSmartName(ctx && ctx.winner, '').trim();
        const loser = __ttsSmartName(ctx && ctx.loser, '').trim();
        const pair = __ttsStoryPair(attacker || winner, defender || loser);
        if (!pair) return '';
        if (t === 'leaderChange') return 'lead:' + pair;
        return 'duel:' + pair;
      } catch(e) { return ''; }
    }

    function __ttsStoryKey(channel, type, ctx) {
      try {
        const t = String(type || '').trim();
        if (channel === 'follow') {
          if (t === 'bestlap') return 'time:' + __ttsSmartName(ctx && ctx.pilot, 'self');
          if (t === 'ritmo_up' || t === 'ritmo_down') return 'pace:' + t;
          return __ttsStoryPairKeyFromCtx(channel, t, ctx);
        }
        if (t === 'record' || t === 'qualiBest') return 'time:' + __ttsSmartName(ctx && ctx.pilot, 'pilot');
        if (t === 'qualiPole') return 'pole:' + __ttsStoryPair(__ttsSmartName(ctx && ctx.p1, ''), __ttsSmartName(ctx && ctx.p2, ''));
        if (t === 'top3') return 'top3:' + [__ttsSmartName(ctx && ctx.p1, ''), __ttsSmartName(ctx && ctx.p2, ''), __ttsSmartName(ctx && ctx.p3, '')].filter(Boolean).join('|');
        if (t === 'train') return 'train:' + [__ttsSmartName(ctx && ctx.p2, ''), __ttsSmartName(ctx && ctx.p3, ''), __ttsSmartName(ctx && ctx.p4, '')].filter(Boolean).join('|');
        if (t === 'gap') return 'gap:' + __ttsStoryPair(__ttsSmartName(ctx && ctx.front, ''), __ttsSmartName(ctx && ctx.back, ''));
        if (t === 'pass') return 'pass:' + __ttsStoryPair(__ttsSmartName(ctx && ctx.winner, ''), __ttsSmartName(ctx && ctx.loser, '')) + ':P' + String((ctx && ctx.newPos) || '');
        return __ttsStoryPairKeyFromCtx(channel, t, ctx);
      } catch(e) { return ''; }
    }

    function __ttsStoryTrack(channel, type, ctx) {
      try {
        __ttsStoryCleanup(channel);
        const bag = __ttsStoryBag(channel);
        if (!bag) return { status:'fresh', trend:'flat', streak:1, key:'', pairKey:'', gapNum:NaN, prev:null, resolvedFrom:null };
        const key = __ttsStoryKey(channel, type, ctx);
        const pairKey = __ttsStoryPairKeyFromCtx(channel, type, ctx);
        const prev = (key && bag.get(key)) || null;
        const prevPair = (pairKey && bag.get(pairKey)) || null;
        const basePrev = prev || prevPair || null;
        const now = Date.now();
        const gapRaw = (ctx && (ctx.sec || ctx.gapStr || ctx.toSec || ctx.fromSec || ctx.gap || ctx.delta)) || '';
        const gapNum = __ttsSmartNum(gapRaw);
        let trend = 'flat';
        if (basePrev && isFinite(gapNum) && isFinite(Number(basePrev.gapNum))) {
          const prevGap = Number(basePrev.gapNum);
          if (gapNum < (prevGap - 0.05)) trend = 'closing';
          else if (gapNum > (prevGap + 0.08)) trend = 'opening';
          else trend = 'steady';
        }
        const ageMs = basePrev ? (now - Number(basePrev.at || 0)) : 999999;
        let streak = 1;
        let status = 'fresh';
        if (basePrev && ageMs < 28000) {
          streak = Number(basePrev.streak || 1) + 1;
          if (trend === 'closing' && streak >= 4) status = 'boiling';
          else if (trend === 'closing' && streak >= 2) status = 'escalating';
          else if (trend === 'opening' && streak >= 2) status = 'cooling';
          else if (streak >= 4) status = 'ongoing';
          else status = 'continuing';
        }
        let resolvedFrom = null;
        if ((type === 'pass' || type === 'leaderChange') && prevPair && ageMs < 32000 && Number(prevPair.streak || 0) >= 2) {
          resolvedFrom = Object.assign({}, prevPair);
          status = Number(prevPair.streak || 0) >= 4 ? 'resolved_hot' : 'resolved';
          streak = Number(prevPair.streak || 1);
        }
        const rivalMeta = __ttsRivalTouch(channel, pairKey || key, type, ctx || {}, {
          status,
          trend,
          streak,
          gapNum: isFinite(gapNum) ? gapNum : NaN,
          resolved: !!resolvedFrom
        });
        const rec = {
          at: now,
          type: String(type || ''),
          status,
          trend,
          streak,
          gapNum: isFinite(gapNum) ? gapNum : NaN,
          names: {
            attacker: __ttsSmartName(ctx && ctx.attacker, ''),
            defender: __ttsSmartName(ctx && ctx.defender, ''),
            winner: __ttsSmartName(ctx && ctx.winner, ''),
            loser: __ttsSmartName(ctx && ctx.loser, ''),
            other: __ttsSmartName(ctx && (ctx.otherName || ctx.who), ''),
            pilot: __ttsSmartName(ctx && ctx.pilot, '')
          },
          pos: String((ctx && (ctx.pos || ctx.newPos || ctx.oldPos)) || ''),
          resolved: !!resolvedFrom,
          rivalMeta: rivalMeta || null
        };
        if (key) bag.set(key, rec);
        if (pairKey) bag.set(pairKey, rec);
        return { key, pairKey, status, trend, streak, gapNum, prev: basePrev, resolvedFrom, ageMs, rivalMeta: rivalMeta || null };
      } catch(e) {
        return { status:'fresh', trend:'flat', streak:1, key:'', pairKey:'', gapNum:NaN, prev:null, resolvedFrom:null };
      }
    }

    function __ttsSmartPick(arr, key) {
      try {
        if (!Array.isArray(arr) || !arr.length) return '';
        return String(__ttsGenPick(arr, 'smart:' + String(key || 'k')) || arr[0] || '');
      } catch(e) { return (Array.isArray(arr) && arr[0]) ? String(arr[0]) : ''; }
    }

    function __ttsSmartClean(s) {
      try {
        let out = String(s || '').replace(/\s+/g, ' ').trim();
        out = out.replace(/\s+,/g, ',').replace(/\s+\./g, '.');
        out = out.replace(/,\s*,/g, ',').replace(/\.\s*\./g, '.');
        out = out.replace(/\s+:/g, ':').replace(/\s+;/g, ';');
        return spotterSanitizeText(out);
      } catch(e) { return String(s || '').trim(); }
    }

    function __ttsSmartName(v, fallback) {
      try {
        const s = safeRacerName(v || '') || '';
        return s || String(fallback || '');
      } catch(e) { return String(v || fallback || ''); }
    }

    function __ttsSmartNum(v) {
      try {
        if (typeof v === 'number' && isFinite(v)) return v;
        const s = String(v == null ? '' : v).trim();
        if (!s) return NaN;
        if (/\+?\s*\d+\s*v/i.test(s) || /m[aá]s\s+\d+\s+vueltas?/i.test(s)) return 99;
        const m = s.match(/-?\d+(?:[\.,]\d+)?/);
        if (!m) return NaN;
        return Number(String(m[0]).replace(',', '.'));
      } catch(e) { return NaN; }
    }

    function __ttsSmartGapBand(sec) {
      const s = Number(sec);
      if (!isFinite(s)) return 'unknown';
      if (s >= 10) return 'lap';
      if (s <= 0.12) return 'knife';
      if (s <= 0.22) return 'close';
      if (s <= 0.45) return 'tight';
      if (s <= 0.90) return 'mid';
      return 'open';
    }

    function __ttsSmartGapSpeech(ctx) {
      try {
        const raw = ctx && (ctx.sec || ctx.gapStr || ctx.toSec || ctx.fromSec || ctx.gap || ctx.delta || '');
        const s = String(raw || '').trim();
        if (s) return s;
      } catch(e) {}
      return '';
    }

    function __ttsSmartSession() {
      try {
        const t = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
        if (t === 'FINAL' || t === 'MANGA' || t === 'TRAIN') return t;
      } catch(e) {}
      return 'GEN';
    }

    function __ttsSmartProgressBand() {
      try {
        const rd = raceData || {};
        const leader = (rd.classification || []).find(r => Number(r && r.pos) === 1) || (rd.classification || [])[0];
        const lap = Number(leader && leader.lapcount) || 0;
        const clk = Number(rd.clockMs || rd.clock || 0) || 0;
        if (clk > 0 && clk < 70000) return 'start';
        if (lap <= 2) return 'start';
        if (lap >= 18) return 'late';
        if (lap >= 10) return 'mid';
      } catch(e) {}
      return 'mid';
    }

    function __ttsSmartRemember(channel, key, payload) {
      try {
        const bag = __ttsSmartState[channel];
        if (!bag || !key) return;
        bag.set(String(key), Object.assign({ at: Date.now() }, payload || {}));
      } catch(e) {}
    }

    function __ttsSmartRecall(channel, key) {
      try {
        const bag = __ttsSmartState[channel];
        if (!bag || !key) return null;
        return bag.get(String(key)) || null;
      } catch(e) { return null; }
    }

    function __ttsSmartTone(type, ctx, style, channel) {
      try {
        const sess = __ttsSmartSession();
        const prog = __ttsSmartProgressBand();
        const sec = __ttsSmartNum((ctx && (ctx.sec || ctx.toSec || ctx.gapStr)) || NaN);
        const band = __ttsSmartGapBand(sec);
        if (channel === 'follow') {
          if (type === 'blueflag') return 'urgent';
          if (type === 'bestlap') return 'celebrate';
          if (type === 'ritmo_down') return 'corrective';
          if (band === 'knife' || band === 'close') return 'urgent';
          return (sess === 'MANGA') ? 'precise' : 'command';
        }
        if (type === 'gap' || type === 'train') return 'technical';
        if (type === 'record' || type === 'qualiBest') return (style === 'engineer') ? 'technical' : 'celebrate';
        if (type === 'leaderChange' && prog === 'late') return 'dramatic';
        if (band === 'knife' || band === 'close') return (style === 'narrativo') ? 'dramatic' : 'urgent';
        if (style === 'picante') return 'spicy';
        if (style === 'engineer') return 'technical';
        if (style === 'narrativo') return 'dramatic';
      } catch(e) {}
      return 'neutral';
    }

    function __ttsSmartJoin(parts) {
      return __ttsSmartClean((parts || []).filter(Boolean).join(' '));
    }

    function __ttsSmartFollowBuilder(type, ctx) {
      try {
        const sess = __ttsSmartSession();
        const prog = __ttsSmartProgressBand();
        const tone = __ttsSmartTone(type, ctx, 'pro', 'follow');
        const other = __ttsSmartName(ctx && (ctx.otherName || ctx.who), 'el rival');
        const gapTxt = __ttsSmartGapSpeech(ctx);
        const sec = __ttsSmartNum(gapTxt);
        const band = __ttsSmartGapBand(sec);
        const story = __ttsStoryTrack('follow', type, ctx || {});
        const status = String((story && story.status) || 'fresh');
        const streak = Number((story && story.streak) || 1);
        const rival = (story && story.rivalMeta) || null;
        const memKey = type + ':' + other;
        const prev = __ttsSmartRecall('follow', memKey);
        let out = '';

        if (type === 'attack' || type === 'defense') {
          const openAttack = {
            urgent: ['Atención atrás.', 'Presión real atrás.', 'Ojo en espejos.'],
            command: ['Hay amenaza atrás.', 'Traes presión seria.', 'Viene a la carga atrás.'],
            precise: ['Hay rival en rango.', 'Presión medida atrás.', 'Rival cerrando por detrás.']
          };
          const openDefense = {
            urgent: ['Toca defender.', 'Posición bajo fuego.', 'Hay que cuidar la plaza.'],
            command: ['Hay que cubrir bien.', 'Cierra esa puerta.', 'No regales la cuerda.'],
            precise: ['Defensa en curso.', 'Posición apretada.', 'Riesgo controlado atrás.']
          };
          const storyAttack = {
            fresh: ['Primera alarma seria.', 'Arranca la presión.', 'Se activa el retrovisor.'],
            continuing: ['La presión no se va.', 'Sigue la misma sombra atrás.', 'Todavía no respiras.'],
            escalating: ['Cada vuelta viene más encima.', 'La distancia sigue cayendo.', 'Esto va creciendo.'],
            boiling: ['Ya está al borde del golpe.', 'La próxima frenada vale doble.', 'Esto huele a maniobra.'],
            cooling: ['Se abrió un poco, pero no está muerto.', 'Respira medio paso, no más.', 'Bajó tantito, sigue vivo.'],
            ongoing: ['Llevan rato en esta historia.', 'Es una pelea larga ya.', 'Esto ya tiene varias vueltas cocinándose.']
          };
          const storyDefense = {
            fresh: ['Hay que cerrar bien desde ya.', 'Todavía estás a tiempo de apagarlo.', 'Defensa desde esta vuelta.'],
            continuing: ['La plaza sigue caliente.', 'No te suelta nada.', 'La defensa sigue viva.'],
            escalating: ['Cada vuelta pide más manos.', 'La puerta está cada vez más cara.', 'Esto se va poniendo serio.'],
            boiling: ['Un error y cae la plaza.', 'Ya está en punto crítico.', 'Aquí no cabe una duda.'],
            cooling: ['Se enfría un poco, pero sigue al acecho.', 'Ganaste aire, no paz.', 'Todavía toca cuidarla.'],
            ongoing: ['Llevas varias vueltas defendiendo.', 'Es una defensa larga ya.', 'La posición se trabaja cada vuelta.']
          };
          const gapLine = gapTxt ? __ttsSmartPick([
            other + ' a ' + gapTxt + '.',
            'Gap ' + gapTxt + ' con ' + other + '.',
            other + ' viene a ' + gapTxt + '.'
          ], 'follow:gap:' + type + ':' + band) : '';
          const commandAttack = {
            knife: ['Una salida fina vale oro.', 'No abras ni media puerta.', 'Sin regalar el apex.'],
            close: ['Cubre la entrada y sal limpio.', 'Cierra bien y tracciona.', 'Todo con cabeza.'],
            tight: ['Buena tracción y no regales metros.', 'No te duermas en la salida.', 'Cuida la línea.'],
            mid: ['Sin errores y lo mantienes ahí.', 'Traza limpio y no lo invites.', 'Haz tu vuelta.'],
            open: ['Mantén el ritmo y no le des vida.', 'No aflojes la referencia.', 'Sigue fino.'],
            unknown: ['Todo limpio.', 'Con cabeza.', 'Sin tocar.'],
            lap: ['No estorbes el flujo.', 'Línea limpia.', 'Hazlo ordenado.']
          };
          const commandDefense = {
            knife: ['Cubre la puerta ya.', 'Cero regalo en la cuerda.', 'Todo fino y sin contacto.'],
            close: ['Frena derecho y sal limpio.', 'No abras el hueco.', 'Defiende con cabeza.'],
            tight: ['Línea limpia y buena salida.', 'No le regales tracción.', 'Cuida la plaza.'],
            mid: ['Que no te recorte más.', 'Sostén la posición.', 'Mantén la calma.'],
            open: ['Orden y ritmo.', 'Sin errores.', 'No te compliques.'],
            unknown: ['Defiende limpio.', 'Con calma.', 'Todo bajo control.'],
            lap: ['Sin bloquear.', 'Línea noble.', 'Hazlo limpio.']
          };
          const op = (type === 'attack') ? openAttack : openDefense;
          const cl = (type === 'attack') ? commandAttack : commandDefense;
          const st = (type === 'attack') ? storyAttack : storyDefense;
          const rivalLine = (rival && type === 'defense' && rival.heroic)
            ? __ttsSmartPick([
                'Esto ya pide defensa heroica.',
                'La plaza se está defendiendo con uñas y dientes.',
                'Ya es una defensa de oficio serio.'
              ], 'follow:rival:hero:' + other + ':' + streak)
            : (rival && type === 'attack' && rival.relentless)
              ? __ttsSmartPick([
                  'El acoso ya es constante.',
                  'No te da un respiro atrás.',
                  'La presión ya viene en serie.'
                ], 'follow:rival:relent:' + other + ':' + streak)
              : (rival && rival.recurrent)
                ? __ttsSmartPick([
                    'Otra vez ' + other + ' en el radar.',
                    'Este duelo ya tiene historia con ' + other + '.',
                    'No es la primera ronda con ' + other + '.'
                  ], 'follow:rival:recur:' + other + ':' + streak)
                : '';
          out = __ttsSmartJoin([
            __ttsSmartPick((op[tone] || op.command || op.urgent), 'follow:open:' + type + ':' + tone + ':' + status),
            gapLine,
            __ttsSmartPick((st[status] || st.continuing || st.fresh), 'follow:story:' + type + ':' + status + ':' + streak),
            rivalLine,
            __ttsSmartPick((cl[band] || cl.unknown), 'follow:cmd:' + type + ':' + band + ':' + prog)
          ]);
        } else if (type === 'fight') {
          const open = {
            urgent: ['Duelo a cuchillo.', 'Esto viene por nada.', 'Batalla de décimas.'],
            command: ['Pelea directa.', 'Dos autos en guerra limpia.', 'Hay duelo serio.'],
            precise: ['Separación mínima.', 'Pelea medida.', 'Todo en décimas.']
          };
          const storyFight = {
            fresh: ['La historia apenas prende.', 'Recién se forma el duelo.', 'Arranca la pelea.'],
            continuing: ['Siguen en la misma vuelta mental.', 'Nadie cede.', 'La pelea no se rompe.'],
            escalating: ['Cada paso es más apretado.', 'Va subiendo la tensión.', 'Se pone más fino.'],
            boiling: ['Ya vale oro la siguiente salida.', 'Esto puede cambiar de golpe.', 'No hay espacio para pestañear.'],
            cooling: ['Se relajó medio paso.', 'Se abrió poquito, pero sigue vivo.', 'Bajó un poco la temperatura.'],
            ongoing: ['Llevan varias curvas tallando esto.', 'Es una batalla larga.', 'Esto ya tiene continuidad seria.']
          };
          const core = [
            'La mejor salida manda.',
            'Aquí gana quien falle menos.',
            'Nada de contacto, puro trazo.',
            'Cada apex cuenta.'
          ];
          const rivalFight = (rival && rival.hot)
            ? __ttsSmartPick([
                'Esto ya parece el duelo del rato.',
                'Estos dos no se han soltado en buen rato.',
                'Ya es una rivalidad en caliente.'
              ], 'follow:fight:rival:hot:' + streak)
            : (rival && rival.recurrent)
              ? __ttsSmartPick([
                  'Otra vez se encuentran los mismos dos.',
                  'Esta pelea ya trae capítulos previos.',
                  'Es el mismo duelo de hace rato.'
                ], 'follow:fight:rival:recur:' + streak)
              : '';
          out = __ttsSmartJoin([
            __ttsSmartPick((open[tone] || open.command), 'follow:fight:open:' + tone + ':' + band),
            gapTxt ? __ttsSmartPick(['Gap ' + gapTxt + '.', 'A ' + gapTxt + '.', 'Separación ' + gapTxt + '.'], 'follow:fight:gap:' + band) : '',
            __ttsSmartPick((storyFight[status] || storyFight.continuing), 'follow:fight:story:' + status + ':' + streak),
            rivalFight,
            __ttsSmartPick(core, 'follow:fight:core:' + prog)
          ]);
        } else if (type === 'ritmo_up' || type === 'ritmo_down') {
          const delta = Math.max(1, Math.round(Math.abs(Number(ctx && ctx.deltaMs) || 0)));
          const big = delta >= 120;
          const open = (type === 'ritmo_up')
            ? (big ? ['Ahí está la ganancia buena.', 'Ese recorte sí pesa.', 'Subida clara de ritmo.'] : ['Ritmo arriba.', 'Pequeña mejora.', 'Algo se ganó.'])
            : (big ? ['Se fue tiempo serio.', 'Ahí se escapó la vuelta.', 'Caída clara de ritmo.'] : ['Se perdió un poco.', 'Vuelta más lenta.', 'Ojo con el ritmo.']);
          const core = (type === 'ritmo_up')
            ? [
                'Recortaste ' + delta + ' milisegundos.',
                'Ganaste ' + delta + ' milisegundos.',
                'Hay mejora de ' + delta + ' milisegundos.'
              ]
            : [
                'Perdiste ' + delta + ' milisegundos.',
                'Se fueron ' + delta + ' milisegundos.',
                'Cedes ' + delta + ' milisegundos.'
              ];
          const close = (type === 'ritmo_up')
            ? ['Repite esa vuelta.', 'Misma receta.', 'Esa línea sí sirve.']
            : ['Respira y vuelve al plan.', 'Recupera la trazada.', 'Sin castigar de más.'];
          out = __ttsSmartJoin([
            __ttsSmartPick(open, 'follow:ritmo:' + type + ':open:' + big),
            __ttsSmartPick(core, 'follow:ritmo:' + type + ':core:' + delta),
            __ttsSmartPick(close, 'follow:ritmo:' + type + ':close:' + prog)
          ]);
        } else if (type === 'bestlap') {
          const best = String((ctx && ctx.best) || '').trim();
          const fresh = !!(prev && String(prev.best || '') !== best);
          const storyBest = {
            fresh: ['Tiempo de referencia.', 'Eso pone el tono.', 'Ahí está la vuelta buena.'],
            continuing: ['Sigue encontrando ritmo.', 'Encadena vueltas fuertes.', 'Mantiene la mano fina.'],
            ongoing: ['Ya son varias vueltas buenas seguidas.', 'Trae racha de ritmo serio.', 'El ritmo está bien amarrado.']
          };
          out = __ttsSmartJoin([
            __ttsSmartPick(fresh ? ['Referencia nueva.', 'Mejor vuelta.', 'Vueltota buena.'] : ['Otra vuelta fuerte.', 'Sigue el ritmo bueno.', 'Vuelta de referencia.'], 'follow:bestlap:open:' + fresh),
            best ? __ttsSmartPick([best + '.', 'Marca ' + best + '.', 'Tiempo ' + best + '.'], 'follow:bestlap:core:' + best) : '',
            __ttsSmartPick((storyBest[status] || storyBest.continuing), 'follow:bestlap:story:' + status),
            __ttsSmartPick(['Quédate ahí.', 'Eso sí sirve.', 'Muy bien, repítelo.'], 'follow:bestlap:close:' + prog)
          ]);
        } else if (type === 'blueflag') {
          const who = __ttsSmartName(ctx && ctx.who, 'el líder');
          const open = ['Bandera azul.', 'Azul.', 'Tráfico para ti.'];
          const core = [
            'Viene ' + who + '.',
            'Encima llega ' + who + '.',
            'Ya está ahí ' + who + '.'
          ];
          const close = ['Dale pista limpia.', 'Sin estorbar.', 'Suéltalo limpio.'];
          out = __ttsSmartJoin([
            __ttsSmartPick(open, 'follow:blue:open'),
            __ttsSmartPick(core, 'follow:blue:core:' + who),
            __ttsSmartPick(close, 'follow:blue:close:' + sess)
          ]);
        }

        out = __ttsSmartClean(out);
        if (out) __ttsSmartRemember('follow', memKey, { text: out, best: String((ctx && ctx.best) || '') });
        return out;
      } catch(e) { return ''; }
    }

    function __ttsSmartAutoBuilder(type, ctx, style) {
      try {
        const sess = __ttsSmartSession();
        const prog = __ttsSmartProgressBand();
        const tone = __ttsSmartTone(type, ctx, style, 'auto');
        const styleKey = String(style || 'pro');
        const attacker = __ttsSmartName(ctx && ctx.attacker, 'el perseguidor');
        const defender = __ttsSmartName(ctx && ctx.defender, 'el de adelante');
        const winner = __ttsSmartName(ctx && ctx.winner, 'el rival');
        const loser = __ttsSmartName(ctx && ctx.loser, 'el rival');
        const pilot = __ttsSmartName(ctx && ctx.pilot, 'el piloto');
        const secTxt = __ttsSmartGapSpeech(ctx);
        const fromSec = String((ctx && ctx.fromSec) || '').trim();
        const toSec = String((ctx && ctx.toSec) || '').trim();
        const secNum = __ttsSmartNum(secTxt || toSec || fromSec);
        const band = __ttsSmartGapBand(secNum);
        const keyCore = [type, winner, loser, attacker, defender, pilot, (ctx && ctx.pos), (ctx && ctx.newPos), (ctx && ctx.oldPos)].join('|');
        const story = __ttsStoryTrack('auto', type, ctx || {});
        const status = String((story && story.status) || 'fresh');
        const streak = Number((story && story.streak) || 1);
        const rival = (story && story.rivalMeta) || null;
        const prev = __ttsSmartRecall('auto', keyCore);
        let out = '';

        if (type === 'leaderChange') {
          const late = (prog === 'late');
          const hotResolve = !!(story && (story.status === 'resolved_hot' || story.status === 'resolved'));
          const open = {
            dramatic: hotResolve ? ['Se concreta la presión por la punta.', 'Después de insistir, cae el liderato.', 'La historia arriba por fin revienta.'] : ['Cambio grande en la punta.', 'Se mueve el mando de la carrera.', 'Golpe fuerte arriba.'],
            spicy: hotResolve ? ['Tanto picar y cayó P1.', 'La presión cobró factura arriba.', 'Le cocinaron la punta y se la quitaron.'] : ['Se volteó la tortilla arriba.', 'Hay mano dura en la punta.', 'La carrera cambia de dueño.'],
            neutral: hotResolve ? ['Se concreta el cambio de líder.', 'La presión termina en relevo de punta.', 'Se resuelve la pelea por P1.'] : ['Cambio de líder.', 'Nueva punta.', 'Líder nuevo.']
          };
          const close = late
            ? ['Esto ya pesa en el cierre.', 'Movimiento serio para la recta final.', 'Golpe con olor a cierre.']
            : ['Todavía hay respuesta en carrera.', 'Esto sigue abierto.', 'Aún falta tela por cortar.'];
          const rivalLine = (rival && rival.recurrent)
            ? __ttsSmartPick([
                'Otra vez estos dos se mueven arriba.',
                'La pelea por P1 ya trae varios capítulos.',
                'No es la primera sacudida entre estos dos.'
              ], 'auto:leader:rival:' + winner + ':' + loser + ':' + streak)
            : '';
          out = __ttsSmartJoin([
            __ttsSmartPick((open[tone] || open.neutral), 'auto:leader:open:' + tone + ':' + status),
            __ttsSmartPick([
              winner + ' toma P1 y ' + loser + ' cae a segundo.',
              winner + ' pasa al frente. ' + loser + ' queda P2.',
              'Punta para ' + winner + '. ' + loser + ' a perseguir.'
            ], 'auto:leader:core:' + winner + ':' + loser),
            rivalLine,
            __ttsSmartPick(close, 'auto:leader:close:' + late + ':' + sess)
          ]);
        } else if (type === 'pass') {
          const newPos = String((ctx && ctx.newPos) || '');
          const oldPos = String((ctx && ctx.oldPos) || '');
          const weight = (newPos === '1') ? 'grande' : ((newPos === '2' || newPos === '3') ? 'podio' : 'normal');
          const hotResolve = !!(story && (story.status === 'resolved_hot' || story.status === 'resolved'));
          const open = {
            spicy: hotResolve ? ['Tanto insistir y cayó la plaza.', 'La presión terminó en rebase.', 'Se cocinó y se sirvió el pase.'] : (weight === 'grande' ? ['Rebase con premio mayor.', 'Golpe grande de posición.', 'Pase de peso.'] : ['Movimiento con colmillo.', 'Puesto ganado.', 'Adelantamiento bueno.']),
            technical: hotResolve ? ['Se concreta el cambio tras varias vueltas de presión.', 'La secuencia termina en rebase.', 'La presión sostenida da resultado.'] : ['Cambio de posición.', 'Ajuste en la tabla.', 'Puesto modificado.'],
            neutral: hotResolve ? ['Se concreta la maniobra.', 'Después de varias vueltas, cae el cambio.', 'La presión por fin se traduce en rebase.'] : ['Rebase confirmado.', 'Cambio de posición.', 'Puesto ganado.']
          };
          const close = (weight === 'podio')
            ? ['Eso mete presión por trofeo.', 'Zona grande de la carrera.', 'Puesto que vale podio.']
            : (weight === 'grande')
              ? ['Eso cambia la película completa.', 'Movimiento que reordena todo.', 'Cambio clave arriba.']
              : ['La pelea sigue viva.', 'No termina ahí.', 'Todavía hay respuesta.'];
          const rivalLine = (rival && rival.recurrent)
            ? __ttsSmartPick([
                'Esto ya venía cocinándose entre los mismos dos.',
                'Otra vez se cruzan los protagonistas de este duelo.',
                'La rivalidad terminó cobrando la plaza.'
              ], 'auto:pass:rival:' + winner + ':' + loser + ':' + streak)
            : '';
          out = __ttsSmartJoin([
            __ttsSmartPick((open[tone] || open.neutral), 'auto:pass:open:' + tone + ':' + weight + ':' + status),
            __ttsSmartPick([
              winner + ' sube a P' + newPos + ' y ' + loser + ' baja a P' + oldPos + '.',
              'P' + newPos + ' para ' + winner + '. ' + loser + ' cae a P' + oldPos + '.',
              winner + ' gana la plaza. ' + loser + ' ahora es P' + oldPos + '.'
            ], 'auto:pass:core:' + winner + ':' + loser + ':' + newPos),
            rivalLine,
            __ttsSmartPick(close, 'auto:pass:close:' + weight + ':' + prog)
          ]);
        } else if (type === 'battle' || type === 'battlePodium') {
          const pos = String((ctx && ctx.pos) || '');
          const isPod = (type === 'battlePodium');
          const openFresh = isPod
            ? ['Podio en juego.', 'Zona de trofeo bajo presión.', 'Hay guerra por el podio.']
            : ['Batalla directa.', 'Duelo en posición.', 'Pelea abierta en pista.'];
          const storyLine = {
            fresh: ['Apenas prende la historia.', 'Esto recién se forma.', 'Empieza la presión.'],
            continuing: ['Siguen pegados vuelta a vuelta.', 'Nadie rompe el duelo.', 'La pelea sigue viva.'],
            escalating: ['La presión viene subiendo.', 'Cada vuelta se acercan más.', 'Esto se está apretando.'],
            boiling: ['Ya está en punto de ebullición.', 'La siguiente salida puede decidirlo.', 'Esto ya huele a maniobra.'],
            cooling: ['Se abrió un poco, pero no se murió.', 'Baja tantito la temperatura.', 'Respiran medio paso, nada más.'],
            ongoing: ['Llevan rato escribiendo esta pelea.', 'Es una historia larga en pista.', 'Esto ya trae varias vueltas encima.']
          };
          const mid = [
            attacker + ' presiona a ' + defender + '.',
            defender + ' aguanta y ' + attacker + ' sigue encima.',
            attacker + ' ya está en rango de ' + defender + '.'
          ];
          const close = (band === 'knife' || band === 'close')
            ? ['Esto se decide por milímetros.', 'La siguiente salida puede cambiarlo.', 'No hay aire entre ellos.']
            : ['Gap ' + (secTxt || 'corto') + '.', 'Separación ' + (secTxt || 'corta') + '.', 'Todo sigue vivo ahí.'];
          const rivalryLine = (rival && rival.hot)
            ? __ttsSmartPick([
                'Ya es el duelo caliente del momento.',
                'Estos dos ya traen una pelea con memoria.',
                'La rivalidad está en punto de ebullición.'
              ], 'auto:battle:rival:hot:' + attacker + ':' + defender + ':' + streak)
            : (rival && rival.recurrent)
              ? __ttsSmartPick([
                  'Otra vez aparecen los mismos protagonistas.',
                  'Este duelo ya suma varios capítulos.',
                  'No se han soltado en buen rato.'
                ], 'auto:battle:rival:recur:' + attacker + ':' + defender + ':' + streak)
              : '';
          out = __ttsSmartJoin([
            __ttsSmartPick(openFresh, 'auto:battle:open:' + type + ':' + pos + ':' + status),
            __ttsSmartPick(mid, 'auto:battle:mid:' + attacker + ':' + defender),
            __ttsSmartPick((storyLine[status] || storyLine.continuing), 'auto:battle:story:' + status + ':' + streak),
            rivalryLine,
            (pos ? __ttsSmartPick(['Es pelea por P' + pos + '.', 'Todo enfocado en P' + pos + '.', 'La cámara está en P' + pos + '.'], 'auto:battle:pos:' + pos) : ''),
            __ttsSmartPick(close, 'auto:battle:close:' + band + ':' + secTxt)
          ]);
        } else if (type === 'closing' || type === 'pressure') {
          const deltaNarr = (fromSec && toSec) ? ['De ' + fromSec + ' a ' + toSec + '.', 'Ahora el gap es ' + toSec + '.', 'Recorte hasta ' + toSec + '.'] : (secTxt ? ['Gap ' + secTxt + '.', 'A ' + secTxt + '.', 'Separación ' + secTxt + '.'] : ['La diferencia cae.', 'La presión sube.', 'Se aprieta la historia.']);
          const open = (type === 'closing')
            ? ['Se viene cerrando.', 'El perseguidor recorta.', 'Esto se aprieta.']
            : ['Presión real.', 'No hay margen adelante.', 'La defensa carga espejos.'];
          const storyLine = {
            fresh: ['Arranca la persecución.', 'Se enciende la cacería.', 'Primera señal fuerte de recorte.'],
            continuing: ['Sigue el martillo detrás.', 'La presión no afloja.', 'Viene insistiendo sin pausa.'],
            escalating: ['Cada vuelta llega más cerca.', 'La diferencia cae y cae.', 'Esto va en subida clara de tensión.'],
            boiling: ['Ya está a nada del golpe.', 'Esto huele a maniobra inmediata.', 'La siguiente curva puede ser clave.'],
            cooling: ['Se enfrió un poco la carga.', 'El frente ganó medio respiro.', 'Se abre apenas, no se termina.'],
            ongoing: ['Es una presión larga ya.', 'Llevan varias vueltas en esta historia.', 'Esto viene cocinándose desde hace rato.']
          };
          const close = (band === 'knife' || band === 'close')
            ? ['Ya huele a pase.', 'La siguiente curva importa mucho.', 'Esto puede cambiar muy pronto.']
            : ['Todavía toca sostenerlo.', 'La defensa sigue trabajando.', 'Esto no está resuelto.'];
          const rivalryLine = (rival && rival.heroic)
            ? __ttsSmartPick([
                'Defensa heroica de ' + defender + '.',
                defender + ' lo está aguantando con oficio.',
                defender + ' sigue resistiendo con mucha cabeza.'
              ], 'auto:closing:rival:hero:' + defender + ':' + streak)
            : (rival && rival.relentless)
              ? __ttsSmartPick([
                  attacker + ' ya viene martillando vuelta tras vuelta.',
                  'La presión de ' + attacker + ' ya es sostenida.',
                  attacker + ' no ha quitado el dedo del renglón.'
                ], 'auto:closing:rival:relent:' + attacker + ':' + streak)
              : (rival && rival.recurrent)
                ? __ttsSmartPick([
                    'Estos dos vuelven a encontrarse en pista.',
                    'La misma pelea reaparece otra vez.',
                    'Otra ronda entre ' + attacker + ' y ' + defender + '.'
                  ], 'auto:closing:rival:recur:' + attacker + ':' + defender + ':' + streak)
                : '';
          out = __ttsSmartJoin([
            __ttsSmartPick(open, 'auto:closing:open:' + type + ':' + tone),
            __ttsSmartPick([
              attacker + ' recorta sobre ' + defender + '.',
              defender + ' ya siente a ' + attacker + '.',
              attacker + ' se mete en la pelea con ' + defender + '.'
            ], 'auto:closing:mid:' + attacker + ':' + defender),
            __ttsSmartPick(deltaNarr, 'auto:closing:delta:' + fromSec + ':' + toSec + ':' + secTxt),
            __ttsSmartPick((storyLine[status] || storyLine.continuing), 'auto:closing:story:' + status + ':' + streak),
            rivalryLine,
            __ttsSmartPick(close, 'auto:closing:close:' + band + ':' + prog)
          ]);
        } else if (type === 'gap') {
          const front = __ttsSmartName(ctx && ctx.front, 'adelante');
          const back = __ttsSmartName(ctx && ctx.back, 'atrás');
          const open = (tone === 'technical') ? ['Lectura técnica.', 'Dato de referencia.', 'Número en pista.'] : ['Gap actual.', 'Diferencia registrada.', 'Separación medida.'];
          out = __ttsSmartJoin([
            __ttsSmartPick(open, 'auto:gap:open:' + tone),
            __ttsSmartPick([
              front + ' sobre ' + back + ', a ' + (secTxt || 'gap no disponible') + '.',
              front + ' mantiene ' + (secTxt || 'el margen') + ' sobre ' + back + '.',
              'La diferencia entre ' + front + ' y ' + back + ' es ' + (secTxt || 'corta') + '.'
            ], 'auto:gap:mid:' + front + ':' + back + ':' + secTxt)
          ]);
        } else if (type === 'top3') {
          const p1 = __ttsSmartName(ctx && ctx.p1, 'P1');
          const p2 = __ttsSmartName(ctx && ctx.p2, 'P2');
          const p3 = __ttsSmartName(ctx && ctx.p3, 'P3');
          out = __ttsSmartJoin([
            __ttsSmartPick(['Top tres actual.', 'Así va el podio.', 'Corte del frente.'], 'auto:top3:open:' + prog),
            __ttsSmartPick([
              'P1 ' + p1 + ', P2 ' + p2 + ', P3 ' + p3 + '.',
              p1 + ' manda, ' + p2 + ' persigue y ' + p3 + ' cierra el top tres.',
              'El frente dice ' + p1 + ', luego ' + p2 + ' y después ' + p3 + '.'
            ], 'auto:top3:mid:' + p1 + ':' + p2 + ':' + p3)
          ]);
        } else if (type === 'train') {
          const p2 = __ttsSmartName(ctx && ctx.p2, 'P2');
          const p3 = __ttsSmartName(ctx && ctx.p3, 'P3');
          const p4 = __ttsSmartName(ctx && ctx.p4, 'P4');
          const trainStory = {
            fresh: ['Tren formado.', 'Grupo compacto.', 'Paquete cerrado.'],
            continuing: ['El tren sigue sin romperse.', 'Siguen tres autos cosidos.', 'El paquete no suelta tensión.'],
            ongoing: ['Ya es un tren sostenido de tres.', 'Llevan varias vueltas en un mismo vagón.', 'Esto ya es un tren largo y vivo.'],
            boiling: ['Tren hirviendo.', 'El tren ya está al borde del cambio.', 'Ese grupo está en máxima tensión.'],
            cooling: ['El tren respira un poco.', 'Se estira medio paso el paquete.', 'El grupo se afloja apenas.']
          };
          out = __ttsSmartJoin([
            __ttsSmartPick((trainStory[status] || trainStory.fresh), 'auto:train:open:' + tone + ':' + status + ':' + streak),
            __ttsSmartPick([
              p2 + ', ' + p3 + ' y ' + p4 + ' van en una sola historia.',
              'P2 a P4 vienen comprimidos con ' + p2 + ' al frente del grupo.',
              p2 + ' encabeza el paquete y ' + p3 + ' con ' + p4 + ' no se despegan.'
            ], 'auto:train:mid:' + p2 + ':' + p3 + ':' + p4),
            __ttsSmartPick(['Cualquier error cambia todo.', 'Nadie puede pestañear ahí.', 'Todo está vivo en ese tren.'], 'auto:train:close:' + prog + ':' + status)
          ]);
        } else if (type === 'record' || type === 'qualiBest') {
          const best = String((ctx && ctx.best) || '').trim();
          const open = (type === 'qualiBest') ? ['En clasificación hay tiempo fuerte.', 'La quali se mueve.', 'Sube la referencia de manga.'] : ['El reloj habla.', 'Nueva referencia.', 'Tiempo de peso.'];
          const close = (styleKey === 'engineer')
            ? ['Dato premium de ritmo.', 'Referencia útil para el resto.', 'Tiempo de mucho valor.']
            : ['Vuelta que pesa.', 'Tiempo serio.', 'Eso sí mete presión.'];
          const timeStory = {
            fresh: ['Marca que ordena la sesión.', 'Tiempo que pone tono.', 'Referencia fresca en pantalla.'],
            continuing: ['Sigue encontrando décimas.', 'No deja de afinar el reloj.', 'Mantiene la mano sobre la referencia.'],
            ongoing: ['Trae una racha muy fina.', 'Ya son varias vueltas con filo.', 'Viene construyendo una sesión fuerte.']
          };
          out = __ttsSmartJoin([
            __ttsSmartPick(open, 'auto:record:open:' + type + ':' + styleKey),
            __ttsSmartPick([
              pilot + ' marca ' + best + '.',
              best ? (pilot + ' deja ' + best + '.') : (pilot + ' pone la referencia.'),
              best ? ('La vuelta de ' + pilot + ' queda en ' + best + '.') : ('La referencia es de ' + pilot + '.')
            ], 'auto:record:mid:' + type + ':' + pilot + ':' + best),
            __ttsSmartPick((timeStory[status] || timeStory.continuing), 'auto:record:story:' + status + ':' + pilot),
            __ttsSmartPick(close, 'auto:record:close:' + styleKey + ':' + prog)
          ]);
        } else if (type === 'qualiPole') {
          const p1 = __ttsSmartName(ctx && ctx.p1, 'P1');
          const p2 = __ttsSmartName(ctx && ctx.p2, 'P2');
          out = __ttsSmartJoin([
            __ttsSmartPick(['Pole en juego.', 'Nada cerrado en la pole.', 'Clasificación caliente.'], 'auto:pole:open:' + band),
            __ttsSmartPick([
              p1 + ' contra ' + p2 + ' a ' + (secTxt || 'muy poco') + '.',
              'La pole provisional es de ' + p1 + ' con ' + p2 + ' a ' + (secTxt || 'nada') + '.',
              p1 + ' manda la quali y ' + p2 + ' aprieta a ' + (secTxt || 'muy poco') + '.'
            ], 'auto:pole:mid:' + p1 + ':' + p2 + ':' + secTxt),
            __ttsSmartPick(['Esto se decide fino.', 'Nada de margen en la pole.', 'Todavía puede cambiar.'], 'auto:pole:close:' + prog)
          ]);
        }

        out = __ttsSmartClean(out);
        if (out) __ttsSmartRemember('auto', keyCore, { text: out });
        return out;
      } catch(e) { return ''; }
    }

    function ttsSmartComposeFollow(type, ctx) {

      try {
        return __ttsSmartFollowBuilder(String(type || '').trim(), ctx || {});
      } catch(e) { return ''; }
    }

    function ttsSmartComposeAuto(type, ctx, style) {
      try {
        return __ttsSmartAutoBuilder(String(type || '').trim(), ctx || {}, String(style || 'pro'));
      } catch(e) { return ''; }
    }

    function msgv2Compose(type, ctx) {
      try {
        const t = String(type || '').trim();
        const bank = (MSGV2 && MSGV2[t]) ? MSGV2[t] : null;
        if (!bank) return '';

        const pk = msgv2PilotKey(ctx);
        const now = Date.now();

        const urgent = (t === 'blueflag');

        // Motor contextual inteligente: decide que decir segun evento, gap y continuidad
        try {
          const smartMsg = ttsSmartComposeFollow(t, ctx || {});
          if (smartMsg) return smartMsg;
        } catch(e) {}

        // Motor generativo v1 para Follow/Spotter: mas variedad sin escribir miles a mano
        try {
          const genMsg = ttsGenMsgv2Compose(t, ctx || {});
          if (genMsg) return genMsg;
        } catch(e) {}

        // SPECIAL BLUEFLAG COMPOSE (más variedad, sin tocar lógica de detección)
        if (t === 'blueflag') {
          try {
            const seq0 = Number(MSGV2_BLUE_SEQ.get(pk) || 0) + 1;
            MSGV2_BLUE_SEQ.set(pk, seq0);

            // rota 3 plantillas para que NO suene igual
            const mode = seq0 % 3; // 0,1,2
            const saltBase = String(seq0);

            function buildOnce(salt) {
              const a = msgv2PickSalt(bank.open || [], t, ctx, 'open', salt + ':o').trim();
              const b = msgv2PickSalt(bank.info || [], t, ctx, 'info', salt + ':i').trim();
              const c = msgv2PickSalt(bank.act  || [], t, ctx, 'act',  salt + ':a').trim();
              const d = msgv2PickSalt(bank.end  || [], t, ctx, 'end',  salt + ':e').trim();

              let parts = [];
              if (mode === 0) parts = [a, b, d];        // info + cierre
              else if (mode === 1) parts = [a, b, c];   // info + acción
              else parts = [a, c, d];                   // acción + cierre

              let out = parts.filter(Boolean).join(' ').replace(/\s+/g, ' ').trim();
              out = spotterSanitizeText(out);
              return out;
            }

            let out = buildOnce(saltBase);

            // dedupe por piloto+tipo (si sale igual, reintenta con otro salt)
            const k = msgv2Key(t, ctx, 'full');
            const last = MSGV2_LAST.get(k) || '';
            if (out && out === last) {
              out = buildOnce(saltBase + ':r1');
              if (out && out === last) out = buildOnce(saltBase + ':r2');
            }

            if (out) { MSGV2_LAST.set(msgv2Key(t, ctx, 'full'), out); return out; }
          } catch(e) {}
        }


        function pickDifferent(arr, part, prevTxt) {
          if (!Array.isArray(arr) || !arr.length) return '';
          let out = '';
          for (let i = 0; i < 4; i++) {
            out = msgv2Pick(arr, t, ctx, part).trim();
            if (!prevTxt || out !== prevTxt) break;
          }
          return out;
        }

        // Probabilidades para compactar (menos repetición / menos "relleno")
        let pInfo = 0.75;
        let pEnd  = 0.45;
        if (urgent) { pInfo = 1.00; pEnd = 0.15; }
        if (t === 'bestlap') { pInfo = 0.10; pEnd = 0.70; }
        if (t === 'ritmo_up' || t === 'ritmo_down') { pInfo = 0.15; pEnd = 0.35; }

        for (let attempt = 0; attempt < 3; attempt++) {
          let a = msgv2Pick(bank.open || [], t, ctx, 'open').trim();
          let b = msgv2Pick(bank.info || [], t, ctx, 'info').trim();
          let c = msgv2Pick(bank.act  || [], t, ctx, 'act').trim();
          let d = msgv2Pick(bank.end  || [], t, ctx, 'end').trim();

          // Compactación
          if (b && Math.random() > pInfo) b = '';
          if (d && Math.random() > pEnd)  d = '';

          // Anti-repetición GLOBAL por piloto (aperturas y cierres)
          try {
            const prevO = MSGV2_LAST_OPEN.get(pk) || { txt:'', at:0 };
            if (a && prevO.txt === a && (now - prevO.at) < 8000) {
              a = pickDifferent(bank.open || [], 'open', a);
            }
          } catch(e) {}

          try {
            const prevE = MSGV2_LAST_END.get(pk) || { txt:'', at:0 };
            if (d && prevE.txt === d && (now - prevE.at) < 12000) {
              d = pickDifferent(bank.end || [], 'end', d);
              // si aún queda igual, mejor lo omitimos para no sonar repetido
              if (d && prevE.txt === d) d = '';
            }
          } catch(e) {}

          let out = [a, b, c, d].filter(Boolean).join(' ');
          out = out.replace(/\s+/g, ' ').trim();
          out = out.replace(/\s+\./g, '.').replace(/\s+,/g, ',');
          out = out.replace(/,\s*,/g, ',').replace(/\s+,\s+/g, ', ');

          // Sanitiza (anti-inglés) antes de comparar dedupe
          out = spotterSanitizeText(out);

          // Evita repetir EXACTAMENTE la misma frase por piloto+tipo
          const k = msgv2Key(t, ctx, 'full');
          const last = MSGV2_LAST.get(k) || '';
          if (out && out !== last) {
            MSGV2_LAST.set(k, out);

            // guarda global open/end si aplica
            try { if (a) MSGV2_LAST_OPEN.set(pk, { txt:a, at:now }); } catch(e) {}
            try { if (d) MSGV2_LAST_END.set(pk,  { txt:d, at:now }); } catch(e) {}

            return out;
          }
        }

        // fallback
        const k = msgv2Key(t, ctx, 'full');
        const out = spotterSanitizeText(msgv2Pick((bank.open || []), t, ctx, 'open').trim());
        if (out) { MSGV2_LAST.set(k, out); return out; }
        return '';
      } catch(e) { return ''; }
    }



    // =========================
    // AI AUTO-INTRO + FINISHERS (Auto Locutor)
    // - Se anuncian solo en Auto Locutor (sin piloto seleccionado)
    // =========================
    let __autoIntroSig = '';
    let __autoIntroDoneKeys = new Set();
    let __autoIntroRetryAt = 0;
    let __autoFinishSig = '';
    let __autoFinishPrevByKey = new Map();
    let __autoFinishAnnouncedByKey = new Set();
    let __autoFinishPhase = false;
    let __autoFinishSummarySig = '';
    let __autoFinishSummaryDone = false;

    // =========================
    // Auto Locutor - Ciclo de vida de carrera (silencio inteligente)
    // - En Auto Locutor: anuncia carrera + participantes y luego ESPERA a que arranque (sin hablar)
    // - Despus narra normal (RUNNING)
    // - Al terminar: entra a CLOSING (solo finalizo en Finales) y luego FINISHED (silencio hasta nueva carrera)
    // =========================
    let __autoPhase = 'IDLE'; // IDLE | WAIT_START | RUNNING | CLOSING | FINISHED
    let __autoLifeSig = '';
    let __autoStartedStable = 0;
    let __autoCloseStartedMs = 0;
    let __autoLastActivityMs = 0;
    let __autoLastMaxLap = 0;
    let __autoLastMaxTotalMs = 0;
    let __autoActiveKeys = new Set(); // pilotos que ya "arrancaron" (laps>0 o time>0)

    let __autoDbg = { phase:'IDLE', maxLap:0, maxTotalMs:0, dur:0, isFinal:false, idleMs:0, trend:'?' };

    function __autoDbgMs(ms){
      const n = Number(ms) || 0;
      if (!n) return '0';
      if (n < 1000) return String(n|0) + 'ms';
      return (n/1000).toFixed(1) + 's';
    }
    function __autoUpdateDebugStrip(){
      try{
        if (!document.body.classList.contains('debug')) return;
        const d = __autoDbg || {};
        const $ = (id)=>document.getElementById(id);
        const ph = String(d.phase||'-');
        const lap = String(Number(d.maxLap)||0);
        const t = __autoDbgMs(d.maxTotalMs);
        const dur = __autoDbgMs(d.dur);
        const fin = d.isFinal ? '1' : '0';
        const idle = __autoDbgMs(d.idleMs);
        const trend = String(d.trend||'?');
        if ($('dbgAutoPhase')) $('dbgAutoPhase').textContent = ph;
        if ($('dbgAutoLap')) $('dbgAutoLap').textContent = lap;
        if ($('dbgAutoT')) $('dbgAutoT').textContent = t;
        if ($('dbgAutoDur')) $('dbgAutoDur').textContent = dur;
        if ($('dbgAutoFinal')) $('dbgAutoFinal').textContent = fin;
        if ($('dbgAutoIdle')) $('dbgAutoIdle').textContent = idle;
        if ($('dbgAutoTrend')) $('dbgAutoTrend').textContent = trend;
      } catch(e) {}

    }

    function __autoNowMs() {
      try { return (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now(); }
      catch(e){ return Date.now(); }
    }

    function __autoResetLifecycle(raceName) {
      try {
        __autoLifeSig = String(raceName || '');
        __autoPhase = 'WAIT_START';
      try{ __autoDbg = { phase: __autoPhase, maxLap:0, maxTotalMs:0, dur: __autoGetDurMs(), isFinal:false, idleMs:0, trend:'?' }; __autoUpdateDebugStrip(); }catch(e){}
        __autoStartedStable = 0;
        __autoCloseStartedMs = 0;
        __autoLastActivityMs = __autoNowMs();
        __autoLastMaxLap = 0;
        __autoLastMaxTotalMs = 0;
        __autoActiveKeys = new Set();
      } catch(e) {}
    }

    function __autoGetDurMs() {
      try {
        const info = currentSessionInfo || {};
        const t = String(info.type || '').toUpperCase();
        const label = String(info.label || '').toUpperCase();
        const d = Number(info.durationMs) || 0;
        if (d > 0) return d;

        // fallback seguro
        if (t === 'FINAL_A' || label.includes('FINAL A')) return 6 * 60 * 1000;
        if (t.startsWith('FINAL') || label.includes('FINAL')) return 4 * 60 * 1000;
        if (t === 'MANGA' || t === 'QUALI' || t === 'TRAIN' || label.includes('MANGA') || label.includes('QUALI') || label.includes('TRAIN')) return 3 * 60 * 1000;
        return 0;
      } catch(e) { return 0; }
    }

    function __autoScanProgress(r) {
      try {
        const rows = (r && Array.isArray(r.classification)) ? r.classification : [];
        let maxLap = 0;
        let maxTotalMs = 0;
        let maxLastLapMs = 0;

        for (const row of rows) {
          if (!row) continue;
          const laps = Number(row.lapcount) || 0;
          const totalMs = getRowTotalMs(row) || 0;
          const lastLapMs = Number(row.lastLapMs) || 0;

          if (laps > maxLap) maxLap = laps;
          if (totalMs > maxTotalMs) maxTotalMs = totalMs;
          if (lastLapMs > maxLastLapMs) maxLastLapMs = lastLapMs;

          if (laps > 0 || totalMs > 0 || lastLapMs > 0) {
            const k = getPilotKey(row) || safeRacerName(row && row.racerName) || '';
            if (k) __autoActiveKeys.add(String(k));
          }
        }

        const bestMs = Number(r && (r.bestLapMs || r.bestLapMsRaw || r.bestLapTimeMs || r.bestLapMsValue)) || 0;
        const bestTime = Number(r && (r.bestLapTime || 0)) || 0;
        const bestAny = bestMs || bestTime;

        return { maxLap, maxTotalMs, maxLastLapMs, bestAny };
      } catch(e) {
        return { maxLap:0, maxTotalMs:0, maxLastLapMs:0, bestAny:0 };
      }
    }

    function __autoIsStarted(scan) {
      try {
        if (!scan) return false;
        const maxLap = Number(scan.maxLap) || 0;
        const maxTotalMs = Number(scan.maxTotalMs) || 0;
        const maxLastLapMs = Number(scan.maxLastLapMs) || 0;
        const bestAny = Number(scan.bestAny) || 0;

        const dur = __autoGetDurMs();

        // Arranque real (evita falsos positivos cuando el feed manda "03:00.xxx" antes de empezar)
        let startedNow = false;

        if (maxLap >= 1) startedNow = true;
        else if (maxLastLapMs > 0) startedNow = true;
        else if (bestAny > 0) startedNow = true;
        else if (maxTotalMs >= 1500) {
          // Si el tiempo ya viene pegado a la duracin objetivo y no hay laps/best/lastlap, NO arranc todava
          if (dur > 0 && maxTotalMs >= (dur - 2000)) startedNow = false;
          else startedNow = true;
        }

        if (startedNow) __autoStartedStable = Math.min(3, (__autoStartedStable || 0) + 1);
        else __autoStartedStable = 0;

        return (__autoStartedStable >= 2);
      } catch(e) {
        __autoStartedStable = 0;
        return false;
      }
    }

    function __autoUpdateLifecycle(r) {
      try {
        if (!r) return;

        const rn = String(r.raceName || '');
        if (!rn) return;

        // cambio de carrera -> reset (aunque por alguna razn el intro no haya hablado)
        if (rn !== __autoLifeSig) {
          __autoResetLifecycle(rn);
          return;
        }

        const now = __autoNowMs();
        const scan = __autoScanProgress(r);

        // actividad (evitar "silencio eterno" si siguen cambiando)
        const maxLap = Number(scan.maxLap) || 0;
        const maxTotalMs = Number(scan.maxTotalMs) || 0;

        const durDbg = __autoGetDurMs();
        const infoDbg = currentSessionInfo || {};
        const typeDbg = String(infoDbg.type || '').toUpperCase();
        const isFinalDbg = (typeDbg.startsWith('FINAL') || String(infoDbg.label||'').toUpperCase().includes('FINAL'));
        __autoDbg = {
          phase: __autoPhase,
          maxLap,
          maxTotalMs,
          dur: durDbg,
          isFinal: !!isFinalDbg,
          idleMs: now - (Number(__autoLastActivityMs) || 0),
          trend: '?'
        };
        const __lastMaxTotalMs = Number(__autoLastMaxTotalMs) || 0;
        const __diffTotalMs = maxTotalMs - __lastMaxTotalMs;
        const __trend = (__diffTotalMs > 600) ? 'UP' : (__diffTotalMs < -600) ? 'DOWN' : '~';
        try{ if (__autoDbg) __autoDbg.trend = __trend; }catch(e){}
        if (maxLap > (__autoLastMaxLap || 0) || Math.abs(__diffTotalMs) > 600) {
          __autoLastActivityMs = now;
          __autoLastMaxLap = maxLap;
          __autoLastMaxTotalMs = maxTotalMs;
        }

        __autoUpdateDebugStrip();

        // WAIT_START: no hablar hasta arrancar de verdad
        if (__autoPhase === 'WAIT_START') {
          if (__autoIsStarted(scan)) {
            __autoPhase = 'RUNNING';
            __autoLastActivityMs = now;
            try{ if (__autoDbg) __autoDbg.phase = __autoPhase; }catch(e){}
            __autoUpdateDebugStrip();
          }
          return;
        }

        const dur = __autoGetDurMs();
        if (!dur) return;

        // Detectar cierre / fin
        const info = currentSessionInfo || {};
        const type = String(info.type || '').toUpperCase();
        const isFinal = (type.startsWith('FINAL') || String(info.label||'').toUpperCase().includes('FINAL'));

        // Al cruzar el tiempo objetivo entramos en cierre
        if ((__autoPhase === 'RUNNING') && maxTotalMs >= dur) {
          if (isFinal) {
            __autoPhase = 'CLOSING';
            __autoCloseStartedMs = now;
            return;
          } else {
            // Manga: anunciar cierre + Top3 y luego silencio
            try { __autoAnnounceTop3Summary(r, 'Termin la clasificacin'); } catch(e) {}
            __autoPhase = 'FINISHED';
            __autoCloseStartedMs = now;
            return;
          }
        }

        // CLOSING: solo finalizo y luego silencio
        if (__autoPhase === 'CLOSING') {
          const activeCount = (__autoActiveKeys && __autoActiveKeys.size) ? __autoActiveKeys.size : 0;
          const announcedCount = (__autoFinishAnnouncedByKey && __autoFinishAnnouncedByKey.size) ? __autoFinishAnnouncedByKey.size : 0;

          // Si ya anunciamos a todos los que arrancaron, acab
          if (activeCount > 0 && announcedCount >= activeCount) {
            try { __autoAnnounceTop3Summary(r, 'Carrera terminada'); } catch(e) {}
            __autoPhase = 'FINISHED';
            return;
          }

          // Cierre inteligente: si ya no hay movimiento (ni laps ni totalMs), cerrar por inactividad
          const idleMs = now - (__autoLastActivityMs || now);
          const sinceCloseMs = __autoCloseStartedMs ? (now - __autoCloseStartedMs) : 0;

          // Caso comun: algunos no tienen totalMs o no cruzan "bonito" -> no te quedes atorado
          if (sinceCloseMs > 7000 && idleMs > 12000) {
            try { __autoAnnounceTop3Summary(r, 'Carrera terminada'); } catch(e) {}
            __autoPhase = 'FINISHED';
            return;
          }

          // Si ya casi todos estan anunciados, y no hay actividad, cerramos rapido
          if (activeCount > 0 && announcedCount >= Math.max(1, activeCount - 1) && idleMs > 8000) {
            try { __autoAnnounceTop3Summary(r, 'Carrera terminada'); } catch(e) {}
            __autoPhase = 'FINISHED';
            return;
          }

          // Failsafe: si ya pas mucho tiempo, acab
          if (__autoCloseStartedMs && sinceCloseMs > 70000) {
            try { __autoAnnounceTop3Summary(r, 'Carrera terminada'); } catch(e) {}
            __autoPhase = 'FINISHED';
            return;
          }
          return;
        }

        // FINISHED: silencio hasta carrera nueva
        if (__autoPhase === 'FINISHED') {
          return;
        }

        // Manga: si ya pas el tiempo y no hay actividad, acabar
        if (!isFinal && maxTotalMs >= dur) {
          const idleMs = now - (__autoLastActivityMs || now);
          if (idleMs > 8000) __autoPhase = 'FINISHED';
        }
      } catch(e) {}
    }

    function __buildParticipantsList(rows, maxNames=12) {
      try {
        if (!Array.isArray(rows)) return { names: [], extra: 0 };
        const seen = new Set();
        const names = [];
        for (const r of rows) {
          const nm = safeRacerName(r && r.racerName);
          if (!nm) continue;
          const k = nm.toLowerCase();
          if (seen.has(k)) continue;
          seen.add(k);
          names.push(nm);
        }
        const extra = Math.max(0, names.length - maxNames);
        return { names: names.slice(0, maxNames), extra };

    function __autoAnnounceTop3Summary(r, forcedLabel) {
      try {
        // Si el usuario est siguiendo a un piloto, NO anunciamos el Top 3 al finalizar.
        // Solo se anuncian los datos del piloto seguido (fin de sesin).
        if (selectedPilotKey) return;
        if (!r || !Array.isArray(r.classification) || !r.classification.length) return;

        const rn = String(r.raceName || '');
        if (!rn) return;

        if (rn !== __autoFinishSummarySig) {
          __autoFinishSummarySig = rn;
          __autoFinishSummaryDone = false;
        }
        if (__autoFinishSummaryDone) return;

        const info = currentSessionInfo || {};
        const type = String(info.type || '').toUpperCase();
        const isManga = (type === 'MANGA');
        const isFinal = (type === 'FINAL');

        const rows = r.classification.slice().filter(x => x && Number(x.pos || 0) > 0);
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const top = rows.slice(0,3);
        if (!top.length) return;

        let head = forcedLabel ? String(forcedLabel) : (isManga ? 'Termin la clasificacin.' : 'Carrera terminada.');
        if (!head.endsWith('.')) head += '.';

        const part = (row, idx) => {
          const nm = safeRacerName(row && row.racerName) || ('P' + (idx+1));
          const laps = Number(row && (row.lapcount ?? row.laps ?? 0)) || 0;
          const totalMs = getRowTotalMs(row) || 0;
          let s = (idx===0 ? ' Primero ' : idx===1 ? ' Segundo ' : ' Tercero ');
          s += nm + '.';
          if (laps > 0) s += ' ' + laps + ' vueltas.';
          if (totalMs > 0) s += ' ' + formatClockMs(totalMs) + '.';
          return s;
        };

        let msg = head + part(top[0],0);
        if (top[1]) msg += part(top[1],1);
        if (top[2]) msg += part(top[2],2);

        enqueueSpeech(msg, {
          key: 'auto_top3_finish_' + rn,
          priority: 99,
          cooldownMs: 0,
          dedupe: true,
          semanticCategory: 'finish',
          semanticThreshold: 0.90,
          semanticWindowMs: 60000
        });

        __autoFinishSummaryDone = true;
      } catch(e) {}
    }

      } catch(e) {
        return { names: [], extra: 0 };
      }
    }

    function __maybeAnnounceAutoIntro(r) {
      try {
        if (!r) return;
        // Al llegar carrera nueva: anuncia siempre (Auto Locutor o Seguimiento)

        // En Auto Locutor, si el usuario no ha tocado VOZ, la activamos en silencio para poder anunciar el titulo
        if (!voiceMasterEnabled) {
          try { if (!userVoiceOverride) setVoiceMaster(true, { silent:true, auto:true }); } catch(e) {}
        }
        if (!voiceMasterEnabled) return;

        const rn = String(r.raceName || '');
        if (!rn) return;

        const introKey = 'auto_intro_title_' + rn;
        const now = Date.now();

        // Si ya anunciamos exitosamente este titulo, no repetir
        if (rn === __autoIntroSig && __autoIntroDoneKeys && __autoIntroDoneKeys.has(introKey)) return;

        // Si aun no se ha podido anunciar (TTS ocupado/errores), reintentar con cooldown corto
        if (rn === __autoIntroSig && now < (__autoIntroRetryAt || 0)) return;

        // Carrera nueva real: reset completo
        const isNewRace = (rn !== __autoIntroSig);
        const sameRace = !isNewRace;
        if (isNewRace) {
          try { __autoEnsureVoiceReadyOnNewRace(rn); } catch(e) {}
          __autoIntroSig = rn;
          try { __autoResetLifecycle(rn); } catch(e) {}
          try { __autoIntroDoneKeys.clear(); } catch(e) { __autoIntroDoneKeys = new Set(); }
        }

        __autoIntroRetryAt = now + 3000;
        // Lifecycle: al llegar carrera nueva, entramos a WAIT_START (silencio) hasta que arranque
        // (ya se resetea arriba solo cuando rn cambia)

        // Reset finishers tracking for new race
        if (isNewRace) {
          __autoFinishSig = '';
          __autoFinishPrevByKey = new Map();
          __autoFinishAnnouncedByKey = new Set();
          __autoFinishPhase = false;
        }
        // Session info SIEMPRE desde raceName nuevo (evita traer la sesion anterior)
        const info = parseSessionFromRaceName(rn) || {};
        try { currentSessionInfo = info; } catch(e) {}

        const type = String(info.type || '').toUpperCase();
        const serie = String(info.serie || '').trim();
        const main = String(info.main || '').trim();

        // Formato pedido (TTS):
        // - MANGA: \"Clasificacion - Qx - Manga X - Serie X\"
        // - FINALES: anuncio por Final A/B/C con arranque + calentamiento
        let introText = '';

                function __pickFinalIntro(mainLetter) {
          const m = String(mainLetter || '').toUpperCase();
          // Default (acordado): FINALES = HYPE, PRO y divertido sin pasarse.
          const A = [
            'Final A. La elite en pista. Vamos a arrancar, pueden calentar.',
            'Final A. Top de pilotos. Vamos a arrancar, pueden calentar.',
            'Final A. Aquíi se corre fino. Vamos a arrancar, pueden calentar.',
            'Final A. Puro nivel. Vamos a arrancar, pueden calentar.',
            'Final A. Los mejores, sin excusas. Vamos a arrancar, pueden calentar.',
            'Final A. Ojos al apex. Vamos a arrancar, pueden calentar.',
            'Final A. Se define en detalles. Vamos a arrancar, pueden calentar.',
            'Final A. La parrilla esta pesada. Vamos a arrancar, pueden calentar.'
          ];
          const B = [
            'Final B. Se pone bueno. Vamos a arrancar, pueden calentar.',
            'Final B. Segunda linea de fuego. Vamos a arrancar, pueden calentar.',
            'Final B. Aquíi se pelea de verdad. Vamos a arrancar, pueden calentar.',
            'Final B. Sin regalos. Vamos a arrancar, pueden calentar.',
            'Final B. Carrera dura, manos suaves. Vamos a arrancar, pueden calentar.',
            'Final B. El podio se gana en paciencia. Vamos a arrancar, pueden calentar.',
            'Final B. Mantengan orden en curva uno. Vamos a arrancar, pueden calentar.',
            'Final B. A correr inteligente. Vamos a arrancar, pueden calentar.'
          ];
          const C = [
            'Final C. Carrera con hambre. Vamos a arrancar, pueden calentar.',
            'Final C. Aquíi todos quieren subir. Vamos a arrancar, pueden calentar.',
            'Final C. Cero contactos, mucha cabeza. Vamos a arrancar, pueden calentar.',
            'Final C. Limpio y constante. Vamos a arrancar, pueden calentar.',
            'Final C. Si te equivocas, pagas. Vamos a arrancar, pueden calentar.',
            'Final C. Que se note el progreso. Vamos a arrancar, pueden calentar.',
            'Final C. Practica hecha, ahora cuenta. Vamos a arrancar, pueden calentar.',
            'Final C. Vamos a divertirnos, pero con control. Vamos a arrancar, pueden calentar.'
          ];
          const mm = (m || 'X');
          const O = [
            'Final ' + mm + '. Vamos a arrancar, pueden calentar.',
            'Final ' + mm + '. Se prende esto. Vamos a arrancar, pueden calentar.',
            'Final ' + mm + '. Ojo en la curva uno. Vamos a arrancar, pueden calentar.',
            'Final ' + mm + '. Ritmo y cabeza. Vamos a arrancar, pueden calentar.'
          ];
          const bag = (m==='A') ? A : (m==='B') ? B : (m==='C') ? C : O;
          // Rotacion real sin repeticion reciente
          return autoRandPick(bag, 'introFinal:' + (m || 'X')) || bag[0];
        }


        function __buildMangaTitleTts2(info) {
          // Formato TTS (pedido): "Clasificacion, Qx, Manga x, Serie x"
          // Nota: sin acento en "Clasificacion" para TTS iOS/Android.
          const parts = ['Clasificacion'];
          const q = String(info.q || '').trim();
          // En tu raceName la MANGA trae letra (ej: "Q1.Manga B") => usamos main (B).
          // Fallback: mangaNo numerico si existe.
          const mLetter = String(info.main || '').trim();
          const mNo = String(info.mangaNo || '').trim();
          const serie = String(info.serie || '').trim();
          if (q) parts.push('Q' + q);
          if (mLetter) { parts.push('Manga'); parts.push(mLetter); }
          else if (mNo) { parts.push('Manga'); parts.push(mNo); }
          if (serie) parts.push('Serie ' + serie);
          return parts.join(', ');
        }

        if (type === 'MANGA') {
          introText = __buildMangaTitleTts2(info);
        } else if (type === 'FINAL') {
          // main es A/B/C si existe
          introText = __pickFinalIntro(main || '');
        } else {
          // fallback
          const label = String(info.label || '').trim();
          const spokenTitle = String(info.spokenTitle || '').trim() || (label ? label.replace('MODO ', '').trim() : '');
          introText = (spokenTitle ? spokenTitle : 'Nueva carrera');
        }

        enqueueSpeech(introText, {
          key: introKey,
          priority: 95,
          cooldownMs: 0,
          dedupe: true,
          maxAgeMs: 60000
        });
      } catch(e) {}
    }

    function __autoAnnounceFinishers() {
      try {
        if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) return;
        // Al llegar carrera nueva: anuncia siempre (Auto Locutor o Seguimiento)
        if (!voiceMasterEnabled) return;

        const info = currentSessionInfo || {};
        const type = String(info.type || '').toUpperCase();
        if (type !== 'FINAL') return; // Solo finales, como pediste
        const dur = Number(info.durationMs) || 0;
        if (!dur) return;

        const rn = String(raceData.raceName || '');
        if (rn && rn !== __autoFinishSig) {
          __autoFinishSig = rn;
          __autoFinishPrevByKey = new Map();
          __autoFinishAnnouncedByKey = new Set();
          __autoFinishPhase = false;
        }

        // Reloj de carrera: usamos tiempo del líder (P1)
        const leader = raceData.classification.find(x => Number(x.pos) === 1) || raceData.classification[0];
        const raceClockMs = getRowTotalMs(leader) || 0;

        // Entramos en fase de cierre cuando el líder ya pas el tiempo objetivo
        if (raceClockMs >= dur) __autoFinishPhase = true;
        if (!__autoFinishPhase) {
          // Aun no toca, pero guardamos prevs
          for (const row of raceData.classification) {
            const key = getPilotKey(row) || safeRacerName(row && row.racerName) || '';
            if (!key) continue;
            const laps = Number(row.lapcount) || 0;
            const totalMs = getRowTotalMs(row) || 0;
            __autoFinishPrevByKey.set(key, { laps, totalMs });
          }
          return;
        }

        // En fase cierre: avisar "X finalizo" cuando cruce el lmite en una vuelta nueva
        let enqueued = 0;
        for (const row of raceData.classification) {
          if (enqueued >= 2) break; // No spamear en un solo tick
          const key = getPilotKey(row) || safeRacerName(row && row.racerName) || '';
          if (!key) continue;

          const nm = safeRacerName(row && row.racerName);
          const laps = Number(row.lapcount) || 0;
          const totalMs = getRowTotalMs(row) || 0;

          const prev = __autoFinishPrevByKey.get(key) || { laps: 0, totalMs: 0 };
          __autoFinishPrevByKey.set(key, { laps, totalMs });

          if (__autoFinishAnnouncedByKey.has(key)) continue;
          if (!isFinite(totalMs) || totalMs <= 0) continue;

          // Solo disparar cuando sube una vuelta
          if (laps <= (prev.laps || 0)) continue;

          // Condicin: cruz el lmite en la última vuelta
          if (totalMs < dur) continue;

          enqueueSpeech((nm || 'Piloto') + ' finalizo.', {
            key: 'auto_finalizo_' + __autoFinishSig + '_' + key,
            priority: 92,
            cooldownMs: 0, // no bloqueo duro: se controla por __autoIntroDoneKeys + retry

            dedupe: true,
            maxAgeMs: 120000
          });

          __autoFinishAnnouncedByKey.add(key);
          enqueued++;
        }
      } catch(e) {}
    }

    // Pintar versin en UI
    window.addEventListener("DOMContentLoaded", () => {
      const el = document.getElementById("appVersion");
      if (el) el.textContent = APP_LABEL;
      // tambin alinear title del documento
      try { document.title = APP_LABEL; } catch(e) {}

      // Debug UI (muestra paneles expertos): agrega ?debug=1 o guarda localStorage aiSpotterDebug=1
      try{
        const qs = new URLSearchParams(location.search);
        const dbg = (qs.get('debug') === '1') || (lsGet('aiSpotterDebug') === '1');
        document.body.classList.toggle('debug', !!dbg);
      }catch(e){}
    });

    

    // Debug: render speech log panel
    function renderSpeechLog() {
      try {
        if (!document.body.classList.contains('debug')) return;
        const box = document.getElementById('speechLogList');
        if (!box) return;
        const list = (Array.isArray(speechLog) ? speechLog : []);
        const last = list.slice(-12).reverse();
        const fmt = (t) => {
          const d = new Date(t);
          const mm = String(d.getMinutes()).padStart(2,'0');
          const ss = String(d.getSeconds()).padStart(2,'0');
          return mm + ':' + ss;
        };
        box.innerHTML = last.map(it => {
          const meta = `${fmt(it.t)} | prio ${it.priority ?? 0} | ${String(it.key||'')}`;
          const txt = String(it.text||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
          return `<div class="speechlog-item"><div class="speechlog-meta">${meta}</div><div>${txt}</div></div>`;
        }).join(' ');
      } catch(e) {}
    }
    try { setInterval(renderSpeechLog, 1200); } catch(e) {}
// =========================
    // Helpers globales (compat)
    // =========================
    // =========================
    // LocalStorage SAFE (Google Sites / iOS / privacy)
    // - Si falla, no revienta el spotter; solo no persiste config
    // =========================
    let __lsOk = true;
    function lsGet(key) {
      try { return localStorage.getItem(key); } catch (e) { __lsOk = false; return null; }
    }
    function lsSet(key, value) {
      try { localStorage.setItem(key, value); return true; } catch (e) { __lsOk = false; return false; }
    }
    function lsRemove(key) {
      try { localStorage.removeItem(key); } catch (e) { __lsOk = false; }
    }

    function groupOf(msgId) {
      const id = String(msgId || '').toLowerCase().trim();
      if (!id) return 'misc';
      // Esenciales
      if (['laps','blueflag','ritmo_up','ritmo_down','estlap','leader','podium','bestlap'].includes(id)) return 'ess';
      // Batalla
      if (['pos','gaps','front06','back06','attack','defense','fight'].includes(id)) return 'bat';
      // Resumen
      if (['total','cons10','box','netgain'].includes(id)) return 'sum';
      return 'misc';
    }

    function say(text, opts = {}) {
      // Alias para compatibilidad (algunos mdulos llaman "say")
      return enqueueSpeech(text, opts);
    }

    // =========================
    // Firebase SDK (dynamic import) - evita que un fallo de red/bloqueo truene TODO el spotter
    // =========================
    let initializeApp = null;
    let initializeFirestore = null;
    let doc = null;
    let getDoc = null;
    let onSnapshot = null;
    let __firebaseSdkReady = false;

    async function ensureFirebaseSdk() {
      if (__firebaseSdkReady) return true;
      try {
        const appMod = await import("https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js");
        const fsMod  = await import("https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js");
        initializeApp = appMod.initializeApp;
        initializeFirestore = fsMod.initializeFirestore;
        doc = fsMod.doc;
        getDoc = fsMod.getDoc;
        onSnapshot = fsMod.onSnapshot;
        __firebaseSdkReady = true;
        return true;
      } catch (e) {
        __firebaseSdkReady = false;
        console.error("Firebase SDK no carg (red/bloqueador/CSP)", e);
        return false;
      }
    }

    const firebaseConfig = {
      apiKey: "AIzaSyBaySYvIxH8JsvXCETv3XwVdNecJY1ez2c",
      authDomain: "turbo-racing-zround.firebaseapp.com",
      projectId: "turbo-racing-zround",
      storageBucket: "turbo-racing-zround.firebasestorage.app",
      messagingSenderId: "628478462576",
      appId: "1:628478462576:web:c2dbc45c95bbe362ce42b5"
    };

    // Firebase runtime init (se hace en bootstrap, despus de cargar SDK)
    let appFB = null;
    let db = null;
    let __firebaseOk = false;

    // Watchdog de refresco (si se congela, lo veras en UI)
    let __lastGoodTickMs = 0;
    let __lastReadErr = '';
    let __feedTickCount = 0;

    async function initFirebaseRuntime() {
      try {
        const ok = await ensureFirebaseSdk();
        if (!ok) throw new Error("Firebase SDK no disponible");
        if (!initializeApp || !initializeFirestore || !doc || !getDoc) {
          throw new Error("Firebase SDK incompleto");
        }
        appFB = initializeApp(firebaseConfig);
        db = initializeFirestore(appFB, {
          experimentalForceLongPolling: true,
          useFetchStreams: false
        });
        __firebaseOk = true;
        return true;
      } catch (e) {
        __firebaseOk = false;
        console.error("Firebase init fall", e);
        return false;
      }
    }

    const raceTitleMain   = document.getElementById('raceTitleMain');
    const raceTitleText   = document.getElementById('raceTitleText');
    const raceModeBadge   = document.getElementById('raceModeBadge');
    const raceSubtitle    = document.getElementById('raceSubtitle');
    const raceInfo        = document.getElementById('raceInfo');
    const lastUpdateInfo  = document.getElementById('lastUpdateInfo');
    const liveIndicator   = document.getElementById('liveIndicator');
    const appHeader      = document.querySelector('.app-header');
    const diagPanelNote   = document.getElementById('diagPanelNote');
    const diagErrorBox    = document.getElementById('diagErrorBox');
    const ttsDiagNote     = document.getElementById('ttsDiagNote');
    const ttsEventList    = document.getElementById('ttsEventList');
    const runtimeProfileNote = document.getElementById('runtimeProfileNote');

    const pilotSelect     = document.getElementById('pilotSelect');

    // Pilot Select UX: iOS Safari a veces tarda en poblar la lista al iniciar.
    // - Muestra placeholder "Cargando pilotos..."
    // - Restaura una lista cacheada (si existe) para no dejar el selector vacio
    // - Reintenta poblar en background hasta que llegue classification
    function setPilotSelectLoading(on, msg){
      try{
        const sel = pilotSelect || document.getElementById('pilotSelect');
        if(!sel) return;
        if(on){
          sel.classList.add('is-loading');
          sel.disabled = false;
          sel.innerHTML = '';
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = msg || 'Cargando pilotos...';
          sel.appendChild(opt);
        } else {
          sel.classList.remove('is-loading');
          sel.disabled = false;
        }
      }catch(e){}
    }

    function restorePilotOptionsCache(){
      try{
        const sel = pilotSelect || document.getElementById('pilotSelect');
        if(!sel) return false;
        const raw = (localStorage.getItem('aiSpotterPilotOptionsCache') || '').trim();
        if(!raw) return false;
        const cache = JSON.parse(raw);
        if(!cache || !Array.isArray(cache.options) || cache.options.length < 2) return false;
        sel.innerHTML = '';
        cache.options.forEach(o=>{
          const opt = document.createElement('option');
          opt.value = String(o.value||'');
          opt.textContent = String(o.label||'');
          sel.appendChild(opt);
        });
        return true;
      }catch(e){ return false; }
    }

    function initPilotSelectUIOnce(){
      try{
        const sel = pilotSelect || document.getElementById('pilotSelect');
        if(!sel) return; // DOM aun no listo
        if (window.__pilotSelectUIInitDone) return;
        window.__pilotSelectUIInitDone = true;

        const hadCache = restorePilotOptionsCache();
        if(!hadCache) setPilotSelectLoading(true, 'Cargando pilotos...');

        // Reintentos suaves (Safari a veces tarda en el primer tick del feed)
        let tries = 0;
        const t = setInterval(()=>{
          tries++;
          try{
            if (raceData && Array.isArray(raceData.classification) && raceData.classification.length){
              try { updatePilotOptions(); } catch(e) {}
              setPilotSelectLoading(false);
              clearInterval(t);
              return;
            }
          }catch(e){}
          // Hint opcional (silencioso si showToast aun no existe)
          if (tries === 8){
            try { if (typeof showToast === 'function') showToast('Cargando pilotos...', 1200); } catch(e) {}
          }
          if (tries > 40) clearInterval(t);
        }, 450);
      }catch(e){}
    }

    // Arranque (si el DOM aun no existe, DOMContentLoaded lo activara)
    try { initPilotSelectUIOnce(); } catch(e) {}
    document.addEventListener('DOMContentLoaded', () => { try { initPilotSelectUIOnce(); } catch(e) {} });


    // Botones VOZ (desktop + mini)
    const voiceToggleBtns = Array.from(document.querySelectorAll('[data-voice-toggle]'));

    // Precision badges (1/2/3 dcimas)
    const precisionSelect = document.getElementById('precisionSelect');
    const precisionBadges = Array.from(document.querySelectorAll('.precision-badge'));

    function applyPilotSelectPosTheme(pos){
      if (!pilotSelect) return;
      const classes = ['pos-none','pos-1','pos-2','pos-3','pos-top5','pos-other'];
      for (const c of classes) pilotSelect.classList.remove(c);

      const n = Number(pos);
      if (!pos || !isFinite(n) || n <= 0){
        pilotSelect.classList.add('pos-none');
        return;
      }
      if (n === 1) pilotSelect.classList.add('pos-1');
      else if (n === 2) pilotSelect.classList.add('pos-2');
      else if (n === 3) pilotSelect.classList.add('pos-3');
      else if (n <= 5) pilotSelect.classList.add('pos-top5');
      else pilotSelect.classList.add('pos-other');
    }

    const pilotNameEl     = document.getElementById('pilotName');
    const pilotMetaEl     = document.getElementById('pilotMeta');
    const posTextEl       = document.getElementById('posText');
    const gapInfoEl       = document.getElementById('gapInfo');
    const lastLapEl       = document.getElementById('lastLap');
    const bestLapEl       = document.getElementById('bestLap');
    const meanLapEl       = document.getElementById('meanLap');
    const consistencyValEl = document.getElementById('consistencyVal');
    const sigmaValEl       = document.getElementById('sigmaVal');
    const lapChartEl      = document.getElementById('lapChart');
    const top3MiniGridEl  = document.getElementById('top3MiniGrid');
    const lapChartMetaEl  = document.getElementById('lapChartMeta');
    // Lap Chart - Top 3 simultneo en modo Auto Locutor (P1/P2/P3)
    let lapChartAutoKey = '';

    
    // === Preferencias persistentes (Cookies + fallback localStorage) ===
    function setCookie(name, value, days){
      try{
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        const expires = "expires=" + d.toUTCString();
        document.cookie = name + "=" + encodeURIComponent(value) + ";" + expires + ";path=/;SameSite=Lax";
      }catch(e){}
    }
    function getCookie(name){
      try{
        const n = name + "=";
        const ca = document.cookie ? document.cookie.split(';') : [];
        for (let i=0;i<ca.length;i++){
          let c = ca[i].trim();
          if (c.indexOf(n) === 0) return decodeURIComponent(c.substring(n.length, c.length));
        }
      }catch(e){}
      return null;
    }
    function prefKey(k){ return "TRMX_SPOTTER_" + String(k||""); }
    function prefGet(k, fallback=null){
      const ck = prefKey(k);
      let v = null;
      try{ v = getCookie(ck); }catch(e){}
      if (v == null){
        try{ v = localStorage.getItem(k); }catch(e){}
      }
      if (v == null) return fallback;
      return v;
    }
    function prefSet(k, value, days=365){
      const ck = prefKey(k);
      const v = (typeof value === 'string') ? value : JSON.stringify(value);
      try{ setCookie(ck, v, days); }catch(e){}
      try{ localStorage.setItem(k, v); }catch(e){}
    }

    // Pref: override para decir "X vueltas..." aun con perfiles AI (solo FOLLOW y con BÁSICO OFF)
    const PREF_SAYLAPS_OVERRIDE = 'spotterSayLapsOverride'; // '1'/'0'
    function getSayLapsOverride(){
      try { return String(prefGet(PREF_SAYLAPS_OVERRIDE, '0')) === '1'; } catch(e) { return false; }
    }
    function setSayLapsOverride(v){
      try { prefSet(PREF_SAYLAPS_OVERRIDE, v ? '1' : '0'); } catch(e) {}
    }


    // Mini grid (TOP 3/TOP 20) estado persistente
    let miniGridExpanded = false;
    let miniGridLimit = 3;
    try {
      miniGridExpanded = (prefGet('miniGridExpanded', '0') === '1');
      miniGridLimit = miniGridExpanded ? 20 : 3;
    } catch(e) { miniGridExpanded = false; miniGridLimit = 3; }

    function htmlEsc(s){
      return String(s == null ? '' : s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    function shortChipName(name){
      const n = (safeRacerName(name) || '').replace(/\s+/g,' ').trim();
      if (!n) return '-';
      return n.length > 12 ? (n.slice(0,12) + '...') : n;
    }

    function getTop3Rows(){
      try{
        const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const top = [];
        const seen = new Set();
        for (let i=0;i<rows.length && top.length<3;i++){
          const r = rows[i];
          if (!r) continue;
          const p = Number(r.pos);
          if (!isFinite(p) || p <= 0) continue;
          const k = getPilotKey(r);
          if (!k || seen.has(k)) continue;
          seen.add(k);
          top.push(r);
        }
        return top;
      }catch(e){ return []; }
    }

    function getTopRows(limit){
      try{
        const lim = Math.max(1, Math.min(50, Number(limit) || 3));
        const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const top = [];
        for (let i=0;i<rows.length && top.length<lim;i++){
          const r = rows[i];
          if (!r) continue;
          const k = getPilotKey(r);
          if (!k) continue;
          top.push(r);
        }
        return top;
      }catch(e){ return []; }
    }

    function getAutoLapChartKey(){
      const top = getTop3Rows();
      const leaderKey = top[0] ? getPilotKey(top[0]) : '';
      if (lapChartAutoKey && top.some(r => getPilotKey(r) === lapChartAutoKey)) return lapChartAutoKey;
      return leaderKey;
    }

    function renderAutoLapChartTop3(){
      if (!lapChartMetaEl) return;
      const top = getTop3Rows();
      if (!top.length){
        lapChartMetaEl.textContent = 'Sin datos';
        return;
      }
      const active = getAutoLapChartKey();
      lapChartMetaEl.innerHTML = top.map((r, i) => {
        const k = getPilotKey(r);
        const label = 'P' + (i+1);
        const nm = shortChipName(r.racerName);
        const posCls = (i===0?'pos1':(i===1?'pos2':'pos3'));
        const cls = (k === active) ? ('lap-pos-chip active ' + posCls) : ('lap-pos-chip ' + posCls);
        return '<span class="' + cls + '" data-key="' + htmlEsc(k) + '" title="' + htmlEsc(safeRacerName(r.racerName) || '') + '"><span class="lp">' + label + '</span><span class="nm">' + htmlEsc(nm) + '</span></span>';
      }).join(' ');
    }

    function renderAutoTop3MiniGrid(){
  if (!top3MiniGridEl) return;

  const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
  rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
  if (!rows.length){
    top3MiniGridEl.innerHTML = '';
    return;
  }

  const limit = Math.min(miniGridLimit || 3, rows.length);
  const top = rows.slice(0, limit);

  if (!window.__miniHist) window.__miniHist = new Map(); // key -> {front:[sec...], back:[sec...]}

  const parseInterval = (raw) => {
    const s0 = String(raw || '').trim();
    if (!s0 || s0 === '-' || s0 === 'LDR') return { sec:null, laps:null };
    const mV = s0.match(/([+-]?\s*\d+)\s*v/i);
    if (mV){
      const n = parseInt(String(mV[1]).replace(/\s+/g,''),10);
      if (isFinite(n)) return { sec:null, laps:Math.abs(n) };
    }
    const s = s0.toLowerCase();
    const mMas = s.match(/m[a]s\s+(\d+|una|un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s+vueltas?/i);
    if (mMas){
      const tok = mMas[1];
      const map = { 'una':1,'un':1,'uno':1,'dos':2,'tres':3,'cuatro':4,'cinco':5,'seis':6,'siete':7,'ocho':8,'nueve':9,'diez':10 };
      const n = /^\d+$/.test(tok) ? parseInt(tok,10) : (map[tok] || NaN);
      if (isFinite(n) && n > 0) return { sec:null, laps:n };
    }
    const f = parseFloat(s0.replace(/[^0-9.+-]/g,''));
    if (isFinite(f)) return { sec:Math.abs(f), laps:null };
    return { sec:null, laps:null };
  };

  const computeBattleTag = (hist, fSec, bSec) => {
    const isManga = (currentSessionInfo && currentSessionInfo.type === 'MANGA');
    const thr = isManga ? 0.55 : 0.60;

    const near2 = (arr) => {
      if (!arr || arr.length < 2) return false;
      const b = arr[arr.length - 2];
      const c = arr[arr.length - 1];
      return isFinite(b) && isFinite(c) && (b <= thr) && (c <= thr);
    };

    const atk = (fSec != null && isFinite(fSec) && fSec <= thr && (near2(hist.front) || (hist.front && hist.front.length>=1 && isFinite(hist.front[hist.front.length-1]) && hist.front[hist.front.length-1] <= thr)));
    const def = (bSec != null && isFinite(bSec) && bSec <= thr && (near2(hist.back) || (hist.back && hist.back.length>=1 && isFinite(hist.back[hist.back.length-1]) && hist.back[hist.back.length-1] <= thr)));

    if (atk && def) return 'DUEL';
    if (atk) return 'ATK';
    if (def) return 'DEF';
    return '-';
  };

  let html = '';

  // Siempre: rows estilo scoreboard (igual que expanded).
  html += '<div class="mini-rows" role="list" aria-label="Timing screen">';
  html += '<div class="mini-head" role="row">';
  html +=   '<div>P</div><div>Piloto</div><div style="text-align:right">V</div><div style="text-align:right">UL</div><div style="text-align:right">INT</div><div style="text-align:right">ST</div>';
  html += '</div>';

  for (let i=0;i<top.length;i++){
    const r = top[i];
    const posVal = Number(r.pos) || (i+1);
    const posCls = (posVal===1?'pos1':(posVal===2?'pos2':(posVal===3?'pos3':'posN')));

    const name = safeRacerName(r.racerName) || '-';
    const _nParts = String(name || '').trim().split(/\s+/).filter(Boolean);
    let name1 = name;
    let name2 = '';
    if (_nParts.length === 2){
      name1 = _nParts[0];
      name2 = _nParts[1];
    } else if (_nParts.length > 2){
      name1 = _nParts.slice(0,2).join(' ');
      name2 = _nParts.slice(2).join(' ');
    }
    const nameCell = '<span class="mt-driver"><span class="mt-line mt-line1">' + htmlEsc(name1) + '</span>' + (name2 ? ('<span class="mt-line mt-line2">' + htmlEsc(name2) + '</span>') : '') + '</span>';

    const laps = formatLaps3(r.lapcount);

    const lastMs = parseTimeToMs((typeof r.lastTime !== 'undefined' ? r.lastTime : (typeof r.lastLap !== 'undefined' ? r.lastLap : (typeof r.lastLapMs !== 'undefined' ? r.lastLapMs : 0))));
    const lastStr = (lastMs && lastMs > 0) ? msToMinSec(lastMs) : '-:--.---';

    // Intervalo al de adelante
    let intervalTxt = '';
    if (posVal === 1) {
      intervalTxt = 'LDR';
    } else {
      const raw = (r.diff != null ? r.diff : (r.interval != null ? r.interval : ''));
      const vis = formatoGapVueltas(raw) || String(raw || '').trim();
      const info = parseInterval(vis);
      if (info.laps != null) intervalTxt = info.laps + 'V';
      else if (info.sec != null && isFinite(info.sec)) intervalTxt = toFixedFloor(info.sec, 2);
      else intervalTxt = vis || '';
    }

    // ATK/DEF/DUEL usando front/back del top visible
    const key = getPilotKey(r) || r._id || (r.racerName || ('p'+posVal));
    const frontRaw = (posVal === 1) ? 'LDR' : (formatoGapVueltas(r.diff != null ? r.diff : (r.interval != null ? r.interval : '')) || (r.diff != null ? r.diff : (r.interval != null ? r.interval : '')));
    const frontInfo = (posVal === 1) ? {sec:null,laps:null} : parseInterval(frontRaw);

    const next = (i < top.length - 1) ? top[i+1] : null;
    const backVis = next ? (formatoGapVueltas(next.diff != null ? next.diff : (next.interval != null ? next.interval : '')) || String(next.diff != null ? next.diff : (next.interval != null ? next.interval : '')) ) : '';
    const backInfo = next ? parseInterval(backVis) : {sec:null,laps:null};

    const H = window.__miniHist;
    let hist = H.get(key);
    if (!hist) { hist = { front: [], back: [] }; H.set(key, hist); }

    const fSec = (frontInfo && frontInfo.laps == null && frontInfo.sec != null && isFinite(frontInfo.sec)) ? Number(frontInfo.sec) : null;
    const bSec = (backInfo  && backInfo.laps  == null && backInfo.sec  != null && isFinite(backInfo.sec))  ? Number(backInfo.sec)  : null;

    if (fSec == null) hist.front = [];
    else { hist.front.push(fSec); if (hist.front.length > 6) hist.front.splice(0, hist.front.length - 6); }

    if (bSec == null) hist.back = [];
    else { hist.back.push(bSec); if (hist.back.length > 6) hist.back.splice(0, hist.back.length - 6); }

    const state = computeBattleTag(hist, fSec, bSec);
    let stateCell = state;
    if (state === 'ATK') stateCell = '<span class="st-atk">ATK</span>';
    else if (state === 'DEF') stateCell = '<span class="st-def">DEF</span>';
    else if (state === 'DUEL') stateCell = '<span class="st-duel">DUEL</span>';
    else stateCell = '<span class="st-na">-</span>';    html += '<div class="mini-row ' + posCls + '" role="listitem">';
      html +=   '<div class="mr-pos">' + htmlEsc(String(posVal)) + '</div>';
      html +=   '<div class="mr-name">' +
                  '<span class="mr-line mr-line1">' + htmlEsc(name1) + '</span>' +
                  (name2 ? ('<span class="mr-line mr-line2">' + htmlEsc(name2) + '</span>') : '') +
                '</div>';
      html +=   '<div class="mr-mono">' + htmlEsc(laps) + '</div>';
      html +=   '<div class="mr-mono">' + htmlEsc(lastStr) + '</div>';
      html +=   '<div class="mr-mono">' + htmlEsc(String(intervalTxt)) + '</div>';
      html +=   '<div class="mr-mono mr-st">' + stateCell + '</div>';
      html += '</div>';
    }
  html += '</div>';

  top3MiniGridEl.innerHTML = html;
}

function applyMiniGridExpandedUI(){
  try{
    if (!top3MiniGridEl) return;
    top3MiniGridEl.classList.add('expanded');
    top3MiniGridEl.setAttribute('aria-label', miniGridExpanded ? 'Top 20 grid' : 'Top 3 grid');
  }catch(e){}
  try{
    const lab = miniGridExpanded ? 'TOP 20' : 'TOP 3';
    if (typeof top3ToggleBtn !== 'undefined' && top3ToggleBtn) top3ToggleBtn.textContent = lab;
    if (btnOpenGrid) btnOpenGrid.textContent = ' ' + lab;
  }catch(e){}
}
applyMiniGridExpandedUI();

try{
  const _toggleMiniGrid = () => {
    miniGridExpanded = !miniGridExpanded;
    miniGridLimit = miniGridExpanded ? 20 : 3;
    try{ prefSet('miniGridExpanded', miniGridExpanded ? '1' : '0'); }catch(e){}
    applyMiniGridExpandedUI();
    try{ renderAutoTop3MiniGrid(); }catch(e){}
  };
  if (btnOpenGrid) btnOpenGrid.addEventListener('click', _toggleMiniGrid);
  if (typeof top3ToggleBtn !== 'undefined' && top3ToggleBtn) top3ToggleBtn.addEventListener('click', _toggleMiniGrid);
}catch(e){}

    const spotterButtons   = document.querySelectorAll('.spotter-btn');
    // VOZ: Desktop por defecto ON. Moviles por defecto OFF (restricciones de autoplay).
    const __ua0 = navigator.userAgent || '';
    const __isIpadOS0 = (navigator.platform === 'MacIntel' && (navigator.maxTouchPoints || 0) > 1);
    const __isMobile0 = /Android|iPhone|iPad|iPod|Mobile/i.test(__ua0) || __isIpadOS0;
    let voiceMasterEnabled = !__isMobile0;
    try {
      const vme = prefGet('voiceMasterEnabled', null);
      if (vme !== null) voiceMasterEnabled = (vme === '1');
    } catch(e) {}
// AI: si el usuario nunca ha tocado VOZ, el spotter puede activar voz en Auto Locutor.
    let userVoiceOverride = false;

    // Modo BASICO (solo vueltas, lap time y posicion)
    let basicModeEnabled = false;
    try {
      const bm = prefGet('basicModeEnabled', null);
      if (bm !== null) basicModeEnabled = (bm === '1');
    } catch(e) {}

    const DEFAULT_VOICE_SETTINGS = {
      laps: true,       // siempre activo (no se apaga)
      saylaps: false,   // decir 'vueltas' en el prefijo de LAPS

      // Esenciales (default)
      blueflag: true,
      ritmo: true,

      // Todo lo demas OFF por default (para no abrumar)
      pos: false,
      gaps: false,
      leadergap: false,
      podium: false,
      attack: false,
      defense: false,
      pelea: false,
      netgain: false,
      front06: false,
      back06: false,
      total: false,
      cons10: false,
      estlap: false,
      bestlap: false,
      box: false
    };

    // One-time: aplicar defaults de esta versin (sin pisar cada recarga)
    // - Evita que el usuario se quede con toggles viejos (todo prendido) cuando cambia de base.
    const DEFAULTS_APPLIED_KEY = 'TRM_DEFAULTS_APPLIED_AI_Spotter_TRM_v0.0.0.90';
    try{
      if (localStorage.getItem(DEFAULTS_APPLIED_KEY) === null && localStorage.getItem('spotterVoiceSettings') === null){
        localStorage.setItem('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        prefSet('spotterDecimalPrecision', '2');
        prefSet('raceDirectorEnabled', '1');
        prefSet('raceDirectorMode', 'minimal');
        prefSet('autoCommentatorMode', 'picante');
        localStorage.setItem(DEFAULTS_APPLIED_KEY, '1');
      }
    }catch(e){}

    // Defaults y migracin NO destructiva (por dispositivo)
    // - Antes reseteaba por "versin de esquema" y eso era gasolina en el fuego.
    // - Ahora: solo si no existe, se siembran defaults. Si existe, solo se rellenan faltantes.
    const SETTINGS_SCHEMA_VERSION = 'TRM_SPOTTER_SCHEMA_V1';
    try {
      const prevSchema = lsGet('spotterSettingsSchema');

      // Si es primera vez: seed defaults
      if (prevSchema === null) {
        if (lsGet('spotterVoiceSettings') === null) lsSet('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        if (lsGet('spotterDecimalPrecision') === null) lsSet('spotterDecimalPrecision', '2');
      } else {
        // Upgrade: NO sobreescribir preferencias existentes
        if (lsGet('spotterVoiceSettings') === null) lsSet('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        if (lsGet('spotterDecimalPrecision') === null) lsSet('spotterDecimalPrecision', '2');
      }

      // Actualizamos schema sin resetear
      lsSet('spotterSettingsSchema', SETTINGS_SCHEMA_VERSION);
    } catch (e) {}

    let voiceSettings = { ...DEFAULT_VOICE_SETTINGS };
    let raceDirectorEnabled = true;
    try {
      const rdStored = prefGet('raceDirectorEnabled', null);
      if (rdStored !== null) raceDirectorEnabled = (rdStored === '1');
      else { raceDirectorEnabled = true; try { prefSet('raceDirectorEnabled','1'); } catch(e) {} }
    } catch(e) {}

    const rdToggleBtn = document.getElementById('rdToggleBtn');
    
    // Manual (ayuda)
    const manualBtn       = document.getElementById('manualBtn');
    const skinBtn         = document.getElementById('skinBtn');
    const autoSkinBtn     = document.getElementById('autoSkinBtn');

    // Tema (paquete T1-T8) - orden A: VIC, CARB, BLUE, LIME, PURP, AMBR, ICE, OLED
    const THEME_KEY = 'spotterSkin';
    const AUTO_SKIN_KEY = 'spotterSkinAuto'; // '1'=auto por sesion, '0'=manual
    let autoSkinEnabled = true;

    const THEMES = [
      { key: 'vicpulse', label: 'VIC', cls: 'skin-vicpulse' },
      { key: 'carbon',   label: 'CARB', cls: 'skin-carbon' },
      { key: 'blue',     label: 'BLUE', cls: 'skin-blue' },
      { key: 'lime',     label: 'LIME', cls: 'skin-lime' },
      { key: 'purple',   label: 'PURP', cls: 'skin-purple' },
      { key: 'amber',    label: 'AMBR', cls: 'skin-amber' },
      { key: 'ice',      label: 'ICE',  cls: 'skin-ice' },
      { key: 'oled',     label: 'OLED', cls: 'skin-oled' },
    ]

    // Auto-skin: por defecto ON. Long-press (700ms) en el boton de tema para alternar AUTO/MANUAL.
    try{
      const a = prefGet(AUTO_SKIN_KEY, null);
      if (a === null) { autoSkinEnabled = true; try{ prefSet(AUTO_SKIN_KEY,'1'); }catch(e){} }
      else autoSkinEnabled = (a === '1');
    }catch(e){ autoSkinEnabled = true; }

    function __skinModeLabel(){ return autoSkinEnabled ? 'AUTO' : 'MANUAL'; }

    function refreshAutoSkinUI(){
      if (!autoSkinBtn) return;
      const lbl = document.getElementById('autoSkinLbl');
      if (lbl) lbl.textContent = autoSkinEnabled ? 'AUTO' : 'MAN';
      autoSkinBtn.classList.toggle('active', !!autoSkinEnabled);
      autoSkinBtn.title = autoSkinEnabled
        ? 'Auto-skin: ON (LIBRE->ICE, MANGA->BLUE, FINAL A->AMBR, FINAL B->PURP, FINAL C->LIME)'
        : 'Auto-skin: OFF (manual)';
      try{ if (skinBtn) skinBtn.title = 'Tema: ' + (skinBtn.textContent||'VIC') + (autoSkinEnabled ? ' [AUTO]' : ' [MAN]'); }catch(e){}
    }


    function getSessionInfoFromRaceName(raceName){
      const s0 = String(raceName || '');
      const s = s0.toUpperCase().replace(/\s+/g,' ').trim();
      const out = { kind: 'unknown', main: null, raw: s0 };
      if (!s) return out;

      // Entrenamiento / libre
      if (/(\bLIBRE\b|ENTRENAMIENTO|PRACTICE|TRAINING|WARM\s?UP)/.test(s)){
        out.kind = 'training';
        return out;
      }

      // Finales (A/B/C)
      if (/(\bFINAL\b|A\s?MAIN|B\s?MAIN|C\s?MAIN|MAIN\s?A|MAIN\s?B|MAIN\s?C|A\-MAIN|B\-MAIN|C\-MAIN)/.test(s)){
        out.kind = 'final';
        if (/(FINAL\s*A|A\s?MAIN|MAIN\s?A|A\-MAIN)/.test(s)) out.main = 'A';
        else if (/(FINAL\s*B|B\s?MAIN|MAIN\s?B|B\-MAIN)/.test(s)) out.main = 'B';
        else if (/(FINAL\s*C|C\s?MAIN|MAIN\s?C|C\-MAIN)/.test(s)) out.main = 'C';
        return out;
      }

      // Manga / clasificación (Q)
      if (/(\bMANGA\b|CLASIF|CLASIFICACI|\bQUALI\b|\bQ\d+\b|\bHEAT\b|\bROUND\b)/.test(s)){
        out.kind = 'manga';
        return out;
      }

      return out;
    }

    function getAutoThemeForSessionInfo(info){
      const k = String((info && info.kind) || '').toLowerCase();
      const m = String((info && info.main) || '').toUpperCase();

      // Mapa AUTO (lo que pediste):
      // Entrenamiento/LIBRE -> ICE
      // Manga/Clasificación -> BLUE
      // Final A -> AMBR
      // Final B -> PURP
      // Final C -> LIME
      if (k === 'training') return 'ice';
      if (k === 'manga') return 'blue';
      if (k === 'final'){
        if (m === 'A') return 'amber';
        if (m === 'B') return 'purple';
        if (m === 'C') return 'lime';
        return 'carbon';
      }
      return null;
    }

    function maybeApplyAutoThemeByRaceName(raceName, force=false){
      if ((!autoSkinEnabled) && (!force)) return;
      if (!raceName) return;

      let info = null;
      try { info = getSessionInfoFromRaceName(String(raceName)); } catch(e) { info = null; }
      const rec = getAutoThemeForSessionInfo(info);
      if (!rec) return;

      try { prefSet(THEME_KEY, rec); } catch(e) {}
      applyTheme(rec);
    }

    function toggleAutoSkin(){
      autoSkinEnabled = !autoSkinEnabled;
      try{ prefSet(AUTO_SKIN_KEY, autoSkinEnabled ? '1' : '0'); }catch(e){}

      // Al prender AUTO, aplica el recomendado segun la carrera actual.
      try{ if (typeof lastRaceName !== 'undefined' && lastRaceName) maybeApplyAutoThemeByRaceName(lastRaceName, true); }catch(e){}
      refreshAutoSkinUI();
    }


    function applyTheme(key){
      const found = THEMES.find(t => t.key === key) || THEMES[0];

      // Limpia clases de tema
      for (const t of THEMES) document.body.classList.remove(t.cls);

      // Activa PRO + tema
      document.body.classList.add('skin-pro');
      document.body.classList.add(found.cls);

      if (skinBtn){
        skinBtn.innerHTML = 'VIC&#x1F40A;';
        skinBtn.classList.add('active');
        skinBtn.title = 'Tema: ' + found.label + ' [' + __skinModeLabel() + ']';
      }
      return found.key;
    }

    function nextTheme(){
      let curKey = null;
      try{ curKey = prefGet(THEME_KEY, null); }catch(e){}
      // Compat: valores viejos
      if (curKey === 'std' || !curKey) curKey = 'vicpulse';
      const idx = Math.max(0, THEMES.findIndex(t => t.key === curKey));
      const next = THEMES[(idx + 1) % THEMES.length].key;
      // Si el usuario cambia tema manualmente, apagamos AUTO (override manual).
      try{ prefSet(AUTO_SKIN_KEY,'0'); }catch(e){}
      autoSkinEnabled = false;
      refreshAutoSkinUI();

      try{ prefSet(THEME_KEY, next); }catch(e){}
      applyTheme(next);
    }

    try{
      let stored = null;
      try{ stored = prefGet(THEME_KEY, null); }catch(e){}
      if (!stored || stored === 'std') stored = 'vicpulse';
      applyTheme(stored);
      refreshAutoSkinUI();
    }catch(e){
      applyTheme('vicpulse');
      refreshAutoSkinUI();
    }

    // Boton AUTO: toggle explcito
    if (autoSkinBtn){
      autoSkinBtn.addEventListener('click', ()=>{ toggleAutoSkin(); });
    }

    // Boton TEMA: click = siguiente tema (manual). AUTO se controla solo con el boton AUTO.
    if (skinBtn){
      skinBtn.addEventListener('click', ()=>{ nextTheme(); });
    }
    const manualBackdrop  = document.getElementById('manualBackdrop');
    const manualCloseBtn  = document.getElementById('manualCloseBtn');

    function openManual(){
      if (!manualBackdrop) return;
      manualBackdrop.classList.add('open');
      manualBackdrop.setAttribute('aria-hidden','false');
    }
    function closeManual(){
      if (!manualBackdrop) return;
      manualBackdrop.classList.remove('open');
      manualBackdrop.setAttribute('aria-hidden','true');
    }

    if (manualBtn) manualBtn.addEventListener('click', openManual);
    if (manualCloseBtn) manualCloseBtn.addEventListener('click', closeManual);
    if (manualBackdrop) manualBackdrop.addEventListener('click', (e)=>{ if (e.target === manualBackdrop) closeManual(); });
    window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeManual(); });

    // URL param: ?manual=1
    try{
      const qp = new URLSearchParams(location.search);
      if (qp.get('manual') === '1') setTimeout(openManual, 250);
    
    // Manual tabs
    (function(){
      const root = document.querySelector('#manualBackdrop .manual-panel');
      if (!root) return;
      const tabs = Array.from(root.querySelectorAll('.manual-tab'));
      const panels = Array.from(root.querySelectorAll('.manual-section'));
      if (!tabs.length || !panels.length) return;

      function setTab(id){
        tabs.forEach(t=>{
          const on = (t.dataset.tab === id);
          t.classList.toggle('active', on);
          t.setAttribute('aria-selected', on ? 'true' : 'false');
        });
        panels.forEach(p=>{
          p.classList.toggle('active', p.dataset.tab === id);
        });
      }

      tabs.forEach(t=> t.addEventListener('click', ()=> setTab(t.dataset.tab)));

      // Reset a Inicio cada vez que abres el manual
      const _openManual = openManual;
      window.openManual = function(){
        _openManual();
        setTab('inicio');
      };
    })();
}catch(e){}
let raceDirectorMode = 'minimal';
    try {
      const m = prefGet('raceDirectorMode', null);
      if (m === 'minimal' || m === 'stratega' || m === 'coach' || m === 'sarca' || m === 'engineer' || m === 'hype') raceDirectorMode = m;
      else { raceDirectorMode = 'minimal'; try { prefSet('raceDirectorMode','minimal'); } catch(e) {} }
    } catch(e) {}

    const rdModeMinimal  = document.getElementById('rdModeMinimal');
    const rdModeStratega = document.getElementById('rdModeStratega');
    const rdModeCoach    = document.getElementById('rdModeCoach');
    const rdModeSarca    = document.getElementById('rdModeSarca');
    const rdModeEngineer = document.getElementById('rdModeEngineer');
    const rdModeHype     = document.getElementById('rdModeHype');

    // ===== Auto Locutor (sin piloto) - 3 estilos
    let autoCommentatorMode = 'picante';
    let autoModeUserOverride = false;
    try {
      const m = prefGet('autoCommentatorMode', null);
      if (m === 'pro' || m === 'picante' || m === 'engineer' || m === 'narrativo') autoCommentatorMode = m;
      else { autoCommentatorMode = 'picante'; try { prefSet('autoCommentatorMode','picante'); } catch(e) {} }
    } catch(e) {}

    const autoLocutorPro      = document.getElementById('autoLocutorPro');
    const autoLocutorPicante  = document.getElementById('autoLocutorPicante');
    const autoLocutorEngineer = document.getElementById('autoLocutorEngineer');
    const autoLocutorNarrativo = document.getElementById('autoLocutorNarrativo');

    function updateAutoCommentatorButtons() {
      const setActive = (el, on) => {
        if (!el) return;
        el.classList.toggle('active', !!on);
        el.setAttribute('aria-pressed', on ? 'true' : 'false');
      };
      setActive(autoLocutorPro,      autoCommentatorMode === 'pro');
      setActive(autoLocutorPicante,  autoCommentatorMode === 'picante');
      setActive(autoLocutorEngineer, autoCommentatorMode === 'engineer');
      setActive(autoLocutorNarrativo, autoCommentatorMode === 'narrativo');
    }

    function setAutoCommentatorMode(mode) {
      if (!(mode === 'pro' || mode === 'picante' || mode === 'engineer' || mode === 'narrativo')) return;
      autoModeUserOverride = true;
      autoCommentatorMode = mode;
      try { prefSet('autoCommentatorMode', mode); } catch(e) {}
      updateAutoCommentatorButtons();
    }

    if (autoLocutorPro)      autoLocutorPro.addEventListener('click', () => setAutoCommentatorMode('pro'));
    if (autoLocutorPicante)  autoLocutorPicante.addEventListener('click', () => setAutoCommentatorMode('picante'));
    if (autoLocutorEngineer) autoLocutorEngineer.addEventListener('click', () => setAutoCommentatorMode('engineer'));
    if (autoLocutorNarrativo) autoLocutorNarrativo.addEventListener('click', () => setAutoCommentatorMode('narrativo'));

function updateRdModeButtons() {
      const setActive = (el, on) => {
        if (!el) return;
        el.classList.toggle('active', !!on);
        el.setAttribute('aria-pressed', on ? 'true' : 'false');
};
      setActive(rdModeMinimal,  raceDirectorMode === 'minimal');
      setActive(rdModeStratega, raceDirectorMode === 'stratega');
      setActive(rdModeCoach,    raceDirectorMode === 'coach');
      setActive(rdModeSarca,    raceDirectorMode === 'sarca');
      setActive(rdModeEngineer, raceDirectorMode === 'engineer');
      setActive(rdModeHype,     raceDirectorMode === 'hype');
    }
    function setRaceDirectorMode(mode) {
      if (!(mode === 'minimal' || mode === 'stratega' || mode === 'coach' || mode === 'sarca' || mode === 'engineer' || mode === 'hype')) return;
      raceDirectorMode = mode;
      try { prefSet('raceDirectorMode', mode); } catch(e) {}
      updateRdModeButtons();
    updateAutoCommentatorButtons();
      try { playBeep('tap'); } catch(e) {}
    }
    if (rdModeMinimal)  rdModeMinimal.addEventListener('click',  () => setRaceDirectorMode('minimal'));
    if (rdModeStratega) rdModeStratega.addEventListener('click', () => setRaceDirectorMode('stratega'));
    if (rdModeCoach)    rdModeCoach.addEventListener('click',    () => setRaceDirectorMode('coach'));
    if (rdModeSarca)    rdModeSarca.addEventListener('click',    () => setRaceDirectorMode('sarca'));
    if (rdModeEngineer) rdModeEngineer.addEventListener('click', () => setRaceDirectorMode('engineer'));
    if (rdModeHype)     rdModeHype.addEventListener('click',     () => setRaceDirectorMode('hype'));
updateRdModeButtons();
    updateAutoCommentatorButtons();

    
// Seleccin "shuffle bag" anti repeticin (ms variacin real)
const rdPhraseBag = new Map();

function rdShuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

function rdPick(variants, key) {
  if (!variants || !variants.length) return '';
  const k = key || 'rd';

  // Dedupe de textos idnticos (evita bancos con clones)
  const uniq = [];
  const seen = new Set();
  for (let i = 0; i < variants.length; i++) {
    const t = String(variants[i]);
    if (!seen.has(t)) { seen.add(t); uniq.push(t); }
  }
  if (!uniq.length) return '';

  let st = rdPhraseBag.get(k);
  if (!st || !Array.isArray(st.bag) || st.srcLen !== uniq.length) {
    st = { bag: [], recent: [], srcLen: uniq.length };
  }

  const RECENT_N = Math.min(6, Math.max(2, Math.floor(uniq.length / 4)));

  if (!st.bag.length) {
    const idxs = [];
    for (let i = 0; i < uniq.length; i++) idxs.push(i);
    rdShuffleInPlace(idxs);

    // Si hay suficiente variedad, empuja lo "recin usado" al final del saco
    if (st.recent && st.recent.length && uniq.length > (st.recent.length + 2)) {
      const rec = new Set(st.recent);
      const a = idxs.filter(i => !rec.has(i));
      const b = idxs.filter(i =>  rec.has(i));
      st.bag = a.concat(b);
    } else {
      st.bag = idxs;
    }
  }

  const pickIdx = st.bag.shift();
  st.recent = st.recent || [];
  st.recent.push(pickIdx);
  while (st.recent.length > RECENT_N) st.recent.shift();

  rdPhraseBag.set(k, st);
  return uniq[pickIdx % uniq.length];
}

// ---- RD helpers (persuasivo + preciso, sin metralleta) ----
    function rdSafeName(name) {
      const n = safeRacerName(name);
      return n || 'el de adelante';
    }
    function rdSec(sec) {
      if (sec == null || !isFinite(sec)) return '';
      const v = Math.max(0, sec);
      return toFixedFloor(v, decimalPrecision);
    }
    function rdExtractPos(txt) {
      const m = String(txt || '').match(/P\s*(\d+)/i);
      if (m) return parseInt(m[1], 10) || 0;
      const n = parseInt(String(txt || '').replace(/\D+/g,''), 10) || 0;
      return n;
    }
    function rdTrimWords(text, maxWords) {
      const t = String(text || '').trim();
      if (!t) return '';
      const parts = t.split(/\s+/).filter(Boolean);
      if (parts.length <= maxWords) return t;
      const cut = parts.slice(0, maxWords).join(' ');
      return cut.replace(/[,:;\-]+$/,'') + '...';
    }
    function rdBuildCtx(baseCtx, p) {
      const ctx = baseCtx || {};
      const posNow = Number((p && (p.pos || p.position)) || 0) || 0;
      const frontName = ctx.frontName || '';
      const backName  = ctx.backName || '';
      const frontSec  = ctx.frontSec;
      const backSec   = ctx.backSec;
      return {
        ...ctx,
        posNow,
        frontName,
        backName,
        frontSec,
        backSec,
        frontNameSafe: rdSafeName(frontName),
        backNameSafe: rdSafeName(backName),
        frontSecStr: rdSec(frontSec),
        backSecStr: rdSec(backSec),
      };
    }
    // Banco de frases por modo (A/B/C) - ms humano y distinto
    
    // Banco de frases por modo - humano, persuasivo y con accin
    // Nota: las plantillas aceptan {frontNameSafe}, {backNameSafe}, {frontSecStr}, {backSecStr}, {posNow}
    const RD_PHRASES = {
      minimal: {
        manga: [
          'Manga, vuelta limpia y sin errores.',
          'Manga, vuelta limpia y sin errores. Mantén el plan.',
          'Manga, vuelta limpia y sin errores. Sin regalar nada.',
          'Manga, vuelta limpia y sin errores. Sin prisa, sin pausa.',
          'Manga, vuelta limpia y sin errores. Control total.',
          'Manga, suma vueltas y cuida la trazada.',
          'Manga, suma vueltas y cuida la trazada. Mantén el plan.',
          'Manga, suma vueltas y cuida la trazada. Sin regalar nada.',
          'Manga, suma vueltas y cuida la trazada. Sin prisa, sin pausa.',
          'Manga, suma vueltas y cuida la trazada. Control total.',
          'Manga, ritmo estable, no te salgas.',
          'Manga, ritmo estable, no te salgas. Mantén el plan.',
          'Manga, ritmo estable, no te salgas. Sin regalar nada.',
          'Manga, ritmo estable, no te salgas. Sin prisa, sin pausa.',
          'Manga, ritmo estable, no te salgas. Control total.',
          'Manga, evita tráfico y busca aire limpio.',
          'Manga, evita tráfico y busca aire limpio. Mantén el plan.',
          'Manga, evita tráfico y busca aire limpio. Sin regalar nada.',
          'Manga, evita tráfico y busca aire limpio. Sin prisa, sin pausa.',
          'Manga, evita tráfico y busca aire limpio. Control total.',
          'Manga, todo es consistencia.',
          'Manga, todo es consistencia. Mantén el plan.',
          'Manga, todo es consistencia. Sin regalar nada.',
          'Manga, todo es consistencia. Sin prisa, sin pausa.',
          'Manga, todo es consistencia. Control total.'
        ],
        attack: [
          'Traes a {frontNameSafe} a {frontSecStr}. Prepara el pase.',
          'Traes a {frontNameSafe} a {frontSecStr}. Ataque con calma.',
          'Traes a {frontNameSafe} a {frontSecStr}. Busca salida fuerte.',
          'Traes a {frontNameSafe} a {frontSecStr}. Sin arriesgar de más.',
          'Traes a {frontNameSafe} a {frontSecStr}. Cuida la entrada y acelera.',
          'Traes a {frontNameSafe} a {frontSecStr}. Coloca el intento en zona segura.',
          'Traes a {frontNameSafe} a {frontSecStr}. Un giro más y lo tienes.',
          'Traes a {frontNameSafe} a {frontSecStr}. Mantén presión y el pase cae.',
          'Traes a {frontNameSafe} a {frontSecStr}. enf cate en la salida.',
          'Traes a {frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Prepara el pase.',
          'A {frontSecStr} de {frontNameSafe}. Ataque con calma.',
          'A {frontSecStr} de {frontNameSafe}. Busca salida fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Sin arriesgar de más.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada y acelera.',
          'A {frontSecStr} de {frontNameSafe}. Coloca el intento en zona segura.',
          'A {frontSecStr} de {frontNameSafe}. Un giro más y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Mantén presión y el pase cae.',
          'A {frontSecStr} de {frontNameSafe}. enf cate en la salida.',
          'A {frontSecStr} de {frontNameSafe}. No te abras en la entrada.',
          '{frontNameSafe} est cerca. Prepara el pase.',
          '{frontNameSafe} est cerca. Ataque con calma.',
          '{frontNameSafe} est cerca. Busca salida fuerte.',
          '{frontNameSafe} est cerca. Sin arriesgar de más.',
          '{frontNameSafe} est cerca. Cuida la entrada y acelera.'
        ],
        defense: [
          '{backNameSafe} a {backSecStr}. Cierra la puerta.',
          '{backNameSafe} a {backSecStr}. línea firme.',
          '{backNameSafe} a {backSecStr}. No regales la entrada.',
          '{backNameSafe} a {backSecStr}. Protege interior.',
          '{backNameSafe} a {backSecStr}. Salida fuerte y recto.',
          '{backNameSafe} a {backSecStr}. Sin volantazos.',
          '{backNameSafe} a {backSecStr}. No te abras.',
          '{backNameSafe} a {backSecStr}. Defiende con trazada.',
          '{backNameSafe} a {backSecStr}. Cubre lo básico.',
          '{backNameSafe} a {backSecStr}. No te desconcentres.',
          'presión atr s: {backNameSafe} a {backSecStr}. Cierra la puerta.',
          'presión atr s: {backNameSafe} a {backSecStr}. línea firme.',
          'presión atr s: {backNameSafe} a {backSecStr}. No regales la entrada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Protege interior.',
          'presión atr s: {backNameSafe} a {backSecStr}. Salida fuerte y recto.',
          'presión atr s: {backNameSafe} a {backSecStr}. Sin volantazos.',
          'presión atr s: {backNameSafe} a {backSecStr}. No te abras.',
          'presión atr s: {backNameSafe} a {backSecStr}. Defiende con trazada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Cubre lo básico.',
          'presión atr s: {backNameSafe} a {backSecStr}. No te desconcentres.',
          'Ojo atr s con {backNameSafe}. Cierra la puerta.',
          'Ojo atr s con {backNameSafe}. línea firme.',
          'Ojo atr s con {backNameSafe}. No regales la entrada.',
          'Ojo atr s con {backNameSafe}. Protege interior.',
          'Ojo atr s con {backNameSafe}. Salida fuerte y recto.'
        ],
        fight: [
          'Dos frentes, cabeza fría.',
          'Dos frentes, cabeza fría. Controla el volante.',
          'Dos frentes, cabeza fría. Sin regalos.',
          'Dos frentes, cabeza fría. Todo con calma.',
          'Dos frentes, cabeza fría. Limpio y rápido.',
          'Pelea cerrada, cero errores.',
          'Pelea cerrada, cero errores. Controla el volante.',
          'Pelea cerrada, cero errores. Sin regalos.',
          'Pelea cerrada, cero errores. Todo con calma.',
          'Pelea cerrada, cero errores. Limpio y rápido.',
          'tráfico, no te enredes.',
          'tráfico, no te enredes. Controla el volante.',
          'tráfico, no te enredes. Sin regalos.',
          'tráfico, no te enredes. Todo con calma.',
          'tráfico, no te enredes. Limpio y rápido.',
          'Mucho movimiento, Mantén la línea.',
          'Mucho movimiento, Mantén la línea. Controla el volante.',
          'Mucho movimiento, Mantén la línea. Sin regalos.',
          'Mucho movimiento, Mantén la línea. Todo con calma.',
          'Mucho movimiento, Mantén la línea. Limpio y rápido.',
          'Hay pelea, prioriza la salida.',
          'Hay pelea, prioriza la salida. Controla el volante.',
          'Hay pelea, prioriza la salida. Sin regalos.',
          'Hay pelea, prioriza la salida. Todo con calma.',
          'Hay pelea, prioriza la salida. Limpio y rápido.'
        ],
        blueflag: [
          'Bandera azul, Mantén línea.',
          'Bandera azul, Mantén línea. Sin drama.',
          'Bandera azul, Mantén línea. Con seguridad.',
          'Bandera azul, Mantén línea. Sin perder la línea.',
          'Bandera azul, Mantén línea. Todo limpio.',
          'Bandera azul, deja pasar seguro.',
          'Bandera azul, deja pasar seguro. Sin drama.',
          'Bandera azul, deja pasar seguro. Con seguridad.',
          'Bandera azul, deja pasar seguro. Sin perder la línea.',
          'Bandera azul, deja pasar seguro. Todo limpio.',
          'Bandera azul, no pelees la posición.',
          'Bandera azul, no pelees la posición. Sin drama.',
          'Bandera azul, no pelees la posición. Con seguridad.',
          'Bandera azul, no pelees la posición. Sin perder la línea.',
          'Bandera azul, no pelees la posición. Todo limpio.',
          'Bandera azul, cede sin frenar de más.',
          'Bandera azul, cede sin frenar de más. Sin drama.',
          'Bandera azul, cede sin frenar de más. Con seguridad.',
          'Bandera azul, cede sin frenar de más. Sin perder la línea.',
          'Bandera azul, cede sin frenar de más. Todo limpio.',
          'Bandera azul, facilita el pase.',
          'Bandera azul, facilita el pase. Sin drama.',
          'Bandera azul, facilita el pase. Con seguridad.',
          'Bandera azul, facilita el pase. Sin perder la línea.',
          'Bandera azul, facilita el pase. Todo limpio.'
        ],
        front06: [
          '{frontNameSafe} a {frontSecStr}. Es alcanzable.',
          '{frontNameSafe} a {frontSecStr}. Ventana de pase.',
          '{frontNameSafe} a {frontSecStr}. Mantén la presión.',
          '{frontNameSafe} a {frontSecStr}. Busca salida fuerte.',
          '{frontNameSafe} a {frontSecStr}. Sin desesperarte.',
          '{frontNameSafe} a {frontSecStr}. Cuida la entrada.',
          '{frontNameSafe} a {frontSecStr}. Una curva bien hecha y ests.',
          '{frontNameSafe} a {frontSecStr}. No te abras.',
          '{frontNameSafe} a {frontSecStr}. Pase posible en la siguiente.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Es alcanzable.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ventana de pase.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Mantén la presión.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Busca salida fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Sin desesperarte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Cuida la entrada.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una curva bien hecha y ests.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No te abras.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Pase posible en la siguiente.',
          'A {frontSecStr} de {frontNameSafe}. Es alcanzable.',
          'A {frontSecStr} de {frontNameSafe}. Ventana de pase.',
          'A {frontSecStr} de {frontNameSafe}. Mantén la presión.',
          'A {frontSecStr} de {frontNameSafe}. Busca salida fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Sin desesperarte.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Una curva bien hecha y ests.'
        ],
        back06: [
          '{backNameSafe} a {backSecStr}. Defiende.',
          '{backNameSafe} a {backSecStr}. Cubre interior.',
          '{backNameSafe} a {backSecStr}. línea firme.',
          '{backNameSafe} a {backSecStr}. No regales la salida.',
          '{backNameSafe} a {backSecStr}. Sin errores.',
          '{backNameSafe} a {backSecStr}. No te abras.',
          '{backNameSafe} a {backSecStr}. Protege la trazada.',
          '{backNameSafe} a {backSecStr}. Salida fuerte.',
          '{backNameSafe} a {backSecStr}. Calma y control.',
          'presión atr s: {backNameSafe} {backSecStr}. Defiende.',
          'presión atr s: {backNameSafe} {backSecStr}. Cubre interior.',
          'presión atr s: {backNameSafe} {backSecStr}. línea firme.',
          'presión atr s: {backNameSafe} {backSecStr}. No regales la salida.',
          'presión atr s: {backNameSafe} {backSecStr}. Sin errores.',
          'presión atr s: {backNameSafe} {backSecStr}. No te abras.',
          'presión atr s: {backNameSafe} {backSecStr}. Protege la trazada.',
          'presión atr s: {backNameSafe} {backSecStr}. Salida fuerte.',
          'presión atr s: {backNameSafe} {backSecStr}. Calma y control.',
          '{backNameSafe} en rango: {backSecStr}. Defiende.',
          '{backNameSafe} en rango: {backSecStr}. Cubre interior.',
          '{backNameSafe} en rango: {backSecStr}. línea firme.',
          '{backNameSafe} en rango: {backSecStr}. No regales la salida.',
          '{backNameSafe} en rango: {backSecStr}. Sin errores.',
          '{backNameSafe} en rango: {backSecStr}. No te abras.',
          '{backNameSafe} en rango: {backSecStr}. Protege la trazada.'
        ],
        pos: [
          'Quedaste P{posNow}. enf cate.',
          'Quedaste P{posNow}. Calma y ritmo.',
          'Quedaste P{posNow}. A trabajar.',
          'Quedaste P{posNow}. No te desconcentres.',
          'Quedaste P{posNow}. Hazlo simple.',
          'Quedaste P{posNow}. Cuida la salida.',
          'Quedaste P{posNow}. Ritmo constante.',
          'Quedaste P{posNow}. Sin errores.',
          'Quedaste P{posNow}. Vuelve al plan.',
          'Ahora P{posNow}. enf cate.',
          'Ahora P{posNow}. Calma y ritmo.',
          'Ahora P{posNow}. A trabajar.',
          'Ahora P{posNow}. No te desconcentres.',
          'Ahora P{posNow}. Hazlo simple.',
          'Ahora P{posNow}. Cuida la salida.',
          'Ahora P{posNow}. Ritmo constante.',
          'Ahora P{posNow}. Sin errores.',
          'Ahora P{posNow}. Vuelve al plan.',
          'Vas P{posNow}. enf cate.',
          'Vas P{posNow}. Calma y ritmo.',
          'Vas P{posNow}. A trabajar.',
          'Vas P{posNow}. No te desconcentres.',
          'Vas P{posNow}. Hazlo simple.',
          'Vas P{posNow}. Cuida la salida.',
          'Vas P{posNow}. Ritmo constante.'
        ],
        leader: [
          'líder al frente, controla tus marcas.',
          'líder al frente, controla tus marcas. Sin errores.',
          'líder al frente, controla tus marcas. Limpio.',
          'líder al frente, controla tus marcas. Control total.',
          'líder al frente, controla tus marcas. Paso a paso.',
          'Referencia del líder, no te salgas.',
          'Referencia del líder, no te salgas. Sin errores.',
          'Referencia del líder, no te salgas. Limpio.',
          'Referencia del líder, no te salgas. Control total.',
          'Referencia del líder, no te salgas. Paso a paso.',
          'Mira al líder y copia la línea.',
          'Mira al líder y copia la línea. Sin errores.',
          'Mira al líder y copia la línea. Limpio.',
          'Mira al líder y copia la línea. Control total.',
          'Mira al líder y copia la línea. Paso a paso.',
          'El líder marca el ritmo, Mantén precisin.',
          'El líder marca el ritmo, Mantén precisin. Sin errores.',
          'El líder marca el ritmo, Mantén precisin. Limpio.',
          'El líder marca el ritmo, Mantén precisin. Control total.',
          'El líder marca el ritmo, Mantén precisin. Paso a paso.',
          'Observa al líder, trazada limpia.',
          'Observa al líder, trazada limpia. Sin errores.',
          'Observa al líder, trazada limpia. Limpio.',
          'Observa al líder, trazada limpia. Control total.',
          'Observa al líder, trazada limpia. Paso a paso.'
        ],
        podium: [
          'Huele a podio, no te compliques.',
          'Huele a podio, no te compliques. Controla.',
          'Huele a podio, no te compliques. Sin drama.',
          'Huele a podio, no te compliques. Cero regalos.',
          'Huele a podio, no te compliques. Bien hecho.',
          'Podio posible, manejo fino.',
          'Podio posible, manejo fino. Controla.',
          'Podio posible, manejo fino. Sin drama.',
          'Podio posible, manejo fino. Cero regalos.',
          'Podio posible, manejo fino. Bien hecho.',
          'Podio a la vista, sin errores.',
          'Podio a la vista, sin errores. Controla.',
          'Podio a la vista, sin errores. Sin drama.',
          'Podio a la vista, sin errores. Cero regalos.',
          'Podio a la vista, sin errores. Bien hecho.',
          'Podio cerca, no regales la salida.',
          'Podio cerca, no regales la salida. Controla.',
          'Podio cerca, no regales la salida. Sin drama.',
          'Podio cerca, no regales la salida. Cero regalos.',
          'Podio cerca, no regales la salida. Bien hecho.',
          'Ests en zona de podio, calma.',
          'Ests en zona de podio, calma. Controla.',
          'Ests en zona de podio, calma. Sin drama.',
          'Ests en zona de podio, calma. Cero regalos.',
          'Ests en zona de podio, calma. Bien hecho.'
        ],
        trend: [
          'Buen ritmo, repite.',
          'Buen ritmo, repite. Sin apuro.',
          'Buen ritmo, repite. Sin errores.',
          'Buen ritmo, repite. Limpio.',
          'Buen ritmo, repite. Control.',
          'Ritmo cay, ajusta.',
          'Ritmo cay, ajusta. Sin apuro.',
          'Ritmo cay, ajusta. Sin errores.',
          'Ritmo cay, ajusta. Limpio.',
          'Ritmo cay, ajusta. Control.',
          'Consistente, sigue as.',
          'Consistente, sigue as. Sin apuro.',
          'Consistente, sigue as. Sin errores.',
          'Consistente, sigue as. Limpio.',
          'Consistente, sigue as. Control.',
          'Mejorando ritmo, Mantén.',
          'Mejorando ritmo, Mantén. Sin apuro.',
          'Mejorando ritmo, Mantén. Sin errores.',
          'Mejorando ritmo, Mantén. Limpio.',
          'Mejorando ritmo, Mantén. Control.',
          'Ritmo irregular, calma y línea.',
          'Ritmo irregular, calma y línea. Sin apuro.',
          'Ritmo irregular, calma y línea. Sin errores.',
          'Ritmo irregular, calma y línea. Limpio.',
          'Ritmo irregular, calma y línea. Control.'
        ],
        est: [
          'estimación lista, Mantén el plan.',
          'estimación lista, Mantén el plan. Todo limpio.',
          'estimación lista, Mantén el plan. Sin drama.',
          'estimación lista, Mantén el plan. A tu ritmo.',
          'estimación lista, Mantén el plan. Control total.',
          'Ojo con la estimación, no te duermas.',
          'Ojo con la estimación, no te duermas. Todo limpio.',
          'Ojo con la estimación, no te duermas. Sin drama.',
          'Ojo con la estimación, no te duermas. A tu ritmo.',
          'Ojo con la estimación, no te duermas. Control total.',
          'estimación estable, sigue empujando.',
          'estimación estable, sigue empujando. Todo limpio.',
          'estimación estable, sigue empujando. Sin drama.',
          'estimación estable, sigue empujando. A tu ritmo.',
          'estimación estable, sigue empujando. Control total.',
          'estimación en marcha, cuida el ritmo.',
          'estimación en marcha, cuida el ritmo. Todo limpio.',
          'estimación en marcha, cuida el ritmo. Sin drama.',
          'estimación en marcha, cuida el ritmo. A tu ritmo.',
          'estimación en marcha, cuida el ritmo. Control total.',
          'estimación cambia, ajusta salida.',
          'estimación cambia, ajusta salida. Todo limpio.',
          'estimación cambia, ajusta salida. Sin drama.',
          'estimación cambia, ajusta salida. A tu ritmo.',
          'estimación cambia, ajusta salida. Control total.'
        ],
        bestlap: [
          'Nueva best lap, bien ahí.',
          'Nueva best lap, bien ahí. Mantén línea.',
          'Nueva best lap, bien ahí. Sin emoción extra.',
          'Nueva best lap, bien ahí. Control.',
          'Nueva best lap, bien ahí. Perfecto.',
          'Mejor vuelta, eso es.',
          'Mejor vuelta, eso es. Mantén línea.',
          'Mejor vuelta, eso es. Sin emoción extra.',
          'Mejor vuelta, eso es. Control.',
          'Mejor vuelta, eso es. Perfecto.',
          'Mejor vuelta, rep telo.',
          'Mejor vuelta, rep telo. Mantén línea.',
          'Mejor vuelta, rep telo. Sin emoción extra.',
          'Mejor vuelta, rep telo. Control.',
          'Mejor vuelta, rep telo. Perfecto.',
          'Mejoraste best lap, Mantén.',
          'Mejoraste best lap, Mantén. Mantén línea.',
          'Mejoraste best lap, Mantén. Sin emoción extra.',
          'Mejoraste best lap, Mantén. Control.',
          'Mejoraste best lap, Mantén. Perfecto.',
          'Mejor vuelta confirmada, buen trabajo.',
          'Mejor vuelta confirmada, buen trabajo. Mantén línea.',
          'Mejor vuelta confirmada, buen trabajo. Sin emoción extra.',
          'Mejor vuelta confirmada, buen trabajo. Control.',
          'Mejor vuelta confirmada, buen trabajo. Perfecto.'
        ],

        cons10: [
          'Consistencia.',
          'Metrónomo.',
          'Estable.',
          'Buen control.'
        ],

        netgain: [
          'Buena ganancia.',
          'Remontada limpia.',
          'Posiciones a favor.',
          'Eso suma.'
        ],

        ritmo_up: [
          'Ritmo arriba.',
          'Vienes cerrando.',
          'Mejorando el paso.',
          'Apretando bien.'
        ],

        ritmo_down: [
          'Ritmo bajó.',
          'Recupera el plan.',
          'Calma y limpio.',
          'Vuelve a lo básico.'
        ],

        total: [
          'Suma vueltas.',
          'Volumen.',
          'Trabajo de hormiga.',
          'Mantén la cuenta.'
        ],

        box: [
          'Reset.',
          'Box.',
          'Ajuste rápido.',
          'Respira.'
        ],
      },
      stratega: {
        manga: [
          'Manga, contra reloj. Busca vuelta limpia.',
          'Manga, contra reloj. Busca vuelta limpia. Mantén el plan.',
          'Manga, contra reloj. Busca vuelta limpia. Sin inventar.',
          'Manga, contra reloj. Busca vuelta limpia. Cero errores.',
          'Manga, contra reloj. Busca vuelta limpia. Vuelta a vuelta.',
          'Manga, suma vueltas y no te salgas.',
          'Manga, suma vueltas y no te salgas. Mantén el plan.',
          'Manga, suma vueltas y no te salgas. Sin inventar.',
          'Manga, suma vueltas y no te salgas. Cero errores.',
          'Manga, suma vueltas y no te salgas. Vuelta a vuelta.',
          'Manga, ritmo constante y sin tráfico.',
          'Manga, ritmo constante y sin tráfico. Mantén el plan.',
          'Manga, ritmo constante y sin tráfico. Sin inventar.',
          'Manga, ritmo constante y sin tráfico. Cero errores.',
          'Manga, ritmo constante y sin tráfico. Vuelta a vuelta.',
          'Manga, prioriza vuelta clara, no pelea.',
          'Manga, prioriza vuelta clara, no pelea. Mantén el plan.',
          'Manga, prioriza vuelta clara, no pelea. Sin inventar.',
          'Manga, prioriza vuelta clara, no pelea. Cero errores.',
          'Manga, prioriza vuelta clara, no pelea. Vuelta a vuelta.',
          'Manga, presión controlada, sin riesgos.',
          'Manga, presión controlada, sin riesgos. Mantén el plan.',
          'Manga, presión controlada, sin riesgos. Sin inventar.',
          'Manga, presión controlada, sin riesgos. Cero errores.',
          'Manga, presión controlada, sin riesgos. Vuelta a vuelta.'
        ],
        attack_front: [
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Ataque quirrgico.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Entra fuerte y sal más fuerte.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Busca la línea corta.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Una vuelta más y lo ejecutas.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Ataque quirrgico.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Entra fuerte y sal más fuerte.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Busca la línea corta.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Una vuelta más y lo ejecutas.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Ataque quirrgico.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Entra fuerte y sal más fuerte.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Busca la línea corta.',
          'Arriba est {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Arriba est {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.'
        ],
        attack_mid: [
          '{frontNameSafe} a {frontSecStr}. Arma el pase con paciencia.',
          '{frontNameSafe} a {frontSecStr}. Intenta en recta.',
          '{frontNameSafe} a {frontSecStr}. Cuida la entrada y sal fuerte.',
          '{frontNameSafe} a {frontSecStr}. Si no se da, vuelve a intentarlo.',
          '{frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          '{frontNameSafe} a {frontSecStr}. p salo y respira.',
          '{frontNameSafe} a {frontSecStr}. Hazlo simple y limpio.',
          '{frontNameSafe} a {frontSecStr}. Busca error y capitaliza.',
          '{frontNameSafe} a {frontSecStr}. Coloca el coche y listo.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Arma el pase con paciencia.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Intenta en recta.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Cuida la entrada y sal fuerte.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Si no se da, vuelve a intentarlo.',
          'Cierre con {frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          'Cierre con {frontNameSafe} a {frontSecStr}. p salo y respira.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Hazlo simple y limpio.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Busca error y capitaliza.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Coloca el coche y listo.',
          'A {frontSecStr} de {frontNameSafe}. Arma el pase con paciencia.',
          'A {frontSecStr} de {frontNameSafe}. Intenta en recta.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada y sal fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Si no se da, vuelve a intentarlo.',
          'A {frontSecStr} de {frontNameSafe}. No te abras en la entrada.',
          'A {frontSecStr} de {frontNameSafe}. p salo y respira.',
          'A {frontSecStr} de {frontNameSafe}. Hazlo simple y limpio.'
        ],
        attack_back: [
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec talo.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Presiona y toma la puerta.',
          'Recupera posición: {frontNameSafe} a {frontSecStr}. Pase rápido, sin drama.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec talo.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Presiona y toma la puerta.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pase rápido, sin drama.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec talo.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.'
        ],
        defense_front: [
          'Defiende el podio: {backNameSafe} a {backSecStr}. Cubre interior.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. línea dura, sin golpes.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Cierra la puerta y acelera limpio.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Defensa inteligente, sin error.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No frenes de más.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Hazlo predecible y firme.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Cubre interior.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. línea dura, sin golpes.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Cierra la puerta y acelera limpio.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Defensa inteligente, sin error.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No frenes de más.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Hazlo predecible y firme.',
          'presión por podio: {backNameSafe} {backSecStr}. Cubre interior.',
          'presión por podio: {backNameSafe} {backSecStr}. línea dura, sin golpes.',
          'presión por podio: {backNameSafe} {backSecStr}. Salida fuerte.',
          'presión por podio: {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'presión por podio: {backNameSafe} {backSecStr}. Cierra la puerta y acelera limpio.',
          'presión por podio: {backNameSafe} {backSecStr}. Defensa inteligente, sin error.',
          'presión por podio: {backNameSafe} {backSecStr}. No te abras en la entrada.'
        ],
        defense_mid: [
          '{backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          '{backNameSafe} a {backSecStr}. Defiende con línea, no con volantazo.',
          '{backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          '{backNameSafe} a {backSecStr}. No regales la curva.',
          '{backNameSafe} a {backSecStr}. Calma, trazada limpia.',
          '{backNameSafe} a {backSecStr}. No frenes tarde de más.',
          '{backNameSafe} a {backSecStr}. Mantén la puerta cerrada.',
          '{backNameSafe} a {backSecStr}. Control total.',
          'Te cazan: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Te cazan: {backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          'Te cazan: {backNameSafe} a {backSecStr}. Defiende con línea, no con volantazo.',
          'Te cazan: {backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          'Te cazan: {backNameSafe} a {backSecStr}. No regales la curva.',
          'Te cazan: {backNameSafe} a {backSecStr}. Calma, trazada limpia.',
          'Te cazan: {backNameSafe} a {backSecStr}. No frenes tarde de más.',
          'Te cazan: {backNameSafe} a {backSecStr}. Mantén la puerta cerrada.',
          'Te cazan: {backNameSafe} a {backSecStr}. Control total.',
          'presión atr s con {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'presión atr s con {backNameSafe} {backSecStr}. Salida fuerte, sin error.',
          'presión atr s con {backNameSafe} {backSecStr}. Defiende con línea, no con volantazo.',
          'presión atr s con {backNameSafe} {backSecStr}. Cubre interior y acelera.',
          'presión atr s con {backNameSafe} {backSecStr}. No regales la curva.',
          'presión atr s con {backNameSafe} {backSecStr}. Calma, trazada limpia.',
          'presión atr s con {backNameSafe} {backSecStr}. No frenes tarde de más.'
        ],
        defense_back: [
          'No regales: {backNameSafe} a {backSecStr}. Orden y manejo.',
          'No regales: {backNameSafe} a {backSecStr}. Sube ritmo sin error.',
          'No regales: {backNameSafe} a {backSecStr}. Cubre interior y listo.',
          'No regales: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'No regales: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'No regales: {backNameSafe} a {backSecStr}. No inventes, defiende.',
          'No regales: {backNameSafe} a {backSecStr}. línea firme.',
          'No regales: {backNameSafe} a {backSecStr}. Sin drama, pero firme.',
          'No regales: {backNameSafe} a {backSecStr}. Mantén la calma.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Orden y manejo.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Sube ritmo sin error.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Cubre interior y listo.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. No te abras en la entrada.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Salida fuerte.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. No inventes, defiende.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. línea firme.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Sin drama, pero firme.',
          'Defiende lo básico: {backNameSafe} {backSecStr}. Mantén la calma.',
          'presión real: {backNameSafe} a {backSecStr}. Orden y manejo.',
          'presión real: {backNameSafe} a {backSecStr}. Sube ritmo sin error.',
          'presión real: {backNameSafe} a {backSecStr}. Cubre interior y listo.',
          'presión real: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'presión real: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'presión real: {backNameSafe} a {backSecStr}. No inventes, defiende.',
          'presión real: {backNameSafe} a {backSecStr}. línea firme.'
        ],
        fight: [
          'Pelea viva: adelante y atr s. Prioriza salida.',
          'Pelea viva: adelante y atr s. Prioriza salida. Plan claro.',
          'Pelea viva: adelante y atr s. Prioriza salida. Sin riesgos tontos.',
          'Pelea viva: adelante y atr s. Prioriza salida. Salida fuerte.',
          'Pelea viva: adelante y atr s. Prioriza salida. Todo limpio.',
          'Doble presión, decide: o atacas o aseguras.',
          'Doble presión, decide: o atacas o aseguras. Plan claro.',
          'Doble presión, decide: o atacas o aseguras. Sin riesgos tontos.',
          'Doble presión, decide: o atacas o aseguras. Salida fuerte.',
          'Doble presión, decide: o atacas o aseguras. Todo limpio.',
          'tráfico pesado. No pierdas tiempo en tonteras.',
          'tráfico pesado. No pierdas tiempo en tonteras. Plan claro.',
          'tráfico pesado. No pierdas tiempo en tonteras. Sin riesgos tontos.',
          'tráfico pesado. No pierdas tiempo en tonteras. Salida fuerte.',
          'tráfico pesado. No pierdas tiempo en tonteras. Todo limpio.',
          'Dos frentes. Elige la batalla correcta.',
          'Dos frentes. Elige la batalla correcta. Plan claro.',
          'Dos frentes. Elige la batalla correcta. Sin riesgos tontos.',
          'Dos frentes. Elige la batalla correcta. Salida fuerte.',
          'Dos frentes. Elige la batalla correcta. Todo limpio.',
          'Cuidado con el tráfico, no regales segundos.',
          'Cuidado con el tráfico, no regales segundos. Plan claro.',
          'Cuidado con el tráfico, no regales segundos. Sin riesgos tontos.',
          'Cuidado con el tráfico, no regales segundos. Salida fuerte.',
          'Cuidado con el tráfico, no regales segundos. Todo limpio.'
        ],
        blueflag: [
          'Bandera azul. líder encima. Mantén línea y deja pasar.',
          'Bandera azul. líder encima. Mantén línea y deja pasar. Con seguridad.',
          'Bandera azul. líder encima. Mantén línea y deja pasar. Sin perder tiempo.',
          'Bandera azul. líder encima. Mantén línea y deja pasar. Todo limpio.',
          'Bandera azul. líder encima. Mantén línea y deja pasar. Sin riesgos.',
          'Bandera azul. No te metas en broncas, cede seguro.',
          'Bandera azul. No te metas en broncas, cede seguro. Con seguridad.',
          'Bandera azul. No te metas en broncas, cede seguro. Sin perder tiempo.',
          'Bandera azul. No te metas en broncas, cede seguro. Todo limpio.',
          'Bandera azul. No te metas en broncas, cede seguro. Sin riesgos.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Con seguridad.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Sin perder tiempo.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Todo limpio.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Sin riesgos.',
          'Bandera azul. línea predecible, no frenes raro.',
          'Bandera azul. línea predecible, no frenes raro. Con seguridad.',
          'Bandera azul. línea predecible, no frenes raro. Sin perder tiempo.',
          'Bandera azul. línea predecible, no frenes raro. Todo limpio.',
          'Bandera azul. línea predecible, no frenes raro. Sin riesgos.',
          'Bandera azul. Abre espacio en la salida.',
          'Bandera azul. Abre espacio en la salida. Con seguridad.',
          'Bandera azul. Abre espacio en la salida. Sin perder tiempo.',
          'Bandera azul. Abre espacio en la salida. Todo limpio.',
          'Bandera azul. Abre espacio en la salida. Sin riesgos.'
        ],
        front06: [
          '{frontNameSafe} a {frontSecStr}. Ventana de ataque abierta.',
          '{frontNameSafe} a {frontSecStr}. Prepara maniobra.',
          '{frontNameSafe} a {frontSecStr}. Entra fuerte, sal más fuerte.',
          '{frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          '{frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          '{frontNameSafe} a {frontSecStr}. Busca el error y capitaliza.',
          '{frontNameSafe} a {frontSecStr}. Ataque en zona segura.',
          '{frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          '{frontNameSafe} a {frontSecStr}. Una vuelta más y lo ejecutas.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ventana de ataque abierta.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Prepara maniobra.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Entra fuerte, sal más fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No dudes en la recta.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Corta la curva y acelera.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Busca el error y capitaliza.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ataque en zona segura.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Presiona sin regalar.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una vuelta más y lo ejecutas.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Ventana de ataque abierta.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Prepara maniobra.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Entra fuerte, sal más fuerte.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Busca el error y capitaliza.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Ataque en zona segura.'
        ],
        back06: [
          '{backNameSafe} a {backSecStr}. Defensa inteligente, sin errores.',
          '{backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          '{backNameSafe} a {backSecStr}. No abras la puerta.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          '{backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          '{backNameSafe} a {backSecStr}. Trazada firme, sin volantazo.',
          '{backNameSafe} a {backSecStr}. Defiende con cabeza.',
          '{backNameSafe} a {backSecStr}. No regales la curva.',
          '{backNameSafe} a {backSecStr}. Calma y control.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Defensa inteligente, sin errores.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Cubre interior y acelera.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. No abras la puerta.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Salida fuerte, sin error.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Trazada firme, sin volantazo.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Defiende con cabeza.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. No regales la curva.',
          'Gap chico atr s: {backNameSafe} {backSecStr}. Calma y control.',
          'presión atr s: {backNameSafe} a {backSecStr}. Defensa inteligente, sin errores.',
          'presión atr s: {backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          'presión atr s: {backNameSafe} a {backSecStr}. No abras la puerta.',
          'presión atr s: {backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          'presión atr s: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Trazada firme, sin volantazo.',
          'presión atr s: {backNameSafe} a {backSecStr}. Defiende con cabeza.'
        ],
        pos: [
          'Ahora P{posNow}. Reacciona: línea limpia y salida fuerte.',
          'Ahora P{posNow}. Cero errores, recupera ritmo.',
          'Ahora P{posNow}. acom date y vuelve al ataque.',
          'Ahora P{posNow}. Plan claro: salida manda.',
          'Ahora P{posNow}. Busca aire limpio y aprieta.',
          'Ahora P{posNow}. Sin prisa tonta, pero firme.',
          'Ahora P{posNow}. Orden y gas.',
          'Ahora P{posNow}. No inventes, ejecuta.',
          'Ahora P{posNow}. A trabajar, vuelta a vuelta.',
          'P{posNow}. Reacciona: línea limpia y salida fuerte.',
          'P{posNow}. Cero errores, recupera ritmo.',
          'P{posNow}. acom date y vuelve al ataque.',
          'P{posNow}. Plan claro: salida manda.',
          'P{posNow}. Busca aire limpio y aprieta.',
          'P{posNow}. Sin prisa tonta, pero firme.',
          'P{posNow}. Orden y gas.',
          'P{posNow}. No inventes, ejecuta.',
          'P{posNow}. A trabajar, vuelta a vuelta.',
          'Vas P{posNow}. Reacciona: línea limpia y salida fuerte.',
          'Vas P{posNow}. Cero errores, recupera ritmo.',
          'Vas P{posNow}. acom date y vuelve al ataque.',
          'Vas P{posNow}. Plan claro: salida manda.',
          'Vas P{posNow}. Busca aire limpio y aprieta.',
          'Vas P{posNow}. Sin prisa tonta, pero firme.',
          'Vas P{posNow}. Orden y gas.'
        ],
        leader: [
          'líder al frente. Usa referencia y no te desesperes.',
          'líder al frente. Usa referencia y no te desesperes. Plan claro.',
          'líder al frente. Usa referencia y no te desesperes. Vuelta a vuelta.',
          'líder al frente. Usa referencia y no te desesperes. Control total.',
          'líder al frente. Usa referencia y no te desesperes. Salida fuerte.',
          'El líder marca la pauta. Copia frenada y salida.',
          'El líder marca la pauta. Copia frenada y salida. Plan claro.',
          'El líder marca la pauta. Copia frenada y salida. Vuelta a vuelta.',
          'El líder marca la pauta. Copia frenada y salida. Control total.',
          'El líder marca la pauta. Copia frenada y salida. Salida fuerte.',
          'Mide al líder. Tu carrera es precisin.',
          'Mide al líder. Tu carrera es precisin. Plan claro.',
          'Mide al líder. Tu carrera es precisin. Vuelta a vuelta.',
          'Mide al líder. Tu carrera es precisin. Control total.',
          'Mide al líder. Tu carrera es precisin. Salida fuerte.',
          'líder al frente. No persigas, ejecuta.',
          'líder al frente. No persigas, ejecuta. Plan claro.',
          'líder al frente. No persigas, ejecuta. Vuelta a vuelta.',
          'líder al frente. No persigas, ejecuta. Control total.',
          'líder al frente. No persigas, ejecuta. Salida fuerte.',
          'líder adelante. Tu vuelta, tu plan.',
          'líder adelante. Tu vuelta, tu plan. Plan claro.',
          'líder adelante. Tu vuelta, tu plan. Vuelta a vuelta.',
          'líder adelante. Tu vuelta, tu plan. Control total.',
          'líder adelante. Tu vuelta, tu plan. Salida fuerte.'
        ],
        podium: [
          'Podio posible. Prioriza consistencia y no te enredes.',
          'Podio posible. Prioriza consistencia y no te enredes. Sin riesgos tontos.',
          'Podio posible. Prioriza consistencia y no te enredes. Control.',
          'Podio posible. Prioriza consistencia y no te enredes. Limpio.',
          'Podio posible. Prioriza consistencia y no te enredes. Firme.',
          'Ests peleando podio. Manejo fino, cero regalos.',
          'Ests peleando podio. Manejo fino, cero regalos. Sin riesgos tontos.',
          'Ests peleando podio. Manejo fino, cero regalos. Control.',
          'Ests peleando podio. Manejo fino, cero regalos. Limpio.',
          'Ests peleando podio. Manejo fino, cero regalos. Firme.',
          'Podio cerca. Paciencia en el tráfico.',
          'Podio cerca. Paciencia en el tráfico. Sin riesgos tontos.',
          'Podio cerca. Paciencia en el tráfico. Control.',
          'Podio cerca. Paciencia en el tráfico. Limpio.',
          'Podio cerca. Paciencia en el tráfico. Firme.',
          'Zona de podio. Salida manda.',
          'Zona de podio. Salida manda. Sin riesgos tontos.',
          'Zona de podio. Salida manda. Control.',
          'Zona de podio. Salida manda. Limpio.',
          'Zona de podio. Salida manda. Firme.',
          'Podio en juego. No inventes en la entrada.',
          'Podio en juego. No inventes en la entrada. Sin riesgos tontos.',
          'Podio en juego. No inventes en la entrada. Control.',
          'Podio en juego. No inventes en la entrada. Limpio.',
          'Podio en juego. No inventes en la entrada. Firme.'
        ],
        trend: [
          'Ritmo subiendo. Mantén la presión.',
          'Ritmo subiendo. Mantén la presión. Vuelta a vuelta.',
          'Ritmo subiendo. Mantén la presión. Control total.',
          'Ritmo subiendo. Mantén la presión. Sin errores.',
          'Ritmo subiendo. Mantén la presión. Plan claro.',
          'Ritmo baj. Corrige trazada y salida.',
          'Ritmo baj. Corrige trazada y salida. Vuelta a vuelta.',
          'Ritmo baj. Corrige trazada y salida. Control total.',
          'Ritmo baj. Corrige trazada y salida. Sin errores.',
          'Ritmo baj. Corrige trazada y salida. Plan claro.',
          'Consistente. Repite la línea y aprieta.',
          'Consistente. Repite la línea y aprieta. Vuelta a vuelta.',
          'Consistente. Repite la línea y aprieta. Control total.',
          'Consistente. Repite la línea y aprieta. Sin errores.',
          'Consistente. Repite la línea y aprieta. Plan claro.',
          'Ritmo slido. No cambies nada.',
          'Ritmo slido. No cambies nada. Vuelta a vuelta.',
          'Ritmo slido. No cambies nada. Control total.',
          'Ritmo slido. No cambies nada. Sin errores.',
          'Ritmo slido. No cambies nada. Plan claro.',
          'Ritmo irregular. Vuelve al plan.',
          'Ritmo irregular. Vuelve al plan. Vuelta a vuelta.',
          'Ritmo irregular. Vuelve al plan. Control total.',
          'Ritmo irregular. Vuelve al plan. Sin errores.',
          'Ritmo irregular. Vuelve al plan. Plan claro.'
        ],
        est: [
          'estimación en marcha. No te desconcentres.',
          'estimación en marcha. No te desconcentres. Control.',
          'estimación en marcha. No te desconcentres. Sin drama.',
          'estimación en marcha. No te desconcentres. Limpio.',
          'estimación en marcha. No te desconcentres. Plan claro.',
          'La estimación cambi. Ajusta y sigue.',
          'La estimación cambi. Ajusta y sigue. Control.',
          'La estimación cambi. Ajusta y sigue. Sin drama.',
          'La estimación cambi. Ajusta y sigue. Limpio.',
          'La estimación cambi. Ajusta y sigue. Plan claro.',
          'estimación estable. Mantén ritmo limpio.',
          'estimación estable. Mantén ritmo limpio. Control.',
          'estimación estable. Mantén ritmo limpio. Sin drama.',
          'estimación estable. Mantén ritmo limpio. Limpio.',
          'estimación estable. Mantén ritmo limpio. Plan claro.',
          'estimación lista. No regales la salida.',
          'estimación lista. No regales la salida. Control.',
          'estimación lista. No regales la salida. Sin drama.',
          'estimación lista. No regales la salida. Limpio.',
          'estimación lista. No regales la salida. Plan claro.',
          'estimación marcada. Control de riesgo.',
          'estimación marcada. Control de riesgo. Control.',
          'estimación marcada. Control de riesgo. Sin drama.',
          'estimación marcada. Control de riesgo. Limpio.',
          'estimación marcada. Control de riesgo. Plan claro.'
        ],
        bestlap: [
          'Mejor vuelta confirmada. Ahora rep tela sin riesgo.',
          'Mejor vuelta confirmada. Ahora rep tela sin riesgo. Sin riesgos.',
          'Mejor vuelta confirmada. Ahora rep tela sin riesgo. Limpio.',
          'Mejor vuelta confirmada. Ahora rep tela sin riesgo. Plan claro.',
          'Mejor vuelta confirmada. Ahora rep tela sin riesgo. Vuelta a vuelta.',
          'Mejoraste best lap. sostén el ritmo.',
          'Mejoraste best lap. sostén el ritmo. Sin riesgos.',
          'Mejoraste best lap. sostén el ritmo. Limpio.',
          'Mejoraste best lap. sostén el ritmo. Plan claro.',
          'Mejoraste best lap. sostén el ritmo. Vuelta a vuelta.',
          'Mejor vuelta. No te emociones, repite.',
          'Mejor vuelta. No te emociones, repite. Sin riesgos.',
          'Mejor vuelta. No te emociones, repite. Limpio.',
          'Mejor vuelta. No te emociones, repite. Plan claro.',
          'Mejor vuelta. No te emociones, repite. Vuelta a vuelta.',
          'Mejor vuelta. Buen trabajo, ahora consistencia.',
          'Mejor vuelta. Buen trabajo, ahora consistencia. Sin riesgos.',
          'Mejor vuelta. Buen trabajo, ahora consistencia. Limpio.',
          'Mejor vuelta. Buen trabajo, ahora consistencia. Plan claro.',
          'Mejor vuelta. Buen trabajo, ahora consistencia. Vuelta a vuelta.',
          'Nueva best lap. Mantén la línea.',
          'Nueva best lap. Mantén la línea. Sin riesgos.',
          'Nueva best lap. Mantén la línea. Limpio.',
          'Nueva best lap. Mantén la línea. Plan claro.',
          'Nueva best lap. Mantén la línea. Vuelta a vuelta.'
        ],

        cons10: [
          'Consistencia.',
          'Metrónomo.',
          'Estable.',
          'Buen control.'
        ],

        netgain: [
          'Buena ganancia.',
          'Remontada limpia.',
          'Posiciones a favor.',
          'Eso suma.'
        ],

        ritmo_up: [
          'Ritmo arriba.',
          'Vienes cerrando.',
          'Mejorando el paso.',
          'Apretando bien.'
        ],

        ritmo_down: [
          'Ritmo bajó.',
          'Recupera el plan.',
          'Calma y limpio.',
          'Vuelve a lo básico.'
        ],

        total: [
          'Suma vueltas.',
          'Volumen.',
          'Trabajo de hormiga.',
          'Mantén la cuenta.'
        ],

        box: [
          'Reset.',
          'Box.',
          'Ajuste rápido.',
          'Respira.'
        ],
      },
      coach: {
        manga: [
          'Manga: vuelta limpia. Respira y aprieta.',
          'Manga: vuelta limpia. Respira y aprieta. T  puedes.',
          'Manga: vuelta limpia. Respira y aprieta. Mantén el plan.',
          'Manga: vuelta limpia. Respira y aprieta. Sin presionarte.',
          'Manga: vuelta limpia. Respira y aprieta. Paso a paso.',
          'Manga: sin errores. Cada meta cuenta.',
          'Manga: sin errores. Cada meta cuenta. T  puedes.',
          'Manga: sin errores. Cada meta cuenta. Mantén el plan.',
          'Manga: sin errores. Cada meta cuenta. Sin presionarte.',
          'Manga: sin errores. Cada meta cuenta. Paso a paso.',
          'Manga: constancia. No persigas fantasmas.',
          'Manga: constancia. No persigas fantasmas. T  puedes.',
          'Manga: constancia. No persigas fantasmas. Mantén el plan.',
          'Manga: constancia. No persigas fantasmas. Sin presionarte.',
          'Manga: constancia. No persigas fantasmas. Paso a paso.',
          'Manga: manos suaves, línea firme.',
          'Manga: manos suaves, línea firme. T  puedes.',
          'Manga: manos suaves, línea firme. Mantén el plan.',
          'Manga: manos suaves, línea firme. Sin presionarte.',
          'Manga: manos suaves, línea firme. Paso a paso.',
          'Manga: aire limpio y ritmo estable.',
          'Manga: aire limpio y ritmo estable. T  puedes.',
          'Manga: aire limpio y ritmo estable. Mantén el plan.',
          'Manga: aire limpio y ritmo estable. Sin presionarte.',
          'Manga: aire limpio y ritmo estable. Paso a paso.'
        ],
        attack: [
          'Vas alcanzando a {frontNameSafe}. Entra suave, sal fuerte.',
          'Vas alcanzando a {frontNameSafe}. Prepara el pase seguro.',
          'Vas alcanzando a {frontNameSafe}. Hazlo limpio, sin tocar.',
          'Vas alcanzando a {frontNameSafe}. Cuida la salida y lo tienes.',
          'Vas alcanzando a {frontNameSafe}. Paciencia, el pase llega.',
          'Vas alcanzando a {frontNameSafe}. No fuerces la entrada.',
          'Vas alcanzando a {frontNameSafe}. Busca aire limpio y ejecuta.',
          'Vas alcanzando a {frontNameSafe}. Un giro más y cae.',
          'Vas alcanzando a {frontNameSafe}. Con calma y precisin.',
          'Vas alcanzando a {frontNameSafe}. Sin prisa tonta.',
          'A {frontSecStr} de {frontNameSafe}. Entra suave, sal fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Prepara el pase seguro.',
          'A {frontSecStr} de {frontNameSafe}. Hazlo limpio, sin tocar.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la salida y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Paciencia, el pase llega.',
          'A {frontSecStr} de {frontNameSafe}. No fuerces la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Busca aire limpio y ejecuta.',
          'A {frontSecStr} de {frontNameSafe}. Un giro más y cae.',
          'A {frontSecStr} de {frontNameSafe}. Con calma y precisin.',
          'A {frontSecStr} de {frontNameSafe}. Sin prisa tonta.',
          '{frontNameSafe} est cerca. Entra suave, sal fuerte.',
          '{frontNameSafe} est cerca. Prepara el pase seguro.',
          '{frontNameSafe} est cerca. Hazlo limpio, sin tocar.',
          '{frontNameSafe} est cerca. Cuida la salida y lo tienes.',
          '{frontNameSafe} est cerca. Paciencia, el pase llega.'
        ],
        defense: [
          'Te viene {backNameSafe}. Mantén tu línea y acelera limpio.',
          'Te viene {backNameSafe}. Puerta cerrada, sin frenar de más.',
          'Te viene {backNameSafe}. Protege interior.',
          'Te viene {backNameSafe}. Defiende con trazada, no con golpes.',
          'Te viene {backNameSafe}. Salida fuerte, manos suaves.',
          'Te viene {backNameSafe}. No te abras en la entrada.',
          'Te viene {backNameSafe}. Respira y controla.',
          'Te viene {backNameSafe}. Todo limpio.',
          'Te viene {backNameSafe}. Sin errores.',
          'Te viene {backNameSafe}. Calma, lo tienes.',
          '{backNameSafe} a {backSecStr}. Mantén tu línea y acelera limpio.',
          '{backNameSafe} a {backSecStr}. Puerta cerrada, sin frenar de más.',
          '{backNameSafe} a {backSecStr}. Protege interior.',
          '{backNameSafe} a {backSecStr}. Defiende con trazada, no con golpes.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, manos suaves.',
          '{backNameSafe} a {backSecStr}. No te abras en la entrada.',
          '{backNameSafe} a {backSecStr}. Respira y controla.',
          '{backNameSafe} a {backSecStr}. Todo limpio.',
          '{backNameSafe} a {backSecStr}. Sin errores.',
          '{backNameSafe} a {backSecStr}. Calma, lo tienes.',
          'Ojo atr s con {backNameSafe}. Mantén tu línea y acelera limpio.',
          'Ojo atr s con {backNameSafe}. Puerta cerrada, sin frenar de más.',
          'Ojo atr s con {backNameSafe}. Protege interior.',
          'Ojo atr s con {backNameSafe}. Defiende con trazada, no con golpes.',
          'Ojo atr s con {backNameSafe}. Salida fuerte, manos suaves.'
        ],
        fight: [
          'Hay pelea. Prioriza salida y cero errores.',
          'Hay pelea. Prioriza salida y cero errores. T  puedes.',
          'Hay pelea. Prioriza salida y cero errores. Paso a paso.',
          'Hay pelea. Prioriza salida y cero errores. Sin drama.',
          'Hay pelea. Prioriza salida y cero errores. Limpio y rápido.',
          'Dos frentes. Cabeza fría, trazada limpia.',
          'Dos frentes. Cabeza fría, trazada limpia. T  puedes.',
          'Dos frentes. Cabeza fría, trazada limpia. Paso a paso.',
          'Dos frentes. Cabeza fría, trazada limpia. Sin drama.',
          'Dos frentes. Cabeza fría, trazada limpia. Limpio y rápido.',
          'tráfico. No te enganches, s  inteligente.',
          'tráfico. No te enganches, s  inteligente. T  puedes.',
          'tráfico. No te enganches, s  inteligente. Paso a paso.',
          'tráfico. No te enganches, s  inteligente. Sin drama.',
          'tráfico. No te enganches, s  inteligente. Limpio y rápido.',
          'Mantén la calma, el pase llega.',
          'Mantén la calma, el pase llega. T  puedes.',
          'Mantén la calma, el pase llega. Paso a paso.',
          'Mantén la calma, el pase llega. Sin drama.',
          'Mantén la calma, el pase llega. Limpio y rápido.',
          'No todo es ahora, cuida el coche.',
          'No todo es ahora, cuida el coche. T  puedes.',
          'No todo es ahora, cuida el coche. Paso a paso.',
          'No todo es ahora, cuida el coche. Sin drama.',
          'No todo es ahora, cuida el coche. Limpio y rápido.'
        ],
        blueflag: [
          'Bandera azul. Deja pasar sin perder la línea.',
          'Bandera azul. Deja pasar sin perder la línea. Con seguridad.',
          'Bandera azul. Deja pasar sin perder la línea. Sin drama.',
          'Bandera azul. Deja pasar sin perder la línea. Todo limpio.',
          'Bandera azul. Deja pasar sin perder la línea. Sin riesgos.',
          'Bandera azul. Cede seguro y sigue tu ritmo.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Con seguridad.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Sin drama.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Todo limpio.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Sin riesgos.',
          'Bandera azul. Respeta, no arriesgues.',
          'Bandera azul. Respeta, no arriesgues. Con seguridad.',
          'Bandera azul. Respeta, no arriesgues. Sin drama.',
          'Bandera azul. Respeta, no arriesgues. Todo limpio.',
          'Bandera azul. Respeta, no arriesgues. Sin riesgos.',
          'Bandera azul. línea predecible.',
          'Bandera azul. línea predecible. Con seguridad.',
          'Bandera azul. línea predecible. Sin drama.',
          'Bandera azul. línea predecible. Todo limpio.',
          'Bandera azul. línea predecible. Sin riesgos.',
          'Bandera azul. Abre espacio en salida.',
          'Bandera azul. Abre espacio en salida. Con seguridad.',
          'Bandera azul. Abre espacio en salida. Sin drama.',
          'Bandera azul. Abre espacio en salida. Todo limpio.',
          'Bandera azul. Abre espacio en salida. Sin riesgos.'
        ],
        front06: [
          'Buen cierre con {frontNameSafe}. Si te abre, vas.',
          'Buen cierre con {frontNameSafe}. Mantén presión.',
          'Buen cierre con {frontNameSafe}. Una vuelta más y lo tienes.',
          'Buen cierre con {frontNameSafe}. Cuida la salida.',
          'Buen cierre con {frontNameSafe}. No fuerces la entrada.',
          'Buen cierre con {frontNameSafe}. Con calma, el pase llega.',
          'Buen cierre con {frontNameSafe}. Todo limpio.',
          'Buen cierre con {frontNameSafe}. Salida fuerte.',
          'Buen cierre con {frontNameSafe}. Aprovecha el error.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Si te abre, vas.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Mantén presión.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una vuelta más y lo tienes.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Cuida la salida.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No fuerces la entrada.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Con calma, el pase llega.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Todo limpio.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Salida fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Aprovecha el error.',
          'A {frontSecStr} de {frontNameSafe}. Si te abre, vas.',
          'A {frontSecStr} de {frontNameSafe}. Mantén presión.',
          'A {frontSecStr} de {frontNameSafe}. Una vuelta más y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la salida.',
          'A {frontSecStr} de {frontNameSafe}. No fuerces la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Con calma, el pase llega.',
          'A {frontSecStr} de {frontNameSafe}. Todo limpio.'
        ],
        back06: [
          '{backNameSafe} est encima. Defiende con trazada, no con golpes.',
          '{backNameSafe} est encima. línea firme y salida fuerte.',
          '{backNameSafe} est encima. Sin errores, lo aguantas.',
          '{backNameSafe} est encima. Calma y control.',
          '{backNameSafe} est encima. No te abras en la entrada.',
          '{backNameSafe} est encima. Puerta cerrada.',
          '{backNameSafe} est encima. Respira y acelera limpio.',
          '{backNameSafe} est encima. Cubre interior.',
          '{backNameSafe} est encima. Todo limpio.',
          'presión atr s: {backNameSafe} a {backSecStr}. Defiende con trazada, no con golpes.',
          'presión atr s: {backNameSafe} a {backSecStr}. línea firme y salida fuerte.',
          'presión atr s: {backNameSafe} a {backSecStr}. Sin errores, lo aguantas.',
          'presión atr s: {backNameSafe} a {backSecStr}. Calma y control.',
          'presión atr s: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Puerta cerrada.',
          'presión atr s: {backNameSafe} a {backSecStr}. Respira y acelera limpio.',
          'presión atr s: {backNameSafe} a {backSecStr}. Cubre interior.',
          'presión atr s: {backNameSafe} a {backSecStr}. Todo limpio.',
          '{backNameSafe} en rango: {backSecStr}. Defiende con trazada, no con golpes.',
          '{backNameSafe} en rango: {backSecStr}. línea firme y salida fuerte.',
          '{backNameSafe} en rango: {backSecStr}. Sin errores, lo aguantas.',
          '{backNameSafe} en rango: {backSecStr}. Calma y control.',
          '{backNameSafe} en rango: {backSecStr}. No te abras en la entrada.',
          '{backNameSafe} en rango: {backSecStr}. Puerta cerrada.',
          '{backNameSafe} en rango: {backSecStr}. Respira y acelera limpio.'
        ],
        pos: [
          'Ahora P{posNow}. Respira, vuelve al plan.',
          'Ahora P{posNow}. Calma y ritmo.',
          'Ahora P{posNow}. Trazada limpia.',
          'Ahora P{posNow}. A trabajar, vuelta a vuelta.',
          'Ahora P{posNow}. No te desconcentres.',
          'Ahora P{posNow}. T  puedes, sigue.',
          'Ahora P{posNow}. Sin errores.',
          'Ahora P{posNow}. Busca aire limpio.',
          'Ahora P{posNow}. Salida fuerte.',
          'Vas P{posNow}. Respira, vuelve al plan.',
          'Vas P{posNow}. Calma y ritmo.',
          'Vas P{posNow}. Trazada limpia.',
          'Vas P{posNow}. A trabajar, vuelta a vuelta.',
          'Vas P{posNow}. No te desconcentres.',
          'Vas P{posNow}. T  puedes, sigue.',
          'Vas P{posNow}. Sin errores.',
          'Vas P{posNow}. Busca aire limpio.',
          'Vas P{posNow}. Salida fuerte.',
          'posición P{posNow}. Respira, vuelve al plan.',
          'posición P{posNow}. Calma y ritmo.',
          'posición P{posNow}. Trazada limpia.',
          'posición P{posNow}. A trabajar, vuelta a vuelta.',
          'posición P{posNow}. No te desconcentres.',
          'posición P{posNow}. T  puedes, sigue.',
          'posición P{posNow}. Sin errores.'
        ],
        leader: [
          'El líder marca el ritmo. T  marca tu línea.',
          'El líder marca el ritmo. T  marca tu línea. T  puedes.',
          'El líder marca el ritmo. T  marca tu línea. Paso a paso.',
          'El líder marca el ritmo. T  marca tu línea. Sin errores.',
          'El líder marca el ritmo. T  marca tu línea. Control.',
          'Referencia del líder, sin obsesionarte.',
          'Referencia del líder, sin obsesionarte. T  puedes.',
          'Referencia del líder, sin obsesionarte. Paso a paso.',
          'Referencia del líder, sin obsesionarte. Sin errores.',
          'Referencia del líder, sin obsesionarte. Control.',
          'líder al frente. enf cate en tus marcas.',
          'líder al frente. enf cate en tus marcas. T  puedes.',
          'líder al frente. enf cate en tus marcas. Paso a paso.',
          'líder al frente. enf cate en tus marcas. Sin errores.',
          'líder al frente. enf cate en tus marcas. Control.',
          'Observa al líder y aprende la trazada.',
          'Observa al líder y aprende la trazada. T  puedes.',
          'Observa al líder y aprende la trazada. Paso a paso.',
          'Observa al líder y aprende la trazada. Sin errores.',
          'Observa al líder y aprende la trazada. Control.',
          'líder adelante. Paciencia y consistencia.',
          'líder adelante. Paciencia y consistencia. T  puedes.',
          'líder adelante. Paciencia y consistencia. Paso a paso.',
          'líder adelante. Paciencia y consistencia. Sin errores.',
          'líder adelante. Paciencia y consistencia. Control.'
        ],
        podium: [
          'Podio posible. Mantén cabeza fría.',
          'Podio posible. Mantén cabeza fría. Paso a paso.',
          'Podio posible. Mantén cabeza fría. Sin drama.',
          'Podio posible. Mantén cabeza fría. Control.',
          'Podio posible. Mantén cabeza fría. Limpio y rápido.',
          'Zona de podio. Todo limpio.',
          'Zona de podio. Todo limpio. Paso a paso.',
          'Zona de podio. Todo limpio. Sin drama.',
          'Zona de podio. Todo limpio. Control.',
          'Zona de podio. Todo limpio. Limpio y rápido.',
          'Podio en juego. No fuerces.',
          'Podio en juego. No fuerces. Paso a paso.',
          'Podio en juego. No fuerces. Sin drama.',
          'Podio en juego. No fuerces. Control.',
          'Podio en juego. No fuerces. Limpio y rápido.',
          'Por el trofeo. Trazada firme.',
          'Por el trofeo. Trazada firme. Paso a paso.',
          'Por el trofeo. Trazada firme. Sin drama.',
          'Por el trofeo. Trazada firme. Control.',
          'Por el trofeo. Trazada firme. Limpio y rápido.',
          'Podio cerca. Cuida la salida.',
          'Podio cerca. Cuida la salida. Paso a paso.',
          'Podio cerca. Cuida la salida. Sin drama.',
          'Podio cerca. Cuida la salida. Control.',
          'Podio cerca. Cuida la salida. Limpio y rápido.'
        ],
        trend: [
          'Ritmo mejorando. Mantén.',
          'Ritmo mejorando. Mantén. T  puedes.',
          'Ritmo mejorando. Mantén. Paso a paso.',
          'Ritmo mejorando. Mantén. Sin errores.',
          'Ritmo mejorando. Mantén. Control.',
          'Ritmo baj. Ajusta y sigue.',
          'Ritmo baj. Ajusta y sigue. T  puedes.',
          'Ritmo baj. Ajusta y sigue. Paso a paso.',
          'Ritmo baj. Ajusta y sigue. Sin errores.',
          'Ritmo baj. Ajusta y sigue. Control.',
          'Consistente. Buen trabajo.',
          'Consistente. Buen trabajo. T  puedes.',
          'Consistente. Buen trabajo. Paso a paso.',
          'Consistente. Buen trabajo. Sin errores.',
          'Consistente. Buen trabajo. Control.',
          'Ritmo slido. No cambies.',
          'Ritmo slido. No cambies. T  puedes.',
          'Ritmo slido. No cambies. Paso a paso.',
          'Ritmo slido. No cambies. Sin errores.',
          'Ritmo slido. No cambies. Control.',
          'Ritmo irregular. Respira y repite.',
          'Ritmo irregular. Respira y repite. T  puedes.',
          'Ritmo irregular. Respira y repite. Paso a paso.',
          'Ritmo irregular. Respira y repite. Sin errores.',
          'Ritmo irregular. Respira y repite. Control.'
        ],
        est: [
          'estimación lista. Mantén el plan.',
          'estimación lista. Mantén el plan. T  puedes.',
          'estimación lista. Mantén el plan. Sin drama.',
          'estimación lista. Mantén el plan. Limpio.',
          'estimación lista. Mantén el plan. Control.',
          'estimación cambi. Ajusta y sigue.',
          'estimación cambi. Ajusta y sigue. T  puedes.',
          'estimación cambi. Ajusta y sigue. Sin drama.',
          'estimación cambi. Ajusta y sigue. Limpio.',
          'estimación cambi. Ajusta y sigue. Control.',
          'estimación estable. No te desconcentres.',
          'estimación estable. No te desconcentres. T  puedes.',
          'estimación estable. No te desconcentres. Sin drama.',
          'estimación estable. No te desconcentres. Limpio.',
          'estimación estable. No te desconcentres. Control.',
          'estimación marcada. Todo limpio.',
          'estimación marcada. Todo limpio. T  puedes.',
          'estimación marcada. Todo limpio. Sin drama.',
          'estimación marcada. Todo limpio. Limpio.',
          'estimación marcada. Todo limpio. Control.',
          'estimación ok. Paso a paso.',
          'estimación ok. Paso a paso. T  puedes.',
          'estimación ok. Paso a paso. Sin drama.',
          'estimación ok. Paso a paso. Limpio.',
          'estimación ok. Paso a paso. Control.'
        ],
        bestlap: [
          'Mejor vuelta. Bien ahí, repite con calma.',
          'Mejor vuelta. Bien ahí, repite con calma. Paso a paso.',
          'Mejor vuelta. Bien ahí, repite con calma. Control.',
          'Mejor vuelta. Bien ahí, repite con calma. Sin errores.',
          'Mejor vuelta. Bien ahí, repite con calma. Limpio.',
          'Nueva best lap. Buen trabajo.',
          'Nueva best lap. Buen trabajo. Paso a paso.',
          'Nueva best lap. Buen trabajo. Control.',
          'Nueva best lap. Buen trabajo. Sin errores.',
          'Nueva best lap. Buen trabajo. Limpio.',
          'Mejor vuelta confirmada. Mantén.',
          'Mejor vuelta confirmada. Mantén. Paso a paso.',
          'Mejor vuelta confirmada. Mantén. Control.',
          'Mejor vuelta confirmada. Mantén. Sin errores.',
          'Mejor vuelta confirmada. Mantén. Limpio.',
          'Mejoraste best lap. Control total.',
          'Mejoraste best lap. Control total. Paso a paso.',
          'Mejoraste best lap. Control total. Control.',
          'Mejoraste best lap. Control total. Sin errores.',
          'Mejoraste best lap. Control total. Limpio.',
          'Mejor vuelta. Ahora consistencia.',
          'Mejor vuelta. Ahora consistencia. Paso a paso.',
          'Mejor vuelta. Ahora consistencia. Control.',
          'Mejor vuelta. Ahora consistencia. Sin errores.',
          'Mejor vuelta. Ahora consistencia. Limpio.'
        ],

        cons10: [
          'Consistencia.',
          'Metrónomo.',
          'Estable.',
          'Buen control.'
        ],

        netgain: [
          'Buena ganancia.',
          'Remontada limpia.',
          'Posiciones a favor.',
          'Eso suma.'
        ],

        ritmo_up: [
          'Ritmo arriba.',
          'Vienes cerrando.',
          'Mejorando el paso.',
          'Apretando bien.'
        ],

        ritmo_down: [
          'Ritmo bajó.',
          'Recupera el plan.',
          'Calma y limpio.',
          'Vuelve a lo básico.'
        ],

        total: [
          'Suma vueltas.',
          'Volumen.',
          'Trabajo de hormiga.',
          'Mantén la cuenta.'
        ],

        box: [
          'Reset.',
          'Box.',
          'Ajuste rápido.',
          'Respira.'
        ],
      }
    };

    
    function rdMakeText(id, baseText, ctx) {
      const mode = (raceDirectorMode === 'minimal' || raceDirectorMode === 'stratega' || raceDirectorMode === 'coach')
        ? raceDirectorMode : 'stratega';

      const c = (ctx || {});
      const isManga = !!c.isManga;
      const tier = c.tier || 'mid';
      const posNow = c.posNow || rdExtractPos(baseText) || 0;

      

      // Normaliza IDs para aprovechar bancos existentes y evitar llaves huérfanas
      const __idMap = {
        gaps: 'trend',
        estlap: 'est'
      };
      const __origId = id;
      id = (__idMap[id] || id);

      // Prefijos: usa banco como "intro" y conserva el texto base (datos duros)
      const __prefixIds = new Set(['cons10','netgain','ritmo_up','ritmo_down','total','box']);
      const __applyPrefix = (modeKey, idKey, fallback) => {
        try {
          const arr = (RD_PHRASES && RD_PHRASES[modeKey] && RD_PHRASES[modeKey][idKey]) ? RD_PHRASES[modeKey][idKey] : null;
          if (arr && arr.length) {
            const pre = fill(rdPick(arr, modeKey[0] + '_p_' + idKey));
            const bt = String(baseText || '').trim();
            if (pre && bt) return (pre + ' ' + bt).replace(/\s+/g,' ').trim();
            if (pre) return pre;
          }
        } catch(e) {}
        return fallback;
      };
// Rellena placeholders
      const fill = (tpl) => {
        let s = String(tpl || '');
        s = s.replace(/\{frontNameSafe\}/g, c.frontNameSafe || 'el de adelante');
        s = s.replace(/\{backNameSafe\}/g, c.backNameSafe || 'el de atrs');
        s = s.replace(/\{frontSecStr\}/g, c.frontSecStr || '');
        s = s.replace(/\{backSecStr\}/g, c.backSecStr || '');
        s = s.replace(/\{posNow\}/g, String(posNow || 0));
        return s.replace(/\s+/g, ' ').trim();
      };

function rdMakeMangaBattleText(kind, c, mode) {
  const front = (c && c.frontNameSafe) ? c.frontNameSafe : 'el de adelante';
  const back  = (c && c.backNameSafe)  ? c.backNameSafe  : 'el de atrs';
  const fs = (c && c.frontSecStr) ? c.frontSecStr : '';
  const bs = (c && c.backSecStr)  ? c.backSecStr  : '';

  // Plantillas cortas, tiles y con nombres. (MANGA = suave, pero con datos)
  const attack = [
    'Manga. {frontNameSafe} a {frontSecStr}. Limpio y lo cazas.',
    'Manga. {frontNameSafe} a {frontSecStr}. Sal bien y cae el pase.',
    'Manga. {frontNameSafe} a {frontSecStr}. Línea fina, sin drama.',
    'Manga. {frontNameSafe} a {frontSecStr}. Cero errores, aprieta.',
    'Manga. {frontNameSafe} a {frontSecStr}. Dos vueltas as y lo tienes.',
    'Manga. Vas por {frontNameSafe}. Gap {frontSecStr}.',
    'Manga. {frontNameSafe} está tiro. {frontSecStr}.',
    'Manga. Se ve el rebufo. {frontNameSafe} {frontSecStr}.',
    'Manga. Ojo con {frontNameSafe}. {frontSecStr}.',
    'Manga. Paciencia y traccin. {frontNameSafe} {frontSecStr}.',
    'Manga. Si la salida es limpia, {frontNameSafe} cae. {frontSecStr}.',
    'Manga. Ataque inteligente. {frontNameSafe} {frontSecStr}.',
    'Manga. No lo forces, provcalo. {frontNameSafe} {frontSecStr}.',
    'Manga. Gap rico para cazar. {frontNameSafe} {frontSecStr}.',
    'Manga. Est en ventana. {frontNameSafe} {frontSecStr}.'
  ];

  const defense = [
    'Manga. {backNameSafe} a {backSecStr}. Cierra puertas, suave.',
    'Manga. {backNameSafe} a {backSecStr}. Sin espejo, pero sin regalo.',
    'Manga. {backNameSafe} a {backSecStr}. Marca el apex y listo.',
    'Manga. {backNameSafe} a {backSecStr}. Control, no ansiedad.',
    'Manga. {backNameSafe} a {backSecStr}. Si te equivocas, te muerde.',
    'Manga. Te vienen oliendo. {backNameSafe} {backSecStr}.',
    'Manga. Defensa fina. {backNameSafe} {backSecStr}.',
    'Manga. No des espacio gratis. {backNameSafe} {backSecStr}.',
    'Manga. Mantn tu línea. {backNameSafe} {backSecStr}.',
    'Manga. Respira. {backNameSafe} est encima. {backSecStr}.',
    'Manga. Sal de curva bien, y se apaga. {backNameSafe} {backSecStr}.',
    'Manga. No te enredes. {backNameSafe} {backSecStr}.',
    'Manga. Si te presiona, tu respuesta es limpieza. {backNameSafe} {backSecStr}.',
    'Manga. Cero contactos. {backNameSafe} {backSecStr}.',
    'Manga. Aguanta el ritmo. {backNameSafe} {backSecStr}.'
  ];

  const fight = [
    'Manga. Duelo doble: adelante {frontSecStr}, atrs {backSecStr}.',
    'Manga. Ests en sndwich. Adelante {frontSecStr}, atrs {backSecStr}.',
    'Manga. Se viene pelea: {frontNameSafe} {frontSecStr}, {backNameSafe} {backSecStr}.',
    'Manga. Tres autos en un respiro. Mantn calma.',
    'Manga. Esto es ajedrez en miniatura. No regales.',
    'Manga. Línea limpia, manos suaves. Duelo real.',
    'Manga. Cada error cuesta dos posiciones. Ojo.',
    'Manga. Juega con la salida, no con el choque.',
    'Manga. Batalla cerrada. Decide con cabeza fra.',
    'Manga. Si te pones nervioso, ya perdiste. Respira.'
  ];

  let bank = null;
  if (kind === 'attack') bank = attack;
  else if (kind === 'defense') bank = defense;
  else if (kind === 'fight') bank = fight;

  if (!bank || !bank.length) return '';
  return fill(rdPick(bank, 'mb_' + String(mode || 'x') + '_' + kind));
}

    
// Manga: NO aplastar todo a frases genricas.
// - Si hay batalla, habla con nombres y gaps (suave, pero til).
if (isManga && (id === 'attack' || id === 'defense' || id === 'fight')) {
  const out = rdMakeMangaBattleText(id, c, mode);
  if (out) return out;

  const arr = RD_PHRASES[mode] && RD_PHRASES[mode].manga;
  if (arr && arr.length) return fill(rdPick(arr, mode[0] + '_manga'));
}
// Seleccin por modo
      if (mode === 'minimal') {
        if (__prefixIds.has(id)) return __applyPrefix('minimal', id, String(baseText || '').trim());
        const arr = RD_PHRASES.minimal[id] || null;
        if (arr && arr.length) return fill(rdPick(arr, 'm_' + id));
        if (id === 'pos' && posNow) return `P${posNow}.`;
        return String(baseText || '').trim();
      }

      if (mode === 'coach') {
        if (__prefixIds.has(id)) return __applyPrefix('coach', id, String(baseText || '').trim());
        const arr = RD_PHRASES.coach[id] || null;
        if (arr && arr.length) return fill(rdPick(arr, 'c_' + id));
        return String(baseText || '').trim();
      }

      // stratega
      if (__prefixIds.has(id)) return __applyPrefix('stratega', id, String(baseText || '').trim());
      if (id === 'attack') {
        const arr = RD_PHRASES.stratega['attack_' + tier] || RD_PHRASES.stratega.attack_mid;
        return fill(rdPick(arr, 's_attack_' + tier));
      }
      if (id === 'defense') {
        const arr = RD_PHRASES.stratega['defense_' + tier] || RD_PHRASES.stratega.defense_mid;
        return fill(rdPick(arr, 's_def_' + tier));
      }
      const arr = RD_PHRASES.stratega[id] || null;
      if (arr && arr.length) return fill(rdPick(arr, 's_' + id));
      return String(baseText || '').trim();
    }

      

    function updateRdButton() {
      if (!rdToggleBtn) return;
      rdToggleBtn.textContent = raceDirectorEnabled ? ' RD ON' : ' RD OFF';
      rdToggleBtn.classList.toggle('active', !!raceDirectorEnabled);
      rdToggleBtn.classList.toggle('off', !raceDirectorEnabled);
      rdToggleBtn.setAttribute('aria-pressed', raceDirectorEnabled ? 'true' : 'false');
    }

    if (rdToggleBtn) {
      updateRdButton();
      rdToggleBtn.addEventListener('click', () => {
        raceDirectorEnabled = !raceDirectorEnabled;
      try { rdToggleBtn.classList.toggle('active', raceDirectorEnabled); } catch(e) {}
        try { prefSet('raceDirectorEnabled', raceDirectorEnabled ? '1' : '0'); } catch(e) {}
        updateRdButton();
        try { playBeep(raceDirectorEnabled ? 'up' : 'down'); } catch(e) {}
      });
    }
    let posImmediateLastSpokenAt = 0;
    let posImmediateLastSpokenPos = 0;
    let posDropDebounceTimer = null;
    let posDropDebounceLatest = null;

    // BASIC (Seguimiento) - estabilidad de posicion para evitar jitter/flip-flop
    const basicPosStability = { lastSeenPos: null, candidatePos: null, candidateCount: 0, pendingStablePos: null, lastAnnouncedStablePos: null };

// MANGA (clasificacin) - estabilidad de posición para evitar "flip-flop" por salida escalonada
    const mangaPosStability = { lastSeenPos: null, stablePos: null, stableCount: 0, lastAnnouncedStablePos: null };
    const mangaPosSettle = { active:false, lap:0, dueAt:0, samples:[], lastComputedPos:null };

    function startMangaPosSettle(lap, posNow){
      try{
        const now = Date.now();
        const p = (posNow!=null && isFinite(posNow)) ? Math.max(1, Math.floor(posNow)) : null;
        const jitter = 1200; // ms
        const base = 3200;   // ms
        mangaPosSettle.active = true;
        mangaPosSettle.lap = Number(lap)||0;
        mangaPosSettle.dueAt = now + base + Math.floor(Math.random()*jitter);
        mangaPosSettle.samples = [];
        if (p) mangaPosSettle.samples.push(p);
        mangaPosSettle.lastComputedPos = null;
      } catch(e){}
    }

    function modeOfIntArray(arr){
      if (!arr || !arr.length) return null;
      const m = new Map();
      let bestK = null; let bestV = 0;
      for (const x of arr){
        const k = Number(x)|0;
        if (!k) continue;
        const v = (m.get(k)||0)+1;
        m.set(k,v);
        if (v>bestV){ bestV=v; bestK=k; }
      }
      return bestK;
    }

    function tickMangaPosSettle(lapsNow, posNow){
      try{
        if (!mangaPosSettle.active) return;
        if ((Number(lapsNow)||0) !== (Number(mangaPosSettle.lap)||0)) return;
        const now = Date.now();
        const p = (posNow!=null && isFinite(posNow)) ? Math.max(1, Math.floor(posNow)) : null;
        if (p && now < (mangaPosSettle.dueAt||0)) {
          mangaPosSettle.samples.push(p);
          if (mangaPosSettle.samples.length > 20) mangaPosSettle.samples.shift();
          return;
        }
        if (now >= (mangaPosSettle.dueAt||0)){
          const stable = modeOfIntArray(mangaPosSettle.samples);
          mangaPosSettle.lastComputedPos = stable;
          mangaPosSettle.active = false;
          if (!stable) return;
          // Solo anunciamos si cambi contra la última posición estable anunciada
          if (mangaPosStability.lastAnnouncedStablePos === stable) return;
          pendingPosChange = {
            pos: stable,
            opts: { key: 'pos_manga_' + stable + '_' + lapsNow, priority: 70, cooldownMs: 1400, dedupe: true },
            expLap: (Number(lapsNow)||0) + 3,
            _mangaStablePos: stable
          };
        }
      } catch(e){}
    }

    function announcePositionBrief(pos) {
      const p = Math.max(1, Math.min(99, Math.floor(Number(pos) || 0)));
      const now = Date.now();

      // No repitas el mismo P# seguido
      if (p === posImmediateLastSpokenPos && (now - posImmediateLastSpokenAt) < 2000) return;

      // Nombre del de adelante (si existe) para que sea til, no solo "P6"
      let aheadName = '';
      try {
        const idx = findPilotIndexByKey(selectedPilotKey);
        const ctx = (idx >= 0) ? getFrontBackContext(idx) : null;
        aheadName = (ctx && ctx.frontName) ? safeRacerName(ctx.frontName) : '';
      } catch(e) {}

      const tail = aheadName ? ('. Adelante ' + aheadName) : '';
      say('P' + p + tail, { key: 'pos_brief_' + p, priority: 85, cooldownMs: 800, dedupe: true });

      posImmediateLastSpokenAt = now;
      posImmediateLastSpokenPos = p;
    }

    function handlePositionChangeNoLap(fromPos, toPos, delta) {
      const from = Math.floor(Number(fromPos) || 0);
      const to = Math.floor(Number(toPos) || 0);
      if (!to) return;

      // + = cae (peor), - = sube (mejor)
      const drop = (from && to) ? (to - from) : (delta || 0);

      // Si cae 2+ lugares, debounce 1.5s y anuncia solo la posición final (evita metralleta)
      if (drop >= 2) {
        posDropDebounceLatest = to;
        if (!posDropDebounceTimer) {
          posDropDebounceTimer = setTimeout(() => {
            announcePositionBrief(posDropDebounceLatest);
            posDropDebounceTimer = null;
            posDropDebounceLatest = null;
          }, 1500);
        }
        return;
      }

      // Si est en debounce, actualiza y no hables an
      if (posDropDebounceTimer) {
        posDropDebounceLatest = to;
        return;
      }

      const now = Date.now();
      if (now - posImmediateLastSpokenAt < 650) return;
      announcePositionBrief(to);
    }

    
function saveVoiceSettings() {
      try {
        const toSave = { ...voiceSettings, laps: true };
        prefSet('spotterVoiceSettings', JSON.stringify(toSave));
      } catch (e) {}
    }

    
function loadVoiceSettings() {
      try {
        const raw = prefGet('spotterVoiceSettings', null);
        if (raw) {
          const parsed = JSON.parse(raw);
          voiceSettings = { ...DEFAULT_VOICE_SETTINGS, ...parsed, laps: true };
        } else {
          voiceSettings = { ...DEFAULT_VOICE_SETTINGS, laps: true };
        }
      } catch (e) {
        voiceSettings = { ...DEFAULT_VOICE_SETTINGS, laps: true };
      }

      // Enforce: Laps siempre activo
      voiceSettings.laps = true;
      // Enforce: prefijo de vueltas por default
      if (voiceSettings.saylaps == null) voiceSettings.saylaps = false;

      // Refresca UI si ya existe la funcin (hoisting en function decl)
      try {
        if (typeof applyVoiceSettingsToButtons === 'function') applyVoiceSettingsToButtons();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      } catch (e) {}
    }

    loadVoiceSettings();

    // Gesto de usuario (Chrome bloquea AudioContext si no hay interaccin)
    let __userGestureUnlocked = false;
    try{
      const _unlock = () => { __userGestureUnlocked = true; };
      ['pointerdown','touchstart','keydown','click'].forEach(ev=>{
        window.addEventListener(ev, _unlock, { once:true, passive:true });
      });
    }catch(e){}

    // WebAudio beeps (sin archivos)
    // SFX: por default OFF (evita el 'tac tac' constante).
    // SFX deshabilitado (sin beeps).
    let soundFxEnabled = false; // UI SFX OFF (evita tic/tac).
    let lapBeepEnabled = true;   // Beep SOLO en SEGUIMIENTO al cerrar vuelta (mejora/empeora).

    let audioCtx = null;
    function ensureAudioCtx() {
      try {
        if (!__userGestureUnlocked) return;
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(()=>{});
        }
      } catch (e) {}
    }


     // Silent audio keep-alive (Chrome/desktop):
     // - Mantiene el AudioContext "running" con una seï¿½al inaudible.
     // - Ayuda a que el TTS no se "duerma" cuando el tab queda en background.
     // Nota: requiere gesto previo (ya cubierto por __userGestureUnlocked).
     let __silentKeepAlive = { osc:null, gain:null, started:false };
     function startSilentAudioKeepAlive(){
       try{
         if (!backgroundModeEnabled) return;
         if (!voiceMasterEnabled) return;
         ensureAudioCtx();
         if (!audioCtx) return;
         if (__silentKeepAlive.started) return;
         const now = audioCtx.currentTime;
         const osc = audioCtx.createOscillator();
         const gain = audioCtx.createGain();
         // Ultra bajo, inaudible en la prï¿½ctica
         gain.gain.setValueAtTime(0.000001, now);
         osc.type = 'sine';
         osc.frequency.setValueAtTime(18, now); // sub-audio
         osc.connect(gain);
         gain.connect(audioCtx.destination);
         osc.start(now);
         __silentKeepAlive.osc = osc;
         __silentKeepAlive.gain = gain;
         __silentKeepAlive.started = true;
       }catch(e){}
     }
     function stopSilentAudioKeepAlive(){
       try{
         if (__silentKeepAlive && __silentKeepAlive.osc){
           try{ __silentKeepAlive.osc.stop(); }catch(e){}
           try{ __silentKeepAlive.osc.disconnect(); }catch(e){}
         }
         if (__silentKeepAlive && __silentKeepAlive.gain){
           try{ __silentKeepAlive.gain.disconnect(); }catch(e){}
         }
       }catch(e){}
       try{ __silentKeepAlive = { osc:null, gain:null, started:false }; }catch(e){}
     }


function hardUnlockAudioPipe(){
  // iOS: a veces el "primer audio" requiere un micro-sonido para abrir el canal.
  try{
    ensureAudioCtx();
    if (!audioCtx) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0.0001, now);
    osc.type = 'sine';
    osc.frequency.setValueAtTime(440, now);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.02);
  }catch(e){}
}


    function playBeep(kind = 'up') {
      const k = String(kind||'').trim();
      const isLap = (k === 'lapUp' || k === 'lapDown');
      if (isLap) { if (!lapBeepEnabled) return; }
      else { if (!soundFxEnabled) return; }
      try {
        ensureAudioCtx();
        if (!audioCtx) return;

        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        const f = (k === 'soft') ? 620 : ((k === 'lapUp' || k === 'up') ? 880 : 440);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(f, now);

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime((k === 'soft') ? 0.06 : (isLap ? 0.10 : 0.18), now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.10);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(now);
        osc.stop(now + ((k === 'soft') ? 0.07 : (isLap ? 0.10 : 0.12)));
      } catch (e) {}
    }

    // TTS
    let chosenVoiceURI = '';

    
// ===== DUO voces (solo Web/desktop): Sabina + Raul =====
// - En mobile (iOS/Android) dejamos SINGLE para no pelear con restricciones de audio.
// - En web/desktop alternamos voces por frase para sonar como duo.
let __duoWebEnabled = false;
let __duoVoiceSabinaURI = '';
let __duoVoiceRaulURI = '';
let __duoLastRole = ''; // 'sabina'|'raul'

function __isDuoWebContext() {
  try {
    const ua = navigator.userAgent || '';
    const isMobUA = /iPad|iPhone|iPod|Android/i.test(ua);
    if (isMobUA) return false;
    // Si la ventana es muy chica, tratamos como mobile para no forzar duo.
    if (window.matchMedia && window.matchMedia('(max-width: 700px)').matches) return false;
    return true;
  } catch (e) { return false; }
}

function __findVoiceByNeedle(voices, needles) {
  try {
    if (!voices || !voices.length) return null;
    const ns = (needles || []).map(s => String(s||'').toLowerCase()).filter(Boolean);
    if (!ns.length) return null;
    // Preferimos es-MX/es-ES si hay varias
    const scored = voices.map(v => {
      const name = String(v.name || '').toLowerCase();
      const uri  = String(v.voiceURI || '').toLowerCase();
      let hit = 0;
      for (const n of ns) {
        if (name.includes(n)) hit += 2;
        if (uri.includes(n)) hit += 1;
      }
      const lang = String(v.lang || '').toLowerCase();
      if (lang.startsWith('es-')) hit += 0.25;
      return { v, hit };
    }).filter(o => o.hit > 0).sort((a,b)=>b.hit-a.hit);
    return scored.length ? scored[0].v : null;
  } catch (e) { return null; }
}

function __refreshDuoVoices(voices) {
  try {
    // Solo web/desktop
    __duoWebEnabled = __isDuoWebContext();
    if (!__duoWebEnabled) { __duoVoiceSabinaURI = ''; __duoVoiceRaulURI = ''; return; }

    // Busca por nombre aproximado. Ajustable si cambian los nombres reales en tu maquina.
    const vSab = __findVoiceByNeedle(voices, ['sabina']);
    const vRau = __findVoiceByNeedle(voices, ['raul']);

    __duoVoiceSabinaURI = vSab ? (vSab.voiceURI || vSab.name || '') : '';
    __duoVoiceRaulURI   = vRau ? (vRau.voiceURI || vRau.name || '') : '';

    // Si no estan las dos, duo off (fallback SINGLE)
    if (!__duoVoiceSabinaURI || !__duoVoiceRaulURI) {
      __duoWebEnabled = false;
    }
  } catch (e) {
    __duoWebEnabled = false;
    __duoVoiceSabinaURI = '';
    __duoVoiceRaulURI = '';
  }
}

function __duoGuessRole(txt, key) {
  try {
    const t = String(txt||'');
    const k = String(key||'');
    // Datos duros y posiciones -> Raul
    if (/(\bP\d+\b|\bpos\b|posici\w+|\bgap\b|\bvuelta\b|\bvueltas\b|\btiempo\b|\bseg\b|\bsegundo\b|\btercero\b|\d)/i.test(t)) return 'raul';
    if (/(\bP\d+\b|pos|gap|lap)/i.test(k)) return 'raul';
    // Narrativa/hype -> Sabina
    return 'sabina';
  } catch (e) { return 'sabina'; }
}
// ===== Auto presets por sesin (TRAIN/MANGA/FINAL) =====
    let autoSessionPresetsEnabled = true;   // ON por default
    let __lastAutoPresetType = '';
    
    function applyDecimalPrecision(val){
      const v = Math.max(1, Math.min(3, parseInt(val,10) || 2));
      decimalPrecision = v;
      try { prefSet('spotterDecimalPrecision', String(v)); } catch(e) {}
      try { if (precisionSelect) precisionSelect.value = String(v); } catch(e) {}
      try { if (typeof syncPrecisionBadges === 'function') syncPrecisionBadges(); } catch(e) {}
    }
    
    function applySessionPreset(type){
      // Mantener compat: ahora el preset lo decide el AI (sesin + modo)
      applySmartProfile({ type: String(type || 'TRAIN').toUpperCase() }, 'manual');
    }

    function maybeAutoApplySessionPreset(sessionInfo){
      // AI Spotter: siempre decide solo (sesin + modo). Sin botones.
      if (!autoSessionPresetsEnabled) return;
      const t = String((sessionInfo && sessionInfo.type) ? sessionInfo.type : 'TRAIN').toUpperCase();
      if (!t || t === __lastAutoPresetType) return;
      __lastAutoPresetType = t;
      applySmartProfile(sessionInfo, 'auto');
      try { _updateBasicBtnUI(); } catch(e) {}
    }
    
    
    // ===== UI: Mostrar modo actual + Presets por sesin =====
    const SESSION_PRESET_PROFILES = {
      TRAIN: {
        label: 'Entrenamiento',
        rdMode: 'engineer',
        autoMode: 'engineer',
        precision: 2,
        voice: {
          laps:true, blueflag:true, ritmo:true, estlap:true, bestlap:true,
          pos:false, gaps:false, leadergap:false, podium:false,
          front06:false, back06:false, attack:false, defense:false, pelea:false,
          total:false, cons10:false, box:false, netgain:false, saylaps:false
        }
      },
      MANGA: {
        label: 'Manga',
        rdMode: 'minimal',
        autoMode: 'pro',
        precision: 2,
        voice: {
          laps:true, blueflag:true, ritmo:true, estlap:true, bestlap:true, leadergap:true,
          pos:false, gaps:false, podium:false,
          front06:false, back06:false, attack:false, defense:false, pelea:false,
          total:false, cons10:false, box:false, netgain:false, saylaps:false
        }
      },
      FINAL: {
        label: 'Final',
        rdMode: 'coach',
        autoMode: 'pro',
        precision: 2,
        voice: {
          laps:true, blueflag:true, ritmo:true, pos:true, gaps:true, leadergap:true, podium:true,
          front06:true, back06:true, attack:true, defense:true,
          bestlap:true, estlap:false,
          pelea:false, total:false, cons10:false, box:false, netgain:false, saylaps:false
        }
      }
    };

    // =========================================
    // AI Spotter - Perfiles inteligentes (sin botones)
    // - Si hay piloto seleccionado: Seguimiento
    // - Si no hay piloto: Auto Locutor
    // - Ajusta RD mode + auto locutor + mensajes por sesin
    // =========================================
    function __sessionBucket(sessionInfo){
      const raw = String((sessionInfo && sessionInfo.type) ? sessionInfo.type : 'TRAIN').toUpperCase();
      if (raw.includes('FINAL')) return 'FINAL';
      if (raw.includes('MANGA') || raw.includes('QUAL') || raw === 'Q') return 'MANGA';
      return 'TRAIN';
    }
    function __modeBucket(){
      try { return (selectedPilotKey ? 'FOLLOW' : 'AUTO'); } catch(e) { return 'AUTO'; }
    }

    const AI_SMART_PROFILES = {
      FOLLOW: {
        TRAIN: { rdMode:'engineer', autoMode:'engineer', precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:true, estlap:true, bestlap:true, leadergap:true, pos:true, gaps:true, podium:false, front06:false, back06:false, attack:false, defense:false, pelea:false, total:false, cons10:false, box:false, netgain:false } },
        MANGA: { rdMode:'minimal',  autoMode:'pro',      precision:2, voice:{ laps:true, saylaps:false, blueflag:true,  ritmo:false, estlap:false, bestlap:true,  leadergap:false, pos:true, gaps:false, podium:false, front06:false, back06:false, attack:false, defense:false, pelea:false, total:false, cons10:false, box:false, netgain:false } },
        FINAL: { rdMode:'coach',    autoMode:'pro',      precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:true, estlap:false, bestlap:true, leadergap:true, pos:true, gaps:true, podium:true,  front06:true,  back06:true,  attack:true,  defense:true,  pelea:false, total:false, cons10:false, box:false, netgain:false } }
      },
      AUTO: {
        TRAIN: { rdMode:'minimal',  autoMode:'engineer', precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:false, estlap:true, bestlap:true, leadergap:true, pos:true, gaps:true, podium:false, front06:true,  back06:true,  attack:false, defense:false, pelea:true,  total:false, cons10:false, box:false, netgain:false } },
        MANGA: { rdMode:'minimal',  autoMode:'pro',      precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:false, estlap:true, bestlap:true, leadergap:true, pos:true, gaps:true, podium:false, front06:true,  back06:true,  attack:false, defense:false, pelea:true,  total:false, cons10:false, box:false, netgain:false } },
        FINAL: { rdMode:'coach',    autoMode:'pro',      precision:2, voice:{ laps:true, saylaps:false, blueflag:true, ritmo:false, estlap:false, bestlap:true, leadergap:true, pos:true, gaps:true, podium:true,  front06:true,  back06:true,  attack:false, defense:false, pelea:true,  total:false, cons10:false, box:false, netgain:false } }
      }
    };

    function _applyBasicOverride(sess, mode){
      // Aplica en AUTO y FOLLOW. En FOLLOW incluye POS; en AUTO solo deja lo esencial.
      try{
        if (!basicModeEnabled) return false;
        const bmode = mode || __modeBucket();

        const next = { ...DEFAULT_VOICE_SETTINGS };
        // Siempre activo
        next.laps = true;
        // BASICO ultra limpio:
        // - Solo last lap (siempre) + posicion (solo en FOLLOW, cambios estables)
        // - Cero extras: no azul, no gaps, no best, no contexto.
        next.pos = true; // BÁSICO también en AUTO (reporta P1)
        next.gaps = false;
        next.leadergap = false;
        next.blueflag = false;
        next.ritmo = false;
        next.estlap = false;
        next.bestlap = false;
        next.front06 = false;
        next.back06 = false;
        next.podium = false;
        next.attack = false;
        next.defense = false;
        next.pelea = false;
        next.netgain = false;
        next.total = false;
        next.cons10 = false;
        next.box = false;
        next.saylaps = false;
        voiceSettings = next;

        // Modos mas sobrios
        try { applyDecimalPrecision(2); } catch(e) {}
        // RD/Auto fuera en BASICO (garantiza 0 ruido)
        try { setRaceDirectorMode('minimal'); } catch(e) {}
        try { setAutoCommentatorMode('engineer'); } catch(e) {}
        try { raceDirectorEnabled = false; } catch(e) {}
        return true;
      }catch(e){ return false; }
    }

    function _updateBasicBtnUI(){
      try{
        if (!basicToggleBtnMini) return;
        const inFollow = (typeof selectedPilotKey !== 'undefined' && !!selectedPilotKey);

        if (!inFollow) {
          // AUTO LOCUTOR: BÁSICO siempre OFF y bloqueado
          basicModeEnabled = false;
          try { prefSet('basicModeEnabled', '0'); } catch(e) {}
          basicToggleBtnMini.disabled = true;
          basicToggleBtnMini.classList.remove('active');
          basicToggleBtnMini.classList.add('disabled');
          basicToggleBtnMini.textContent = 'BÁSICO';
          return;
        }

        basicToggleBtnMini.disabled = false;
        basicToggleBtnMini.classList.remove('disabled');
        basicToggleBtnMini.classList.toggle('active', !!basicModeEnabled);
        basicToggleBtnMini.textContent = (basicModeEnabled ? 'BÁSICO ON' : 'BÁSICO');
        try { if (typeof updateSayLapsUI === 'function') updateSayLapsUI(); } catch(e) {}
      }catch(e){}
    }

    function applySmartProfile(sessionInfo, reason){
      try{
        const sess = __sessionBucket(sessionInfo);
        const mode = __modeBucket();
        const prof = (AI_SMART_PROFILES[mode] && AI_SMART_PROFILES[mode][sess]) ? AI_SMART_PROFILES[mode][sess] : null;

        // 1) BASICO manda - debe funcionar aun si no hay perfil listo.
        if (basicModeEnabled) {
          try { _applyBasicOverride(sess, mode); } catch(e) {}
          try { applyVoiceSettingsToButtons(); } catch(e) {}
          try { if (typeof updateSessionPresetUI === 'function') updateSessionPresetUI(sess); } catch(e) {}
          try { if (typeof updateSessionNowUI === 'function') updateSessionNowUI(); } catch(e) {}
          try { _updateBasicBtnUI(); } catch(e) {}
          return;
        }

        // 2) Si no hay perfil, fallback a defaults (evita quedarse "atorado" en BASICO al apagarlo).
        if (!prof) {
          try { applySessionPresetFull(sess, 'smart'); } catch(e) {}
          try { applyDecimalPrecision(2); } catch(e) {}
          try { setRaceDirectorMode('minimal'); } catch(e) {}
          try { setAutoCommentatorMode('pro'); } catch(e) {}
          try { raceDirectorEnabled = true; } catch(e) {}
          try { voiceSettings = { ...DEFAULT_VOICE_SETTINGS }; } catch(e) {}
          try { applyVoiceSettingsToButtons(); } catch(e) {}
          try { if (typeof updateSessionPresetUI === 'function') updateSessionPresetUI(sess); } catch(e) {}
          try { if (typeof updateSessionNowUI === 'function') updateSessionNowUI(); } catch(e) {}
          try { _updateBasicBtnUI(); } catch(e) {}
          return;
        }

        // Base: preset por sesion (mantiene UI/labels coherentes)
        try { applySessionPresetFull(sess, 'smart'); } catch(e) {}

        // Overrides por modo
        try { applyDecimalPrecision(prof.precision || 2); } catch(e) {}
        try { setRaceDirectorMode(prof.rdMode || 'minimal'); } catch(e) {}
        try { setAutoCommentatorMode(prof.autoMode || 'pro'); } catch(e) {}
        try { raceDirectorEnabled = true; } catch(e) {}

        // Voz: aplicar flags del perfil (sin dejar toggles viejos)
        try {
          const next = { ...DEFAULT_VOICE_SETTINGS };
          const v = prof.voice || {};
          Object.keys(next).forEach(k => { next[k] = (k === 'laps') ? true : !!v[k]; });
          next.laps = true;
          voiceSettings = next;
        } catch(e) {}

        try { applyVoiceSettingsToButtons(); } catch(e) {}
        try { if (typeof updateSessionPresetUI === 'function') updateSessionPresetUI(sess); } catch(e) {}
        try { if (typeof updateSessionNowUI === 'function') updateSessionNowUI(); } catch(e) {}

        // BASICO override (solo si esta activo) - aqui ya seria false, pero dejamos la llamada por seguridad
        try { _applyBasicOverride(sess, mode); } catch(e) {}
        try { applyVoiceSettingsToButtons(); } catch(e) {}
        try { _updateBasicBtnUI(); } catch(e) {}
      }catch(e){}
    }

    function _pillHtml(name, on){
      const cls = on ? 'toggle-pill on' : 'toggle-pill off';
      const safe = String(name||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      return `<span class="${cls}">${safe}</span>`;
    }

    function _getVoiceToggleMap(){
      // voiceSettings es la fuente de verdad
      const out = {};
      try{
        Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => out[k] = !!voiceSettings[k]);
        // asegurar llaves nuevas si faltan
        ['front06','back06','leadergap','podium','pelea','netgain','bestlap','estlap','cons10','box','total','gaps','pos','attack','defense','blueflag','ritmo','saylaps'].forEach(k=>{
          if (typeof out[k] === 'undefined') out[k] = !!voiceSettings[k];
        });
        out.laps = true;
      }catch(e){}
      return out;
    }

    function renderPresetCards(){
      const mapNow = _getVoiceToggleMap();
      const cards = [
        {id:'presetCardTrain', key:'TRAIN', metaId:'presetTrainMeta', togId:'presetTrainToggles'},
        {id:'presetCardManga', key:'MANGA', metaId:'presetMangaMeta', togId:'presetMangaToggles'},
        {id:'presetCardFinal', key:'FINAL', metaId:'presetFinalMeta', togId:'presetFinalToggles'}
      ];
      cards.forEach(c=>{
        const prof = SESSION_PRESET_PROFILES[c.key];
        const metaEl = document.getElementById(c.metaId);
        const togEl = document.getElementById(c.togId);
        if (metaEl) metaEl.textContent = `RD ${prof.rdMode.toUpperCase()} - Auto ${prof.autoMode.toUpperCase()} - ${prof.precision} dc.`;
        if (togEl){
          const order = ['laps','blueflag','ritmo','estlap','leadergap','podium','pos','gaps','front06','back06','attack','defense','pelea','bestlap','total','cons10','box','netgain','saylaps'];
          const nice = {
            laps:'LAPS', blueflag:'AZUL', ritmo:'RITMO', estlap:'EST', leadergap:'LDER', podium:'PODIO',
            pos:'POS', gaps:'GAP', front06:'ADEL<0.6', back06:'ATRAS<0.6', attack:'ATK', defense:'DEF', pelea:'PELEA',
            bestlap:'BEST', total:'TOTAL', cons10:'CONS10', box:'BOX', netgain:'NET', saylaps:'VUELTAS'
          };
          let html='';
          order.forEach(k=>{
            const onRec = !!prof.voice[k];
            html += _pillHtml(nice[k]||k, onRec);
          });
          togEl.innerHTML = html;
        }
      });

      // Row "Ahora"
      const nowEl = document.getElementById('sessionNowToggles');
      if (nowEl){
        const orderNow = ['laps','blueflag','ritmo','estlap','leadergap','podium','pos','gaps','front06','back06','attack','defense','pelea','bestlap','total','cons10','box','netgain','saylaps'];
        const niceNow = {
          laps:'LAPS', blueflag:'AZUL', ritmo:'RITMO', estlap:'EST', leadergap:'LDER', podium:'PODIO',
          pos:'POS', gaps:'GAP', front06:'ADEL<0.6', back06:'ATRAS<0.6', attack:'ATK', defense:'DEF', pelea:'PELEA',
          bestlap:'BEST', total:'TOTAL', cons10:'CONS10', box:'BOX', netgain:'NET', saylaps:'VUELTAS'
        };
        let html='';
        orderNow.forEach(k=>{
          const on = (k==='laps') ? true : !!mapNow[k];
          html += _pillHtml(niceNow[k]||k, on);
        });
        nowEl.innerHTML = html;
      }
    }

    function updateConfigStatusUI(){
      try{
        const sess = String(__lastAutoPresetType || 'TRAIN').toUpperCase();
        const prof = SESSION_PRESET_PROFILES[sess] || SESSION_PRESET_PROFILES.TRAIN;

        const sessionPill = document.getElementById('cfgSessionPill');
        const presetPill  = document.getElementById('cfgPresetPill');
        const rdEl        = document.getElementById('cfgRdMode');
        const autoEl      = document.getElementById('cfgAutoMode');
        const precEl      = document.getElementById('cfgPrec');
        const voicesEl    = document.getElementById('cfgVoices');
        const noteEl      = document.getElementById('sessionPresetNote');

        if (sessionPill) sessionPill.textContent = `Sesin: ${sess}`;
        if (presetPill)  presetPill.textContent  = `Preset: ${prof.label}`;

        // RD actual
        const rd = (typeof raceDirectorMode === 'string' ? raceDirectorMode : prof.rdMode);
        const am = (typeof autoCommentatorMode === 'string' ? autoCommentatorMode : prof.autoMode);
        const pr = (typeof decimalPrecision !== 'undefined' ? decimalPrecision : prof.precision);

        if (rdEl) rdEl.textContent = (raceDirectorEnabled ? rd.toUpperCase() : 'OFF');
        if (autoEl) autoEl.textContent = am.toUpperCase();
        if (precEl) precEl.textContent = `${pr} dcimas`;
        if (voicesEl) voicesEl.textContent = (autoVoiceRotateEnabled ? 'ES + rotacin' : 'ES');

        if (noteEl) noteEl.textContent = `Auto: ${autoSessionPresetsEnabled ? 'ON' : 'OFF'} | Runtime: ${__getRuntimeProfileConfig(runtimeProfileKey).label}`;

        // active card highlight
        ['TRAIN','MANGA','FINAL'].forEach(k=>{
          const el = document.querySelector(`.session-preset-card[data-session="${k}"]`);
          if (el) el.classList.toggle('active', k===sess);
        });

        renderPresetCards();
        try { updateRuntimeDiagUI(); } catch(e) {}
      }catch(e){}
    }

    function applySessionPresetFull(type, source){
      const t = String(type || 'TRAIN').toUpperCase();
      const prof = SESSION_PRESET_PROFILES[t] || SESSION_PRESET_PROFILES.TRAIN;

      // Ajustes core
      raceDirectorEnabled = true;
      try { prefSet('raceDirectorEnabled', '1'); } catch(e) {}
      try { if (typeof updateRdButton === 'function') updateRdButton(); } catch(e) {}

      try { setRaceDirectorMode(prof.rdMode); } catch(e) {}
      try { setAutoCommentatorMode(prof.autoMode); } catch(e) {}
      applyDecimalPrecision(prof.precision);

      // Ajustes de mensajes por sesin: dejar claro ON/OFF
      try{
        Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => {
          if (k === 'laps'){ voiceSettings.laps = true; return; }
          voiceSettings[k] = !!prof.voice[k];
        });
        voiceSettings.laps = true;
        applyVoiceSettingsToButtons();
        saveVoiceSettings();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      }catch(e){}

      __lastAutoPresetType = t;
      updateConfigStatusUI();
      try { if (source) console.log('[PresetSesion]', t, 'source=', source); } catch(e){}
    }

    // Click handlers para aplicar preset manual
    function bindSessionPresetCards(){
      document.querySelectorAll('.session-preset-card').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const t = btn.getAttribute('data-session') || 'TRAIN';
          applySessionPresetFull(t, 'manual');
          playBeep('up');
        });
      });
    }

// ===== Voces (solo espaol) + rotacin Auto Locutor =====
    // Timers/flags globales (evita globals implícitos por parches)
    let __ttsKeepAliveTimer = 0;
    let __ttsCancelShieldUntil = 0;

    function __isIOSLike(){
      try {
        const ua = navigator.userAgent || '';
        const isTouchMac = (navigator.platform === 'MacIntel' && (navigator.maxTouchPoints || 0) > 1);
        return /iPad|iPhone|iPod/i.test(ua) || isTouchMac;
      } catch(e) { return false; }
    }
    function __isAndroidLike(){
      try { return /Android/i.test(navigator.userAgent || ''); } catch(e) { return false; }
    }
    function __isChromiumRuntime(){
      try {
        const ua = navigator.userAgent || '';
        const hasChromeLikeUA = /Chrome\/\d+|CriOS\/\d+/i.test(ua);
        const hasChromeRuntime = !!window.chrome || !!navigator.brave;
        return (hasChromeLikeUA || hasChromeRuntime) && !/OPR\/|DuckDuckGo\//i.test(ua);
      } catch(e) { return false; }
    }
    function __supportsSpeechEngine(){
      return !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
    }
    function __supportsWakeLockApi(){
      return !!(navigator.wakeLock && navigator.wakeLock.request);
    }

    let autoVoiceRotateEnabled = true; // ON por default
    let __autoVoicePool = [];
    let __autoVoiceIdx = 0;
    
    function nextAutoVoiceURI(){
      if (!autoVoiceRotateEnabled) return '';
      if (!__autoVoicePool || !__autoVoicePool.length) return '';
      const uri = __autoVoicePool[__autoVoiceIdx % __autoVoicePool.length];
      __autoVoiceIdx = (__autoVoiceIdx + 1) % __autoVoicePool.length;
      return uri || '';
    }

    
    // Default rate: 1.8
    function _isIOSWebKitRate() {
      return __isIOSLike();
    }
    function _isAndroidRate() {
      return __isAndroidLike();
    }
    function detectDefaultTtsRate() {
      return 1.8;
    }

let ttsRate = detectDefaultTtsRate();

    try {
      const storedRate = prefGet('spotterTtsRate', null);
      if (storedRate) {
        const r = Number(storedRate);
        if (isFinite(r) && r >= 1.0 && r <= 2.5) ttsRate = r;
      }
      else {
        // Si no hay setting guardado, usamos el default por plataforma
        try { prefSet('spotterTtsRate', String(ttsRate)); } catch (e) {}
      }
} catch (e) {}

    if (rateRange) {
      rateRange.value = String(ttsRate);
      rateDisplay.textContent = `${Number(rateRange.value).toFixed(1)}x`;
      rateRange.addEventListener('input', () => {
        ttsRate = Number(rateRange.value) || 1.5;
        rateDisplay.textContent = `${Number(rateRange.value).toFixed(1)}x`;
        try { prefSet('spotterTtsRate', String(ttsRate)); } catch (e) {}
      });
    }

    function pickDefaultVoice(voices) {
      // Prioridad: es-MX, luego es (cualquier), luego lo que haya.
      const vMx = voices.find(v => (v.lang || '').toLowerCase().startsWith('es-mx'));
      if (vMx) return vMx;
      const vEs = voices.find(v => (v.lang || '').toLowerCase().startsWith('es'));
      if (vEs) return vEs;
      return voices[0] || null;
    }

    function refreshVoiceList() {
      if (!voiceSelect) return;

      const raw = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
      if (!raw || !raw.length) return;

      // Cargar seleccionado previo una sola vez
      if (!chosenVoiceURI) {
        try {
          const storedURI = prefGet('spotterVoiceURI', null);
          if (storedURI) chosenVoiceURI = storedURI;
        } catch (e) {}
      }

      // Deduplicar y ordenar (es-MX arriba)
      const seen = new Set();
      const voicesAll = raw.filter(v => {
        const k = `${v.voiceURI || v.name || ''}|${v.lang || ''}`;
        if (!k.trim()) return false;
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
      }).sort((a,b) => {
        const al = (a.lang || '').toLowerCase();
        const bl = (b.lang || '').toLowerCase();
        const aMx = al.startsWith('es-mx') ? 0 : 1;
        const bMx = bl.startsWith('es-mx') ? 0 : 1;
        if (aMx !== bMx) return aMx - bMx;
        return (a.name || '').localeCompare(b.name || '');
      });

      // Solo espaol (fallback a todo si no hay voces ES)
      const voicesES = voicesAll.filter(v => ((v.lang || '').toLowerCase().startsWith('es')));
      const voices = voicesES.length ? voicesES : voicesAll;

      // Pool para rotacion de Auto Locutor
      // - Preferimos voces ES "Microsoft" cuando existan.
      // - Si el navegador no muestra "Microsoft" (caso comun: solo ves Raul/Sabina/Helena/Laura/Pablo),
      //   las incluimos como preferidas para rotar siempre entre ellas.
      try {
        // Pool de rotacion para AUTO LOCUTOR:
// - Solo Microsoft
// - Idiomas objetivo: es-MX y es-ES (fallback a cualquier es-* Google/Microsoft)
// - Sin Google: solo Microsoft (cuando existan)
const isGoogle = v => /google/i.test((v && v.name) || '') || /google/i.test((v && v.voiceURI) || '');
const isMS     = v => /microsoft/i.test((v && v.name) || '') || /microsoft/i.test((v && v.voiceURI) || '');
const isESMX   = v => String((v && v.lang) || '').toLowerCase().startsWith('es-mx');
const isESES   = v => String((v && v.lang) || '').toLowerCase().startsWith('es-es');
const isESAny  = v => String((v && v.lang) || '').toLowerCase().startsWith('es');

function buildInterleaved(msArr, gArr){
  const out = [];
  const n = Math.max(msArr.length, gArr.length);
  for (let i=0;i<n;i++){
    if (i < msArr.length) out.push(msArr[i]);
    if (i < gArr.length) out.push(gArr[i]);
  }
  return out;
}

let candidates = (voicesAll || []).filter(v => (isMS(v)) && (isESMX(v) || isESES(v)));
if (!candidates.length) candidates = (voicesAll || []).filter(v => (isMS(v)) && isESAny(v));

// Solo si NO hay nada Google/Microsoft ES, cae a cualquier ES y al final a todo.
if (!candidates.length) candidates = (voicesES.length ? voicesES : (voices || []));
if (!candidates.length) candidates = (voicesAll || []);

let ms = candidates.filter(v => isMS(v));
let gg = candidates.filter(v => isGoogle(v));

// En PC (desktop), el Auto Locutor se puede forzar a solo Microsoft para mejor claridad.
const __isMobileUA = (typeof isMobileDevice === 'function') ? isMobileDevice() : (__isAndroidLike() || __isIOSLike());
// En PC (desktop), limpia el pool: solo voces en español (evita EN como 'David').
if (!__isMobileUA && ms.length) {
  const _es = ms.filter(v => (((v.lang||'')+'').toLowerCase().startsWith('es')));
  if (_es.length) ms = _es;
}
const __mxOnlyDesktop = !__isMobileUA && (prefGet('spotterAutoVoiceMXOnlyDesktop','0') !== '0');
const __msOnlyDesktop = !__isMobileUA && (prefGet('spotterAutoVoiceMSOnlyDesktop','1') !== '0');


if (__mxOnlyDesktop && ms.length) {
  const _msmx = ms.filter(v => (((v.lang||'')+'').toLowerCase().startsWith('es-mx')) || /mexico/i.test((v.name||'')));
  if (_msmx.length) ms = _msmx;
}

let inter = (ms && ms.length) ? ms : [];
__autoVoicePool = inter.map(v => (v.voiceURI || v.name)).filter(Boolean);
      } catch(e) {}

      voiceSelect.innerHTML = '';
      voices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI || v.name || '';
        opt.textContent = `${v.name} (${v.lang || 'lang'})`;
        voiceSelect.appendChild(opt);
      });

      let toUse = chosenVoiceURI ? voices.find(v => (v.voiceURI || v.name) === chosenVoiceURI) : null;
      if (!toUse) {
        toUse = pickDefaultVoice(voices);
        chosenVoiceURI = toUse ? (toUse.voiceURI || toUse.name) : '';
      
      try { __refreshDuoVoices(voicesAll); } catch (e) {}
}

      if (chosenVoiceURI) voiceSelect.value = chosenVoiceURI;

      if (!voiceSelect.__bound) {
        voiceSelect.__bound = true;
        voiceSelect.addEventListener('change', () => {
          chosenVoiceURI = voiceSelect.value || '';
          try { prefSet('spotterVoiceURI', chosenVoiceURI); } catch (e) {}
          try { __autoSetRateFromSelectedVoice(); } catch (e) {}
        });
      }
    }

    // Auto-rate por tipo de voz seleccionada:
    // - Microsoft: 1.7
    // - Google: 1.2
    // Nota: si no coincide, no tocamos el rate (respeta el slider).
    function __autoSetRateFromSelectedVoice() {
      try {
        if (!window.speechSynthesis || !window.speechSynthesis.getVoices) return;
        const raw = window.speechSynthesis.getVoices() || [];
        if (!raw || !raw.length) return;

        const v = raw.find(x => (x.voiceURI || x.name) === chosenVoiceURI);
        const nm = String((v && v.name) || '').toLowerCase();

        let target = null;
        if (nm.includes('microsoft')) target = 1.7;
        else if (nm.includes('google')) target = 1.2;

        if (target === null) return;

        ttsRate = target;
        try { prefSet('spotterTtsRate', String(ttsRate)); } catch (e) {}
        try { if (rateRange) rateRange.value = String(ttsRate); } catch (e) {}
        try { if (rateDisplay) rateDisplay.textContent = String(ttsRate); } catch (e) {}
      } catch (e) {}
    }



    if (window.speechSynthesis) {
      refreshVoiceList();
    try { bindSessionPresetCards(); } catch(e) {}
    try { updateConfigStatusUI(); } catch(e) {}

      // Reintentos por si getVoices() llega vaco al inicio (comn en iOS/Android)
      let __vtries = 0;
      const __vtimer = setInterval(() => {
        __vtries++;
        refreshVoiceList();
        const v = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
        if ((v && v.length) || __vtries >= 8) clearInterval(__vtimer);
      }, 350);

      try {
        if (!window.__spotterVoicesChangedBound) {
          const __voiceRefreshHandler = () => refreshVoiceList();
          if (typeof window.speechSynthesis.addEventListener === 'function') {
            window.speechSynthesis.addEventListener('voiceschanged', __voiceRefreshHandler);
          } else {
            window.speechSynthesis.onvoiceschanged = __voiceRefreshHandler;
          }
          window.__spotterVoicesChangedBound = true;
        }
      } catch(e) {
        window.speechSynthesis.onvoiceschanged = () => refreshVoiceList();
      }

      // Keep-alive TTS en primer plano: evita que el motor se "duerma" aunque la pantalla esté activa.
      // Solo actúa cuando VOZ está ON, la pestaña está visible y no estamos en estado de "needs unlock".
      try {
        if (!__ttsKeepAliveTimer) {
          __ttsKeepAliveTimer = setInterval(() => {
            try {
              const vis = (document && document.visibilityState) ? document.visibilityState : 'visible';
              if (vis !== 'visible') return;
              if (!voiceMasterEnabled) return;
              const __kaIOS = (typeof isIOSWebKit === 'function' ? isIOSWebKit() : false);
              if (pendingAutoVoiceUnlock && __kaIOS) return;
              if (!window.speechSynthesis) return;

      try { if (typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
              try { if (typeof window.speechSynthesis.getVoices === 'function') window.speechSynthesis.getVoices(); } catch(e) {}

              // Anti-freeze TTS (primer plano): Chrome a veces se queda en "speaking=true" fantasma.
              try {
                const ss = window.speechSynthesis;
                const now = Date.now();
                const lastEv = (__ttsLastEventAt || 0);

                // speaking/pending fantasma: el browser dice speaking/pending, pero no hay actividad real y nuestra bandera no esta en speaking
                if (ss && (ss.speaking || ss.pending) && !speechSpeaking && lastEv) {
                  const thr = ss.speaking ? 9000 : 4500;
                  if ((now - lastEv) > thr) {
                    try { if (!__ttsCancelShieldUntil || now > __ttsCancelShieldUntil) ss.cancel(); } catch(e) {}
                    __ttsLastEventAt = now;
                  }
                }
// bandera interna atorada
                if (speechSpeaking && ss && !ss.speaking && lastEv && (now - lastEv) > 4500) {
                  speechSpeaking = false;
                }
              } catch(e) {}

              // Si hay cola y no esta hablando, empuja
              try {
                if (speechQueue && speechQueue.length && !speechSpeaking && !(window.speechSynthesis && (window.speechSynthesis.speaking || window.speechSynthesis.pending))) {
                  pumpSpeechQueue();
                }
              } catch(e) {}
            } catch(e) {}
          }, Math.max(1800, Number(__ttsFrontKeepAliveIntervalMs || 3000)));
        }
      } catch(e) {}

    }

    // Botn de prueba de voz (genera gesto de usuario y ayuda a iOS)
    if (ttsTestBtn) {
      ttsTestBtn.addEventListener('click', () => {
        try { setVoiceMaster(true, { silent:true, auto:true }); } catch(e) {}
        try { startSilentAudioKeepAlive(); } catch(e) {}
        try { hardUnlockAudioPipe(); } catch(e) {}
      try { if (voiceMasterEnabled && isIOSWebKit && isIOSWebKit()) unlockTTSOnce('voice-master'); } catch(e) {}
        try { playBeep('soft'); } catch(e) {}
        try {
          enqueueSpeech('Spotter listo. Probando voz.', { key:'tts_test', priority: 99, cooldownMs: 0, interrupt:true, dedupe: true });
        } catch(e) {}
      });
    }

    // Speech queue manager: evita que se trunque cuando entra otro mensaje.
    const speechQueue = [];
    let speechSpeaking = false;
    let speechWatchdog = 0;
    const lastSpokenKeyAt = new Map();
    const lastSpokenTextAt = new Map();
let __ttsStartGuard = 0;
    let __ttsStartGuardFails = 0; // conteo de fallos de arranque (para no exigir tap a la primera)
    let __ttsLastEventAt = 0;
    let __ttsLastStartAt = 0;
    let __ttsLastEndAt = 0;
    let __ttsLastSpeakCallAt = 0;
    let __ttsCurrentText = '';
 // si el utterance no arranca, no drenar cola (iOS/Android post-idle)

    
    // =========================
    // TTS normalizacin de tiempos (evita que diga dgito por dgito)
    // =========================
    function normalizeTtsText(raw) {
      try {
        let s = String(raw || '');

        // Normaliza unicode (acentos) para TTS
        try { s = s.normalize('NFC'); } catch(e) {}
        // Corrige mojibake común antes de hablar
        s = s
          .replace(/Ã¡/g, 'á').replace(/Ã©/g, 'é').replace(/Ãí/g, 'í').replace(/Ã³/g, 'ó').replace(/Ãº/g, 'ú')
          .replace(/Ã‘/g, 'Ñ').replace(/Ã±/g, 'ñ')
          .replace(/Â¿/g, '¿').replace(/Â¡/g, '¡');
        // TTS-safe: evita que algunas voces pronuncien raro "Clasificación"
        s = s.replace(/Clasificación/gi, 'Clasificación');

        // Unidades: "123 ms" -> segundos/d\xe9cimas/cent\xe9simas/mil\xe9simas seg\xfan corresponda
        // Nota: esto SOLO aplica cuando "ms" viene con n\xfa mero. "ms" suelto se trata como "m\xe1s" m\xe1s abajo.
        const __msToSpeech = (msStr) => {
          const ms = parseInt(msStr, 10);
          if (!isFinite(ms) || ms <= 0) return msStr + ' ms';
          // >= 1s => segundos (con 1-3 decimales seg\xfan exactitud)
          if (ms >= 1000) {
            const whole = (ms % 1000) === 0;
            if (whole) {
              const secInt = Math.round(ms / 1000);
              return secInt + (secInt === 1 ? ' segundo' : ' segundos');
            }
            let decs = 3;
            if ((ms % 100) === 0) decs = 1;
            else if ((ms % 10) === 0) decs = 2;
            let secStr = (ms / 1000).toFixed(decs);
            secStr = secStr.replace(/0+$/,'').replace(/\.$/,'');
            const spoken = secStr.replace('.', ' punto ');
            return spoken + ' segundos';
          }
          // < 1s => d\xe9cimas / cent\xe9simas / mil\xe9simas (seg\xfan divisibilidad)
          if ((ms % 100) === 0) {
            const d = ms / 100;
            return d + (d === 1 ? ' d\xe9cima' : ' d\xe9cimas');
          }
          if ((ms % 10) === 0) {
            const c = ms / 10;
            return c + (c === 1 ? ' cent\xe9sima' : ' cent\xe9simas');
          }
          return ms + (ms === 1 ? ' mil\xe9sima' : ' mil\xe9simas');
        };
        s = s.replace(/\b(\d+)\s*ms\b/gi, (m, n) => __msToSpeech(n));

        // Diccionario r\xe1pido de tildes y pronunciaci\xf3n (TTS)
        // - evita lecturas raras por falta de acento ("basico") o por encoding/recortes (ej. "líder", "línea")
        const __dict = [
          [/\bbasico\b/gi, 'básico'],
          [/\bautomatico\b/gi, 'automático'],
          [/\bclasificaci[oó]n\b/gi, 'clasificación'],
          [/\bclasificacin\b/gi, 'clasificación'],
          [/\bposicion\b/gi, 'posición'],
          [/\bultima\b/gi, 'última'],
          [/\bultimas\b/gi, 'últimas'],
          [/\bultimo\b/gi, 'último'],
          [/\bultimos\b/gi, 'últimos'],
          [/\blider\b/gi, 'líder'],
          [/\blideres\b/gi, 'líderes'],
          [/\bmas\b/gi, 'más'],
          [/\bpenalizacion\b/gi, 'penalización'],
          [/\btrafico\b/gi, 'tráfico'],
          [/\blinea\b/gi, 'línea'],
          [/\bpresion\b/gi, 'presión'],
          [/\batras\b/gi, 'atrás'],
          [/\brapido\b/gi, 'rápido'],
          [/\brapida\b/gi, 'rápida'],
          [/\brapidamente\b/gi, 'rápidamente'],
          [/\btecnico\b/gi, 'técnico'],
          [/\btecnica\b/gi, 'técnica'],
          [/\bepico\b/gi, 'épico'],
          [/\bepica\b/gi, 'épica'],
          [/\bcritico\b/gi, 'crítico'],
          [/\bcritica\b/gi, 'crítica'],
          [/\bmaximo\b/gi, 'máximo'],
          [/\bminimo\b/gi, 'mínimo'],
          [/\bpractica\b/gi, 'práctica'],
          [/\bpracticas\b/gi, 'prácticas'],
          [/\banalisis\b/gi, 'análisis'],
          [/\bcronometro\b/gi, 'cronómetro'],
          [/\bcronometros\b/gi, 'cronómetros'],
          [/\bdecima\b/gi, 'décima'],
          [/\bdecimas\b/gi, 'décimas'],
          [/\bnumero\b/gi, 'número'],
          [/\bnumeros\b/gi, 'números'],
          [/\bcampeon\b/gi, 'campeón'],
          [/\bsubcampeon\b/gi, 'subcampeón'],
          [/\benfocate\b/gi, 'enfócate'],
          [/\baqui\b/gi, 'aquí'],
          [/\basi\b/gi, 'así'],
          [/\bMexico\b/g, 'México'],
          [/\bHobbyShopMX\b/gi, 'HobbyShop México'],
          [/Italia\s*-\s*Messina/gi, 'Italia, Messina'],
        ];
        for (const [re, rep] of __dict) s = s.replace(re, rep);

        // P2 -> "P dos" (evita "pee two")
        const __u = ['cero','uno','dos','tres','cuatro','cinco','seis','siete','ocho','nueve','diez',
                     'once','doce','trece','catorce','quince','diecis\xe9is','diecisiete','dieciocho','diecinueve'];
        const __tens = {20:'veinte',30:'treinta',40:'cuarenta',50:'cincuenta',60:'sesenta',70:'setenta',80:'ochenta',90:'noventa'};
        const __numToEs = (n) => {
          n = Number(n);
          if (!isFinite(n)) return String(n);
          if (n < 20) return __u[n] || String(n);
          if (n === 20) return 'veinte';
          if (n < 30) return 'veinti' + (__u[n-20] || String(n-20));
          const t = Math.floor(n/10)*10, r = n%10;
          if (!r) return __tens[t] || String(n);
          return (__tens[t] || String(t)) + ' y ' + (__u[r] || String(r));
        };
        s = s.replace(/\bP\s*([0-9]{1,2})\b/gi, (m, n) => 'P ' + __numToEs(n));

        // +1 V / +2 V / +3 V -> "m\xe1s una vuelta", "m\xe1s dos vueltas" (quita el "+", que suele confundir al TTS)
        s = s.replace(/\+(\d+)\s*V\b/gi, (m, n) => {
          const k = parseInt(n,10);
          if (!isFinite(k) || k <= 0) return m;
          const w = (k <= 30) ? __numToEs(k) : String(k);
          return k === 1 ? 'm\xe1s una vuelta' : ('m\xe1s ' + w + ' vueltas');
        });
        s = s.replace(/\+(\d+)V\b/gi, (m, n) => {
          const k = parseInt(n,10);
          if (!isFinite(k) || k <= 0) return m;
          const w = (k <= 30) ? __numToEs(k) : String(k);
          return k === 1 ? 'm\xe1s una vuelta' : ('m\xe1s ' + w + ' vueltas');
        });

        // mm:ss.mmm
        s = s.replace(/\b(\d{1,2}):(\d{2})\.(\d{3})\b/g, (m0) => {
          const ms = parseTimeToMs(m0);
          return ms ? tiempoATexto(ms) : m0;
        });

        // ss.xxx (evitar tocar versiones tipo 4.0.7: usa lookaround para no estar pegado a otro punto)
        s = s.replace(/(^|[^\d.])(\d{1,2}\.\d{1,3})(?![\d.])/g, (m0, pre, tok) => {
          const v = parseFloat(tok);
          if (!isFinite(v) || v <= 0 || v >= 180) return pre + tok;
          const ms = parseTimeToMs(v);
          return pre + (ms ? tiempoATexto(ms) : tok);
        });

        
        // Limpieza: evitar repetir el mismo dato dos veces en la misma frase (bug/armado)
        // Ej: "ms una vuelta, ms una vuelta" / "0.2 segundos, 0.2 segundos"
        try {
          // Repite "ms X vuelta(s)"
          s = s.replace(/\b(m\xe1s\s+(?:una|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s+vueltas?)\b(?:\s*[,;:\-]\s*\1\b)+/gi, '$1');
          // Repite "P#"
          s = s.replace(/\b(P\s*\d+)\b(?:\s*[,;:\-]\s*\1\b)+/gi, '$1');
          // Repite "<n> segundos/dcimas/centsimas/milsimas"
          s = s.replace(/\b(\d+(?:\.\d+)?\s*(?:segundos?|d\xe9cimas?|cent\xe9simas?|mil\xe9simas?))\b(?:\s*[,;:\-]\s*\1\b)+/gi, '$1');
        } catch(e) {}
return s;
      } catch(e) {
        return String(raw || '');
      }
    }

    // =========================
    // MANGA: reloj de 3:00 POR PILOTO (arranca en su 1er cruce por meta)
    // - La sesin dura 3:00, pero cada piloto trae su propio cronmetro (salida escalonada).
    // - Guardamos el inicio por piloto (pilotKey) para que NO se reinicie al cambiar de piloto seguido.
    // =========================
    let mangaClockTimer = 0;
    const MANGA_SESSION_MS = 180000;

    // pilotKey -> epoch ms (inicio aproximado del cronmetro de ese piloto)
    let mangaPilotStartAt = new Map();
    // pilotKey -> laps vistos en el tick anterior (para detectar primer cruce)
    let mangaPrevLapsByPilot = new Map();
    // pilotKey -> ya anunciamos "Inicio cronometro" (evita repetir al volver a seleccionar)
    let mangaStartAnnouncedByPilot = new Set();

    // First-detect beep (suave) por piloto (no repetir cuando re-seleccionas)
    let firstDetectBeepedByPilot = new Map();

    function setMangaClockVisible(on) {
      const it = document.getElementById('mangaClockItem');
      if (!it) return;
      if (on) it.classList.remove('timer-only');
      else it.classList.add('timer-only');
    }

    function formatClockMs(ms) {
      const v = Math.max(0, Math.floor(ms));
      const mm = Math.floor(v / 60000);
      const ss = Math.floor((v % 60000) / 1000);
      const mmm = v % 1000;
      return String(mm) + ':' + String(ss).padStart(2,'0') + '.' + String(mmm).padStart(3,'0');
    }

    // =========================
    // NUEVO FEED: reloj global (elapsed) + countdown derivado
    // - El feed manda elapsed (sube). Nosotros interpolamos localmente para que corra suave.
    // - Countdown = targetMs - elapsedNow (target ideal: estTimeMs del feed).
    // - Anuncios: cuanto falta (incluye practica).
    // =========================
    let __sessClockTimer = 0;
    let __sessClockBaseElapsedMs = 0;
    let __sessClockRxAt = 0;
    let __sessClockTargetMs = 0;
    let __sessClockLastRemainingMs = null;
    let __sessClockAnnounced = new Set();
    let __sessClockSig = '';
    let __sessClockLastTargetMs = 0;
    let __sessClockLastFeedElapsedMs = 0;

    function __pickElapsedClockMs(rawRace){
      try{
        const a = (rawRace && typeof rawRace.clockMs === 'number') ? rawRace.clockMs : null;
        const b = (rawRace && typeof rawRace.clock === 'number') ? rawRace.clock : null;
        const v = (a != null) ? a : (b != null ? b : 0);
        const n = Number(v);
        if (!isFinite(n) || n < 0) return 0;
        // Guard rail: si viene en micro/milis raras (muy grande), no lo usamos.
        if (n > 60 * 60 * 1000 * 6) return 0; // >6h elapsed es sospechoso
        return Math.floor(n);
      } catch(e){
        return 0;
      }
    }

    function __inferTargetMsFromEst(raceData){
      try{
        const cls = (raceData && Array.isArray(raceData.classification)) ? raceData.classification : [];
        let mx = 0;
        for (const r of cls){
          const est = Number(r && r.estTime) || 0;
          if (est > mx) mx = est;
        }
        // plausible: 30s .. 20min
        if (mx >= 30000 && mx <= 20*60*1000) return Math.floor(mx);
      } catch(e) {}

      // Fallback por tipo de sesion (si el feed aun no trae est)
      try{
        const rn = String((raceData && raceData.raceName) || '').toLowerCase();
        if (rn.includes('final a') || rn.includes('a-main') || rn.includes('main a')) return 6*60*1000;
        if (rn.includes('final b') || rn.includes('final c') || rn.includes('b-main') || rn.includes('c-main')) return 4*60*1000;
        // Clasificacion / Manga
        return 3*60*1000;
      } catch(e) {}

      return 0;
    }

    function __maybeAnnounceRemainingMs(remMs){
      // TTS de tiempo restante desactivado (sin anuncio final).
      return;
      try{
        if (!voiceMasterEnabled) return;
        if (!remMs || remMs < 0) remMs = 0;

        // Umbrales (ms)
        const marks = [
          120000, 60000, 30000
        ];

        // Detecta cruces hacia abajo
        const prev = (__sessClockLastRemainingMs == null) ? remMs : __sessClockLastRemainingMs;
        __sessClockLastRemainingMs = remMs;

        for (const m of marks){
          if (prev > m && remMs <= m && !__sessClockAnnounced.has(m)){
            __sessClockAnnounced.add(m);

            let txt = '';
            if (m === 120000) txt = 'Quedan dos minutos.';
            else if (m === 60000) txt = 'Último minuto.';
            else if (m === 30000) txt = 'Treinta segundos.';

            if (txt) {
              enqueueSpeech(txt, { key: 'time_mark_' + m + '_' + __sessClockSig, priority: 86, cooldownMs: 15000, dedupe: true });
            }
            break;
          }
        }
      } catch(e) {}
    }

    function __startSessionClockTicker(){
      if (__sessClockTimer) return;
      __sessClockTimer = setInterval(() => {
        try{
          if (!raceData) return;
          if (!__sessClockRxAt) return;
          if (!__sessClockTargetMs || __sessClockTargetMs <= 0) return;

          const now = Date.now();
          const elapsedNow = Math.max(0, __sessClockBaseElapsedMs + (now - __sessClockRxAt));
          const remMs = Math.max(0, __sessClockTargetMs - elapsedNow);

          __maybeAnnounceRemainingMs(remMs);
        } catch(e) {}
      }, 120);
    }

    function __stopSessionClockTicker(){
      if (__sessClockTimer) { clearInterval(__sessClockTimer); __sessClockTimer = 0; }
      __sessClockRxAt = 0;
      __sessClockBaseElapsedMs = 0;
      __sessClockTargetMs = 0;
      __sessClockLastRemainingMs = null;
      __sessClockAnnounced = new Set();
      __sessClockSig = '';
      __sessClockLastTargetMs = 0;
      __sessClockLastFeedElapsedMs = 0;
    }

    function __updateSessionClockFromFeed(rawRace, normRace){
      try{
        const rn = String((normRace && normRace.raceName) || '').trim();
        const pr = (normRace && normRace.practice != null) ? Number(normRace.practice) : null;
        const sig = rn + '|' + String(pr);
        if (sig !== __sessClockSig){
          // carrera nueva
          __sessClockSig = sig;
          __sessClockAnnounced = new Set();
          __sessClockLastRemainingMs = null;
          __sessClockLastTargetMs = 0;
          __sessClockLastFeedElapsedMs = 0;
        }

        const elapsedFeed = __pickElapsedClockMs(rawRace);
        // si el feed se reinicia (elapsed baja fuerte), reset interno
        if (__sessClockLastFeedElapsedMs && elapsedFeed + 2000 < __sessClockLastFeedElapsedMs){
          __sessClockAnnounced = new Set();
          __sessClockLastRemainingMs = null;
        }
        __sessClockLastFeedElapsedMs = elapsedFeed;

        const target = __inferTargetMsFromEst(normRace);
        // si cambian minutos en caliente (target se mueve), ajustar y limpiar marks futuros
        if (__sessClockLastTargetMs && target && Math.abs(target - __sessClockLastTargetMs) > 5000){
          // conserva lo ya anunciado por debajo del nuevo remaining, pero re-habilita los mayores
          const newSet = new Set();
          for (const m of __sessClockAnnounced){
            // si ya lo cruzamos, lo dejamos
            newSet.add(m);
          }
          __sessClockAnnounced = newSet;
          __sessClockLastRemainingMs = null;
        }
        __sessClockLastTargetMs = target;

        // Si no hay target (feed sin est), no hacemos anuncios.
        if (!target || target <= 0){
          __sessClockTargetMs = 0;
          return;
        }

        // Update base
        __sessClockTargetMs = target;
        __sessClockBaseElapsedMs = elapsedFeed;
        __sessClockRxAt = Date.now();
        __startSessionClockTicker();
      } catch(e) {}
    }

    function setMangaClockColorByRemaining(remMs) {
      const el = document.getElementById('mangaClock');
      if (!el) return;
      const r = Math.max(0, Math.min(1, remMs / MANGA_SESSION_MS));
      const hue = 120 * r; // 120=verde, 60=amarillo, 0=rojo
      el.style.setProperty('--clock-hue', hue.toFixed(1));
    }

    function flashMangaClock() {
      const el = document.getElementById('mangaClock');
      if (!el) return;
      el.classList.add('flash');
      setTimeout(() => el.classList.remove('flash'), 750);
    }

    
function updateMangaClockDisplay() {
      const el = document.getElementById('mangaClock');
      if (!el) return;

      // Sin piloto seleccionado: dejamos placeholder estable
      if (!selectedPilotKey) {
        el.textContent = '0:00.000';
        setMangaClockColorByRemaining(MANGA_SESSION_MS);
        return;
      }

      // En MANGA mostramos el "time" real del feed (tiempo total del piloto)
      const pNow = (raceData && Array.isArray(raceData.classification))
        ? raceData.classification.find(r => getPilotKey(r) === selectedPilotKey)
        : null;

      const elapsedMs = pNow ? (Number(pNow.time) || 0) : 0;
      const timeTxt = elapsedMs > 0 ? msToMinSec(elapsedMs) : '0:00.000';

      el.textContent = timeTxt;

      // Color por restante estimado (3:00 - elapsed)
      const rem = Math.max(0, MANGA_SESSION_MS - elapsedMs);
      setMangaClockColorByRemaining(rem);
    }

    function ensureMangaClockTicker() {
      setMangaClockVisible(true);
      // Siempre refrescamos al menos una vez al tick actual
      updateMangaClockDisplay();

      if (mangaClockTimer) return;
      mangaClockTimer = setInterval(() => {
        updateMangaClockDisplay();
      }, 300);
    }

    function stopMangaClock() {
      if (mangaClockTimer) { clearInterval(mangaClockTimer); mangaClockTimer = 0; }
      setMangaClockVisible(false);

      // Reset total cuando se sale de MANGA / cambia carrera
      mangaPilotStartAt = new Map();
      mangaPrevLapsByPilot = new Map();
      mangaStartAnnouncedByPilot = new Set();
    }

    // MANGA: actualizar reloj por piloto en cada tick (arranca al 1er cruce REAL por meta: 0 -> 1)
function updateMangaPilotStartsFromClassification(classification) {
  try {
    if (!Array.isArray(classification)) return;

    const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
    if (!isManga) return;

    const now = Date.now();

    for (const row of classification) {
      const pk = getPilotKey(row);
      if (!pk) continue;

      const laps = Number(row.lapcount) || 0;
      const hadPrev = mangaPrevLapsByPilot.has(pk);
      const prev = hadPrev ? (Number(mangaPrevLapsByPilot.get(pk)) || 0) : 0;

      // Guardar laps vistos
      mangaPrevLapsByPilot.set(pk, laps);

      // Primer cruce detectado REAL: solo cuando YA vimos laps=0 y ahora sube a >0
      // (Evita arrancar el reloj "al seleccionar" si abres el spotter con la manga ya empezada)
      if (!mangaPilotStartAt.get(pk) && hadPrev && prev === 0 && laps > 0) {
        mangaPilotStartAt.set(pk, now);

        // Aviso solo para el piloto seleccionado (evita spam de todos)
        if (pk === selectedPilotKey && !mangaStartAnnouncedByPilot.has(pk)) {
          try { if (voiceMasterEnabled) playBeep('up'); } catch(e) {}
          enqueueSpeech('Inicio cronometro.', { key: 'manga_start_' + pk, priority: 92, cooldownMs: 8000, dedupe: true });
          try { flashPilotCardGreen(); } catch(e) {}
          try { flashMangaClock(); } catch(e) {}
          mangaStartAnnouncedByPilot.add(pk);
        }
      }
    }

    // UI: si hay piloto seleccionado, muestra reloj (3:00 hasta que arranque)
    if (selectedPilotKey) {
      setMangaClockVisible(true);
      updateMangaClockDisplay();
      if (mangaPilotStartAt.get(selectedPilotKey)) ensureMangaClockTicker();
    } else {
      // sin piloto seleccionado: opcional mantener visible 3:00
      setMangaClockVisible(true);
      updateMangaClockDisplay();
    }
  } catch(e) {}
}

function flashPilotCardGreen() {
      const card = document.querySelector('.pilot-card');
      if (!card) return;
      card.classList.add('flash-green');
      setTimeout(() => card.classList.remove('flash-green'), 650);
    }

    // =========================
    // Record de carrera: avisar cuando lo mejora CUALQUIERA
    // =========================
    let lastGlobalBestSpokenMs = 0;
    let lastGlobalBestSpokenHolderKey = null;
    let lastGlobalBestSpokenAt = 0;

function clampNum(v, lo, hi){
      const n = Number(v);
      if (!isFinite(n)) return lo;
      return Math.max(lo, Math.min(hi, n));
    }

    function prosodyFromMood(mood){
      const m = String(mood||'').toLowerCase();
      // Nota: Web Speech API no tiene "emociones" reales. Esto solo ajusta rate/pitch/volume.
      if (m === 'hype' || m === 'excited') return { rateMul: 1.06, pitch: 1.12, volume: 1.0 };
      if (m === 'urgent') return { rateMul: 1.10, pitch: 1.18, volume: 1.0 };
      if (m === 'calm') return { rateMul: 0.98, pitch: 0.96, volume: 1.0 };
      if (m === 'serious') return { rateMul: 0.99, pitch: 0.92, volume: 1.0 };
      return { rateMul: 1.0, pitch: 1.0, volume: 1.0 };
    }



// =============================
// Anti-repeticion semantica v2
// - Evita repetir la misma idea con texto distinto
// - Aplica solo en categorias narrativas (no POS/LAPS)
// =============================
const __semMem = new Map();
const __semStop = new Set([
  'el','la','los','las','un','una','unos','unas','de','del','al','y','o','a','en','por','para','con','sin','que','se','su','sus',
  'tu','tus','mi','mis','ya','va','vamos','ahi','aquí','ok','bien','dale','ahora','solo','muy','mas','menos','uno','dos','tres',
  'p','pos','posicion','vueltas','vuelta','lap','laps','seg','segundos','segundo','ms'
]);

function __semStripAccents(s){
  try{ return String(s||'').normalize('NFD').replace(/[-]/g,''); }catch(e){ return String(s||''); }
}

function __semNorm(s){
  s = __semStripAccents(String(s||'').toLowerCase());
  // quita numeros para comparar "idea" (9.812 vs 9.803)
  s = s.replace(/[0-9]+([.:][0-9]+)*/g,' # ');
  // limpia puntuacion
  s = s.replace(/[^a-z#\s]/g,' ');
  s = s.replace(/\s+/g,' ').trim();
  return s;
}

function __semTokens(s){
  const n = __semNorm(s);
  if (!n) return [];
  const parts = n.split(' ').filter(Boolean);
  const out = [];
  for (const w of parts){
    if (w === '#') continue;
    if (w.length <= 2) continue;
    if (__semStop.has(w)) continue;
    out.push(w);
  }
  return out;
}

function __semJaccard(aTokens, bTokens){
  try{
    const a = new Set(aTokens||[]);
    const b = new Set(bTokens||[]);
    if (!a.size && !b.size) return 1;
    if (!a.size || !b.size) return 0;
    let inter = 0;
    for (const x of a) if (b.has(x)) inter++;
    const uni = a.size + b.size - inter;
    return uni ? (inter / uni) : 0;
  }catch(e){ return 0; }
}

function __semPrune(list, now, windowMs){
  try{
    const w = Math.max(2000, Number(windowMs)||25000);
    const keep = [];
    for (const it of (list||[])){
      if (!it) continue;
      if ((now - (it.t||0)) <= w) keep.push(it);
    }
    return keep;
  }catch(e){ return list||[]; }
}

function __semSkipCategory(cat){
  const c = String(cat||'').toLowerCase();
  // Nunca bloquees POS ni LAPS ni test
  if (!c) return true;
  if (c === 'pos' || c === 'laps' || c === 'lap' || c === 'tts' || c === 'test') return true;
  if (c === 'manga_start') return true;
  return false;
}

function __inferSemCategoryFromKey(key){
  const k = String(key||'').toLowerCase();
    if (k.startsWith('sys_')) return true;
  if (!k) return '';
  if (k.includes('blue') || k.includes('bandera_azul') || k.includes('blueflag')) return 'blueflag';
  if (k.startsWith('auto_finalizo_') || k.includes('finalizo')) return 'finalizo';
  if (k.startsWith('pos_') || k.includes('pos_manga_') || k.includes('pos_brief_')) return 'pos';
  if (k.startsWith('lap_') || k.includes('lastlap') || k.includes('lap')) return 'lap';
  if (k.includes('attack') || k.includes('ataque') || k.includes('defense') || k.includes('defensa') || k.includes('fight') || k.includes('duel')) return 'battle';
  if (k.includes('gap') || k.includes('interval')) return 'gaps';
  if (k.includes('leader') || k.includes('líder')) return 'leader';
  if (k.includes('best') || k.includes('record')) return 'bestlap';
  if (k.includes('session_finish')) return 'finish';
  return '';
}

function __semIsRepeat(cat, text, threshold, windowMs){
  try{
    const c = String(cat||'').toLowerCase().trim();
    if (!c) return false;
    const now = Date.now();
    const thr = (Number.isFinite(Number(threshold)) ? Number(threshold) : 0.78);
    const win = (Number.isFinite(Number(windowMs)) ? Number(windowMs) : 25000);

    const norm = __semNorm(text);
    const tokens = __semTokens(text);

    let list = __semMem.get(c) || [];
    list = __semPrune(list, now, win);

    for (const it of list){
      if (!it) continue;
      // 1) match directo por normalizado (muy estricto)
      if (it.norm && norm && it.norm === norm) {
        __semMem.set(c, list);
        return true;
      }
      // 2) similitud por tokens (jaccard)
      const sim = __semJaccard(tokens, it.tokens||[]);
      if (sim >= thr) {
        __semMem.set(c, list);
        return true;
      }
    }

    __semMem.set(c, list);
    return false;
  }catch(e){ return false; }
}

function __semRemember(cat, text, windowMs){
  try{
    const c = String(cat||'').toLowerCase().trim();
    if (!c) return;
    const now = Date.now();
    const win = (Number.isFinite(Number(windowMs)) ? Number(windowMs) : 25000);
    const norm = __semNorm(text);
    const tokens = __semTokens(text);

    let list = __semMem.get(c) || [];
    list = __semPrune(list, now, win);
    list.push({ t: now, norm, tokens });
    // limita memoria por categoria
    if (list.length > 16) list = list.slice(-16);
    __semMem.set(c, list);
  }catch(e){}
}


// =========================
// Silencio por inactividad (VOZ sigue ON)
// - Si el feed no cambia (pos/laps/top3), evitamos que el spotter repita y repita.
// - Solo dejamos pasar mensajes esenciales (bandera azul, cambios fuertes, sistema).
// =========================
let __activitySig = '';
let __lastActivityChangeTs = Date.now();
let __silenceAfterMs = 20000; // 20s sin cambios = silencio

function __setActivitySig(sig){
  try{
    const s = String(sig||'');
    if (!s) return;
    if (s !== __activitySig){
      __activitySig = s;
      __lastActivityChangeTs = Date.now();
    }
  }catch(e){}
}
function __inActivitySilence(){
  try{ return (Date.now() - (__lastActivityChangeTs||0)) > (__silenceAfterMs||20000); }catch(e){ return false; }
}
function __isEssentialSpeech(opts, key, priority){
  try{
    if (opts && (opts.force === true || opts.user === true)) return true;
    const pr = Number(priority||0) || 0;
    if (pr >= 80) return true;
    const k = String(key||'').toLowerCase();
    const cat = String((opts && (opts.semanticCategory || opts.category)) || '').toLowerCase();
    if (cat === 'ess' || cat === 'system' || cat === 'critical') return true;
    if (k.includes('blue') || k.includes('bandera') || k.includes('leader') || k.includes('líder') || k.includes('finish') || k.includes('cuadros') || k.includes('podium')) return true;
    if (k.includes('tts_test') || k.includes('unlock') || k.includes('audio listo')) return true;
    return false;
  }catch(e){ return false; }
}

// =========================
// TTS RECOVERY (evita "se tarda / no arranca / luego escupe todo")
// - Si el motor de voz se bloquea, no acumulamos backlog infinito.
// - Al reactivar, limpiamos mensajes viejos y retomamos suave.
// =========================
let __ttsBlockedSince = 0;

// =========================
// Speech Arbiter / Filtro editorial
// - La cola NO debe vomitar mensajes viejos.
// - Cada frase nace con prioridad + categoría + caducidad.
// - Mensajes ruidosos (gaps/front/back/mini/ritmo) se caen primero.
// =========================
const __speechQueueCfg = {
  maxQueue: 6,
  maxQueueBlocked: 4,
  staleLowMs: 2200,
  staleNormalMs: 4200,
  staleHighMs: 9000,
  sameCatSuppressMs: 3200,
  recentSpokenSuppressMs: 4500,
  noisyPendingMax: 2
};
const __speechLastCategoryAt = new Map();
const __speechLastCategoryText = new Map();

function __speechCatFromOpts(opts, key, text){
  try{
    const direct = String((opts && (opts.queueCategory || opts.category || opts.semanticCategory)) || '').trim().toLowerCase();
    if (direct) return direct;
    const k = String(key || '').toLowerCase();
    if (!k) return __inferSemCategoryFromKey(text || '') || 'general';
    if (k.includes('front06')) return 'front06';
    if (k.includes('back06')) return 'back06';
    if (k.includes('ritmo')) return 'ritmo';
    if (k.includes('netgain')) return 'netgain';
    if (k.includes('estlap')) return 'estlap';
    if (k.includes('mini')) return 'mini';
    if (k.includes('top3')) return 'top3';
    if (k.includes('train')) return 'train';
    if (k.includes('pressure')) return 'pressure';
    if (k.includes('attack') || k.includes('defense') || k.includes('fight') || k.includes('duel')) return 'battle';
    if (k.includes('pos_') || k.includes('pos_manga_') || k.includes('pos_brief_')) return 'pos';
    if (k.includes('lap_') || k.includes('lastlap')) return 'lap';
    if (k.includes('best') || k.includes('record')) return 'bestlap';
    if (k.includes('leader')) return 'leader';
    if (k.includes('gap')) return 'gaps';
    if (k.includes('blue')) return 'blueflag';
    if (k.includes('podio') || k.includes('podium')) return 'podium';
    if (k.includes('finish') || k.includes('finalizo')) return 'finish';
    if (k.startsWith('sys_')) return 'system';
    return __inferSemCategoryFromKey(k) || 'general';
  }catch(e){ return 'general'; }
}

function __speechIsNoisyCat(cat){
  const c = String(cat || '').toLowerCase();
  return (c === 'gaps' || c === 'front06' || c === 'back06' || c === 'ritmo' || c === 'mini' || c === 'netgain' || c === 'estlap');
}

function __speechIsCriticalCat(cat, priority, opts, key){
  try{
    if (__isEssentialSpeech(opts, key, priority)) return true;
    const c = String(cat || '').toLowerCase();
    if (c === 'system' || c === 'finish' || c === 'blueflag' || c === 'podium') return true;
    if ((Number(priority) || 0) >= 90) return true;
    return false;
  }catch(e){ return false; }
}

function __speechExpiryFor(cat, priority, opts){
  try{
    if (opts && typeof opts.textTtlMs === 'number') return Math.max(0, Number(opts.textTtlMs) || 0);
    if (__speechIsCriticalCat(cat, priority, opts, opts && opts.key)) return 0;
    const pr = Number(priority || 0) || 0;
    const c = String(cat || '').toLowerCase();
    if (c === 'lap') return 1500;
    if (c === 'pos') return 1800;
    if (c === 'battle' || c === 'pressure' || c === 'front06' || c === 'back06') return 2400;
    if (c === 'gaps' || c === 'ritmo' || c === 'mini' || c === 'netgain' || c === 'estlap') return 2000;
    if (c === 'leader' || c === 'bestlap' || c === 'top3' || c === 'train') return 4200;
    if (pr >= 80) return __speechQueueCfg.staleHighMs;
    if (pr <= 35) return __speechQueueCfg.staleLowMs;
    return __speechQueueCfg.staleNormalMs;
  }catch(e){ return __speechQueueCfg.staleNormalMs; }
}

function __speechIsExpired(it, now){
  try{
    if (!it) return true;
    if (__speechIsCriticalCat(it.category, it.priority, it.opts || {}, it.key)) return false;
    const exp = Number(it.expireAt || 0) || 0;
    if (exp > 0 && now > exp) return true;
    return false;
  }catch(e){ return false; }
}

function __speechPruneQueue(now){
  try{
    const t = Number(now || Date.now()) || Date.now();
    const keep = [];
    let noisyCount = 0;
    for (const it of (speechQueue || [])){
      if (!it) continue;
      if (__speechIsExpired(it, t)) continue;
      const cat = String(it.category || '').toLowerCase();
      if (__speechIsNoisyCat(cat)) {
        noisyCount++;
        if (noisyCount > __speechQueueCfg.noisyPendingMax && !__speechIsCriticalCat(cat, it.priority, it.opts || {}, it.key)) continue;
      }
      keep.push(it);
    }
    keep.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));
    const maxQ = pendingAutoVoiceUnlock ? __speechQueueCfg.maxQueueBlocked : __speechQueueCfg.maxQueue;
    speechQueue.length = 0;
    for (const it of keep.slice(0, maxQ)) speechQueue.push(it);
  }catch(e){}
}

function __speechShouldSkipIncoming(clean, key, cat, priority, opts, now){
  try{
    const t = Number(now || Date.now()) || Date.now();
    const critical = __speechIsCriticalCat(cat, priority, opts, key);
    if (critical) return false;

    __speechPruneQueue(t);

    const maxQ = pendingAutoVoiceUnlock ? __speechQueueCfg.maxQueueBlocked : __speechQueueCfg.maxQueue;
    if ((speechQueue || []).length >= maxQ) return true;

    const lastCatAt = __speechLastCategoryAt.get(cat) || 0;
    if (lastCatAt && (t - lastCatAt) < __speechQueueCfg.recentSpokenSuppressMs) {
      const lastTxt = String(__speechLastCategoryText.get(cat) || '').trim().toLowerCase();
      const curTxt = String(clean || '').trim().toLowerCase();
      if (lastTxt && curTxt && (lastTxt === curTxt || __speechIsNoisyCat(cat))) return true;
    }

    for (const it of (speechQueue || [])){
      if (!it) continue;
      const sameCat = String(it.category || '').toLowerCase() === String(cat || '').toLowerCase();
      if (!sameCat) continue;
      const age = t - (Number(it.ts || t) || t);
      if (age > __speechQueueCfg.sameCatSuppressMs) continue;
      if ((Number(it.priority || 0) || 0) >= (Number(priority || 0) || 0)) return true;
    }

    if ((speechSpeaking || (speechQueue && speechQueue.length)) && __speechIsNoisyCat(cat) && (Number(priority || 0) || 0) < 80) {
      return true;
    }

    return false;
  }catch(e){ return false; }
}

function __speechSupersedePending(cat, priority, opts, key, now){
  try{
    const t = Number(now || Date.now()) || Date.now();
    const incomingPr = Number(priority || 0) || 0;
    const incomingCat = String(cat || '').toLowerCase();
    if (!incomingCat) return;
    for (let i = speechQueue.length - 1; i >= 0; i--){
      const it = speechQueue[i];
      if (!it) continue;
      const sameCat = String(it.category || '').toLowerCase() === incomingCat;
      if (!sameCat) continue;
      if (__speechIsCriticalCat(it.category, it.priority, it.opts || {}, it.key)) continue;
      const age = t - (Number(it.ts || t) || t);
      const itPr = Number(it.priority || 0) || 0;
      if (__speechIsNoisyCat(incomingCat) || incomingPr > itPr || age > __speechQueueCfg.sameCatSuppressMs) {
        speechQueue.splice(i, 1);
      }
    }
  }catch(e){}
}

function __flushSpeechQueueStale(maxAgeMs = 8000){
  try{
    const now = Date.now();
    const maxAge = Math.max(1500, Number(maxAgeMs) || 8000);
    const keep = [];
    for (const it of (speechQueue || [])){
      if (!it) continue;
      const age = now - (it.ts || now);
      if ((it.priority || 0) >= 80) { keep.push(it); continue; }
      if (age <= maxAge) keep.push(it);
    }
    speechQueue.length = 0;
    keep.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));
    for (const it of keep) speechQueue.push(it);
    if (speechQueue.length > 14) speechQueue.splice(14);
  }catch(e){}
}

function __pruneQueueDuringBlock(){
  try{
    // Conserva criticos + solo los uúúltimos no-criticos (para que NO vomite al reactivar)
    const critical = [];
    const nonCrit = [];
    for (const it of (speechQueue || [])){
      if (!it) continue;
      if ((it.priority || 0) >= 80) critical.push(it);
      else nonCrit.push(it);
    }
    const tail = nonCrit.slice(-4);
    const merged = critical.concat(tail);
    speechQueue.length = 0;
    merged.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));
    for (const it of merged) speechQueue.push(it);
    if (speechQueue.length > 12) speechQueue.splice(12);
  }catch(e){}
}

function forceTtsRecover(reason = ''){
  try{
    if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;

    // Si estamos tratando de destrabar el motor (unlock), NO mates el utterance
    try { if (typeof __ttsUnlockInFlight !== 'undefined' && __ttsUnlockInFlight) return; } catch(e) {}

    // "Soft recover": reanuda motor y drena cola sin spamear cancel()
    try { if (typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e){}

    // Solo cancela si ya estaba hablando y el motivo es "stuck/idle" (evita romper unlock/primer speak)
    try {
      const r = String(reason || '');
      if (window.speechSynthesis.speaking && (r.includes('stuck') || r.includes('idle') || r.includes('recover'))) {
        if (typeof window.speechSynthesis.cancel === 'function') if (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil) window.speechSynthesis.cancel();
      }
    } catch(e){}

    try { speechSpeaking = false; } catch(e){}
    try { __flushSpeechQueueStale(8000); } catch(e){}
    try { pumpSpeechQueue(); } catch(e){}
  }catch(e){}
}



function enqueueSpeech(text, opts = {}) {
      try {
        if (!voiceMasterEnabled) return;
        let clean = String(text || '').trim();
        clean = (opts && opts.noSanitize) ? clean : spotterSanitizeText(clean);

        if (!clean) return;
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;

        const now = Date.now();
                // Anti-loop: evita repetir el MISMO texto en ventanas cortas aunque cambie el key.
// - Se puede desactivar por mensaje con textTtlMs:0
// - Mensajes de sistema (sys_) y forzados no se filtran aquí
        try {
          const k0 = String(opts.key || '').trim() || clean;
          const kL = String(k0 || '').toLowerCase();
          if (kL.startsWith('sys_') || (opts && (opts.force === true || opts.user === true))) {
            // sin filtro
          } else {
            const tTTL = (typeof opts.textTtlMs === 'number') ? opts.textTtlMs : 4500;
            if (tTTL > 0) {
              const lastT = lastSpokenTextAt.get(clean) || 0;
              if ((now - lastT) < tTTL) return;
            }
          }
        } catch(e) {}
const key = String(opts.key || '').trim() || clean; // dedupe por texto si no hay key
        const cooldownMs = Number(opts.cooldownMs || 0) || 0;
        if (cooldownMs > 0) {
          const last = lastSpokenKeyAt.get(key) || 0;
          if (now - last < cooldownMs) return;
        }
        const priority = Number.isFinite(opts.priority) ? opts.priority : 0;
        const interrupt = !!opts.interrupt;
        const dedupe = (opts.dedupe !== false);
        const queueCategory = __speechCatFromOpts(opts, key, clean);

        // Silencio por inactividad: si no hay cambios reales, no hables (salvo esenciales)
        if (__inActivitySilence() && !__isEssentialSpeech(opts, key, priority)) {
          return;
        }

        // Si el TTS esta bloqueado y espera reactivacion por gesto,
        // no acumules backlog: solo dejamos pasar mensajes esenciales.
        if (pendingAutoVoiceUnlock) {
          if (!__isEssentialSpeech(opts, key, priority)) return;
        }


        // Anti-repeticion semantica (misma idea, texto distinto)
        // - default ON en categorias narrativas
        // - se puede desactivar por mensaje: { semanticDedupe:false }
        const __semCat = String(opts.semanticCategory || opts.category || __inferSemCategoryFromKey(key) || '').trim();
        if (opts.semanticDedupe !== false && __semCat && !__semSkipCategory(__semCat)) {
          const thr = (opts.semanticThreshold != null) ? Number(opts.semanticThreshold) : 0.78;
          const win = (opts.semanticWindowMs != null) ? Number(opts.semanticWindowMs) : 25000;
          if (__semIsRepeat(__semCat, clean, thr, win)) return;
          // solo recordamos si va a entrar a cola
          __semRemember(__semCat, clean, win);
        }

        if (dedupe) {
          if (speechQueue.some(it => it.text === clean)) return;
        }

        if (__speechShouldSkipIncoming(clean, key, queueCategory, priority, opts, now)) return;
        try { __speechSupersedePending(queueCategory, priority, opts, key, now); } catch(e) {}

        if (interrupt) {
          speechQueue.length = 0;
          speechSpeaking = false;
          try { if (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil) window.speechSynthesis.cancel(); } catch (e) {}
        }

        const baseRate = (Number.isFinite(ttsRate) ? ttsRate : 1.8);
        const mood = opts.mood;
        const pr = prosodyFromMood(mood);
        let rate = clampNum((opts.rate != null ? opts.rate : (baseRate * (pr.rateMul || 1.0))), 0.6, 2.2);
        const pitch = clampNum((opts.pitch != null ? opts.pitch : (pr.pitch != null ? pr.pitch : 1.0)), 0.5, 2.0);
        const volume = clampNum((opts.volume != null ? opts.volume : (pr.volume != null ? pr.volume : 1.0)), 0.0, 1.0);
        const postDelayMs = clampNum((opts.postDelayMs != null ? Number(opts.postDelayMs) : 0), 0, 2000);
        const __voiceURI = (opts && (opts.voiceURI || opts.voiceUri)) || '';
        // Auto-rate por proveedor cuando viene voiceURI (Auto Locutor: solo Microsoft)
        // Solo si el mensaje NO forzo rate explícito.
        if ((opts == null || opts.rate == null) && __voiceURI) {
          try {
            const __vv = (window.speechSynthesis && window.speechSynthesis.getVoices) ? (window.speechSynthesis.getVoices() || []) : [];
            const __v = __vv.find(x => (x.voiceURI || x.name) === __voiceURI);
            const __nm = String((__v && __v.name) || '').toLowerCase();
            if (__nm.includes('microsoft')) rate = 1.8;
          } catch(e) {}
        }

        const ttlMs = __speechExpiryFor(queueCategory, priority, opts);
        speechQueue.push({ text: clean, key, priority, ts: now, rate, pitch, volume, postDelayMs, voiceURI: __voiceURI, category: queueCategory, expireAt: ttlMs > 0 ? (now + ttlMs) : 0, opts });
        try { if (pendingAutoVoiceUnlock) __pruneQueueDuringBlock(); } catch(e) {}
        try { __speechPruneQueue(now); } catch(e) {}
        try { pushSpeechLog({ text: clean, key, priority }); } catch(e) {}
        try { pushTtsEvent('queue', clean, `q ${speechQueue.length}`); } catch(e) {}
        // prioridad desc, FIFO por tiempo
        speechQueue.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));

        pumpSpeechQueue();
      } catch (e) {
        console.error('enqueueSpeech', e);
      }
    }

    function pumpSpeechQueue() {
      try {
        if (!voiceMasterEnabled) return;
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;

        // Guard + recovery: Chrome a veces se queda en speaking/pending fantasma y deja de sacar cola.
        const __ss = window.speechSynthesis;
        if (speechSpeaking) return;

        if (__ss && (__ss.speaking || __ss.pending)){
          const now = Date.now();
          const lastEv = (__ttsLastEventAt || 0);
          const thr = __ss.speaking ? 9000 : 4500;
          // Si no hay actividad reciente, es speaking/pending fantasma: cancela y reintenta
          if (lastEv && (now - lastEv) > thr) {
            try { if (!__ttsCancelShieldUntil || now > __ttsCancelShieldUntil) __ss.cancel(); } catch(e){}
            try { pushTtsEvent('recover', 'Cancel por ghost speaking/pending', 'tts'); } catch(e) {}
            __ttsLastEventAt = now;
            speechSpeaking = false;
            setTimeout(()=>{ try{ pumpSpeechQueue(); }catch(e){} }, 80);
          }
          return;
        }
// Si el TTS esta bloqueado y esperando tap, no intentes hablar (evita loops y 20 taps).
        // Pero si estamos en primer plano y ya se desbloqueo antes, auto-recupera sin exigir tap.
        if (pendingAutoVoiceUnlock) {
          try {
            const vis = (document && document.visibilityState) ? document.visibilityState : 'visible';
            if (vis === 'visible' && __ttsUnlockedOnce) {
              pendingAutoVoiceUnlock = false;
              __ttsBlockedSince = 0;
              try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
            } else {
              return;
            }
          } catch(e) { return; }
        }

        try { __speechPruneQueue(Date.now()); } catch(e) {}
        let next = null;
        while (speechQueue && speechQueue.length) {
          const cand = speechQueue.shift();
          if (!cand) continue;
          if (__speechIsExpired(cand, Date.now())) {
            try { pushTtsEvent('drop', cand.text || '', `ttl ${cand.category || ''}`); } catch(e) {}
            continue;
          }
          next = cand;
          break;
        }
        if (!next) return;

        try { __ttsLastSpeakCallAt = Date.now(); __ttsLastEventAt = __ttsLastSpeakCallAt; __ttsCurrentText = (next.text || ''); } catch(e) {}
        const u = new SpeechSynthesisUtterance(normalizeTtsText(next.text));
        let __ttsDidStart = false;
        try {
          u.onstart = () => {
            __ttsDidStart = true;
        try { __ttsLastStartAt = Date.now(); __ttsLastEventAt = __ttsLastStartAt; } catch(e) {}
        try { __speechLastCategoryAt.set(String(next.category || 'general'), __ttsLastStartAt || Date.now()); __speechLastCategoryText.set(String(next.category || 'general'), String(next.text || '')); } catch(e) {}
        try { pushTtsEvent('start', next.text || '', next.key || 'tts'); } catch(e) {}
                        try { __ttsStartGuardFails = 0; } catch(e) {}
try { if (__ttsStartGuard) { clearTimeout(__ttsStartGuard); __ttsStartGuard = 0; } } catch(e) {}
          };
        } catch(e) {}
        u.lang = 'es-MX';
        u.rate = (next.rate != null ? next.rate : (isFinite(ttsRate) ? ttsRate : 1.8));
        u.pitch = (next.pitch != null ? next.pitch : 1.0);
        u.volume = (next.volume != null ? next.volume : 1.0);

        const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
        if (voices && voices.length) {
          
let v = null;

// DUO web/desktop: alterna Sabina/Raul por frase (fallback a SINGLE si no estan ambas)
if (__duoWebEnabled && __duoVoiceSabinaURI && __duoVoiceRaulURI) {
  try {
    let role = __duoGuessRole(next.text, next.key);
    if (__duoLastRole && role === __duoLastRole) role = (role === 'raul' ? 'sabina' : 'raul');
    const wanted = (role === 'raul') ? __duoVoiceRaulURI : __duoVoiceSabinaURI;
    const dv = voices.find(x => (x.voiceURI || x.name) === wanted);
    if (dv) { v = dv; __duoLastRole = role; }
  } catch (e) {}
}
          // Auto voice override (per-message), used by Auto Locutor rotation
          if (!v && next && next.voiceURI) {
            try { v = voices.find(x => (x.voiceURI || x.name) === next.voiceURI); } catch(e) {}
          }
          if (!v && chosenVoiceURI && !(next && next.voiceURI)) v = voices.find(x => (x.voiceURI || x.name) === chosenVoiceURI);
          if (!v) v = pickDefaultVoice(voices);
          const __pickedEs = pickDefaultVoice(voices);
          const __vLang = String((v && v.lang) || '').toLowerCase();
          if (v && __pickedEs && !__vLang.startsWith('es')) {
            try { pushTtsEvent('voice', 'fallback a voz española', next.text || '', next.key || 'tts'); } catch(e) {}
            v = __pickedEs;
          }
          if (v) {
            u.voice = v;
            if (v.lang) u.lang = v.lang;
          } else {
            u.lang = 'es-MX';
          }
        }

        speechSpeaking = true;

        const clearWd = () => {
          if (speechWatchdog) { clearTimeout(speechWatchdog); speechWatchdog = 0; }
        };
        clearWd();
        speechWatchdog = setTimeout(() => {
          try { __ttsLastEventAt = Date.now(); } catch(e) {}
          // watchdog anti-freeze (iOS/Chrome a veces se queda "hablando")
          try { if (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil) window.speechSynthesis.cancel(); } catch (e) {}
          speechSpeaking = false;
          pumpSpeechQueue();
        }, 15000);

        u.onend = () => {
        try { __ttsLastEndAt = Date.now(); __ttsLastEventAt = __ttsLastEndAt; } catch(e) {}
          try { pushTtsEvent('end', next.text || '', next.key || 'tts'); } catch(e) {}
          clearWd();
          speechSpeaking = false;
                    try { __ttsStartGuardFails = 0; } catch(e) {}
try { if (next && typeof next.key === 'string' && next.key.indexOf('auto_intro_title_') === 0) { __autoIntroDoneKeys.add(next.key); } } catch(e) {}
          lastSpokenKeyAt.set(next.key, Date.now());
          try { lastSpokenTextAt.set(next.text, Date.now()); } catch(e) {}
          try { __speechLastCategoryAt.set(String(next.category || 'general'), Date.now()); __speechLastCategoryText.set(String(next.category || 'general'), String(next.text || '')); } catch(e) {}
          try { __speechLastCategoryAt.set(String(next.category || 'general'), Date.now()); __speechLastCategoryText.set(String(next.category || 'general'), String(next.text || '')); } catch(e) {}
          const d = Number(next.postDelayMs || 0) || 0;
          if (d > 0) setTimeout(pumpSpeechQueue, d);
          else pumpSpeechQueue();
        };
        u.onerror = () => {
        try { __ttsLastEventAt = Date.now(); } catch(e) {}
          try { pushTtsEvent('error', next.text || '', next.key || 'tts'); } catch(e) {}
          clearWd();
          speechSpeaking = false;
                    try { __ttsStartGuardFails = 0; } catch(e) {}
lastSpokenKeyAt.set(next.key, Date.now());
          try { lastSpokenTextAt.set(next.text, Date.now()); } catch(e) {}
          const d = Number(next.postDelayMs || 0) || 0;
          if (d > 0) setTimeout(pumpSpeechQueue, d);
          else pumpSpeechQueue();
        };

        window.speechSynthesis.speak(u);

        // Start-guard: si no arranca en ~1.2s, suele ser bloqueo de TTS (iOS/Android tras auto-lock o background).
        // Importante: NO drenamos la cola. Dejamos el mensaje en espera y pedimos un tap para reactivar.
        try {
          if (__ttsStartGuard) { clearTimeout(__ttsStartGuard); __ttsStartGuard = 0; }
          __ttsStartGuard = setTimeout(() => {
            try {
              if (__ttsDidStart) return;
              // Intento de recuperacion suave
              try {
                if (!pendingAutoVoiceUnlock && window.speechSynthesis && typeof window.speechSynthesis.cancel === 'function') {
                  const ss = window.speechSynthesis;
                  if ((ss.speaking || ss.pending) && (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil)) ss.cancel();
                }
              } catch(e) {}
              speechSpeaking = false;

              // Reinsertar el mismo mensaje al frente (no se pierde)
              try {
                speechQueue.unshift(next);
                speechQueue.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));
              } catch(e) {}

              // Si el utterance no arranco, reintenta antes de pedir tap (primer plano debe auto-recuperar).
              try { __ttsStartGuardFails = (__ttsStartGuardFails || 0) + 1; } catch(e) {}
              try {
                const vis = (document && document.visibilityState) ? document.visibilityState : 'visible';
                const canAutoRecover = (vis === 'visible' && __ttsUnlockedOnce);
                if (canAutoRecover && __ttsStartGuardFails <= 6) {
                  // Recuperacion suave: reanuda + re-pump sin bloquear UI
                  try { if (typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
                  try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
                  try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
                  try { setTimeout(() => pumpSpeechQueue(), 120); } catch(e) {}
                } else {
                  // Solo iOS/WebKit puede requerir gesto nuevo tras idle. En desktop/Android seguimos auto-recuperando.
                  const __sgIOS = (typeof isIOSWebKit === 'function' ? isIOSWebKit() : false);
                  if (!__sgIOS) {
                    try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
                    try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
                    try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
                    try { setTimeout(() => pumpSpeechQueue(), 180); } catch(e) {}
                  } else {
                    try { pendingAutoVoiceUnlock = true; } catch(e) {}
                    try { __ttsBlockedSince = Date.now(); } catch(e) {}
                    try { __pruneQueueDuringBlock(); } catch(e) {}
                    try { const vis2 = (document && document.visibilityState) ? document.visibilityState : 'visible'; if (vis2 !== 'visible' && (typeof isIOSWebKit === 'function' ? isIOSWebKit() : false)) __ttsUnlockedOnce = false; } catch(e) {}
                    try { if ((typeof isIOSWebKit === 'function' ? isIOSWebKit() : false) && voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
                    try { pushTtsEvent('unlock', 'Toca la pantalla para reactivar audio', 'ios'); } catch(e) {}
                    try { if ((typeof isIOSWebKit === 'function' ? isIOSWebKit() : false)) showToast('Toca la pantalla para reactivar audio', 1800); } catch(e) {}
                  }
                }
              } catch(e) {
                try { pendingAutoVoiceUnlock = true; } catch(_e) {}
              }
              try { if (typeof scheduleOneTapUnlock === 'function') scheduleOneTapUnlock(); } catch(e) {}
            } catch(e) {}
          }, 3500);
        } catch(e) {}
      } catch (e) {
        console.error('pumpSpeechQueue', e);
        speechSpeaking = false;
      }
    }

    function speakText(text, opts) {
      enqueueSpeech(text, opts || {});
    }

    // LAPS prefix latch: evita repetir "X vueltas" dos veces en la misma vuelta
    let __lastLapsPrefixLap = null;
    let __lastLapsPrefixAt = 0;

function speakWithLaps(_laps, message, opts) {
      // Prefijo de LAPS (opcional): si "Vueltas" estápagado, no digas "10 vueltas..."
      const msg = String(message || '').trim();
      const inFollow = (typeof selectedPilotKey !== 'undefined' && !!selectedPilotKey);
      const allowPrefix = !!(voiceSettings && voiceSettings.saylaps) || (getSayLapsOverride() && inFollow && !(typeof basicModeEnabled !== 'undefined' && basicModeEnabled));

      if (!allowPrefix) {
        if (msg) speakText(msg, opts || {});
        return;
      }

      // Regla: no decir "Vuelta X" ni el nmero de vuelta.
      // Aquí s leemos LAPS primero (como siempre), y metemos coma para pausar antes del mensaje.
      let prefix = '';
      const laps = (_laps == null) ? null : Number(_laps);
      const __now = Date.now();
      const __sameLapRecently = (Number.isFinite(laps) && (__lastLapsPrefixLap === Math.floor(laps)) && ((__now - __lastLapsPrefixAt) < 1800));
      if (Number.isFinite(laps) && laps >= 0) {
        if (!__sameLapRecently) {
          if (laps === 1) prefix = 'Una vuelta';
          else prefix = String(Math.floor(laps)) + ' vueltas';
          __lastLapsPrefixLap = Math.floor(laps);
          __lastLapsPrefixAt = __now;
        }
      }

      const finalText = prefix ? (msg ? (prefix + ', ' + msg) : (prefix + '.')) : msg;
      if (finalText) speakText(finalText, opts || {});
    }

    function formatAnnouncer(msg) {
      // PRO: directo y claro
      return String(msg || '').trim();
    }

    // Botn maestro de voz (iOS requiere gesto del usuario)
    if (voiceToggleBtns && voiceToggleBtns.length) {
      
    
    function isIOSWebKit() {
      try {
        return __isIOSLike();
      } catch(e) {
        const ua = navigator.userAgent || '';
        const isTouchMac = (navigator.platform === 'MacIntel' && (navigator.maxTouchPoints || 0) > 1);
        return /iPad|iPhone|iPod/i.test(ua) || isTouchMac;
      }
    }

    function isMobileDevice(){
      try {
        const ua = navigator.userAgent || '';
        const isIpadOS = (navigator.platform === 'MacIntel' && (navigator.maxTouchPoints || 0) > 1);
        return /Android|iPhone|iPad|iPod|Mobile/i.test(ua) || isIpadOS;
      } catch(e) { return false; }
    }
    let __oneTapUnlockArmed = false;
let __oneTapUnlockLastAt = 0;

function scheduleOneTapUnlock() {
  // iOS/WebKit: a veces el TTS queda mudo tras sleep/background.
  // Sencillo: armamos 1 click para intentar unlock, SIN tragarnos el toque.
  try { if (__oneTapUnlockArmed) return; } catch(e) {}
  try { __oneTapUnlockArmed = true; } catch(e) {}

  const handler = () => {
    try { __oneTapUnlockArmed = false; __oneTapUnlockLastAt = Date.now(); } catch(e) {}
    if (!pendingAutoVoiceUnlock) return;

    try { __userGestureUnlocked = true; } catch(e) {}
    try { ensureAudioCtx(); } catch(e) {}
    try { hardUnlockAudioPipe(); } catch(e) {}

    try { unlockTTSOnce('one-tap'); } catch(e) {}

    // Si sigue bloqueado, dejamos pendingAutoVoiceUnlock y se rearmar donde corresponda.
    try { if (pendingAutoVoiceUnlock) scheduleOneTapUnlock(); } catch(e) {}
  };

  try { window.addEventListener('click', handler, { once:true, passive:true }); } catch(e) {}
}

// Unlock TTS en iOS/WebKit: requiere gesto del usuario.

// Nota: NO uses cancel() aquí - en iPhone mata el "primer speak" y obliga a dar 20 taps.
let __ttsUnlockedOnce = false;
    

      // Desktop: no requiere unlock por gesto. Lo marcamos como listo para auto-recovery.
      try {
        const __isIOS = isIOSWebKit();
        const __isMob = isMobileDevice();
        if (!__isIOS && !__isMob) {
          __ttsUnlockedOnce = true;
          pendingAutoVoiceUnlock = false;
        }
      } catch(e) {}
let __ttsCancelShieldUntil = 0; // evita cancelar mientras se esta desbloqueando (iPhone)

let __ttsUnlockInFlight = false;
let __ttsUnlockStartedAt = 0;

function updateVoiceStatusDot(){
  try{
    const dot = document.getElementById('voiceStatusDot');
    if (!dot) return;

    const synth = (window && window.speechSynthesis) ? window.speechSynthesis : null;
    const speaking = !!synth && (synth.speaking || synth.pending);

    const needsUnlock = (typeof pendingAutoVoiceUnlock !== 'undefined' && pendingAutoVoiceUnlock) ||
                        (typeof voiceToggleBtns !== 'undefined' && voiceToggleBtns && voiceToggleBtns.some(b => b.classList.contains('needs-unlock')));

    // "Armed" = la voz esta habilitada para hablar aunque en este instante no este speaking/pending.
    // Evita que el puntito se quede rojo mientras el sistema SI funciona (caso comun: idle entre mensajes).
    const armed = !!voiceMasterEnabled || (!!__ttsUnlockedOnce);

    const ok = armed && !needsUnlock;
    const warn = armed && needsUnlock;

    dot.classList.toggle('voice-on', ok);
    dot.classList.toggle('voice-off', !armed);
    dot.classList.toggle('voice-warn', warn);
    dot.classList.toggle('voice-speaking', speaking);

    dot.title = ok ? 'Voz OK' : (warn ? 'Voz ON - requiere toque' : 'Voz OFF');
    dot.setAttribute('aria-label', ok ? 'Voz OK' : (warn ? 'Voz ON (requiere toque)' : 'Voz OFF'));
  }catch(e){}
}


function unlockTTSOnce(reason = '') {
      try {
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return false;
        if (!voiceMasterEnabled) return false;

        // Si ya se desbloqueo en esta sesion, solo reanuda y sigue.
        if (__ttsUnlockedOnce) {
          try { if (typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
          try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
          try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
          try { updateVoiceStatusDot(); } catch(e) {}
          return true;
        }

        const now = Date.now();

        // Anti-spam: evita 20 taps que disparen 20 unlocks en paralelo.
        try {
          if (__ttsUnlockInFlight && (now - (__ttsUnlockStartedAt || 0)) < 1800) return false;
        } catch(e) {}

        try { __ttsUnlockInFlight = true; __ttsUnlockStartedAt = now; } catch(e) {}

        // Gesto de usuario + WebAudio (iOS)
        try { __userGestureUnlocked = true; } catch(e) {}
        try { ensureAudioCtx(); } catch(e) {}
        try { hardUnlockAudioPipe(); } catch(e) {}

        const synth = window.speechSynthesis;

        // Resume suave
        try { if (typeof synth.resume === 'function') synth.resume(); } catch(e) {}

        // NO canceles siempre: en iPhone a veces lo empeora.
        // Solo si estaba hablando o pendiente.
        try {
          if ((synth.speaking || synth.pending) && (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil)) {
            __ttsCancelShieldUntil = Date.now() + 1200;
            if (typeof synth.cancel === 'function') synth.cancel();
            if (typeof synth.resume === 'function') synth.resume();
          }
        } catch(e) {}

        let didStart = false;

        const u = new SpeechSynthesisUtterance('Audio listo');
        u.lang = 'es-MX';
        u.rate = clampNum((isFinite(ttsRate) ? ttsRate : 1.8), 0.8, 2.0);
        u.pitch = 1.0;
        // Casi inaudible: desbloquea sin gritarte "AUDIO LISTO" cada vez.
        u.volume = 0.05;

        try {
          u.onstart = () => {
            didStart = true;
            try { __ttsStartGuardFails = 0; } catch(e) {}
            try { __ttsUnlockedOnce = true; } catch(e) {}
            try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(e) {}

            // Ahora SI: ya arranco el motor, limpiamos estado de bloqueo.
            try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
            try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
            try { updateVoiceStatusDot(); } catch(e) {}

            try { showToast('Audio listo', 900); } catch(e) {}
            try { pumpSpeechQueue(); } catch(e) {}
          };
        } catch(e) {}

        const finishFail = () => {
          try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(e) {}
          // Seguimos marcando bloqueo: requiere otro tap
          try { pendingAutoVoiceUnlock = true; } catch(e) {}
          try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
          try { if (typeof scheduleOneTapUnlock === 'function') scheduleOneTapUnlock(); } catch(e) {}
          try { updateVoiceStatusDot(); } catch(e) {}
        };

        try { u.onend = () => { if (!didStart) finishFail(); }; } catch(e) {}
        try { u.onerror = () => { finishFail(); }; } catch(e) {}

        // Respetar voz elegida (si existe)
        try {
          const voices = synth.getVoices ? synth.getVoices() : [];
          if (voices && voices.length) {
            let v = null;
            if (chosenVoiceURI) v = voices.find(x => (x.voiceURI || x.name) === chosenVoiceURI);
            if (!v) v = pickDefaultVoice(voices);
            if (v) {
              u.voice = v;
              if (v.lang) u.lang = v.lang;
            }
          }
        } catch(e) {}

        try {
          synth.speak(u);
        } catch(e) {
          try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(ex) {}
          return false;
        }

        // Watchdog: si no arranca rapido, marcamos bloqueo y pedimos otro tap.
        try {
          setTimeout(() => {
            try {
              if (__ttsUnlockedOnce) return;
              if (didStart) return;
              finishFail();
            } catch(e) {}
          }, 900);
        } catch(e) {}

        return true;
      } catch (e) {
        try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(ex) {}
        return false;
      }
    }


function setVoiceMaster(on, opts = {}) {
      
      const turningOn = !!on;

      // Si apagamos VOZ: limpiamos todo.
      // Si prendemos VOZ: NO borres 'needs-unlock' hasta que el motor realmente arranque (onstart).
      if (!turningOn) {
        try { pushTtsEvent('voice', 'VOZ OFF', 'master'); } catch(e) {}
        try { __lastVoiceRecoverAttemptAt = 0; } catch(e) {}
        try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
        try { voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
      }

      voiceMasterEnabled = turningOn;
      try { prefSet('voiceMasterEnabled', voiceMasterEnabled ? '1' : '0'); } catch(e) {}
      try { voiceToggleBtns.forEach(b => b.classList.toggle('voice-on', voiceMasterEnabled)); } catch(e) {}
      try { voiceToggleBtns.forEach(b => b.textContent = voiceMasterEnabled ? ' VOZ ACTIVA' : ' ACTIVAR VOZ'); } catch(e) {}
      try { updateVoiceStatusDot(); } catch(e) {}
      // unlock audio (seleccionar piloto cuenta como gesto)
      try { ensureAudioCtx(); } catch(e) {}
      if (voiceMasterEnabled && !opts.silent) {
        try { pushTtsEvent('voice', 'VOZ ON', 'master'); } catch(e) {}
        try { showToast('VOZ ON', 900); } catch(e) {}
        try {
          const __isIOS = isIOSWebKit();
          const __isMob = isMobileDevice();
          if (__isIOS) {
            if (!__ttsUnlockedOnce) {
              pendingAutoVoiceUnlock = true;
              try { voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(_e) {}
              try { scheduleOneTapUnlock(); } catch(_e) {}
            }
          } else if (__isMob) {
            // Android: suele funcionar con gesto del boton, lo marcamos como listo.
            __ttsUnlockedOnce = true;
            pendingAutoVoiceUnlock = false;
            try { pushTtsEvent('unlock-clear', 'Android listo sin tap pendiente', 'tts'); } catch(e) {}
            try { voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(_e) {}
          } else {
            // Desktop: listo sin gestos extra.
            __ttsUnlockedOnce = true;
            pendingAutoVoiceUnlock = false;
            try { voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(_e) {}
          }
        } catch(e) {}
      }
      if (!voiceMasterEnabled) {
        try { if (!__ttsCancelShieldUntil || Date.now() > __ttsCancelShieldUntil) window.speechSynthesis.cancel(); } catch(e) {}
        // Importante: si apagas la voz, NO dejes cola acumulada (evita que luego 'escupa todo')
        try { speechQueue.length = 0; } catch(e) {}
        try { speechSpeaking = false; } catch(e) {}
        try { pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
      } else {
        // Encendido: NO canceles en este punto (iPhone se queda mudo). Solo intenta unlock + drena cola.
        try { setTimeout(()=>{ try{ pumpSpeechQueue(); }catch(e){} }, 80); } catch(e) {}
}
    
      // TTS Heartbeat (desktop/OBS): evita que el motor se duerma y caiga en espera de accion
      try { if (voiceMasterEnabled) { startTtsHeartbeat(); startTtsSafetyLoop(); } else { stopTtsHeartbeat(); stopTtsSafetyLoop(); } } catch(e) {}
}



    // ============================================================
    // 
    // ============================================================
    // TTS HEARTBEAT (Desktop/OBS)
    // - En Windows/Chrome/OBS, algunos contextos reportan visibilityState != 'visible'
    //   y/o el motor de SpeechSynthesis se "duerme" tras inactividad.
    // - Este heartbeat hace resume() y, si esta completamente idle, inyecta un keepalive SILENCIOSO (volume=0).
    // - NO aplica en iOS/Android (ahi si puede requerir gesto).
    // ============================================================
    let __ttsHeartbeatTimer = 0;
    let __ttsKeepAliveLastAt = 0;

    function __isObsBrowserContext() {
      try {
        const ua = (navigator && navigator.userAgent) ? String(navigator.userAgent) : '';
        return /OBS|obs-browser|CEF/i.test(ua);
      } catch(e) { return false; }
    }

    function startTtsHeartbeat() {
      try {
        if (__ttsHeartbeatTimer) return;
        const isIOS = (typeof isIOSWebKit === 'function') ? isIOSWebKit() : false;
        const isMob = (typeof isMobileDevice === 'function') ? isMobileDevice() : false;
        const gapMs = Number(__ttsHeartbeatIntervalMs || 0);
        if (isIOS || isMob || gapMs <= 0) return;

        __ttsHeartbeatTimer = window.setInterval(() => {
          try { __ttsHeartbeatTick(); } catch(e) {}
        }, Math.max(12000, gapMs));
      } catch(e) {}
    }

    function stopTtsHeartbeat() {
      try {
        if (__ttsHeartbeatTimer) {
          window.clearInterval(__ttsHeartbeatTimer);
          __ttsHeartbeatTimer = 0;
        }
      } catch(e) {}
    }

    // ============================================================
    // TTS SAFETY LOOP (anti-apagado)
    // ============================================================
    let __ttsSafetyTimer = 0;
    function startTtsSafetyLoop() {
      try {
        if (__ttsSafetyTimer) return;
        __ttsSafetyTimer = window.setInterval(() => {
          try {
            if (!voiceMasterEnabled) return;
            if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;

            const ss = window.speechSynthesis;
            const now = Date.now();
            try { if (typeof ss.resume === 'function') ss.resume(); } catch(e) {}

            try {
              if (speechSpeaking && ss && !ss.speaking && !ss.pending) {
                const lastEv = (__ttsLastEventAt || 0);
                if (!lastEv || (now - lastEv) > 2500) {
                  speechSpeaking = false;
                  try { pushTtsEvent('recover', 'Desync speaking=false', 'tts'); } catch(e) {}
                }
              }
            } catch(e) {}

            try {
              if (!speechSpeaking && Array.isArray(speechQueue) && speechQueue.length > 0) {
                pumpSpeechQueue();
              }
            } catch(e) {}

            try {
              const lastEv = (__ttsLastEventAt || 0);
              if (__ttsUnlockedOnce && (!lastEv || (now - lastEv) > Math.max(25000, Number(__ttsHeartbeatIntervalMs || 30000) + 5000))) {
                const u = new SpeechSynthesisUtterance(' ');
                u.volume = 0;
                u.rate = 1;
                u.onend = () => { try { __ttsLastEventAt = Date.now(); } catch(e) {} };
                u.onerror = () => { try { __ttsLastEventAt = Date.now(); } catch(e) {} };
                try { ss.speak(u); __ttsLastEventAt = now; } catch(e) {}
              }
            } catch(e) {}
          } catch(e) {}
        }, Math.max(1800, Number(__ttsSafetyIntervalMs || 3000)));
      } catch(e) {}
    }
    function stopTtsSafetyLoop() {
      try {
        if (__ttsSafetyTimer) {
          clearInterval(__ttsSafetyTimer);
          __ttsSafetyTimer = 0;
        }
      } catch(e) {}
    }

    function __ttsHeartbeatTick() {
      try {
        if (!voiceMasterEnabled) return;

        const isIOS = (typeof isIOSWebKit === 'function') ? isIOSWebKit() : false;
        const isMob = (typeof isMobileDevice === 'function') ? isMobileDevice() : false;
        if (isIOS || isMob) return;

        // Mantener estado "unlocked" en desktop aunque visibilityState no sea visible (OBS a veces reporta hidden)
        try { __ttsUnlockedOnce = true; pendingAutoVoiceUnlock = false; __ttsBlockedSince = 0; } catch(e) {}
        try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}

        // Reanudar motor
        try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}

        // Si esta completamente idle por mucho tiempo, inyecta keepalive SILENCIOSO.
        const now = Date.now();
        const speaking = (window.speechSynthesis && window.speechSynthesis.speaking) ? true : false;
        const pending = (window.speechSynthesis && window.speechSynthesis.pending) ? true : false;
        const qLen = (speechQueue && speechQueue.length) ? speechQueue.length : 0;

        const lastEvt = Number(__ttsLastEventAt || __ttsLastSpeakCallAt || 0) || 0;
        const idleMs = now - lastEvt;

        const fullyIdle = (!speaking && !pending && !speechSpeaking && qLen === 0);
        if (fullyIdle && idleMs > 45000 && (now - __ttsKeepAliveLastAt) > 60000) {
          __ttsKeepAliveLastAt = now;
          try {
            // '.' es suficiente para que el motor no se duerma. Volume 0 = silencioso.
            enqueueSpeech('.', { key:'sys_keepalive', volume:0, priority:-999, textTtlMs:0, force:true });
          } catch(e) {}
        }
      } catch(e) {}
    }


// Desktop Chrome: Auto-activar VOZ al detectar carrera nueva
    // - Si el usuario dejo VOZ apagada o quedo en "needs-unlock", lo corregimos en carrera nueva.
    // - NO cambia comportamiento en iOS/Android.
    // ============================================================
    function __isDesktopChromeContext() {
      try {
        if (typeof isMobileDevice === 'function' && isMobileDevice()) return false;
        if (typeof isIOSWebKit === 'function' && isIOSWebKit()) return false;
        return __isChromiumRuntime();
      } catch(e) { return false; }
    }

    function __autoEnsureVoiceReadyOnNewRace(raceSig = '') {
      try {
        if (!__isDesktopChromeContext()) return false;

        // Si VOZ esta apagada, prendela en silencio.
        if (!voiceMasterEnabled) {
          try { setVoiceMaster(true, { silent:true, auto:true, reason:'new_race' }); } catch(e) {}
        }

        // Desktop Chrome no deberia pedir tap. Si quedo atascado, limpiamos estado.
        try {
          if (pendingAutoVoiceUnlock) {
            pendingAutoVoiceUnlock = false;
            __ttsBlockedSince = 0;
            __ttsUnlockedOnce = true;
            try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
          }
        } catch(e) {}

        // Reanuda y recupera motor TTS
        try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
        try { pushTtsEvent('recover', 'Carrera nueva, reenganche TTS', 'auto'); } catch(e) {}
        try { if (voiceMasterEnabled) forceTtsRecover('new_race_auto'); } catch(e) {}
        try { if (voiceMasterEnabled) pumpSpeechQueue(); } catch(e) {}
        try { updateVoiceStatusDot(); } catch(e) {}

        return true;
      } catch(e) { return false; }
    }

      // VOZ: respuesta inmediata al primer toque (iOS/Android).
      // - Usamos pointerdown/touchstart para evitar retrasos y taps perdidos.
      // - Si el motor se bloqueo por idle/background, aquí solo reactivamos (sin apagar).
      let __lastVoiceTapAt = 0;
      let __lastVoiceRecoverAttemptAt = 0;

      function __voiceBtnNeedsUnlock(){
        try{
          if (pendingAutoVoiceUnlock) return true;
          return voiceToggleBtns.some(b => b.classList.contains('needs-unlock'));
        }catch(e){ return !!pendingAutoVoiceUnlock; }
      }

            function __onVoiceToggle(ev){
              try{ if (ev && ev.preventDefault) ev.preventDefault(); }catch(e){}
              try{ if (ev && ev.stopPropagation) ev.stopPropagation(); }catch(e){}

              const now = Date.now();
              if (now - __lastVoiceTapAt < 320) return;
              __lastVoiceTapAt = now;

              try{ __userGestureUnlocked = true; }catch(e){}
              try{ if (!__audioCtxReady) ensureAudioCtxOnce(); }catch(e){}
              try{ playBeep('tap'); }catch(e){}

              const next = !voiceMasterEnabled;

              // OFF: corta TODO y limpia cola
              if (!next){
                try { setVoiceMaster(false, { user:true }); } catch(e) {}
                try { showToast('VOZ OFF', 700); } catch(e) {}
                return;
              }

              // ON: desktop queda listo sin gestos extra
              try {
                const __isIOS = isIOSWebKit();
                const __isMob = isMobileDevice();
                if (!__isIOS && !__isMob){
                  __ttsUnlockedOnce = true;
                  pendingAutoVoiceUnlock = false;
                  try { voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(_e) {}
                }
              } catch(e) {}

              try { setVoiceMaster(true, { user:true }); } catch(e) {}

              // iOS: primero unlock, luego confirmacion (si no, el unlock te la cancela)
              try {
                const __isIOS = isIOSWebKit();
                if (__isIOS){
                  try { unlockTTSOnce('voice-btn'); } catch(e) {}
                  setTimeout(()=>{
                    try { speakText('Voz lista', { priority: 90, category: 'system', force: true, dedupe: false, semanticDedupe: false, textTtlMs: 0, cooldownMs: 0, key: 'sys_voice_on' }); } catch(e) {}
                    try { forceTtsRecover('voice-btn'); } catch(e) {}
                    try { pumpSpeechQueue(); } catch(e) {}
                  }, 140);
                  return;
                }
              } catch(e) {}

              // Desktop/Android: confirmacion inmediata
              try { speakText('Voz lista', { priority:'high', dedupe:false, semantic:false, cooldownMs:0, key:'sys_voice_on' }); } catch(e) {}
              try { forceTtsRecover('voice-btn'); } catch(e) {}
              try { setTimeout(()=>{ try{ pumpSpeechQueue(); }catch(e){} }, 80); } catch(e) {}
            }

            voiceToggleBtns.forEach(btn => {
        try { btn.style.touchAction = 'manipulation'; } catch(e) {}

        // iPhone: usar CLICK (mas confiable para destrabar TTS).
        // Otros: pointerdown/touchstart para respuesta rapida y evitar doble toggle.
        try {
          const isIOS = (() => {
            try {
              return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            } catch(e) { return false; }
          })();

          const evName = (isIOS ? 'click' : (window.PointerEvent ? 'pointerdown' : 'touchstart'));
          btn.addEventListener(evName, __onVoiceToggle, { passive:false });

          // Evita doble toggle por click fantasma SOLO cuando el handler principal no es click
          if (evName !== 'click') {
            try { btn.addEventListener('click', (ev)=>{ try{ev.preventDefault();}catch(e){} }, { passive:false }); } catch(e) {}
          }
        } catch(e) {
          try { btn.addEventListener('click', __onVoiceToggle, { passive:false }); } catch(e2) {}
        }
      });
}

      // Sync UI del boton VOZ con el estado real al cargar (evita clicks extra)
      try { setVoiceMaster(voiceMasterEnabled, { silent:true }); } catch(e) {}
      try { updateVoiceStatusDot(); } catch(e) {}
      try { setInterval(()=>{ try{ updateVoiceStatusDot(); }catch(e){} }, 1200); } catch(e) {}

      // Botón BÁSICO (solo FOLLOW). Reduce el show: solo laps, última y posición.
    if (typeof basicToggleBtnMini !== 'undefined' && basicToggleBtnMini) {
      try {
        basicToggleBtnMini.addEventListener('click', () => {
          try {
            const inFollow = (typeof selectedPilotKey !== 'undefined' && !!selectedPilotKey);
            if (!inFollow) {
              try { playBeep('down'); } catch(e) {}
              try { showToast('BÁSICO solo en FOLLOW', 900); } catch(e) {}
              basicModeEnabled = false;
              try { prefSet('basicModeEnabled', '0'); } catch(e) {}
              try { _updateBasicBtnUI(); } catch(e) {}
              return;
            }

            basicModeEnabled = !basicModeEnabled;
            try { prefSet('basicModeEnabled', basicModeEnabled ? '1' : '0'); } catch(e) {}
            try { applySmartProfile(currentSessionInfo || {}, 'basic-toggle'); } catch(e) {}
            try { playBeep('tap'); } catch(e) {}
            try { _updateBasicBtnUI(); } catch(e) {}

            // feedback corto (si voz activa)
            try {
              if (voiceMasterEnabled) speakText(basicModeEnabled ? 'Básico activado' : 'Básico desactivado', { priority: 90, category: 'system', force: true, dedupe: false, semanticDedupe: false, textTtlMs: 0, cooldownMs: 0, key: (basicModeEnabled ? 'sys_basic_on' : 'sys_basic_off') });
            } catch(e) {}
          } catch(e) {}
        });
      } catch(e) {}
    }

    // Checkbox: prefijo de VUELTAS (solo FOLLOW)
    function updateSayLapsUI(){
      try{
        const sayLapsChk = document.getElementById('sayLapsChk');
        const sayLapsWrap = document.getElementById('sayLapsWrap');
        if (!sayLapsChk || !sayLapsWrap) return;
        const inFollow = (typeof selectedPilotKey !== 'undefined' && !!selectedPilotKey);
        const ov = getSayLapsOverride();

        // En AUTO no aplica (sin piloto). En BÁSICO no aplica (override bloqueado).
        sayLapsChk.disabled = !inFollow;
        sayLapsWrap.classList.toggle('disabled', !inFollow);

        sayLapsChk.checked = !!ov && inFollow && !(typeof basicModeEnabled !== 'undefined' && basicModeEnabled);
      }catch(e){}
    }

    try { updateSayLapsUI(); } catch(e) {}

    (function wireSayLapsCheckbox(){
      try{
        const sayLapsChk = document.getElementById('sayLapsChk');
        if (!sayLapsChk) return;

        sayLapsChk.addEventListener('change', ()=>{
          try{
            const want = !!sayLapsChk.checked;

            // Si lo prendes y BÁSICO está ON, apágalo (para que se note el cambio)
            if (want && (typeof basicModeEnabled !== 'undefined' && basicModeEnabled)) {
              basicModeEnabled = false;
              try { prefSet('basicModeEnabled', '0'); } catch(e) {}
              try { applySmartProfile(currentSessionInfo || {}, 'saylaps-toggle'); } catch(e) {}
              try { _updateBasicBtnUI(); } catch(e) {}
            }

            setSayLapsOverride(want);
            try { playBeep('tap'); } catch(e) {}
            try { updateSayLapsUI(); } catch(e) {}
          }catch(e){}
        });
      }catch(e){}
    })();



    // Toggle UI de mensajes
    function applyVoiceSettingsToButtons() {
      spotterButtons.forEach(btn => {
        const flag = btn.getAttribute('data-flag');
        if (!flag) return;
        const on = (flag === 'laps') ? true : !!voiceSettings[flag];
        btn.classList.toggle('active', on);

        // LAPS siempre activo y bloqueado visual
        if (flag === 'laps') { btn.classList.add('locked'); } else { btn.classList.remove('locked'); }
      });

      try { if (typeof updateConfigStatusUI === 'function') updateConfigStatusUI(); } catch(e) {}
    }

    applyVoiceSettingsToButtons();

spotterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const flag = btn.getAttribute('data-flag');
        if (!flag) return;

        if (flag === 'laps') {
          // no se apaga
          voiceSettings.laps = true;
          applyVoiceSettingsToButtons();
          saveVoiceSettings();
          try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
          return;
        }

        voiceSettings[flag] = !voiceSettings[flag];
        applyVoiceSettingsToButtons();
        saveVoiceSettings();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
        playBeep(voiceSettings[flag] ? 'up' : 'down');
      });
    });

    

    // =========================
    // Master: prender/apagar todos los mensajes (excepto Laps)
    // =========================
    const toggleAllMsgsBtn = document.getElementById('toggleAllMsgsBtn');

    // =========================
    // Presets rápidos (RD PRO limpio / RD SHOW)
    // - Ajusta los mismos toggles del spotter (lo que el RD usa para decidir que narrar).
    // =========================
    const presetRdProBtn  = document.getElementById('presetRdProBtn');
    const presetRdShowBtn = document.getElementById('presetRdShowBtn');
    const SPOTTER_PRESET_KEY = 'spotterMasterPreset';

    function setPresetBtnActive(name){
      try{
        if (presetRdProBtn)  presetRdProBtn.classList.toggle('active', name === 'pro');
        if (presetRdShowBtn) presetRdShowBtn.classList.toggle('active', name === 'show');
        localStorage.setItem(SPOTTER_PRESET_KEY, name || '');
      }catch(e){}
    }

    function applyPresetVoiceSettings(preset){
      // PRO limpio: directo, sin ruido
      const base = {
        laps: true,
        pos: true,
        gaps: true,
        leadergap: true,
        podium: true,
        blueflag: true,
        front06: true,
        back06: true,
        attack: true,
        defense: true,

        // OFF por defecto
        ritmo: false,
        estlap: false,
        total: false,
        cons10: false,
        bestlap: false,
        box: false,
        pelea: false,
        netgain: false
      };

      // SHOW: mas emocion
      if (preset === 'show'){
        base.bestlap = true;
        base.pelea = true;
        base.ritmo = true;
      }

      try{
        Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => {
          if (k === 'laps'){ voiceSettings.laps = true; return; }
          if (k === 'saylaps'){ return; }
          voiceSettings[k] = !!base[k];
        });
        voiceSettings.laps = true;
        applyVoiceSettingsToButtons();
        saveVoiceSettings();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      }catch(e){}
    }

    if (presetRdProBtn){
      presetRdProBtn.addEventListener('click', () => {
        applyPresetVoiceSettings('pro');
        setPresetBtnActive('pro');
        playBeep('up');
      });
    }
    if (presetRdShowBtn){
      presetRdShowBtn.addEventListener('click', () => {
        applyPresetVoiceSettings('show');
        setPresetBtnActive('show');
        playBeep('up');
      });
    }

    // Solo restaura highlight (no pisa tus settings)
    try{
      const savedPreset = localStorage.getItem(SPOTTER_PRESET_KEY);
      if (savedPreset === 'pro' || savedPreset === 'show') setPresetBtnActive(savedPreset);
    }catch(e){}

    function isAllMsgsOn(){
      let allOn = true;
      try{
        spotterButtons.forEach(btn => {
          const flag = btn.getAttribute('data-flag');
          if (!flag || flag === 'laps' || flag === 'saylaps') return;
          if (!voiceSettings[flag]) allOn = false;
        });
      }catch(e){}
      return allOn;
    }

    function updateToggleAllMsgsBtn(){
      if (!toggleAllMsgsBtn) return;
      const allOn = isAllMsgsOn();
      toggleAllMsgsBtn.textContent = allOn ? 'TODO OFF' : 'TODO ON';
      toggleAllMsgsBtn.classList.toggle('active', allOn);
    }

    if (toggleAllMsgsBtn){
      updateToggleAllMsgsBtn();
      toggleAllMsgsBtn.addEventListener('click', () => {
        const allOn = isAllMsgsOn();
        try{
          spotterButtons.forEach(btn => {
            const flag = btn.getAttribute('data-flag');
            if (!flag || flag === 'laps' || flag === 'saylaps') return;
            voiceSettings[flag] = !allOn;
          });
          voiceSettings.laps = true;
          applyVoiceSettingsToButtons();
          saveVoiceSettings();
          updateToggleAllMsgsBtn();
          playBeep(!allOn ? 'up' : 'down');
        }catch(e){}
      });
    }

    // =========================
    // Categoras desplegables (Esenciales / Batalla / Resumen)
    // =========================

// =========================
    
    const DEFAULT_MESSAGE_TOGGLES = {
      laps: true,              // siempre ON (bloqueado)
      blueflag: true,
      ritmo_up: true,
      ritmo_down: true,
      estlap: true,
      leader: true,
      podium: true,
      bestlap: true,

      pos: true,
      gaps: true,
      front06: true,
      back06: true,
      attack: true,
      defense: true,
      fight: true,

      total: true,
      cons10: true,
      box: true,
      netgain: true
    };
    let toggles = {};
    try {
      const storedMsgToggles = prefGet('spotterMessageToggles', null);
      if (storedMsgToggles) {
        toggles = JSON.parse(storedMsgToggles) || {};
      } else {
        toggles = { ...DEFAULT_MESSAGE_TOGGLES };
        prefSet('spotterMessageToggles', JSON.stringify(toggles));
      }
    } catch(e) {
      toggles = { ...DEFAULT_MESSAGE_TOGGLES };
    }

// Voice message toggles (18 botones)
    // - laps: siempre activo (no se puede apagar)
    // - blueflag: por defecto activo al abrir (si no hay config guardada)
    // =========================

    // Estado global (debe existir SIEMPRE en mdulos ES)
    let raceData = null;
    let selectedPilotKey = '';
    let selectedPilotFirstDetectBeeped = false;// hotfix: init without undefined k

    
    var pendingAutoVoiceUnlock = false;
let isLoading = false;
    let loadingSince = 0;

    let isSelectingPilot = false;
    let pendingPilotOptionsUpdate = false;
    let lastPilotOptionsSignature = '';
    let lastRaceName = '';

    let previousClassification = null;

    let decimalPrecision = 2;
    try {
      const storedDec = prefGet('spotterDecimalPrecision', null);
      if (storedDec != null) {
        const parsed = parseInt(storedDec, 10);
        if (parsed >= 1 && parsed <= 3) {
          decimalPrecision = parsed;
        }
      }
    } catch (e) {}

    if (precisionSelect) precisionSelect.value = String(decimalPrecision);
// =========================
// Truncado (sin redondeo) para lecturas/clculos mostrados o hablados
// - Requisito: no redondear, usar floor.
// =========================
function floorTo(value, decimals = 0) {
  const p = Math.pow(10, decimals);
  if (!isFinite(value)) return 0;
  return Math.floor(value * p) / p;
}

function toFixedFloor(value, decimals = 0) {
  const v = floorTo(Number(value), decimals);
  return v.toFixed(decimals);
}

    if (precisionSelect) {
      precisionSelect.addEventListener('change', () => {
        const val = parseInt(precisionSelect.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 3) {
          decimalPrecision = val;
          try {
            prefSet('spotterDecimalPrecision', String(decimalPrecision));
          } catch (e) {}
        }
      });
    }

    function syncPrecisionBadges() {
      (precisionBadges||[]).forEach(badge => {
        const val = parseInt(badge.getAttribute('data-precision'), 10);
        badge.classList.toggle('active', val === decimalPrecision);
      });
    }

    (precisionBadges||[]).forEach(badge => {
      badge.addEventListener('click', () => {
        const val = parseInt(badge.getAttribute('data-precision'), 10);
        if (!isNaN(val) && val >= 1 && val <= 3) {
          decimalPrecision = val;
          if (precisionSelect) {
            precisionSelect.value = String(val);
            precisionSelect.dispatchEvent(new Event('change'));
          }
          syncPrecisionBadges();
        }
      });
    });

    syncPrecisionBadges();


    let wakeLock = null;
    let wakeLockWanted = false;
    var backgroundModeEnabled = true;

    function syncWakeLockUI() {
      try {
        if (wakeLockToggle) wakeLockToggle.classList.toggle('active', !!wakeLockWanted);
        if (!wakeLockStatus) return;
        if (!wakeLockWanted) {
          wakeLockStatus.textContent = '';
          return;
        }
        wakeLockStatus.textContent = wakeLock ? 'Pantalla activa' : (__supportsWakeLockApi() ? 'Wake lock en espera' : 'Tu navegador no soporta wake lock');
      } catch(e) {}
    }

    async function requestWakeLock(force = false) {
      try {
        if (!__supportsWakeLockApi()) {
          syncWakeLockUI();
          return false;
        }
        if (!force && !wakeLockWanted) return false;
        if (document.visibilityState !== 'visible') {
          syncWakeLockUI();
          return false;
        }
        if (wakeLock) return true;
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => {
          wakeLock = null;
          syncWakeLockUI();
          try {
            if (wakeLockWanted && document.visibilityState === 'visible') {
              setTimeout(() => { try { requestWakeLock(); } catch(e) {} }, 250);
            }
          } catch(e) {}
        });
        syncWakeLockUI();
        return true;
      } catch (e) {
        console.error('Error wake lock', e);
        if (wakeLockStatus) wakeLockStatus.textContent = 'Toca pantalla para mantener despierta';
        return false;
      }
    }

    async function releaseWakeLock() {
      try {
        if (wakeLock) {
          const wl = wakeLock;
          wakeLock = null;
          await wl.release();
        }
      } catch (e) {
        console.error('Error liberando wake lock', e);
      } finally {
        syncWakeLockUI();
      }
    }

    try {
      wakeLockWanted = prefGet('spotterWakeLock', '0') !== '0';
    } catch(e) { wakeLockWanted = false; }
    syncWakeLockUI();

    if (wakeLockToggle) {
      wakeLockToggle.addEventListener('click', async () => {
        wakeLockWanted = !wakeLockWanted;
        try { prefSet('spotterWakeLock', wakeLockWanted ? '1' : '0'); } catch(e) {}
        syncWakeLockUI();
        if (wakeLockWanted) await requestWakeLock(true);
        else await releaseWakeLock();
      });
    }

    if (wakeLockWanted) {
      try { requestWakeLock(); } catch(e) {}
    }

    (function(){
      let __wlGestureDone = false;
      async function __wlTry() {
        if (__wlGestureDone) return;
        __wlGestureDone = true;
        try {
          if (wakeLockWanted && !wakeLock) {
            await requestWakeLock(true);
          }
        } catch(e) {}
      }
      window.addEventListener('pointerdown', __wlTry, { once:true, passive:true });
      window.addEventListener('keydown', __wlTry, { once:true, passive:true });
    })();
// =========================
    // MODO BACKGROUND
    // =========================
    function setBackgroundStatus() {
      if (!backgroundStatus) return;
      backgroundStatus.textContent = backgroundModeEnabled ? 'Background ON' : 'Background OFF';
    }

    try {
      const savedBg = prefGet('spotterBackgroundMode', '1');
      backgroundModeEnabled = savedBg !== '0';
      if (backgroundToggle) {
        backgroundToggle.classList.toggle('active', backgroundModeEnabled);
      }
      setBackgroundStatus();
    } catch(e) {}

    if (backgroundToggle) {
      backgroundToggle.addEventListener('click', () => {
        backgroundModeEnabled = !backgroundModeEnabled;
        backgroundToggle.classList.toggle('active', backgroundModeEnabled);
        try { prefSet('spotterBackgroundMode', backgroundModeEnabled ? '1' : '0'); } catch(e) {}
        if (!backgroundModeEnabled) {
          try { stopSilentAudioKeepAlive(); } catch(e) {}
        }
        setBackgroundStatus();
      });
    }

    // Reenganche al volver al tab (Chrome puede soltar wake lock)
    let __visHiddenAt = 0;
    document.addEventListener('visibilitychange', async () => {
      try {
        const isIOS = (typeof isIOSWebKit === 'function') ? isIOSWebKit() : __isIOSLike();

        if (document.visibilityState === 'hidden') {
          __visHiddenAt = Date.now();

          // Desktop/Android: arranca keep-alive silencioso + reanuda motor TTS
          if (voiceMasterEnabled && !isIOS && backgroundModeEnabled) {
            try { startSilentAudioKeepAlive(); } catch(e) {}
            try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
          }
          // iOS: al ir a background, el motor de voz suele "dormirse" y requiere gesto al volver.
          if (voiceMasterEnabled && isIOS) {
            try { __ttsUnlockedOnce = false; } catch(e) {}
            try { __ttsUnlockInFlight = false; __ttsUnlockStartedAt = 0; } catch(e) {}
            try { pendingAutoVoiceUnlock = true; } catch(e) {}
            try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
          }
          return;
        }

        if (document.visibilityState === 'visible') {
          const awayMs = __visHiddenAt ? (Date.now() - __visHiddenAt) : 0;

          try { loadRaceFromFirebase(); } catch(e) {}

          try {
            if (wakeLockWanted) {
              await requestWakeLock(true);
            }
          } catch(e) {}

          if (voiceMasterEnabled) {
            try { if (window.speechSynthesis && typeof window.speechSynthesis.resume === 'function') window.speechSynthesis.resume(); } catch(e) {}
            try { confirmVoiceButtons && confirmVoiceButtons(); } catch(e) {}

            if (isIOS) {
              try { pendingAutoVoiceUnlock = true; } catch(e) {}
              try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
              try {
                const msg = (awayMs > 3000)
                  ? 'Volviste. Un tap y el audio revive.'
                  : 'Si el iPhone se quedo mudo, toca una vez.';
                showToast(msg, 2200);
              } catch(e) {}
              try { if (typeof scheduleOneTapUnlock === 'function') scheduleOneTapUnlock(); } catch(e) {}
            } else {
              try { pendingAutoVoiceUnlock = false; } catch(e) {}
              try { if (voiceToggleBtns && voiceToggleBtns.length) voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
              try { setTimeout(()=>{ try{ pumpSpeechQueue(); }catch(e){} }, 140); } catch(e) {}
            }
          }
        }
      } catch(e) {}

    });

    // iOS: al volver desde sleep/bfcache, forzar reenganche de audio con un solo tap
    try {
      window.addEventListener('pageshow', () => {
        try {
          const isIOS = (typeof isIOSWebKit === 'function') ? isIOSWebKit() : false;
          if (voiceMasterEnabled && isIOS) {
            __ttsUnlockedOnce = false;
            pendingAutoVoiceUnlock = true;
            if (typeof scheduleOneTapUnlock === 'function') scheduleOneTapUnlock();
          }
        } catch(e) {}
        try { if (wakeLockWanted) requestWakeLock(true).catch(()=>{}); } catch(e) {}
        try { startBgKeepAlive(); } catch(e) {}
        try { loadRaceFromFirebase(); } catch(e) {}
        try { if (typeof startRaceRealtime === 'function') startRaceRealtime(); } catch(e) {}
      }, { passive:true });

      window.addEventListener('pagehide', () => {
        try {
          const isIOS = (typeof isIOSWebKit === 'function') ? isIOSWebKit() : false;
          if (voiceMasterEnabled && isIOS) {
            __ttsUnlockedOnce = false;
            pendingAutoVoiceUnlock = true;
          }
        } catch(e) {}
      }, { passive:true });

      // (Opcional) Eventos tipo app-wrapper (Cordova/Capacitor). En web normal no dispara, pero no estorba.
      window.addEventListener('resume', () => {
        try { startBgKeepAlive(); } catch(e) {}
        try { loadRaceFromFirebase(); } catch(e) {}
        try { if (typeof startRaceRealtime === 'function') startRaceRealtime(); } catch(e) {}
      }, { passive:true });

    } catch(e) {}

// LIVE status (debounced) - evita parpadeo por lecturas intermitentes
let __liveApplied = null;
let __liveWanted = null;
let __liveTimer = 0;

function __applyLiveStatus(online){
  const on = !!online;
  try {
    if (liveIndicator) liveIndicator.classList.toggle('live-off', !on);
  } catch(e) {}
  try {
    if (appHeader) {
      // Importante: clases no deben cambiar layout (altura estable por CSS)
      appHeader.classList.toggle('live-on', on);
      appHeader.classList.toggle('live-off', !on);
    }
  } catch(e) {}
}

function setLiveStatus(isOnline) {
  const online = !!isOnline;
  __liveWanted = online;

  // Online: aplica inmediato. Offline: espera un poco (evita "brinco" por fallos momentaneos).
  const delay = online ? 0 : 1200;

  try { if (__liveTimer) clearTimeout(__liveTimer); } catch(e) {}
  __liveTimer = setTimeout(() => {
    __liveTimer = 0;
    const target = !!__liveWanted;
    if (__liveApplied === target) return;
    __liveApplied = target;
    __applyLiveStatus(target);
  }, delay);

  if (delay === 0) {
    try {
      // Ejecuta ya en el mismo frame para que el header no cambie despues "de golpe"
      if (__liveTimer) { clearTimeout(__liveTimer); __liveTimer = 0; }
      const target = !!__liveWanted;
      if (__liveApplied !== target){
        __liveApplied = target;
        __applyLiveStatus(target);
      }
    } catch(e) {}
  }
}

function __diagSet(cardId, level, stateText, bodyText, titleText=''){
  try{
    const el = document.getElementById(cardId);
    if (!el) return;
    el.classList.remove('good','warn','bad','off');
    el.classList.add(level || 'off');
    const st = el.querySelector('.diag-state');
    const tx = el.querySelector('.diag-text');
    if (st) st.textContent = String(stateText || '').trim() || 'OFF';
    if (tx) tx.textContent = String(bodyText || '').trim() || '-';
    if (titleText != null) el.title = String(titleText || '');
  }catch(e){}
}

function updateRuntimeDiagUI(){
  try{
    const now = Date.now();
    const isIOS = (typeof isIOSWebKit === 'function') ? isIOSWebKit() : (__isIOSLike ? __isIOSLike() : false);
    const ss = window.speechSynthesis || null;
    const voices = (ss && typeof ss.getVoices === 'function') ? (ss.getVoices() || []) : [];
    const hasSpeech = !!(ss && window.SpeechSynthesisUtterance);
    const voicesEs = voices.filter(v => String(v.lang || '').toLowerCase().startsWith('es'));
    const tickAge = __lastGoodTickMs ? (now - __lastGoodTickMs) : 0;
    const tickTxt = __lastGoodTickMs ? `${(tickAge/1000).toFixed(tickAge < 10000 ? 1 : 0)} s` : 'sin tick';
    const fallbackActive = !!__fallbackPollTimer;
    const pollDelay = (__fallbackPollSchedule && __fallbackPollSchedule.length)
      ? (__fallbackPollSchedule[Math.max(0, Math.min(__fallbackPollStep || 0, __fallbackPollSchedule.length - 1))] || 0)
      : 0;

    const voiceLevel = !hasSpeech ? 'bad' : (!voiceMasterEnabled ? 'off' : ((voicesEs.length || voices.length) ? 'good' : 'warn'));
    const voiceState = !hasSpeech ? 'NO' : (!voiceMasterEnabled ? 'OFF' : ((speechSpeaking || (ss && ss.speaking)) ? 'HABLA' : 'OK'));
    const voiceBody = !hasSpeech
      ? 'Speech API no disponible'
      : (!voiceMasterEnabled
        ? `Motor listo, voces ${voicesEs.length || voices.length}`
        : `Voces ES ${voicesEs.length} de ${voices.length}, cola ${speechQueue ? speechQueue.length : 0}`);
    __diagSet('diagVoice', voiceLevel, voiceState, voiceBody, voiceBody);

    let unlockLevel = 'off', unlockState = 'N/A', unlockBody = 'Solo aplica cuando iOS pide tap';
    if (isIOS) {
      unlockLevel = pendingAutoVoiceUnlock ? 'warn' : (voiceMasterEnabled ? 'good' : 'off');
      unlockState = pendingAutoVoiceUnlock ? 'TAP' : (voiceMasterEnabled ? 'OK' : 'OFF');
      unlockBody = pendingAutoVoiceUnlock
        ? 'iPhone/iPad pide un toque para revivir voz'
        : (voiceMasterEnabled ? 'Pipe listo, sin tap pendiente' : 'Voz apagada');
    }
    __diagSet('diagUnlock', unlockLevel, unlockState, unlockBody, unlockBody);

    const fbLevel = __firebaseOk ? 'good' : 'bad';
    const fbState = __firebaseOk ? 'OK' : 'FAIL';
    const fbBody = __firebaseOk ? 'SDK y runtime arriba' : 'Firebase caido o bloqueado';
    __diagSet('diagFirebase', fbLevel, fbState, fbBody, fbBody);

    const rtLevel = __raceUnsub ? 'good' : (__firebaseOk ? 'warn' : 'bad');
    const rtState = __raceUnsub ? 'ON' : (__firebaseOk ? 'FB' : 'OFF');
    const rtBody = __raceUnsub ? 'onSnapshot suscrito' : (__firebaseOk ? 'Sin realtime, depende fallback' : 'Sin runtime');
    __diagSet('diagRealtime', rtLevel, rtState, rtBody, rtBody);

    const pollLevel = fallbackActive ? 'warn' : 'good';
    const pollState = fallbackActive ? 'RUN' : 'STBY';
    const pollBody = fallbackActive ? `Backoff ${Math.round((pollDelay || 0)/1000)} s, paso ${(__fallbackPollStep || 0)+1}` : 'Fallback en espera';
    __diagSet('diagPolling', pollLevel, pollState, pollBody, pollBody);

    const wakeSupported = __supportsWakeLockApi ? __supportsWakeLockApi() : false;
    let wakeLevel = 'off', wakeState = 'OFF', wakeBody = 'Wake Lock desactivado';
    if (!wakeSupported) {
      wakeLevel = 'bad'; wakeState = 'N/A'; wakeBody = 'Navegador sin Wake Lock API';
    } else if (wakeLockWanted && wakeLock) {
      wakeLevel = 'good'; wakeState = 'ON'; wakeBody = 'Pantalla anclada';
    } else if (wakeLockWanted && !wakeLock) {
      wakeLevel = 'warn'; wakeState = 'WAIT'; wakeBody = 'Solicitado, esperando gesto o reenganche';
    }
    __diagSet('diagWake', wakeLevel, wakeState, wakeBody, wakeBody);

    let feedLevel = 'bad', feedState = 'OFF', feedBody = `Ultimo tick: ${tickTxt}`;
    if (__lastGoodTickMs) {
      if (tickAge <= 4000) { feedLevel = 'good'; feedState = 'OK'; }
      else if (tickAge <= 10000) { feedLevel = 'warn'; feedState = 'LENTO'; }
      else { feedLevel = 'bad'; feedState = 'STALE'; }
      feedBody = `Ultimo tick ${tickTxt}, lecturas ${__feedTickCount || 0}`;
    }
    __diagSet('diagFeed', feedLevel, feedState, feedBody, feedBody);

    const vis = (document && document.visibilityState) ? document.visibilityState : 'visible';
    const visLevel = (vis === 'visible') ? 'good' : (backgroundModeEnabled ? 'warn' : 'off');
    const visState = (vis === 'visible') ? 'LIVE' : (backgroundModeEnabled ? 'BG ON' : 'HIDDEN');
    const visBody = (vis === 'visible')
      ? 'Pestana al frente'
      : (backgroundModeEnabled ? 'Oculta pero con modo background activo' : 'Oculta y sin background');
    __diagSet('diagVisibility', visLevel, visState, visBody, visBody);

    const cfg = __getRuntimeProfileConfig(runtimeProfileKey);
    const note = __firebaseOk
      ? (fallbackActive ? `Fallback ${Math.round((pollDelay || 0)/1000)} s${__lastFallbackReason ? ' - ' + __lastFallbackReason : ''}` : `Realtime vivo, feed ${tickTxt}`)
      : 'Sin runtime Firebase';
    if (diagPanelNote) diagPanelNote.textContent = note + ` | Perfil ${cfg.label}`;
    try { renderTtsEventLog(); } catch(e) {};

    const err = String(__lastReadErr || '').trim();
    if (diagErrorBox) {
      if (err) {
        const shortErr = err.length > 180 ? (err.slice(0, 177) + '...') : err;
        diagErrorBox.textContent = `Ultimo error: ${shortErr}`;
        diagErrorBox.classList.add('show');
      } else {
        diagErrorBox.textContent = '';
        diagErrorBox.classList.remove('show');
      }
    }
  }catch(e){}
}
    function normalizePilotKey(key) {
      const s = (key || '').toLowerCase().trim();
      if (!s) return '';
      // Backward compatibility: older keys were "num||name"
      if (s.includes('||')) {
        const parts = s.split('||').map(x=>x.trim()).filter(Boolean);
        return (parts[parts.length-1] || '').toLowerCase().trim();
      }
      return s;
    }

    function getPilotKey(row) {
      if (!row) return '';
      const nameRaw = row.racerName != null ? String(row.racerName).trim() : '';
      return (nameRaw || '').toLowerCase().trim();
    }


    function safeRacerName(name) {
      if (!name) return '';
      let s = String(name).trim();
      // Quitar prefijos numricos tipo "26 Victor" o "#26 Victor"
      s = s.replace(/^#?\d+\s+/, '');
      // Normalizar espacios
      s = s.replace(/\s{2,}/g, ' ');
      return s;
    }

    function parseTimeToMs(input) {
      if (input == null) return 0;

      // Heurstica clave:
      // - Si viene como nmero y es "chico" (ej. 9.881, 14.564), normalmente est en segundos.
      // - Si viene grande (ej. 9881, 14564), normalmente ya est en milisegundos.
      if (typeof input === 'number') {
        const n = input;
        if (!isFinite(n) || n <= 0) return 0;
        if (n < 300) return n * 1000; // tratar como segundos
        return n;                     // tratar como ms
      }

      // Strings: a veces llegan con prefijos tipo "27L 04:05.107" o texto extra.
      let str = String(input).trim();
      if (!str) return 0;

      // 1) Si hay un patrn de tiempo, tomamos el LTIMO (lo ms probable es el tiempo real).
      //    Soporta: "m:ss.mmm", "mm:ss", "h:mm:ss.mmm"
      try {
        const matches = str.match(/(?:\d{1,2}:)?\d{1,2}:\d{2}(?:\.\d{1,3})?/g);
        if (matches && matches.length) {
          str = matches[matches.length - 1];
        }
      } catch(e) {}

      // 2) Si es entero puro, asumimos ms (ej. "14564")
      if (/^\d+$/.test(str)) return parseInt(str, 10);

      // 3) Parse con ":" (m:ss o h:mm:ss)
      const parts = str.split(':');
      if (parts.length === 2) {
        const m = parseInt(parts[0], 10);
        const s = parseFloat(parts[1]);
        if (!isNaN(m) && !isNaN(s)) return (m * 60 * 1000) + (s * 1000);
      }
      if (parts.length === 3) {
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        const s = parseFloat(parts[2]);
        if (!isNaN(h) && !isNaN(m) && !isNaN(s)) return (h * 3600 * 1000) + (m * 60 * 1000) + (s * 1000);
      }

      // 4) Nmero en string sin ":" -> puede venir en segundos ("14.564") o en ms ("3000")
      // Regla:
      // - Si es entero y >= 300, lo tratamos como milisegundos.
      // - Si es decimal o < 300, lo tratamos como segundos.
      if (/^\d+$/.test(str)) {
        const n = parseInt(str, 10);
        if (!isNaN(n)) return (n < 300) ? (n * 1000) : n;
      }
      const s = parseFloat(str);
      if (!isNaN(s)) return (s < 300) ? (s * 1000) : s;

      return 0;
    }

    function msToMinSec(ms) {
      if (!ms || isNaN(ms) || ms <= 0) return '-:--.---';
      const totalSeconds = ms / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds - minutes * 60;
      const secInt = Math.floor(seconds);
      let msRemainder = Math.floor((seconds - secInt) * 1000);
      if (!isFinite(msRemainder) || msRemainder < 0) msRemainder = 0;
      if (msRemainder > 999) msRemainder = 999;
      const secStr = String(secInt).padStart(2, '0');
      const msStr = String(msRemainder).padStart(3, '0');
      return `${minutes}:${secStr}.${msStr}`;
    }

    function formatLaps3(v){
      const n = Math.floor(Number(v));
      if (!isFinite(n) || n < 0) return '-';
      if (n > 999) return '999';
      const s = String(n);
      // Mximo 3 caracteres
      return (s.length <= 3) ? s : s.slice(-3);
    }

    // Rangos plausibles de una vuelta Turbo Racing 1/76 (evita basura tipo 0:00.010)
    const LAP_MS_MIN = 2500;   // 2.5 s (hay feeds que reportan medias vueltas)
    const LAP_MS_MAX = 90000;  // 90.0 s  // 60.0 s

    
    // Normaliza valores que a veces llegan en segundos (ej 9.339) en lugar de ms (9339)
    function normalizeIncomingLapValue(v) {
      // Acepta number o string (ej. 9.339, "9.339", "0:09.339", "9339")
      const ms = parseTimeToMs(v);
      if (!ms || !isFinite(ms) || ms <= 0) return 0;
      return Math.round(ms);
    }

function isLapPlausible(ms) {
      // Validacin para guardar historial (NO depende del rango dinmico del chart).
      // As, si alguien hace una vuelta lenta (ej. >30s por choque/reincorporacin), se registra.
      return typeof ms === 'number' && isFinite(ms) && ms >= LAP_MS_MIN && ms <= LAP_MS_MAX;
    }

    function normalizeLapMs(ms) {
      return isLapPlausible(ms) ? ms : 0;
    }

    
    // Rango dinmico (se ajusta con el historial para no "matar" la grfica con umbrales fijos)
    let lapRange = { min: LAP_MS_MIN, max: LAP_MS_MAX };

    function updateLapRangeFromHistory(timesAll) {
      if (!timesAll || timesAll.length < 6) return;
      const arr = timesAll.slice(-40).filter(v => typeof v === 'number' && isFinite(v) && v > 0).sort((a,b)=>a-b);
      if (arr.length < 6) return;
      const p90 = arr[Math.floor(arr.length * 0.90)];
      if (!p90) return;

      // Escala dinmica por sesion:
      // - MANGA: zoom un poco ms apretado (3:00, ms estable)
      // - FINAL: margen ms amplio (fatiga/errores)
      const info = currentSessionInfo || {};
      const type = String(info.type || '').toUpperCase();
      const isManga = (type === 'MANGA');
      const isFinal = (type === 'FINAL');

      // IMPORTANTE:
      // No subimos el mnimo con el histrico, porque al arranque o en re-incorporaciones
      // pueden llegar "vueltas parciales" (ej. 3.0s) y se deben registrar.
      const min = LAP_MS_MIN;

      const preset = getLapChartPreset();

      let pad = preset.pad;
      // cap por seguridad
      const maxCap = preset.maxCap;
      const max = Math.min(maxCap, p90 + pad);

      lapRange = { min, max };
    }

// Consistencia en porcentaje: % de vueltas dentro de +/- tolMs del promedio
// Ej: tolMs=200 -> +/-0.200 s
function consistencyPercent(arr, tolMs = 200) {
  // Consistencia % = 100 - (variabilidad %)
  // Variabilidad % = (sigma / media) * 100  (coeficiente de variacin)
  // Nota: arr viene en ms.
  if (!arr || arr.length < 2) return 0;
  const clean = arr.filter(v => typeof v === 'number' && isFinite(v) && v > 0);
  if (clean.length < 2) return 0;
  const mean = clean.reduce((a,b)=>a+b,0) / clean.length;
  if (!isFinite(mean) || mean <= 0) return 0;
  // sigma (ms)
  let s2 = 0;
  for (const v of clean) { const d = v - mean; s2 += d*d; }
  const sigma = Math.sqrt(s2 / clean.length);
  const variabilityPct = (sigma / mean) * 100;
  let cons = 100 - variabilityPct;
  if (!isFinite(cons)) cons = 0;
  if (cons < 0) cons = 0;
  if (cons > 100) cons = 100;
  return Math.floor(cons);
}

// Consistencia desde Firebase (ya viene calculada)
function getConsistencyFromFirebase(p) {
  if (!p) return 0;
  const candidates = [
    p.consistency,
    p.consistencyPercent,
    p.consPct,
    p.cons,
    p.consistencia,
    p.consistenciaPct,
    p.consistency_pct,
    p.consistency10,
    p.cons10,
    p.CONSISTENCY
  ];
  for (const v of candidates) {
    if (v == null) continue;
    if (typeof v === 'string') {
      const m = v.match(/(\d+(?:\.\d+)?)/);
      if (m) {
        const n = Number(m[1]);
        if (isFinite(n) && n > 0) return Math.max(0, Math.min(100, Math.floor(n)));
      }
      continue;
    }
    const n = Number(v);
    if (isFinite(n) && n > 0) return Math.max(0, Math.min(100, Math.floor(n)));
  }
  return 0;
}

function statsFromTimes(arr) {
      if (!arr || !arr.length) return { n: 0, best: 0, mean: 0, sigma: 0, last: 0 };
      const n = arr.length;
      const last = arr[n - 1] || 0;
      let best = Infinity;
      let sum = 0;
      for (const v of arr) {
        if (!isLapPlausible(v)) continue;
        if (v < best) best = v;
        sum += v;
      }

      const mean = sum / n;
      let varSum = 0;
      for (const v of arr) {
        varSum += (v - mean) * (v - mean);
      }
      const sigma = Math.sqrt(varSum / n);
      return { n, best: isFinite(best) ? best : 0, mean, sigma, last };
    }

// Devuelve el mejor "stint" consecutivo de tamao window (por promedio), y la peor vuelta.
// times debe venir en ms, ya filtrado a vueltas plausibles.
function findFastestStint(times, window=5) {
  try {
    if (!Array.isArray(times) || times.length < window) return null;
    let bestSum = Infinity;
    let bestStart = 0;
    let sum = 0;
    for (let i = 0; i < times.length; i++) {
      sum += times[i];
      if (i >= window) sum -= times[i - window];
      if (i >= window - 1) {
        if (sum < bestSum) {
          bestSum = sum;
          bestStart = i - window + 1;
        }
      }
    }
    return { start: bestStart, end: bestStart + window - 1, sum: bestSum, avg: bestSum / window };
  } catch (e) { return null; }
}

function findWorstLap(times) {
  try {
    if (!Array.isArray(times) || !times.length) return null;
    let worst = -Infinity;
    let idx = -1;
    for (let i = 0; i < times.length; i++) {
      const v = times[i];
      if (!isLapPlausible(v)) continue;
      if (v > worst) { worst = v; idx = i; }
    }
    if (idx < 0) return null;
    return { idx, ms: worst };
  } catch (e) { return null; }
}
    function ensureCanvasHiDpi(canvas) {
      if (!canvas) return;
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }

    
    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

function drawLapChartForKey(pilotKey) {
      if (!lapChartEl || !lapChartMetaEl) return;
      if (!pilotKey) {
        lapChartMetaEl.textContent = 'Sin datos';
        const ctx = lapChartEl.getContext('2d');
        if (ctx) ctx.clearRect(0, 0, lapChartEl.width, lapChartEl.height);
        return;
      }
      const hist = lapHistory.get(pilotKey) || { lastLapcount: 0, times: [] };
      const timesAllRaw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
      updateLapRangeFromHistory(timesAllRaw);
      const timesAll = timesAllRaw.filter(isLapPlausible);
      if (!timesAll.length) {
        lapChartMetaEl.textContent = 'Sin datos';
        const ctx = lapChartEl.getContext('2d');
        if (ctx) ctx.clearRect(0, 0, lapChartEl.width, lapChartEl.height);
        return;
      }
      applyLapChartPreset();
      const preset = getLapChartPreset();
      const N = preset.N;
      // Eje X por TIEMPO: acumulado desde el inicio
      let __accT = 0;
      const tAll = timesAll.map(ms => (__accT += ms));
      const times = timesAll.slice(-N);
      const tMs = tAll.slice(-N);
      const marksAll = (hist.marks || []).filter(v => (typeof v === 'string' || v == null));
      const marks = marksAll.slice(-N);
      const st = statsFromTimes(times);
      const best = st.best || 0;
      const last = st.last || 0;
      const mean = st.mean || 0;

      // Best/Worst globales (historial completo) + Fast5 (mejor bloque consecutivo)
      const bestAll = timesAll.length ? Math.min(...timesAll) : 0;
      const idxBestAll = bestAll ? timesAll.indexOf(bestAll) : -1;
      const worstInfo = findWorstLap(timesAll);
      const worstAll = worstInfo ? worstInfo.ms : 0;
      const idxWorstAll = worstInfo ? worstInfo.idx : -1;
      const fast5 = findFastestStint(timesAll, 5);

      const pNow = (raceData && Array.isArray(raceData.classification))
        ? raceData.classification.find(r => getPilotKey(r) === pilotKey)
        : null;
      const lapsNow = pNow ? (Number(pNow.lapcount) || 0) : 0;
      const consFb = getConsistencyFromFirebase(pNow);

      const lapsLabel = lapsNow ? lapsNow : timesAll.length;

      const bestTxt = (bestAll && idxBestAll >= 0) ? `${msToMinSec(bestAll)} (L${idxBestAll + 1})` : '-:--.---';
      const fastTxt = (fast5 && fast5.avg) ? `${msToMinSec(fast5.avg)} (L${fast5.start + 1}-${fast5.end + 1})` : '-:--.---';
      const worstTxt = (worstAll && idxWorstAll >= 0) ? `${msToMinSec(worstAll)} (L${idxWorstAll + 1})` : '-:--.---';

      lapChartMetaEl.textContent =
        `${lapsLabel} vueltas  Hist ${timesAll.length}  Best ${bestTxt}  Fast5 ${fastTxt}  Worst ${worstTxt}  Last ${last ? msToMinSec(last) : '-:--.---'}  Cons ${consFb ? (consFb + '%') : '-'}`;

ensureCanvasHiDpi(lapChartEl);
      const ctx = lapChartEl.getContext('2d');
      if (!ctx) return;

      const w = lapChartEl.width;
      const h = lapChartEl.height;

      ctx.clearRect(0, 0, w, h);

      // fondo suave
      ctx.fillStyle = 'rgba(2,6,23,0.45)';
      ctx.fillRect(0, 0, w, h);

      // escala
      let minV = Math.min(...times);
      let maxV = Math.max(...times);
      minV = Math.min(minV, best);
      maxV = Math.max(maxV, best);

      const pad = Math.max(400, (maxV - minV) * 0.18);
      minV = Math.max((lapRange && lapRange.min) ? lapRange.min : LAP_MS_MIN, minV - pad);
      maxV = Math.min((lapRange && lapRange.max) ? lapRange.max : LAP_MS_MAX, maxV + pad);

      const left = Math.floor(w * 0.06);
      const right = Math.floor(w * 0.03);
      const top = Math.floor(h * 0.12);
      const bottom = Math.floor(h * 0.18);
      const gw = w - left - right;
      const gh = h - top - bottom;
      // X: izquierda->derecha. Inicia desde la izquierda (lap 1 a la izquierda) y se va llenando hacia la derecha.
      // Con pocas vueltas queda espacio vaco a la derecha (intencional).
      const k = times.length;
      const xMax = getLapChartXMaxMs((tMs && tMs.length) ? tMs[tMs.length - 1] : 0);
      const xFor = (i) => {
        const ii = Math.max(0, Math.min(k - 1, i));
        const t = (tMs && tMs[ii]) ? tMs[ii] : 0;
        const frac = xMax ? Math.max(0, Math.min(1, t / xMax)) : 0;
        return left + (gw * frac);
      };

      const baseIdx = timesAll.length - times.length; // ndice global del primer punto mostrado

      // grid horizontal (4)
      ctx.strokeStyle = 'rgba(148,163,184,0.18)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = top + (gh * i / 4);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(left + gw, y);
        ctx.stroke();
      }

      // grid vertical por minutos (eje X = tiempo)
      try{
        const xMaxG = getLapChartXMaxMs((tMs && tMs.length) ? tMs[tMs.length - 1] : 0);
        const mins = Math.max(0, Math.floor(xMaxG / 60000));
        for (let m=1; m<=mins; m++){
          const frac = xMaxG ? (m*60000 / xMaxG) : 0;
          const x = left + (gw * frac);
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(148,163,184,0.10)';
          ctx.lineWidth = 1;
          ctx.moveTo(x, top);
          ctx.lineTo(x, top + gh);
          ctx.stroke();
        }
      } catch(e){}

      // línea promedio
      if (isLapPlausible(mean)) {
        const yMean = top + (1 - (Math.min(Math.max(mean, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.strokeStyle = 'rgba(34,211,238,0.35)';
        ctx.beginPath();
        ctx.moveTo(left, yMean);
        ctx.lineTo(left + gw, yMean);
        ctx.stroke();
      }

// Highlight Fast5 (mejor bloque consecutivo de 5 vueltas) si cae dentro del rango mostrado
try {
  if (fast5 && maxV > minV && times.length > 1) {
    const startDisp = fast5.start - baseIdx;
    const endDisp = fast5.end - baseIdx;
    if (endDisp >= 0 && startDisp <= (times.length - 1)) {
      const s = Math.max(0, startDisp);
      const e = Math.min(times.length - 1, endDisp);
      const x1 = xFor(s);
      const x2 = xFor(e);
      ctx.save();
      ctx.fillStyle = 'rgba(34,197,94,0.08)';
      ctx.fillRect(Math.min(x1, x2), top, Math.abs(x2 - x1), gh);
      ctx.restore();
    }
  }
} catch(e) {}

      // línea tiempos
      ctx.strokeStyle = 'rgba(251,146,60,0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      times.forEach((v, i) => {
        const x = xFor(i);
        const y = top + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // puntos/medias/markers (Preset A)
      // banda de ritmo (extra #2): media +- 0.20s
      const BAND_MS = 200;
      if (mean && maxV > minV) {
        const lo = Math.max(minV, mean - BAND_MS);
        const hi = Math.min(maxV, mean + BAND_MS);
        const yHi = top + (1 - (Math.min(Math.max(hi, minV), maxV) - minV) / (maxV - minV)) * gh;
        const yLo = top + (1 - (Math.min(Math.max(lo, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.save();
        ctx.fillStyle = 'rgba(226,232,240,0.06)';
        ctx.fillRect(left, yHi, gw, Math.max(0, yLo - yHi));
        ctx.restore();
      }

      // línea de media (pace)
      if (mean && maxV > minV) {
        const yM = top + (1 - (Math.min(Math.max(mean, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.save();
        ctx.strokeStyle = 'rgba(226,232,240,0.28)';
        ctx.setLineDash([Math.max(4, Math.floor(w*0.01)), Math.max(3, Math.floor(w*0.008))]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(left, yM);
        ctx.lineTo(left + gw, yM);
        ctx.stroke();
        ctx.restore();
      }

      // puntos (Preset A): best personal (verde) / best sesin (morado) / error grande (rojo) + last por estado
      const drawDot = (x, y, fill, rMul=1.0) => {
        const r = Math.max(2, Math.floor(w * 0.005)) * rMul;
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      };

      // best sesin (Opcin B: desde clasificacin visible)
      const sessionBestMs = computeSessionBestMs ? computeSessionBestMs() : 0;

      // errores grandes (rojo): +0.8s vs media o +0.9s vs best (lo que aplique)
      const ERR_A_MS = 800;
      const ERR_B_MS = 900;

      for (let i = 0; i < times.length; i++) {
        const v = times[i];
        const x = xFor(i);
        const y = top + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;

        const bigErr = (mean && v > (mean + ERR_A_MS)) || (best && v > (best + ERR_B_MS));
        if (bigErr) drawDot(x, y, 'rgba(239,68,68,0.92)', 1.15);
      }

      // last (color por mejora)
      const iLast = times.length - 1;
      const xLast = xFor(iLast);
      const yLast = top + (1 - (Math.min(Math.max(times[iLast], minV), maxV) - minV) / (maxV - minV)) * gh;
      const prevBest = (times.length > 1) ? Math.min(...times.slice(0, -1)) : 0;
      const lastClass = classifyLapColor ? classifyLapColor(times[iLast], prevBest || best || 0, sessionBestMs) : 'lap-neutral';
      const lastFill =
        lastClass === 'lap-purple' ? 'rgba(167,139,250,0.95)' :
        lastClass === 'lap-green'  ? 'rgba(34,197,94,0.95)'  :
        lastClass === 'lap-yellow' ? 'rgba(251,191,36,0.92)' :
                                     'rgba(226,232,240,0.85)';
      drawDot(xLast, yLast, lastFill, 1.18);

      // best (ndice) - verde, pero si es best sesin -> morado
      const idxBest = times.findIndex(v => v === best);
      if (idxBest >= 0) {
        const xB = xFor(idxBest);
        const yB = top + (1 - (Math.min(Math.max(best, minV), maxV) - minV) / (maxV - minV)) * gh;
        const bestFill = 'rgba(167,139,250,0.98)';
        drawDot(xB, yB, bestFill, 1.28);
      }

      // Tags de batalla (ATK/DEF/DUEL) por vuelta
      try {
        const fontPx = Math.max(9, Math.floor(w * 0.028));
        ctx.font = `600 ${fontPx}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';

        for (let i = 0; i < marks.length && i < times.length; i++) {
          const tag = marks[i];
          if (!tag) continue;
          const x = xFor(i);
          const y = top + (1 - (Math.min(Math.max(times[i], minV), maxV) - minV) / (maxV - minV)) * gh;

          let bg = 'rgba(255,255,255,0.10)';
          let fg = 'rgba(226,232,240,0.95)';
          if (tag === 'ATK') { bg = 'rgba(255,140,0,0.22)'; fg = 'rgba(255,230,200,0.95)'; }
          if (tag === 'DEF') { bg = 'rgba(59,130,246,0.22)'; fg = 'rgba(220,235,255,0.95)'; }
          if (tag === 'DUEL'){ bg = 'rgba(255,40,40,0.22)'; fg = 'rgba(255,230,230,0.95)'; }

                    // marcador visible en la grfica
          try {
            let stroke = 'rgba(226,232,240,0.35)';
            let fill = 'rgba(226,232,240,0.70)';
            if (tag === 'ATK') { stroke = 'rgba(255,140,0,0.85)'; fill = 'rgba(255,140,0,0.70)'; }
            if (tag === 'DEF') { stroke = 'rgba(59,130,246,0.85)'; fill = 'rgba(59,130,246,0.70)'; }
            if (tag === 'DUEL'){ stroke = 'rgba(239,68,68,0.85)'; fill = 'rgba(239,68,68,0.70)'; }
            ctx.save();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, top + 2);
            ctx.stroke();
            // dot ring
            const rr = Math.max(2, Math.floor(w * 0.004));
            ctx.fillStyle = 'rgba(2,6,23,0.45)';
            ctx.beginPath();
            ctx.arc(x, y, rr + 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, rr, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          } catch(e) {}

          let stroke = 'rgba(226,232,240,0.35)';
          let fill = 'rgba(226,232,240,0.70)';
          if (tag === 'ATK') { stroke = 'rgba(255,140,0,0.85)'; fill = 'rgba(255,140,0,0.70)'; }
          if (tag === 'DEF') { stroke = 'rgba(59,130,246,0.85)'; fill = 'rgba(59,130,246,0.70)'; }
          if (tag === 'DUEL'){ stroke = 'rgba(239,68,68,0.85)'; fill = 'rgba(239,68,68,0.70)'; }

          const iconS = Math.max(6, Math.floor(fontPx * 0.72));
          const iy = y - Math.max(10, iconS); // arriba del punto
          ctx.save();
          ctx.translate(x, iy);

          ctx.fillStyle = fill;
          ctx.strokeStyle = stroke;
          ctx.lineWidth = 2;

          ctx.beginPath();
          if (tag === 'ATK') {
            // tringulo arriba (zona de ataque)
            ctx.moveTo(0, -iconS * 0.65);
            ctx.lineTo(iconS * 0.65, iconS * 0.65);
            ctx.lineTo(-iconS * 0.65, iconS * 0.65);
          } else if (tag === 'DEF') {
            // tringulo abajo (zona de defensa)
            ctx.moveTo(0, iconS * 0.65);
            ctx.lineTo(iconS * 0.65, -iconS * 0.65);
            ctx.lineTo(-iconS * 0.65, -iconS * 0.65);
          } else {
            // DUEL: rombo
            ctx.moveTo(0, -iconS * 0.8);
            ctx.lineTo(iconS * 0.8, 0);
            ctx.lineTo(0, iconS * 0.8);
            ctx.lineTo(-iconS * 0.8, 0);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          ctx.restore();}
      } catch(e) {}

// Labels BEST / WORST y FAST5 (solo si estn dentro del rango mostrado)
try {
  const labelFont = Math.max(9, Math.floor(w * 0.024));
  const drawLabel = (txt, x, y, bg, fg) => {
    ctx.save();
    ctx.font = `700 ${labelFont}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    const padX = Math.max(5, Math.floor(labelFont * 0.55));
    const padY = Math.max(3, Math.floor(labelFont * 0.35));
    const tw = ctx.measureText(txt).width;
    const bw = tw + padX * 2;
    const bh = labelFont + padY * 2;
    const bx = x - bw / 2;
    const by = y - 6;
    ctx.fillStyle = bg;
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    roundRect(ctx, bx, by - bh, bw, bh, Math.max(6, Math.floor(labelFont*0.6)));
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = fg;
    ctx.fillText(txt, x, by - padY);
    ctx.restore();
  };

  // BEST global
  if (idxBestAll >= 0) {
    const iB = idxBestAll - baseIdx;
    if (iB >= 0 && iB < times.length) {
      const x = xFor(iB);
      const y = top + (1 - (Math.min(Math.max(times[iB], minV), maxV) - minV) / (maxV - minV)) * gh;
      drawLabel('BEST', x, y, 'rgba(167,139,250,0.22)', 'rgba(245,240,255,0.98)');
    }
  }

  // WORST global (dentro del rango mostrado)
  if (idxWorstAll >= 0) {
    const iW = idxWorstAll - baseIdx;
    if (iW >= 0 && iW < times.length) {
      const x = xFor(iW);
      const y = top + (1 - (Math.min(Math.max(times[iW], minV), maxV) - minV) / (maxV - minV)) * gh;
      // dot extra para que se vea
      drawDot(x, y, 'rgba(239,68,68,0.92)', 1.25);
      drawLabel('WORST', x, y, 'rgba(239,68,68,0.18)', 'rgba(255,235,235,0.95)');
    }
  }

  // FAST5 label (centro del bloque)
  if (fast5 && times.length > 1) {
    const s = fast5.start - baseIdx;
    const e = fast5.end - baseIdx;
    if (e >= 0 && s <= (times.length - 1)) {
      const ss = Math.max(0, s);
      const ee = Math.min(times.length - 1, e);
      const xc = ((xFor(ss) + xFor(ee)) / 2);
      const yTop = top + 2;
      drawLabel('FAST5', xc, yTop + labelFont + 10, 'rgba(34,197,94,0.16)', 'rgba(220,255,235,0.95)');
    }
  }
} catch(e) {}

      }

function drawLapChartTop3Auto(){
      if (!lapChartEl || !lapChartMetaEl) return;

      const top = getTop3Rows();
      const keys = top.map(r => getPilotKey(r)).filter(Boolean);

      // Si no hay top3, limpia
      if (!keys.length){
        lapChartMetaEl.textContent = 'Sin datos';
        if (top3MiniGridEl) top3MiniGridEl.innerHTML = '';
        const ctx0 = lapChartEl.getContext('2d');
        if (ctx0) ctx0.clearRect(0,0,lapChartEl.width,lapChartEl.height);
        return;
      }

      // Render UI (chips + grid)
      try { renderAutoLapChartTop3(); } catch(e) {}
      try { renderAutoTop3MiniGrid(); } catch(e) {}

      const N = 40;
      const colors = [
        { stroke: 'rgba(251,191,36,0.95)', dot: 'rgba(251,191,36,0.98)' }, // P1 amarillo
        { stroke: 'rgba(255,255,255,0.92)', dot: 'rgba(255,255,255,0.96)' }, // P2 blanco
        { stroke: 'rgba(249,115,22,0.95)', dot: 'rgba(249,115,22,0.98)' } // P3 naranja
      ];

      // Series por piloto (alineadas a la derecha)
      const series = [];
      let allVals = [];
      for (let i=0;i<keys.length && i<3;i++){
        const k = keys[i];
        const hist = lapHistory.get(k) || { times: [] };
        const raw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
        // Construye vals + tiempo acumulado (eje X)
        let valsAll = [];
        let tAll = [];
        let acc = 0;
        for (let r=0; r<raw.length; r++){
          const v0 = normalizeLapMs(raw[r]);
          if (!isLapPlausible(v0)) continue;
          acc += v0;
          valsAll.push(v0);
          tAll.push(acc);
        }

        // Fallback: si todavia no hay historial (inicio de carrera), al menos pinta un punto con lastTime/best.
        if (!valsAll.length) {
          const row = top[i] || null;
          const last = row ? normalizeLapMs(parseTimeToMs(row.lastTime)) : 0;
          const best = row ? normalizeLapMs(parseTimeToMs(row.best)) : 0;
          const candidate = isLapPlausible(last) ? last : (isLapPlausible(best) ? best : 0);
          if (candidate) {
            valsAll = [candidate];
            tAll = [candidate];
          }
        }

        if (!valsAll.length) continue;
        const vals = valsAll.slice(-N);
        const tms = tAll.slice(-N);
        series.push({ key: k, vals, tms, color: colors[i], idx: i });
        allVals = allVals.concat(vals);
      }

      if (!series.length){
        lapChartMetaEl.textContent = 'Sin datos';
        if (top3MiniGridEl) top3MiniGridEl.innerHTML = '';
        const ctx0 = lapChartEl.getContext('2d');
        if (ctx0) ctx0.clearRect(0,0,lapChartEl.width,lapChartEl.height);
        return;
      }

      updateLapRangeFromHistory(allVals);

      ensureCanvasHiDpi(lapChartEl);
      const ctx = lapChartEl.getContext('2d');
      if (!ctx) return;

      const w = lapChartEl.width;
      const h = lapChartEl.height;
      ctx.clearRect(0,0,w,h);

      // fondo
      ctx.fillStyle = 'rgba(2,6,23,0.45)';
      ctx.fillRect(0,0,w,h);

      // escala combinada
      try { updateLapRangeFromHistory(allVals); } catch(e) {}
      let minV = Math.min(...allVals);
      let maxV = Math.max(...allVals);
      const pad = Math.max(400, (maxV - minV) * 0.18);
      minV = Math.max((lapRange && lapRange.min) ? lapRange.min : LAP_MS_MIN, minV - pad);
      maxV = Math.min((lapRange && lapRange.max) ? lapRange.max : LAP_MS_MAX, maxV + pad);

      const left = Math.floor(w * 0.06);
      const right = Math.floor(w * 0.03);
      const topPad = Math.floor(h * 0.12);
      const bottom = Math.floor(h * 0.18);
      const gw = w - left - right;
      const gh = h - topPad - bottom;

      // Eje X por TIEMPO: max por modo (3/4/6 min + fraccion)
      let __lastElapsed = 0;
      for (const ss of series){
        const tt = ss.tms || [];
        const lt = tt.length ? tt[tt.length - 1] : 0;
        if (lt > __lastElapsed) __lastElapsed = lt;
      }
      const xMax = getLapChartXMaxMs(__lastElapsed);

      // grid
      ctx.strokeStyle = 'rgba(148,163,184,0.18)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = topPad + (gh * i / 4);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(left + gw, y);
        ctx.stroke();
      }

      // grid vertical por minutos (eje X = tiempo)
      try{
        const mins = Math.max(0, Math.floor(xMax / 60000));
        for (let m=1; m<=mins; m++){
          const frac = xMax ? (m*60000 / xMax) : 0;
          const x = left + (gw * frac);
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(148,163,184,0.10)';
          ctx.lineWidth = 1;
          ctx.moveTo(x, topPad);
          ctx.lineTo(x, topPad + gh);
          ctx.stroke();
        }
      } catch(e){}

      const focusKey = (lapChartAutoKey && keys.includes(lapChartAutoKey)) ? lapChartAutoKey : keys[0];

      // dibuja series
      for (const s of series){
        const vals = s.vals;
        const len = vals.length;
        if (!len) continue;

        const isFocus = (s.key === focusKey);
        ctx.save();
        ctx.globalAlpha = isFocus ? 1.0 : 0.65;
        ctx.strokeStyle = s.color.stroke;
        ctx.lineWidth = isFocus ? 2.8 : 1.9;
        ctx.beginPath();

        for (let j=0;j<len;j++){
          const t = (s.tms && s.tms[j]) ? s.tms[j] : 0;
          const frac = xMax ? Math.max(0, Math.min(1, t / xMax)) : 0;
          const x = left + (gw * frac);
          const v = vals[j];
          const y = topPad + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;
          if (j===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();

        // dot última vuelta
        const jLast = len - 1;
        const tL = (s.tms && s.tms[jLast]) ? s.tms[jLast] : 0;
        const fracL = xMax ? Math.max(0, Math.min(1, tL / xMax)) : 0;
        const xL = left + (gw * fracL);
        const vL = vals[jLast];
        const yL = topPad + (1 - (Math.min(Math.max(vL, minV), maxV) - minV) / (maxV - minV)) * gh;
        const r = Math.max(2, Math.floor(w * 0.005)) * (isFocus ? 1.25 : 1.05);
        ctx.fillStyle = s.color.dot;
        ctx.beginPath();
        ctx.arc(xL, yL, r, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
      }

      // Meta (texto corto)
      try{
        const leader = top[0];
        const lapsLabel = leader && leader.lapcount != null ? leader.lapcount : '-';
        lapChartMetaEl.title = `Top 3 (auto) - último dibujo: P1 laps ${lapsLabel}`;
      }catch(e){}
    }

    window.addEventListener('resize', () => {
      if (selectedPilotKey) drawLapChartForKey(selectedPilotKey);
      else { try { drawLapChartTop3Auto(); } catch(e) {} }
    });

    function numeroATexto0a999(n) {
      n = Math.floor(n);
      if (Number.isNaN(n) || n < 0 || n > 999) return String(n);
      const unidades = ['cero','uno','dos','tres','cuatro','cinco','seis','siete','ocho','nueve'];
      const especiales = ['diez','once','doce','trece','catorce','quince','dieciseis','diecisiete','dieciocho','diecinueve'];
      const decenas = ['','','veinte','treinta','cuarenta','cincuenta','sesenta','setenta','ochenta','noventa'];
      const centenas = ['','cien','doscientos','trescientos','cuatrocientos','quinientos','seiscientos','setecientos','ochocientos','novecientos'];

      if (n < 10) return unidades[n];
      if (n < 20) return especiales[n - 10];
      if (n < 100) {
        const d = Math.floor(n / 10);
        const u = n % 10;
        if (n === 20) return 'veinte';
        if (n < 30) return 'veinti' + unidades[u];
        if (u === 0) return decenas[d];
        return decenas[d] + ' y ' + unidades[u];
      }
      const c = Math.floor(n / 100);
      const resto = n % 100;
      if (n === 100) return 'cien';
      let resultado = centenas[c];
      if (resto > 0) {
        resultado += ' ' + numeroATexto0a999(resto);
      }
      return resultado;
    }

    function tiempoATexto(ms) {
      if (ms == null || isNaN(ms) || ms <= 0) return '';
      const totalSeconds = ms / 1000;

      // Para anuncios largos (ej: "Total X minutos..."), mantenemos texto tradicional.
      if (totalSeconds >= 60) {
        const minutes = Math.floor(totalSeconds / 60);
        const secondsFloat = totalSeconds - minutes * 60;

        const minutesTxt = numeroATexto0a999(minutes);
        const secondsStr = toFixedFloor(secondsFloat, decimalPrecision);
        const secParts = secondsStr.split('.');
        const secIntPart = parseInt(secParts[0], 10);
        const secDecStr = (secParts[1] || '').padEnd(3, '0');
        const d1 = secDecStr[0] || '0';
        const d2 = secDecStr[1] || '0';
        const d3 = secDecStr[2] || '0';

        let secondsTxt = '';
        if (!isNaN(secIntPart)) secondsTxt += numeroATexto0a999(secIntPart);
        if (secDecStr !== '000') {
          // Aquí usamos dígitos separados para que no se coma ceros.
          secondsTxt = secondsTxt ? `${secondsTxt} punto ${d1} ${d2} ${d3}` : `cero punto ${d1} ${d2} ${d3}`;
        }
        if (!secondsTxt) secondsTxt = 'cero';

        const palabraMin = minutes === 1 ? 'minuto' : 'minutos';
        return `${minutesTxt} ${palabraMin} con ${secondsTxt} segundos`;
      }

      // ---- Lap time (lo que el piloto escucha todo el rato)
      // Regla: si la dcima es 0 (X.0xx) -> "X flat"
      // Si no, el decimal (0-999) se lee como nmero completo:
      // 9.103 -> "nueve punto ciento tres"
      // 5.546 -> "cinco punto quinientos cuarenta y seis"
      const secInt = Math.floor(ms / 1000);
      const rem = Math.max(0, ms - secInt * 1000); // 0..999
      const d1 = Math.floor(rem / 100); // dcima (0..9)

      // "flat" SOLO cuando la dcima es 0 (X.0xx), sin importar la precisin seleccionada.
      if (d1 === 0) {
        return `${secInt} flat`;
      }

      // Aplicar precisin seleccionada (1, 2 o 3 decimales) a la lectura:
      // 1 decimal  -> floor(rem/100)  (0..9)
      // 2 decimales -> floor(rem/10)   (0..99)
      // 3 decimales -> rem            (0..999)
      let decN = 0;
      if (decimalPrecision === 1) decN = Math.floor(rem / 100);
      else if (decimalPrecision === 2) decN = Math.floor(rem / 10);
      else decN = rem;

      return `${secInt} punto ${numeroATexto0a999(decN)}`;
          }

    function formatoGapVueltas(raw) {
      if (!raw) return '';
      const trimmed = raw.toString().trim();
      if (!trimmed || trimmed === '-') return '';
      // Queremos UI compacta: 1V, 2V, 3V (sin texto)
      const m = trimmed.match(/^(?:\+)?(\d+)\s*V$/i);
      if (m) {
        const n = parseInt(m[1], 10);
        if (isFinite(n) && n > 0) return String(n) + 'V';
      }
      return trimmed;
    }

    function normalizeRaceData(rawRace) {
      const result = {
        raceName: rawRace.raceName || '',
        lapCount: rawRace.lapCount || 0,
        // Nuevo feed (watcher): reloj y modo
        clockMs: (typeof rawRace.clockMs === 'number') ? rawRace.clockMs : ((typeof rawRace.clock === 'number') ? rawRace.clock : 0),
        clockFmt: (rawRace.clockFmt != null) ? String(rawRace.clockFmt) : '',
        practice: (rawRace.practice != null) ? Number(rawRace.practice) : null,
        mode: (rawRace.mode != null) ? String(rawRace.mode) : '',
        bestLapTime: parseTimeToMs(rawRace.bestLapTime),
        classification: []
      };

      const passEvents = [];
      const prevByKey = new Map();
      if (previousClassification && Array.isArray(previousClassification)) {
        previousClassification.forEach(p => {
          prevByKey.set(getPilotKey(p), p);
        });
      }

      const nextPrev = [];

      (rawRace.classification || []).forEach(row => {
        const key = getPilotKey(row);
        const lap = Number(row.lapcount) || 0;

        let totalMs = 0;
        const timeStr = row.time != null ? String(row.time) : '';
        if (typeof row.timeMs === 'number') {
          totalMs = row.timeMs;
        } else if (timeStr) {
          totalMs = parseTimeToMs(timeStr);
        }

        // bestLap suele ser NUMERO DE VUELTA (indice), no tiempo. Usar "best"/"bestLapTime" para el tiempo.
const bestTimeRaw =
  (row.best != null ? row.best :
   (row.bestMs != null ? row.bestMs :
    (row.bestLapTime != null ? row.bestLapTime :
     (row.bestLapTimeMs != null ? row.bestLapTimeMs :
      (row.bestTime != null ? row.bestTime : 0)))));
let bestMs = parseTimeToMs(bestTimeRaw);
        // meanLap a veces se usa para otra cosa; prioriza campos de tiempo.
const meanTimeRaw =
  (row.mean != null ? row.mean :
   (row.meanMs != null ? row.meanMs :
    (row.meanLapTime != null ? row.meanLapTime :
     (row.meanLapTimeMs != null ? row.meanLapTimeMs : 0))));
let meanMs = parseTimeToMs(meanTimeRaw);
        const estMs  = parseTimeToMs((row.estTime != null) ? row.estTime : (row.estTimeMs != null ? row.estTimeMs : 0));

        let lastMs = 0;
        const prev = prevByKey.get(key);
        if (prev) {
          const prevLaps = Number(prev.lapcount) || 0;
          if (lap > prevLaps && totalMs > prev.time) {
            lastMs = totalMs - prev.time;
            // registrar evento de paso por meta para lgica de bandera azul (último paso por piloto)
            if (!lastPassEvents || typeof lastPassEvents.set !== 'function') {
              lastPassEvents = new Map();
            }
            lastPassEvents.set(key, {
              key,
              pos: row.pos,
              name: safeRacerName(row.racerName),
              lap,
              time: totalMs
            });
          } else if (lap === prevLaps && prev.lastTime && prev.lastTime > 0) {
            lastMs = prev.lastTime;
          } else if (lap === 0) {
            lastMs = 0;
          }
        }

        lastMs = normalizeLapMs(lastMs);
        bestMs = normalizeLapMs(bestMs);
        meanMs = normalizeLapMs(meanMs);

        // Correccin de best/mean cuando vienen como nmero de vuelta u otro formato raro
        const MIN_VALID_LAP_MS = LAP_MS_MIN;
        const MAX_VALID_LAP_MS = LAP_MS_MAX;
        if (!bestMs || isNaN(bestMs) || bestMs < MIN_VALID_LAP_MS || bestMs > MAX_VALID_LAP_MS) {
          if (prev && prev.best && !isNaN(prev.best) && prev.best > 0) {
            bestMs = prev.best;
          }
          if (lastMs && lastMs > 0 && (!bestMs || lastMs < bestMs)) {
            bestMs = lastMs;
          }
        }

        if ((!meanMs || isNaN(meanMs) || meanMs < MIN_VALID_LAP_MS || meanMs > MAX_VALID_LAP_MS) && lap > 0 && totalMs > 0) {
          meanMs = totalMs / lap;
        } else if ((!meanMs || isNaN(meanMs) || meanMs <= 0) && prev && prev.mean && !isNaN(prev.mean) && prev.mean > 0) {
          meanMs = prev.mean;
        }

        const normalized = {
          pos:         row.pos,
          racerNumber: row.racerNumber,
          racerName:   safeRacerName(row.racerName),
          lapcount:    lap,
          time:        totalMs,
          timeStr:     timeStr,
          lastTime:    lastMs,
          gap:         row.gap || "",
          diff:        row.diff || "",
          best:        bestMs,
          bestLap:     row.bestLap,
          mean:        meanMs,
          estLap:      row.estLap || 0,
          estTime:     estMs,
          consistency: row.consistency
        };

        result.classification.push(normalized);
        nextPrev.push({ ...normalized });
      });

      previousClassification = nextPrev;
      return result;
    }

    let lastSpokenLastTime = null;
    let lastAnnouncedLapcount = 0;
    let lastKnownPos = null;
    let lastTotalTimeAnnouncedSeconds = 0;
    let lastGapInfoLap = 0;
    let lastBehindAlertMs = 0;

    let lastBestAnnouncedMs = null;
    let lastBestAnnouncedLap = 0;
    let lastTrendSpokenLap = 0;
    let lastAheadAlertMs = 0;
    
    // Latches para alertas <0.6 (decir solo una vez hasta que se libere)
    let behind06Latch = { active:false, otherKey:'', lap:-1 };
    let ahead06Latch  = { active:false, otherKey:'', lap:-1 };

    // Latches y estado para estrategia
    let attackLatch  = { active:false, otherKey:'', lap:-1 };
    let defenseLatch = { active:false, otherKey:'', lap:-1 };
    let fightLatch   = { active:false, lap:-1 };

    // =========================
    // DUEL / ATK / DEF (EMA + histeresis)
    // - Entra: gap suavizado <= 0.45s
    // - Sale: >= 0.65s (ATAQUE) o >= 0.60s (DEFENSA)
    // - EMA reduce jitter, sobre todo en MANGA
    // =========================
    const DUEL_ENTER_SEC = 0.45;
    const DUEL_EXIT_ATTACK_SEC = 0.65;
    const DUEL_EXIT_DEFEND_SEC = 0.60;
    const DUEL_EMA_ALPHA = 0.35;
    const duelStateByPilotKey = new Map();

    let startPosForSelected = null;
    let lastNetGainValue = null;
    let lastNetGainSpokenLap = 0;
    let lastLeaderGapSpokenLap = 0;
    let lastPodiumSpokenLap = 0;
let lastAutoSummaryAnnouncedSeconds = 0;

    // =========================
    // Modo LOCUTOR (AUTO cuando NO hay piloto seleccionado)
    // =========================
    let commentatorTop3LastLeaderLap = 0;
    let commentatorTop3LastSpokenMs = 0;
    let commentatorBattleLatch = new Map(); // pairKey -> { active, lastLeadLap }
    let commentatorGapHistory = new Map();  // pairKey -> { lastGapMs, lastTrailLap, lastSpokenTrailLap }

// Narracin con contexto (Auto Locutor) - seguimiento de una pelea para que suene hilado
let autoNarratorState = {
  focusPairKey: '',
  focusPos: 0,
  focusDefender: '',
  focusAttacker: '',
  focusSinceMs: 0,
  focusLastSec: null,
  focusStage: '',
  focusLastSpeakMs: 0,
  focusStickyUntilMs: 0,
  lastSpokenType: '',
  lastSpokenMs: 0
};

// pairKey -> { lastSec, lastSec2, lastMs, lastLap, lastMentionMs }
let autoPairState = new Map();

// MANGA (clasificacin): seguimiento de pole/best lap sin saturar
let autoQualiState = {
  bestOverallMs: null,
  bestOverallKey: '',
  lastBestSpeakMs: 0,
  lastPoleFightSpeakMs: 0
};

function resetAutoNarratorState() {
  try {
    autoNarratorState = {
      focusPairKey: '',
      focusPos: 0,
      focusDefender: '',
      focusAttacker: '',
      focusSinceMs: 0,
      focusLastSec: null,
      focusStage: '',
      focusLastSpeakMs: 0,
      focusStickyUntilMs: 0,
      lastSpokenType: '',
      lastSpokenMs: 0
    };
    if (autoPairState && typeof autoPairState.clear === 'function') autoPairState.clear();
    autoQualiState = { bestOverallMs: null, bestOverallKey: '', lastBestSpeakMs: 0, lastPoleFightSpeakMs: 0 };
  } catch(e) {}
}

    function resetAutoCommentatorState() {
      try {
        commentatorTop3LastLeaderLap = 0;
        commentatorTop3LastSpokenMs = 0;
        if (commentatorBattleLatch && typeof commentatorBattleLatch.clear === 'function') commentatorBattleLatch.clear();
        if (commentatorGapHistory && typeof commentatorGapHistory.clear === 'function') commentatorGapHistory.clear();
        if (commentatorAutoState) {
          commentatorAutoState.lastSpeakMs = 0;
          commentatorAutoState.window = [];
          if (commentatorAutoState.recentSig && typeof commentatorAutoState.recentSig.clear === 'function') commentatorAutoState.recentSig.clear();
          if (commentatorAutoState.prevPosByKey && typeof commentatorAutoState.prevPosByKey.clear === 'function') commentatorAutoState.prevPosByKey.clear();
          commentatorAutoState.prevKeyByPos = [];
          commentatorAutoState.lastLeaderKey = '';
          commentatorAutoState.lastLeaderLap = 0;
          commentatorAutoState.lastQuietMs = 0;
          commentatorAutoState.lastTop3Ms = 0;
          commentatorAutoState.lastTop3Sig = '';
          commentatorAutoState.lastMilestone = 0;
          commentatorAutoState.lastTop5Sig = '';
          commentatorAutoState.stableTop5Laps = 0;
          commentatorAutoState.lastTop5Lap = 0;
        }
        try { resetAutoNarratorState(); } catch(e) {}
      } catch(e) {}
    }

    // Historial de vueltas para consistencia
    let lapHistory = new Map();
    
    // Lap Chart marks: tags por vuelta (ATK/DEF/DUEL)
    function setLastLapMark(pilotKey, tag) {
      try {
        if (!pilotKey || !tag) return;
        const hist = lapHistory.get(pilotKey);
        if (!hist) return;
        if (!Array.isArray(hist.times)) hist.times = [];
        if (!Array.isArray(hist.marks)) hist.marks = [];
        const tlen = hist.times.length;
        if (!tlen) return;
        while (hist.marks.length < tlen) hist.marks.push(null);

        const i = tlen - 1;
        const cur = hist.marks[i];
        const pr = { DUEL: 3, ATK: 2, DEF: 2, PB: 1, ERR: 1 };
        if (!cur || (pr[tag] || 0) >= (pr[cur] || 0)) {
          hist.marks[i] = tag;
        }
        lapHistory.set(pilotKey, hist);
      } catch (e) {}
    }

// Best lap previo por piloto (para detectar mejora aunque Firebase ya actualice el best)
    let prevBestByKey = new Map();
    let lastSessionSigForBest = '';

    // Race Director: memoria anti repeticin (por laps)
    let rdLastIdLap = new Map();
    let rdLastTextLap = new Map();

    let lastConsistencySpokenLap = 0;
    let lastSpokenEstLap = null;
    let lastEstLapSpokenLap = 0;

    // Pendientes para AI Director (se anuncian post-Laps)
    let pendingPosChange = null;
    let pendingNetGain   = null;
    let pendingBestLap   = null;
    let pendingEstLap    = null;

    // eventos de paso por meta y estado de bandera azul
    let lastPassEvents = new Map();
    let pendingBlueFlagForPilotKey = '';
    let pendingBlueFlagMessage = '';
    let lastBlueFlagPilotLap = 0;
    let lastBlueWarnPilotLap = 0;
    let lastBlueFlagLeaderLap = 0;
    let lastBlueWarnLeaderLap = 0;
    let blueFlagConfirm = { pilotKey:'', leaderKey:'', lap:0, hits:0, t:0 };

    function renderPilotCard(p) {
      if (!p) {
        pilotNameEl.textContent = 'Auto Locutor';
      // En Auto Locutor, mostrar vueltas del líder
      let leaderLap = 0;
      try {
        if (raceData && Array.isArray(raceData.classification) && raceData.classification.length) {
          const leader = raceData.classification.reduce((best, r) => {
            const pos = (r && r.pos != null) ? (+r.pos || 999) : 999;
            const bpos = (best && best.pos != null) ? (+best.pos || 999) : 999;
            return (pos < bpos) ? r : best;
          }, null);
          leaderLap = (leader && leader.lapcount != null) ? leader.lapcount : ((leader && leader.laps != null) ? leader.laps : 0);
          if (!isFinite(leaderLap) || leaderLap < 0) leaderLap = 0;
        }
      } catch(e) { leaderLap = 0; }
      pilotMetaEl.textContent = String(leaderLap || 0) + ' v';
        posTextEl.textContent   = 'P -';
        gapInfoEl.textContent   = 'Diferencia líder  vueltas  estado';
        lastLapEl.textContent   = '-:--.---';
        bestLapEl.textContent   = '-:--.---';
        meanLapEl.textContent   = '-:--.---';
        if (consistencyValEl) consistencyValEl.textContent = '--%';
        if (sigmaValEl) sigmaValEl.textContent = '-.---';
        try { renderAutoLapChartTop3(); } catch(e) {}
        try { drawLapChartTop3Auto(); } catch(e) {}
        try { applyPilotSelectPosTheme(null); } catch(e) {}
        try { renderAutoTop3MiniGrid(); } catch(e) {}
        return;
      }

      pilotNameEl.textContent = safeRacerName(p.racerName) || 'Sin nombre';
      pilotMetaEl.textContent = String((p.lapcount != null ? p.lapcount : 0)) + " v";

      posTextEl.textContent = p.pos ? `P ${p.pos}` : 'P -';
      try { applyPilotSelectPosTheme(p.pos); } catch(e) {}

      const gapText = formatoGapVueltas(p.gap);
      const meanStr = p.mean ? msToMinSec(p.mean) : '-:--.---';
      const totalStr = p.time ? msToMinSec(p.time) : '-:--.---';

      const partes = [];
      if (gapText) partes.push(`Diferencia ${gapText}`);
      if (p.lapcount != null) partes.push(`${p.lapcount} vueltas`);
      if (totalStr && totalStr !== '-:--.---') partes.push(`Total ${totalStr}`);
      gapInfoEl.textContent = partes.join('  ') || 'Diferencia líder  vueltas  estado';

      const key = getPilotKey(p);
      const hist = lapHistory.get(key) || { lastLapcount: 0, times: [] };
      const timesRaw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
      updateLapRangeFromHistory(timesRaw);
      const times = timesRaw.filter(isLapPlausible);

      const computed = statsFromTimes(times);

      const consPct = getConsistencyFromFirebase(p);

      // Mostrar consistencia (feed) y  (historial lap chart)
      try {
        if (consistencyValEl) consistencyValEl.textContent = consPct ? (consPct + '%') : '--%';
      } catch(e) {}
      try {
        const sig = (computed && computed.sigma && isFinite(computed.sigma)) ? (computed.sigma / 1000) : NaN;
        if (sigmaValEl) sigmaValEl.textContent = (isFinite(sig) && sig > 0) ? sig.toFixed(3) : '-.---';
      } catch(e) {}

      const computedBest = computed.best || 0;
      const computedLast = computed.last || 0;
      const computedMean = computed.mean || 0;

      const pLast = normalizeIncomingLapValue(p.lastTime);
      const pBest = normalizeIncomingLapValue(p.best);
      const pMean = normalizeIncomingLapValue(p.mean);

      const lastMsFinal = isLapPlausible(pLast) ? pLast : computedLast;
      let bestMsFinal = isLapPlausible(pBest) ? pBest : computedBest;
      // Si ya tenemos historia confiable (pasos por meta), sala para corregir "best" raro del feed
      if (computedBest && computedBest > 0) {
        if (!bestMsFinal || bestMsFinal <= 0) {
          bestMsFinal = computedBest;
        } else {
          const lapsSeen = times.length || 0;
          // Si el best del feed es demasiado mas rapido que lo visto, es casi seguro basura
          if (lapsSeen >= 3 && bestMsFinal < (computedBest * 0.80)) {
            bestMsFinal = computedBest;
          } else if (computedBest < bestMsFinal) {
            bestMsFinal = computedBest;
          }
        }
      }
const meanMsFinal = isLapPlausible(pMean) ? pMean : computedMean;

      const lastStr = lastMsFinal ? msToMinSec(lastMsFinal) : '-:--.---';
      const bestStr = bestMsFinal ? msToMinSec(bestMsFinal) : '-:--.---';
      const meanStrFinal = meanMsFinal ? msToMinSec(meanMsFinal) : meanStr;

      lastLapEl.textContent = lastStr;
      bestLapEl.textContent = bestStr;
      meanLapEl.textContent = meanStrFinal;
      // Colores estilo cronometraje (F1)
      const sessionBestMs = computeSessionBestMs();

      // LTIMA: morado (mejor absoluto) / verde (mejor personal) / amarillo (no mejora) / neutral
      const prevBest = prevBestByKey.get(key) || 0;
      const personalRef = prevBest > 0 ? prevBest : (bestMsFinal || 0);
      const lastClass = classifyLapColor(lastMsFinal, personalRef, sessionBestMs);
      // Actualiza referencia para prxima vuelta
      if (bestMsFinal && bestMsFinal > 0) prevBestByKey.set(key, bestMsFinal);
      setLapClass(lastLapEl, lastClass);

      // MEJOR: siempre morado (y si adems es el mejor absoluto, se queda morado igual)
      if (bestMsFinal && bestMsFinal > 0) setLapClass(bestLapEl, 'lap-purple');
      else setLapClass(bestLapEl, 'lap-neutral');

      // MEDIA: color distinto (suave) cuando existe
      if (meanMsFinal && meanMsFinal > 0) setLapClass(meanLapEl, 'lap-avg');
      else setLapClass(meanLapEl, 'lap-neutral');

      // grfica vuelta por vuelta
      if (selectedPilotKey && key === selectedPilotKey) {
        drawLapChartForKey(selectedPilotKey);
      }
    }

    
    
// Cache del record de carrera (best lap global) en ms
let sessionBestCache = { ms: 0, holder: '-', key: null };

function refreshSessionBestCache() {
  try {
    const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification : [];
    let best = 0;
    let holder = '-';
    let holderKey = null;

    // 1) Fuente confiable: lo que nosotros vimos pasar por meta (delta de tiempos)
    for (const r of rows) {
      const key = getPilotKey(r);
      if (!key) continue;
      const hist = lapHistory ? lapHistory.get(key) : null;
      const ms = hist && hist.bestMs ? normalizeLapMs(hist.bestMs) : 0;
      if (!ms) continue;
      if (!best || ms < best) {
        best = ms;
        holder = safeRacerName(r.racerName) || '-';
        holderKey = key;
      }
    }

    // 2) Fallback: el "best" que manda el feed (por si abriste ya avanzada la carrera)
    if (!best) {
      for (const r of rows) {
        const raw =
          (typeof r.best !== 'undefined' ? r.best :
           (typeof r.bestMs !== 'undefined' ? r.bestMs :
            (typeof r.bestLapTime !== 'undefined' ? r.bestLapTime :
             (typeof r.bestLapTimeMs !== 'undefined' ? r.bestLapTimeMs : 0))));
        const ms = normalizeLapMs(normalizeIncomingLapValue(raw));
        if (!ms) continue;
        if (!best || ms < best) {
          best = ms;
          holder = safeRacerName(r.racerName) || '-';
          holderKey = getPilotKey(r);
        }
      }
    }

    // 3) último recurso: raceData.bestLapTime (sin dueo seguro)
    if ((!best || best <= 0) && raceData && typeof raceData.bestLapTime !== 'undefined') {
      const fb = normalizeLapMs(normalizeIncomingLapValue(raceData.bestLapTime));
      if (fb) {
        best = fb;
        holder = (holder && holder !== '-') ? holder : '-';
      }
    }

    sessionBestCache = { ms: best || 0, holder: holder || '-', holderKey: holderKey || null };
    // Aviso de record de carrera (cualquiera)
    try {
      const now = Date.now();
      const cur = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
      const hKey = (sessionBestCache && sessionBestCache.holderKey) ? sessionBestCache.holderKey : null;
      const hName = (sessionBestCache && sessionBestCache.holder) ? sessionBestCache.holder : '-';
      let hPos = null;
      try {
        if (hKey && rows && rows.length) {
          const rr = rows.find(x => (getPilotKey(x) === hKey));
          if (rr && rr.pos) hPos = rr.pos;
        }
      } catch(e) {}
      const improved = cur && ((lastGlobalBestSpokenMs === 0) || (cur < (lastGlobalBestSpokenMs - 25)));
      const newHolder = hKey && (hKey !== lastGlobalBestSpokenHolderKey);
      if (improved && (newHolder || cur < (lastGlobalBestSpokenMs - 60)) && (now - lastGlobalBestSpokenAt > 2500)) {
        lastGlobalBestSpokenMs = cur;
        lastGlobalBestSpokenHolderKey = hKey;
        lastGlobalBestSpokenAt = now;
        // Beep + voz (no interrumpe si ya va hablando)
        playBeep('up');
        enqueueSpeech(`Best lap global. ${hPos != null ? ('P ' + hPos + '. ') : ''}${hName}. ${tiempoATexto(cur)}.`, { key: 'global_best_' + cur, priority: 88, cooldownMs: 2000, dedupe: true });
        flashPilotCardGreen();
        flashMangaClock();
      }
    } catch(e) {}

  } catch (e) {
    console.error('refreshSessionBestCache', e);
    sessionBestCache = { ms: 0, holder: '-', holderKey: null };
  }
}

function updateRecordCarreraUI() {
  const lapEl = document.getElementById('bestOverallLap');
  const holderEl = document.getElementById('bestLapHolder');
  if (!lapEl || !holderEl) return;

  const best = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
  if (!best) {
    lapEl.textContent = '-:--.---';
    holderEl.textContent = '-';
    return;
  }

  lapEl.textContent = msToMinSec(best);
  holderEl.textContent = (sessionBestCache && sessionBestCache.holder) ? sessionBestCache.holder : '-';
}

function computeSessionBestMs() {
      // Usar cache (se refresca en cada tick)
      const best = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
      if (best && isFinite(best)) return best;

      // fallback: recalcula si todava no hay cache por alguna razn
      refreshSessionBestCache();
      return (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
    }

    function classifyLapColor(lastMs, personalBestMs, sessionBestMs) {
      if (!lastMs || lastMs <= 0 || !isFinite(lastMs)) return 'lap-neutral';
      // Morado: mejor absoluto (tolerancia mnima)
      if (sessionBestMs && sessionBestMs > 0 && lastMs <= (sessionBestMs + 1)) return 'lap-purple';
      // Verde: mejor su propio
      if (personalBestMs && personalBestMs > 0 && lastMs <= (personalBestMs + 1)) return 'lap-green';
      // Amarillo: no mejor
      if (personalBestMs && personalBestMs > 0) return 'lap-yellow';
      return 'lap-neutral';
    }

    function setLapClass(el, cls) {
      if (!el) return;
      el.classList.remove('lap-purple','lap-green','lap-yellow','lap-neutral','lap-avg');
      if (cls) el.classList.add(cls);
    }

    function flashLastLap() {
      lastLapEl.classList.add('flash');
      setTimeout(() => {
        lastLapEl.classList.remove('flash');
      }, 300);
    }

    

    function updatePilotOptions() {
      if (isSelectingPilot) { pendingPilotOptionsUpdate = true; return; }
      if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) { try { setPilotSelectLoading(true, 'Cargando pilotos...'); } catch(e) {} return; }
      const currentKey = selectedPilotKey;

      const signature = raceData.classification
        .map(r => getPilotKey(r) + '::' + safeRacerName(r.racerName))
        .sort()
        .join('|');

      if (signature === lastPilotOptionsSignature) {
        if (currentKey) {
          const exists = raceData.classification.some(r => getPilotKey(r) === currentKey);
          if (!exists) {
            pilotSelect.value = '';
            selectedPilotKey = '';
          } else {
            pilotSelect.value = currentKey;
          }
        } else {
          pilotSelect.value = '';
        }
        return;
      }

      lastPilotOptionsSignature = signature;

      const options = [];
      options.push({ value: '', label: 'Sin piloto seleccionado' });

      raceData.classification.forEach(row => {
        const key = getPilotKey(row);
        const name = safeRacerName(row.racerName) || '(sin nombre)';
        const label = name;
        options.push({ value: key, label });
      });

      try { localStorage.setItem('aiSpotterPilotOptionsCache', JSON.stringify({ ts: Date.now(), raceName: String((raceData && raceData.raceName) || ''), options })); } catch(e) {}
      try { setPilotSelectLoading(false); } catch(e) {}

      pilotSelect.innerHTML = '';
      options.forEach(optData => {
        const opt = document.createElement('option');
        opt.value = optData.value;
        opt.textContent = optData.label;
        pilotSelect.appendChild(opt);
      });

      if (currentKey) {
        const exists = raceData.classification.some(r => getPilotKey(r) === currentKey);
        if (exists) {
          pilotSelect.value = currentKey;
          selectedPilotKey = currentKey;
        } else {
          pilotSelect.value = '';
          selectedPilotKey = '';
        }
      } else {
        pilotSelect.value = '';
      }
    }

    pilotSelect.addEventListener('focus', () => {
      isSelectingPilot = true;
    });
    pilotSelect.addEventListener('blur', () => {
      isSelectingPilot = false;
      if (pendingPilotOptionsUpdate) {
        pendingPilotOptionsUpdate = false;
        setTimeout(() => { try { updatePilotOptions(); } catch(e) {} }, 0);
      }
    });

        function resetSelectedPilotTrackingState() {
      // NO detener el reloj de MANGA aqu: el cronmetro es por piloto y debe persistir al cambiar seleccin.
      lastSpokenLastTime = null;
          lastAnnouncedLapcount = 0;
          lastKnownPos = null;
          lastTotalTimeAnnouncedSeconds = 0;
          lastBestAnnouncedMs = null;
          lastBestAnnouncedLap = 0;
          lastTrendSpokenLap = 0;
          lastAheadAlertMs = 0;
          lastAutoSummaryAnnouncedSeconds = 0;

          attackLatch  = { active:false, otherKey:'', lap:-1 };
          defenseLatch = { active:false, otherKey:'', lap:-1 };
          fightLatch   = { active:false, lap:-1 };
          startPosForSelected = null;
          lastNetGainValue = null;
          lastNetGainSpokenLap = 0;
          lastLeaderGapSpokenLap = 0;
          lastPodiumSpokenLap = 0;
        }

        function ensurePilotOptionExists(key) {
          if (!pilotSelect || !key) return;
          for (let i = 0; i < pilotSelect.options.length; i++) {
            if (pilotSelect.options[i].value === key) return;
          }
          let label = key;
          try {
            if (raceData && Array.isArray(raceData.classification)) {
              const p = raceData.classification.find(r => getPilotKey(r) === key);
              if (p) {
                const name = safeRacerName(p.racerName) || '(sin nombre)';
                label = name;
              }
            }
          } catch(e) {}
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = label;
          pilotSelect.appendChild(opt);
        }

        
        // =========================
        // Persistencia: uúltimo piloto seleccionado
        // - Guarda y restaura automaticamente la uúltima seleccion (por dispositivo)
        // - Si el piloto no existe en la carrera actual, no selecciona nada
        // =========================
        function restoreLastPilotSelectionIfNeeded() {
          try {
            if (selectedPilotKey) return;
            const saved = normalizePilotKey(localStorage.getItem('aiSpotterLastPilotKey') || '');
            if (!saved) return;
            if (!raceData || !raceData.classification || !raceData.classification.length) return;
            const exists = raceData.classification.some(r => getPilotKey(r) === saved);
            if (!exists) return;
            // Asegura que el option exista en el select antes de seleccionar
            if (typeof ensurePilotOptionExists === 'function') ensurePilotOptionExists(saved);
            selectPilotByKey(saved, { announce:false, source:'restore' });
          } catch(e) {}
        }



function showToast(msg, ms=1400){
  try{
    const el = document.getElementById('toast');
    if(!el) return;
    el.textContent = String(msg||'');
    el.classList.add('on');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>{ try{el.classList.remove('on');}catch(e){} }, ms);
  }catch(e){}
}

function selectPilotByKey(key, opts = {}) {
          const k = normalizePilotKey(key || '');
          const announce = (opts.announce !== false);

          selectedPilotKey = k;
          try {
            const __src = (opts && opts.source) ? String(opts.source) : '';
            const __manual = (__src === 'select' || __src === 'manual');
            if (k) {
              localStorage.setItem('aiSpotterLastPilotKey', k);
            } else if (__manual) {
              // Si el usuario eligio manualmente Auto Locutor, si se limpia la preferencia.
              // Si fue fallback automatico (ej. piloto no esta en esta carrera), NO se borra.
              localStorage.setItem('aiSpotterLastPilotKey', '');
            }
          } catch(e) {}
          selectedPilotFirstDetectBeeped = !!firstDetectBeepedByPilot.get(k);
          pendingAutoVoiceUnlock = false; // solo se activa cuando el TTS se bloquea

          if (pilotSelect) {
            if (k) ensurePilotOptionExists(k);
            pilotSelect.value = k || '';
          }

          resetSelectedPilotTrackingState();

          if (k) {
            // FOLLOW: por defecto BÁSICO OFF al elegir piloto (el usuario lo puede encender)
            try { basicModeEnabled = false; prefSet('basicModeEnabled','0'); _updateBasicBtnUI(); } catch(e) {}

            // MANGA: NO inicia reloj al seleccionar (solo muestra UI)
            try { onPilotSelectedManga(k); } catch(e) {}
          } else {
            // Modo locutor: sin piloto seleccionado
            try { basicModeEnabled = false; prefSet('basicModeEnabled','0'); _updateBasicBtnUI(); } catch(e) {}
            try { resetAutoCommentatorState();
        if (announce){
          try { showToast('AUTO LOCUTOR activo', { tone: 'info' }); } catch(e) {}
          try { if (voiceMasterEnabled) speakText('Auto locutor activado'); } catch(e) {}
        } } catch(e) {}

            // UI/voz: avisar que estas en Auto Locutor
            try {
              if ((opts && opts.source === 'select') || (opts && opts.source === 'restore')) {
                showToast('Auto Locutor activo');
                if (announce && voiceMasterEnabled) {
                  speakText('Auto locutor activado');
                }
              }
            } catch(e) {}
          }

          // AI Spotter: en cuanto cambia la seleccin, recalcula perfil (Seguimiento vs Auto)
          try { applySmartProfile(currentSessionInfo, 'pilot-select'); } catch(e) {}
          try { _updateBasicBtnUI(); } catch(e) {}

          if (!raceData || !k) {
            renderPilotCard(null);
        try { renderAutoTop3MiniGrid(); } catch(e) {}
        try { checkSessionFinishOnLap(); } catch(e) {}
            return;
          }
          const p = raceData.classification.find(r => getPilotKey(r) === k);
          renderPilotCard(p || null);
          try { renderAutoTop3MiniGrid(); } catch(e) {}
          if (p && p.pos && p.pos > 0) { startPosForSelected = p.pos; lastNetGainValue = 0; }
          if (announce && p && voiceMasterEnabled) {
            try { forceTtsRecover('pilot-select'); } catch(e) {}
            speakText('Siguiendo a ' + safeRacerName(p.racerName), { priority: 'high', dedupe: false, semantic: false, cooldownMs: 0, key: 'pilot-follow' });
          }
        }

        

// MANGA: NO inicia el reloj al seleccionar.
// El reloj por piloto inicia en su 1er cruce por meta (lapcount pasa de 0 -> 1).
function onPilotSelectedManga(pilotKey) {
  try {
    const pk = (pilotKey || '').toLowerCase().trim();
    if (!pk) return;

    // Asegura session info actual
    try {
      if (raceData && raceData.raceName) {
        currentSessionInfo = parseSessionFromRaceName(raceData.raceName);
       try { applyLapChartPreset(); } catch(e) {}
try { maybeAutoApplySessionPreset(currentSessionInfo); } catch(e) {}
      }
    } catch(e) {}

    const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
    if (!isManga) return;

    // Solo UI: mostrar reloj, pero NO definir inicio aqu
    setMangaClockVisible(true);
    updateMangaClockDisplay();

    // Si ya arranc por cruce (ej. seleccionas tarde), enciende ticker
    if (mangaPilotStartAt.get(pk)) {
      ensureMangaClockTicker();
    }
  } catch(e) {}
}

pilotSelect.addEventListener('change', () => {
          selectPilotByKey(pilotSelect.value || '', { source:'select', announce:true });
        });

        pilotSelect.addEventListener('input', () => {
          // iOS a veces dispara input antes de change
          selectPilotByKey(pilotSelect.value || '', { source:'select', announce:false });
        });

    function findPilotIndexByKey(key) {
      if (!raceData || !Array.isArray(raceData.classification)) return -1;
      return raceData.classification.findIndex(r => getPilotKey(r) === key);
    }

    // =========================
    // GAP lapDiff guard (anti "1 vuelta" fantasma)
    // - Solo hablamos de diferencia de vueltas si se repite estable en 2 lecturas
    // =========================
    const lapDiffSpeakGuard = new Map();
    function lapDiffGuardAllow(pairKey, lapDiff) {
      try {
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const st = lapDiffSpeakGuard.get(pairKey) || { last: null, count: 0, firstMs: 0 };
        if (st.last !== lapDiff) {
          st.last = lapDiff;
          st.count = 1;
          st.firstMs = now;
          lapDiffSpeakGuard.set(pairKey, st);
          return false;
        }
        st.count = (st.count || 0) + 1;
        lapDiffSpeakGuard.set(pairKey, st);
        if (st.count >= 2) return true;
        if ((now - (st.firstMs || 0)) >= 1200) return true;
        return false;
      } catch(e) {
        return false;
      }
    }

    function buildGapSummaryForPilotIndex(idx) {
      if (!raceData || !Array.isArray(raceData.classification)) return null;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length) return null;

      const me = arr[idx];
      const ahead = idx > 0 ? arr[idx - 1] : null;
      const behind = idx < arr.length - 1 ? arr[idx + 1] : null;

      function diffTexto(me, other, direction) {
        if (!me || !other || me.time == null || other.time == null) return null;

        const meLaps = (me.lapcount != null) ? me.lapcount : 0;
        const otherLaps = (other.lapcount != null) ? other.lapcount : 0;
        const lapDiff = meLaps - otherLaps;

        // Si hay diferencia de vueltas, dilo como "ms una vuelta" (sin nombres).
        if (lapDiff !== 0) {

          // Guard: evitar glitches de lapcount en lecturas pegadas

          const expectedOk = (direction === 'ahead') ? (lapDiff <= 0) : (lapDiff >= 0);

          if (!expectedOk) {

            // Inconsistente: tratamos como mismo giro y seguimos con segundos

          } else {

            const meKey = getPilotKey(me) || (me.racerName || 'me');

            const otherKey = getPilotKey(other) || (other.racerName || 'other');

            const pairKey = meKey + '|' + otherKey + '|' + direction;

            if (!lapDiffGuardAllow(pairKey, lapDiff)) return null;

            const v = Math.abs(lapDiff);

            const palabra = (v === 1) ? 'una vuelta' : (v + ' vueltas');

            if (direction === 'ahead') return 'Gap con ' + (other.racerName || 'adelante') + ' ms ' + palabra;

            return 'Gap con ' + (other.racerName || 'atrs') + ' ms ' + palabra;

          }
        }
        const diffMs = Math.abs(me.time - other.time);
        if (!diffMs || diffMs <= 0) {
          if (direction === 'ahead') return 'Diferencia adelante pegados';
          return 'Diferencia atrs pegados';
        }

        const secStr = gapToSpeech((diffMs / 1000), 'pilotgaps');
        if (direction === 'ahead') return 'Gap con ' + (other.racerName || 'adelante') + ' ' + secStr;
        return 'Gap con ' + (other.racerName || 'atrs') + ' ' + secStr;
      }

      const parts = [];
      if (ahead) {
        const t = diffTexto(me, ahead, 'ahead');
        if (t) parts.push(t);
      }
      if (behind) {
        const t = diffTexto(me, behind, 'behind');
        if (t) parts.push(t);
      }
      if (!parts.length) return null;
      return parts.join('. ');
    }

    function getFrontBackContext(idx) {
      if (!raceData || !Array.isArray(raceData.classification)) return null;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length) return null;

      const me = arr[idx];
      const ahead = idx > 0 ? arr[idx - 1] : null;
      const behind = idx < arr.length - 1 ? arr[idx + 1] : null;

      const meLaps = (me && me.lapcount != null) ? Number(me.lapcount) || 0 : 0;

      const wordToNum = (w) => {
        const map = { 'una':1,'un':1,'uno':1,'dos':2,'tres':3,'cuatro':4,'cinco':5,'seis':6,'siete':7,'ocho':8,'nueve':9,'diez':10 };
        return map[w] || NaN;
      };

      const parseDiff = (raw) => {
        try{
          const s0 = String(raw || '').trim();
          if (!s0 || s0 === '-' || s0 === '') return { sec: null, laps: null };
          const mV = s0.match(/([+-]?\s*\d+)\s*v/i);
          if (mV){
            const n = parseInt(String(mV[1]).replace(/\s+/g,''),10);
            if (isFinite(n)) return { sec: null, laps: Math.abs(n) };
          }
          const s = s0.toLowerCase();
          const mMas = s.match(/m[a]s\s+(\d+|una|un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s+vueltas?/i);
          if (mMas){
            const tok = mMas[1];
            const n = /^\d+$/.test(tok) ? parseInt(tok,10) : wordToNum(tok);
            if (isFinite(n) && n > 0) return { sec: null, laps: n };
          }
          if (s0.includes(':')){
            const parts = s0.split(':');
            if (parts.length >= 2){
              const mm = parseFloat(parts[0].replace(/[^0-9.]/g,''));
              const sec = parseFloat(parts.slice(1).join(':').replace(/[^0-9.]/g,''));
              if (isFinite(mm) && isFinite(sec)) return { sec: Math.abs((mm*60)+sec), laps: null };
            }
          }
          const f = parseFloat(s0.replace(/[^0-9.+-]/g,''));
          if (isFinite(f)) return { sec: Math.abs(f), laps: null };
          return { sec: null, laps: null };
        }catch(e){
          return { sec: null, laps: null };
        }
      };

      let frontSec = null, backSec = null;
      let frontKey = '', backKey = '';
      let frontName = '', backName = '';
      let sameFrontLap = false, sameBackLap = false;

      if (ahead && me) {
        const meDiff = (me.diff != null ? me.diff : (me.interval != null ? me.interval : ''));
        const info = parseDiff(formatoGapVueltas(meDiff) || meDiff);
        const aLaps = (ahead.lapcount != null) ? Number(ahead.lapcount) || 0 : 0;

        if (info.laps != null) {
          sameFrontLap = false;
          frontSec = null;
        } else if (info.sec != null && isFinite(info.sec)) {
          sameFrontLap = true;
          frontSec = info.sec;
        } else {
          sameFrontLap = (aLaps === meLaps && meLaps > 0);
          if (sameFrontLap && me.time != null && ahead.time != null) {
            const diffMs = Number(me.time) - Number(ahead.time);
            if (diffMs && diffMs > 0) frontSec = diffMs / 1000;
          }
        }
        frontKey = getPilotKey(ahead) || ahead._id || ahead.racerName || String(idx - 1);
        frontName = ahead.racerName || '';
      }

      if (behind && me) {
        const bDiff = (behind.diff != null ? behind.diff : (behind.interval != null ? behind.interval : ''));
        const infoB = parseDiff(formatoGapVueltas(bDiff) || bDiff);
        const bLaps = (behind.lapcount != null) ? Number(behind.lapcount) || 0 : 0;

        if (infoB.laps != null) {
          sameBackLap = false;
          backSec = null;
        } else if (infoB.sec != null && isFinite(infoB.sec)) {
          sameBackLap = true;
          backSec = infoB.sec;
        } else {
          sameBackLap = (bLaps === meLaps && meLaps > 0);
          if (sameBackLap && me.time != null && behind.time != null) {
            const diffMs = Number(behind.time) - Number(me.time);
            if (diffMs && diffMs > 0) backSec = diffMs / 1000;
          }
        }
        backKey = getPilotKey(behind) || behind._id || behind.racerName || String(idx + 1);
        backName = behind.racerName || '';
      }

      // DUEL (EMA + histeresis)
      const meKey = getPilotKey(me) || (me && (me._id || me.racerName)) || String(idx);
      let st = duelStateByPilotKey.get(meKey);
      if (!st) st = { frontEma:null, backEma:null, active:false, kind:'' };
      const ema = (prev, x) => (prev == null || !isFinite(prev)) ? x : (DUEL_EMA_ALPHA * x + (1 - DUEL_EMA_ALPHA) * prev);

      let frontSecEma = null;
      let backSecEma  = null;

      if (sameFrontLap && frontSec != null && isFinite(frontSec)) {
        st.frontEma = ema(st.frontEma, frontSec);
        frontSecEma = st.frontEma;
      } else {
        st.frontEma = null;
      }

      if (sameBackLap && backSec != null && isFinite(backSec)) {
        st.backEma = ema(st.backEma, backSec);
        backSecEma = st.backEma;
      } else {
        st.backEma = null;
      }

      let preferred = '';
      let duelSec = null;
      if (frontSecEma != null && backSecEma != null) {
        preferred = (frontSecEma <= backSecEma) ? 'ATTACK' : 'DEFEND';
        duelSec = Math.min(frontSecEma, backSecEma);
      } else if (frontSecEma != null) {
        preferred = 'ATTACK';
        duelSec = frontSecEma;
      } else if (backSecEma != null) {
        preferred = 'DEFEND';
        duelSec = backSecEma;
      }

      // Histeresis
      if (st.active) {
        if (st.kind === 'ATTACK') {
          if (!sameFrontLap || frontSecEma == null || frontSecEma >= DUEL_EXIT_ATTACK_SEC) st.active = false;
        } else if (st.kind === 'DEFEND') {
          if (!sameBackLap || backSecEma == null || backSecEma >= DUEL_EXIT_DEFEND_SEC) st.active = false;
        } else {
          if (duelSec == null || duelSec >= 0.70) st.active = false;
        }
      }

      if (!st.active) {
        if (preferred === 'ATTACK' && frontSecEma != null && sameFrontLap && frontSecEma <= DUEL_ENTER_SEC) {
          st.active = true;
          st.kind = 'ATTACK';
        } else if (preferred === 'DEFEND' && backSecEma != null && sameBackLap && backSecEma <= DUEL_ENTER_SEC) {
          st.active = true;
          st.kind = 'DEFEND';
        } else {
          st.kind = preferred || st.kind || '';
        }
      } else {
        // Permite cambio de rol solo si la diferencia es clara (evita flip-flop)
        if (preferred && preferred !== st.kind && frontSecEma != null && backSecEma != null) {
          if (Math.abs(frontSecEma - backSecEma) >= 0.12) st.kind = preferred;
        } else if (preferred && preferred !== st.kind && (frontSecEma == null || backSecEma == null)) {
          st.kind = preferred;
        }
      }

      duelStateByPilotKey.set(meKey, st);

      const duelActive = !!st.active;
      const duelKind = duelActive ? st.kind : (preferred || '');
      const duelGapSec = duelActive ? (duelKind === 'ATTACK' ? frontSecEma : (duelKind === 'DEFEND' ? backSecEma : duelSec)) : duelSec;

      return {
        me, ahead, behind,
        meLaps,
        frontSec, backSec,
        frontSecEma, backSecEma,
        duelActive, duelKind, duelGapSec,
        frontKey, backKey,
        frontName, backName,
        sameFrontLap, sameBackLap
      };
    }

    function checkBehindAlertForPilotIndex(idx) {

      if (!raceData || !Array.isArray(raceData.classification)) return;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length - 1) return;

      const me = arr[idx];
      const behind = arr[idx + 1];
      if (!me || !behind || !me.time || !behind.time) return;

      const meLaps = me.lapcount != null ? me.lapcount : 0;
      const behindLaps = behind.lapcount != null ? behind.lapcount : 0;

      // Si estn en distinta vuelta, liberamos latch (y no avisamos)
      if (meLaps !== behindLaps) {
        behind06Latch.active = false;
        return;
      }

      const diffMs = behind.time - me.time;
      if (!diffMs || diffMs <= 0) return;

      const sec = diffMs / 1000;

      // Histeresis: solo rearmamos cuando se libera bien el gap
      const otherKey = behind._id || behind.racerName || String(idx + 1);

      if (behind06Latch.active) {
        // Si cambia el rival o cambia la vuelta o ya se liber el gap, se rearma
        if (behind06Latch.otherKey !== otherKey || sec >= 0.80) {
          behind06Latch.active = false;
        } else {
          return; // sigue activo: NO repetir
        }
      }

      if (sec >= 0.6) return;

      const secStr = toFixedFloor(sec, decimalPrecision);
      const nombreDetras = behind.racerName || '';
      if (nombreDetras) {
        speakWithLaps(meLaps, 'Cuidado, ' + nombreDetras + ' viene atrs a ' + secStr + ' segundos', { key: 'back06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      } else {
        speakWithLaps(meLaps, 'Cuidado, traes un piloto atrs a ' + secStr + ' segundos', { key: 'back06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      }

      behind06Latch.active = true;
      behind06Latch.otherKey = otherKey;
      behind06Latch.lap = meLaps;

      const ahora = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      lastBehindAlertMs = ahora;
    }
    function checkAheadAlertForPilotIndex(idx) {

      if (!raceData || !Array.isArray(raceData.classification)) return;
      const arr = raceData.classification;
      if (idx <= 0 || idx >= arr.length) return;

      const me = arr[idx];
      const ahead = arr[idx - 1];
      if (!me || !ahead || !me.time || !ahead.time) return;

      const meLaps = me.lapcount != null ? me.lapcount : 0;
      const aheadLaps = ahead.lapcount != null ? ahead.lapcount : 0;

      if (meLaps !== aheadLaps) {
        ahead06Latch.active = false;
        return;
      }

      const diffMs = me.time - ahead.time;
      if (!diffMs || diffMs <= 0) return;

      const sec = diffMs / 1000;
      const otherKey = ahead._id || ahead.racerName || String(idx - 1);

      if (ahead06Latch.active) {
        if (ahead06Latch.otherKey !== otherKey || sec >= 0.80) {
          ahead06Latch.active = false;
        } else {
          return;
        }
      }

      if (sec >= 0.6) return;

      const secStr = toFixedFloor(sec, decimalPrecision);
      const nombreAdelante = ahead.racerName || '';
      if (nombreAdelante) {
        speakWithLaps(meLaps, 'Lo traes a tiro. ' + nombreAdelante + ' adelante a ' + secStr + ' segundos', { key: 'front06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      } else {
        speakWithLaps(meLaps, 'Lo traes a tiro. Adelante a ' + secStr + ' segundos', { key: 'front06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      }

      ahead06Latch.active = true;
      ahead06Latch.otherKey = otherKey;
      ahead06Latch.lap = meLaps;

      const ahora = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      lastAheadAlertMs = ahora;
      }

function updateBlueFlagFromPassEvents() {
      try {
        if (!raceData || !Array.isArray(raceData.classification) || !selectedPilotKey) return;
        if (!lastPassEvents || typeof lastPassEvents.get !== 'function') return;
        if (typeof voiceSettings !== 'undefined' && voiceSettings && voiceSettings.blueflag === false) return;

        // Bandera azul por proximidad real de cruce (0.8s fijo) + considera P1/P2/P3 cuando lapean.
        // Se dispara solo cuando el lapeador (Top3) pasa MUY cerca por meta DESPUES del rezagado
        // y ya trae al menos +1 vuelta (lapDiff>=1). Evita falsos por el salto a "+1" cuando estan lejos.
        const BLUE_PROX_MS = 800;
        const sessionType = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
        const isFinal = (sessionType === 'FINAL');

        const arr = raceData.classification.slice().filter(r => r && (r.pos != null));
        if (!arr.length) return;
        arr.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));

        const top3 = arr.filter(r => {
          const p = Number(r.pos)||999;
          return p >= 1 && p <= 3;
        }).slice(0,3);
        if (!top3.length) return;

        const selEvent = lastPassEvents.get(selectedPilotKey);
        if (!selEvent || !isFinite(selEvent.time)) return;

        const selLap = Number(selEvent.lap) || 0;
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

        let best = null;
        for (const laper of top3) {
          if (!laper) continue;
          const lk = getPilotKey(laper);
          if (!lk) continue;
          const le = lastPassEvents.get(lk);
          if (!le || !isFinite(le.time)) continue;
          if (le.time <= selEvent.time) continue; // laper paso antes o igual, no viene detras

          const delta = le.time - selEvent.time;
          if (delta <= 0 || delta > BLUE_PROX_MS) continue;

          const laperLap = Number(le.lap) || 0;
          const lapDiff = laperLap - selLap;
          if (lapDiff < 1) continue; // no hay lapeo confirmado

          if (!best || delta < best.delta) {
            best = { laper, lk, le, delta, laperLap, lapDiff };
          }
        }
        if (!best) return;

        // Confirmacion anti-jitter (2 hits cercanos con mismo par y misma vuelta del rezagado)
        const samePair = (blueFlagConfirm.pilotKey === selectedPilotKey && blueFlagConfirm.leaderKey === best.lk && blueFlagConfirm.lap === selLap);
        if (samePair && (now - (blueFlagConfirm.t || 0)) <= 2600) {
          blueFlagConfirm.hits = (blueFlagConfirm.hits || 0) + 1;
          blueFlagConfirm.t = now;
        } else {
          blueFlagConfirm = { pilotKey: selectedPilotKey, leaderKey: best.lk, lap: selLap, hits: 1, t: now };
        }
        if ((blueFlagConfirm.hits || 0) < 2) return;

        // Cooldowns: una vez cada 2 vueltas del lapeador y no repetir en la misma vuelta del rezagado
        if (selLap && selLap <= lastBlueFlagPilotLap) { blueFlagConfirm.hits = 0; return; }
        if (best.laperLap && (best.laperLap - lastBlueFlagLeaderLap) < 2) { blueFlagConfirm.hits = 0; return; }
        const laperPos = Number(best.laper.pos) || 0;
        const laperName = (best.laper && (best.laper.racerName || best.laper.name || best.laper.pilotName)) || '';
        const laperNameClean = String(laperName).replace(/\s+/g,' ').trim();
        if (!laperNameClean) return;
        const who = (laperPos === 1) ? ('el líder P1 ' + laperNameClean) : ('P' + laperPos + ' ' + laperNameClean);

        pendingBlueFlagForPilotKey = selectedPilotKey;
        pendingBlueFlagMessage = msgv2Compose('blueflag', { who: who, isFinal: !!isFinal, pilotKey: (typeof selectedPilotKey !== 'undefined' ? selectedPilotKey : '') });
        lastBlueFlagPilotLap = selLap || lastBlueFlagPilotLap;
        lastBlueFlagLeaderLap = best.laperLap || lastBlueFlagLeaderLap;
        blueFlagConfirm.hits = 0;

      } catch (e) {
        console.error('Error en updateBlueFlagFromPassEvents', e);
      }
    }

    function updateLapHistoryAll() {
      try {
        if (!raceData || !Array.isArray(raceData.classification)) return;

        for (const p of raceData.classification) {
          const key = getPilotKey(p);
          if (!key) continue;

          const lapsNow = Number(p.lapcount) || 0;

          // Tiempo total del piloto (string "02:01.964" o ms/seg)
          const totalNowMs = parseTimeToMs(
            (typeof p.time !== 'undefined' ? p.time :
             (typeof p.totalTime !== 'undefined' ? p.totalTime :
              (typeof p.totalMs !== 'undefined' ? p.totalMs :
               (typeof p.totalTimeMs !== 'undefined' ? p.totalTimeMs :
                (typeof p.estTime !== 'undefined' ? p.estTime : 0)))))
          );

          let hist = lapHistory.get(key);
          if (!hist) hist = { lastLapcount: 0, lastTotalLapMs: 0, times: [], marks: [], bestMs: 0 };

          // Reset por re-arranque / cambio de heat sin cambiar raceName (o data rara)
          if (lapsNow < (hist.lastLapcount || 0)) {
            hist.lastLapcount = lapsNow;
            hist.lastTotalLapMs = (totalNowMs && isFinite(totalNowMs) && totalNowMs > 0) ? totalNowMs : 0;
            hist.times = [];
            hist.marks = [];
            hist.bestMs = 0;
            lapHistory.set(key, hist);
            continue;
          }

          // Nueva(s) vuelta(s)
          if (lapsNow > (hist.lastLapcount || 0)) {
            const diffLaps = lapsNow - (hist.lastLapcount || 0);

            const lastTimeMs = normalizeLapMs(parseTimeToMs(
              (typeof p.lastTime !== 'undefined' ? p.lastTime :
               (typeof p.lastLap !== 'undefined' ? p.lastLap :
                (typeof p.lastLapMs !== 'undefined' ? p.lastLapMs : 0)))
            ));

            const pushLap = (ms) => {
              if (!ms) return;
              hist.times.push(ms);
              if (!hist.marks) hist.marks = [];
              hist.marks.push(null);
              while (hist.times.length > 180) hist.times.shift();
              while (hist.marks.length > 180) hist.marks.shift();
              if (!hist.bestMs || ms < hist.bestMs) hist.bestMs = ms;
            };

            let didPush = false;

            // 1) Prioridad: lastTime del feed (mejor para Lap Chart y marcas)
            if (lastTimeMs && isFinite(lastTimeMs) && lastTimeMs > 0) {
              const pushN = Math.min(Math.max(1, diffLaps), 6);
              for (let i = 0; i < pushN; i++) pushLap(lastTimeMs);
              didPush = true;
            }

            // 2) Fallback: delta de tiempo total distribuido (si el feed brinc y no trae lastTime confiable)
            if (!didPush && hist.lastTotalLapMs && totalNowMs && isFinite(totalNowMs) && totalNowMs > hist.lastTotalLapMs) {
              const deltaMs = totalNowMs - hist.lastTotalLapMs;
              const nLaps = Math.max(1, diffLaps);
              const avgLapMs = normalizeLapMs(Math.round(deltaMs / nLaps));
              if (avgLapMs) {
                const pushN = Math.min(nLaps, 6);
                for (let i = 0; i < pushN; i++) pushLap(avgLapMs);
              }
            }

            hist.lastLapcount = lapsNow;
          }

          // Siempre actualiza el total para el siguiente delta (aunque no haya nueva vuelta)
          if (typeof totalNowMs === 'number' && isFinite(totalNowMs) && totalNowMs > 0) {
            hist.lastTotalLapMs = totalNowMs;
          }

          lapHistory.set(key, hist);
        }
      } catch (e) {
        console.error('updateLapHistoryAll', e);
      }
    }

    // =========================
    // LOCUTOR AUTO (cuando NO hay piloto seleccionado)
    // Objetivo:
    // - Decidir QUE vale la pena decir (scoring)
    // - Decirlo con variedad (frases)
    // - No saturar (rate limit + dedupe)
    // =========================

const commentatorAutoCfg = {
  // Calma por defecto: el Auto Locutor solo debe hablar cuando hay "acción real".
  // Subimos el filtro para que NO se amontonen mensajes viejos ni comentarios de relleno.
  minIntervalMs: 14500,
  windowMs: 70000,
  maxMsgsInWindow: 2,
  sigDefaultCooldownMs: 32000,
  top3CooldownMs: 42000,
  allowUrgentOverLimitScore: 9.4,
  baseThresholdScore: 5.2,
  quietMinMs: 38000,// mini resumen 38-52s,
  quietMaxMs: 52000
};

    let commentatorAutoState = {
      lastSpeakMs: 0,
      lastBasicSpeakMs: 0,
      window: [],
      recentSig: new Map(),
      prevPosByKey: new Map(),
      prevKeyByPos: [],
      lastLeaderKey: '',
      lastLeaderLap: 0,
      lastQuietMs: 0,
      lastTop3Ms: 0,
      lastTop3Sig: '',
      lastMilestone: 0,
      nextQuietCooldownMs: 0,
      lastTop5Sig: '',
      stableTop5Laps: 0,
      lastTop5Lap: 0,
      bestOverallRaceMs: null,
      bestOverallRaceKey: '',
      lastRecordSpeakMs: 0
    };

    function autoGapTextFromLapDiff(lapDiff) {
      if (!lapDiff || lapDiff <= 0) return '';
      // Voz compacta: 'a 1V', 'a 2V'
      return 'a ' + String(lapDiff) + 'V';
    }

    function autoPairKey(aKey, bKey) {
      return String(aKey || '') + '::' + String(bKey || '');
    }

    function clamp01(x) {
      if (!isFinite(x)) return 0;
      if (x < 0) return 0;
      if (x > 1) return 1;
      return x;
    }

    
// Auto Locutor: shuffle bag anti repeticin (evita "me dijo eso hace 2 segundos")
const autoPhraseBag = new Map();

function autoShuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
  }
  return arr;
}

function autoRandPick(list, key) {
  try {
    if (!Array.isArray(list) || !list.length) return null;
    const k = String(key || 'auto');
    let st = autoPhraseBag.get(k);
    if (!st || !Array.isArray(st.bag) || st.srcLen !== list.length) {
      st = { bag: [], recent: [], srcLen: list.length };
    }

    const RECENT_N = Math.min(5, Math.max(2, Math.floor(list.length / 4)));

    if (!st.bag.length) {
      const idxs = [];
      for (let i = 0; i < list.length; i++) idxs.push(i);
      autoShuffleInPlace(idxs);

      if (st.recent && st.recent.length && list.length > (st.recent.length + 2)) {
        const rec = new Set(st.recent);
        const a = idxs.filter(i => !rec.has(i));
        const b = idxs.filter(i =>  rec.has(i));
        st.bag = a.concat(b);
      } else {
        st.bag = idxs;
      }
    }

    const pickIdx = st.bag.shift();
    st.recent = st.recent || [];
    st.recent.push(pickIdx);
    while (st.recent.length > RECENT_N) st.recent.shift();
    autoPhraseBag.set(k, st);

    return list[pickIdx % list.length];
  } catch(e) { return null; }
}

    function autoFmtSec(sec) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      return String(toFixedFloor(s, decimalPrecision));
    }

    // ========================================================
    // GAP SPEECH (TV style): frases condicionales por rangos
    // - < 1s: dcimas y frases tipo "a menos de tres dcimas"
    // - >= 1s: segundos con "a", "a menos de", "a ms de" y buckets de 0.5s
    // ========================================================
    function gapNumWord(n) {
      const m = {
        0:'cero',1:'uno',2:'dos',3:'tres',4:'cuatro',5:'cinco',6:'seis',7:'siete',8:'ocho',9:'nueve',
        10:'diez',11:'once',12:'doce',13:'trece',14:'catorce',15:'quince',16:'dieciseis',17:'diecisiete',18:'dieciocho',19:'diecinueve',
        20:'veinte',21:'veintiuno',22:'veintidos',23:'veintitres',24:'veinticuatro',25:'veinticinco',
        30:'treinta',35:'treinta y cinco',40:'cuarenta',45:'cuarenta y cinco',50:'cincuenta',55:'cincuenta y cinco',60:'sesenta'
      };
      const k = Number(n);
      return m[k] || String(k);
    }

    function gapHalfLabel(base) {
      const b = Number(base);
      if (!isFinite(b) || b <= 0) return '';
      const whole = Math.floor(b + 1e-9);
      const isHalf = Math.abs(b - (whole + 0.5)) < 1e-6;

      // 1.x es especial
      if (whole === 1 && !isHalf) return 'un segundo';
      if (whole === 1 && isHalf) return 'un segundo y medio';

      // 2.x: "dos segundos" / "dos y medio"
      if (whole === 2 && !isHalf) return 'dos segundos';
      if (whole === 2 && isHalf) return 'dos y medio';

      // 3+ : "tres segundos" / "tres y medio"
      const w = gapNumWord(whole);
      return isHalf ? (w + ' y medio') : (w + ' segundos');
    }

    function gapSmallSpeech(sec, bagKey) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      const key = String(bagKey || 'gap') + ':<1:' + Math.floor(s * 100);

      const pick = (arr) => {
        const v = autoRandPick(arr, key);
        return String(v || '').trim();
      };

      if (s < 0.12) {
        return pick(['a nada', 'a menos de una dcima', 'pegadsimo, a nada']);
      }
      if (s < 0.25) {
        return pick(['a menos de dos dcimas', 'a poco ms de una dcima', 'a dos dcimas']);
      }
      if (s < 0.35) {
        return pick(['a menos de tres dcimas', 'a tres dcimas', 'a unas tres dcimas']);
      }
      if (s < 0.45) {
        return pick(['a menos de cinco dcimas', 'a cuatro dcimas', 'a menos de medio segundo']);
      }
      if (s < 0.55) {
        return pick(['a medio segundo', 'a cinco dcimas', 'a medio segundo cerrado']);
      }
      if (s < 0.75) {
        return pick(['a menos de ocho dcimas', 'a siete dcimas', 'a menos de un segundo']);
      }
      return pick(['a menos de un segundo', 'a menos de un segundo clavado', 'a un segundo menos']);
    }

    function gapLargeSpeech(sec) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      // buckets de 5s para no aburrir
      const b = Math.max(10, Math.floor(s / 5) * 5);
      const w = gapNumWord(b);
      return 'a ms de ' + w + ' segundos';
    }

    function gapToSpeech(sec, bagKey) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      if (s < 1) return gapSmallSpeech(s, bagKey);
      if (s >= 10) return gapLargeSpeech(s);

      const bucket = Math.round(s * 2) / 2; // 0.5s
      const label = gapHalfLabel(bucket);
      if (!label) return '';
      const eps = 0.08;

      if (Math.abs(s - bucket) <= eps) return 'a ' + label;
      if (s < (bucket - eps)) return 'a menos de ' + label;
      return 'a ms de ' + label;
    }

    function gapToSpeechBare(sec, bagKey) {
      const s = gapToSpeech(sec, bagKey);
      if (!s) return '';
      const ss = String(s).trim();
      // Si empieza con "a ", quitamos solo ese prefijo para evitar "a a ..."
      if (ss.toLowerCase().startsWith('a ')) return ss.slice(2).trim();
      return ss;
    }

    function gapDeltaSpeech(deltaSec) {
      const d = Number(deltaSec);
      if (!isFinite(d) || d <= 0) return '';
      // delta se dice sin "a"
      if (d < 0.15) return 'una dcima';
      if (d < 0.35) return 'un par de dcimas';
      if (d < 0.60) return 'medio segundo';
      const bucket = Math.round(d * 2) / 2;
      return gapHalfLabel(bucket) || '';
    }

    function autoRaceProgress(leaderLap) {
      const total = Number(raceData && raceData.lapCount);
      if (!isFinite(total) || total <= 0) return 0;
      const lap = Number(leaderLap) || 0;
      return clamp01(lap / total);
    }

    function autoPruneWindow(now) {
      const w = commentatorAutoState.window || [];
      const keep = [];
      for (const t of w) {
        if (now - t <= commentatorAutoCfg.windowMs) keep.push(t);
      }
      commentatorAutoState.window = keep;
      return keep.length;
    }

    function autoSigOk(sig, cooldownMs, now) {
      try {
        if (!sig) return true;
        const cd = Number(cooldownMs || 0) || commentatorAutoCfg.sigDefaultCooldownMs;
        const last = commentatorAutoState.recentSig.get(sig) || 0;
        return (now - last) >= cd;
      } catch(e) { return true; }
    }

    function autoMarkSig(sig, now) {
      try {
        if (!sig) return;
        commentatorAutoState.recentSig.set(sig, now);
      } catch(e) {}
    }

    function autoCanSpeak(score, sig, sigCooldownMs, now) {
      try {
        const winCount = autoPruneWindow(now);
        const since = now - (commentatorAutoState.lastSpeakMs || 0);

        // dedupe por firma
        if (!autoSigOk(sig, sigCooldownMs, now)) return false;

        // anti metralleta
        if (since < commentatorAutoCfg.minIntervalMs && score < commentatorAutoCfg.allowUrgentOverLimitScore) return false;

        // ventana
        if (winCount >= commentatorAutoCfg.maxMsgsInWindow && score < commentatorAutoCfg.allowUrgentOverLimitScore) return false;

        // umbral dinamico (si ya hablaste mucho, sube la barra)
        let threshold = commentatorAutoCfg.baseThresholdScore;
        threshold += Math.max(0, winCount - 1) * 0.8;
        if (since < 11000) threshold += 0.6;

        return score >= threshold;
      } catch(e) {
        return false;
      }
    }

// =========================
// Auto Locutor - Narracin con contexto (focus battle)
// =========================

function autoStageFromSec(sec) {
  const s = Number(sec);
  if (!isFinite(s) || s <= 0) return '';
  if (s <= 0.32) return 'strike';
  if (s <= 0.50) return 'attack';
  if (s <= 0.80) return 'pressure';
  if (s <= 1.25) return 'closing';
  return 'loose';
}

function autoRememberPair(pairKey, sec, leaderLap, now) {
  try {
    if (!pairKey) return { prevSec:null, deltaSec:0, rate:0, lastMentionMs:0, encounterCount:0, closeTicks:0, hotTicks:0, activeMs:0 };
    const st = autoPairState.get(pairKey) || {
      lastSec:null, lastSec2:null, lastMs:0, lastLap:0, lastMentionMs:0,
      encounterCount:0, closeTicks:0, hotTicks:0, encounterStartMs:0
    };
    const prev = (st.lastSec != null) ? Number(st.lastSec) : null;
    const prev2 = (st.lastSec2 != null) ? Number(st.lastSec2) : null;
    const sameEncounter = st.lastMs && ((now - Number(st.lastMs || 0)) < 42000);
    if (!sameEncounter) {
      st.encounterCount = Number(st.encounterCount || 0) + 1;
      st.encounterStartMs = now;
      st.closeTicks = 0;
      st.hotTicks = 0;
    }
    st.lastSec2 = prev;
    st.lastSec = Number(sec);
    st.lastMs = now;
    st.lastLap = Number(leaderLap) || st.lastLap || 0;
    if (Number(sec) <= 0.60) st.closeTicks = Math.min(20, Number(st.closeTicks || 0) + 1);
    else st.closeTicks = Math.max(0, Number(st.closeTicks || 0) - 1);
    if (Number(sec) <= 0.35) st.hotTicks = Math.min(20, Number(st.hotTicks || 0) + 1);
    else st.hotTicks = Math.max(0, Number(st.hotTicks || 0) - 1);

    const deltaSec = (prev != null && isFinite(prev)) ? (Number(sec) - prev) : 0;
    // rate aprox: cambio por tick (negativo = cerrando)
    const rate = (prev2 != null && isFinite(prev2)) ? (Number(sec) - prev2) : deltaSec;
    const activeMs = st.encounterStartMs ? (now - Number(st.encounterStartMs || now)) : 0;

    autoPairState.set(pairKey, st);
    return {
      prevSec: prev,
      deltaSec,
      rate,
      lastMentionMs: st.lastMentionMs || 0,
      encounterCount: Number(st.encounterCount || 0),
      closeTicks: Number(st.closeTicks || 0),
      hotTicks: Number(st.hotTicks || 0),
      activeMs
    };
  } catch(e) {
    return { prevSec:null, deltaSec:0, rate:0, lastMentionMs:0, encounterCount:0, closeTicks:0, hotTicks:0, activeMs:0 };
  }
}

function autoMarkPairMention(pairKey, now) {
  try {
    if (!pairKey) return;
    const st = autoPairState.get(pairKey) || { lastSec:null, lastSec2:null, lastMs:0, lastLap:0, lastMentionMs:0 };
    st.lastMentionMs = now;
    autoPairState.set(pairKey, st);
  } catch(e) {}
}

function autoGetPairNarrativeMeta(pairKey, now) {
  try {
    if (!pairKey) return { encounters:0, closeTicks:0, hotTicks:0, activeMs:0, recurrent:false, sustained:false, boiling:false };
    const st = autoPairState.get(pairKey) || null;
    if (!st) return { encounters:0, closeTicks:0, hotTicks:0, activeMs:0, recurrent:false, sustained:false, boiling:false };
    const activeMs = st.encounterStartMs ? ((Number(now) || Date.now()) - Number(st.encounterStartMs || 0)) : 0;
    const encounters = Number(st.encounterCount || 0);
    const closeTicks = Number(st.closeTicks || 0);
    const hotTicks = Number(st.hotTicks || 0);
    return {
      encounters,
      closeTicks,
      hotTicks,
      activeMs,
      recurrent: encounters >= 3,
      sustained: activeMs >= 22000 || closeTicks >= 4,
      boiling: hotTicks >= 4
    };
  } catch(e) {
    return { encounters:0, closeTicks:0, hotTicks:0, activeMs:0, recurrent:false, sustained:false, boiling:false };
  }
}

function autoFocusMsg(stage, c, style) {
  const st = String(stage || '');
  const pos = c.pos;
  const a = c.attacker;
  const d = c.defender;
  const sec = c.sec;
  const delta = c.deltaStr || '';
  const fromSec = c.fromSec || '';
  const toSec = c.toSec || '';
  const ctx = { pos, attacker: a, defender: d, sec, delta, fromSec, toSec };

  // Conectores para hilar (menos robot, mas TV)
  const connectors = {
    pro: [
      'Ojo con esto.',
      'Atencion aquí.',
      'Se calienta la cosa.',
      'Dato clave.',
      'Esto se mueve.',
      'Importante.',
      'Tenemos tema.'
    ],
    picante: [
      'Se prendio.',
      'Uy.',
      'Ahi viene.',
      'Huele a pase.',
      'Ahora si.',
      'Aguas.',
      'Esto va a tronar.'
    ],
    engineer: [
      'Telemetria rapida.',
      'Lectura de ritmo.',
      'Numero mata chisme.',
      'Datos en corto.',
      'Aquíi hay delta.',
      'Lo que importa.'
    ],
    narrativo: [
      'Seguimos con la historia.',
      'Mientras tanto...',
      'En el radar...',
      'Y ojo, porque...',
      'La pelea sigue viva.',
      'Sin soltar el volante...',
      'Atencion, que esto cambia.',
      'Del otro lado...'
    ]
  };

  const s = (style === 'picante' || style === 'engineer' || style === 'narrativo') ? style : 'pro';
  const c0 = autoRandPick(connectors[s] || connectors.pro, 'auto:conn:' + s);

  const BANK = {
    keep: [
      (x) => `${c0} ${x.defender} aguanta en P${x.pos}. ${x.attacker} sigue pegado a ${x.sec}.`,
      (x) => `${c0} La pelea por P${x.pos} no se suelta: ${x.attacker} a ${x.sec} de ${x.defender}.`,
      (x) => `${c0} P${x.pos}: ${x.defender} adelante, ${x.attacker} atras. Gap ${x.sec}.`,
      (x) => `${c0} P${x.pos} esta en modo espejo: ${x.attacker} no lo suelta a ${x.defender}.`
    ],
    closing: [
      (x) => `${c0} Se esta cerrando P${x.pos}: ${x.attacker} recorta ${x.delta} y ya esta a ${x.toSec || x.sec} de ${x.defender}.`,
      (x) => `${c0} P${x.pos} se aprieta: de ${x.fromSec} baja a ${x.toSec}. ${x.attacker} viene encima.`,
      (x) => `${c0} P${x.pos}: ${x.attacker} acorta el gap. ${x.defender} ya lo trae en el espejo a ${x.toSec || x.sec}.`,
      (x) => `${c0} P${x.pos} se esta cocinando. ${x.attacker} viene recortando y ya esta a ${x.toSec || x.sec}.`
    ],
    opening: [
      (x) => `${c0} Se abre un poco la pelea en P${x.pos}. ${x.defender} estira a ${x.sec}.`,
      (x) => `${c0} Respiro para ${x.defender}: P${x.pos} se va a ${x.sec}.`,
      (x) => `${c0} P${x.pos} afloja tantito. ${x.attacker} pierde el contacto, gap ${x.sec}.`
    ],
    pass: [
      (x) => `${c0} Cambio de mando en P${x.pos}. ${x.attacker} le quita la posicion a ${x.defender}.`,
      (x) => `${c0} Pase hecho en P${x.pos}. ${x.attacker} se mete por delante de ${x.defender}.`,
      (x) => `${c0} P${x.pos} ya cambio. ${x.attacker} adelante, ${x.defender} a perseguir.`
    ]
  };

  const pool = BANK[st] || BANK.keep;
  let out = autoRandPick(pool, 'auto:focus:' + st + ':' + s)(ctx);
  try {
    const extra = [];
    const encounters = Number(ctx && ctx.encounters) || 0;
    const activeMs = Number(ctx && ctx.activeMs) || 0;
    const hotTicks = Number(ctx && ctx.hotTicks) || 0;
    if (encounters >= 3) extra.push(autoRandPick([
      'Otra vez aparecen los mismos dos.',
      'Este duelo ya trae varias rondas.',
      'La rivalidad sigue escribiendo capítulos.'
    ], 'auto:focus:rival:' + encounters));
    if (activeMs >= 22000) extra.push(autoRandPick([
      'Llevan rato en esta pelea.',
      'Es una historia larga ya.',
      'No se han soltado en un buen tramo.'
    ], 'auto:focus:active:' + Math.floor(activeMs / 5000)));
    if (hotTicks >= 4) extra.push(autoRandPick([
      'Ya huele a maniobra grande.',
      'Esto viene hirviendo.',
      'La tensión ya está arriba del límite.'
    ], 'auto:focus:hot:' + hotTicks));
    if (extra.length) out = [out].concat(extra.slice(0, 1)).join(' ');
  } catch(e) {}
  return out;
}

function autoBuildStoryCandidate(args) {
  try {
    const { battles, now, leaderLap, progress, isMangaSess } = args;
    if (!battles || !battles.length) return null;

    // 1) si hay foco vigente, intentamos seguirlo
    const stickyOk = (autoNarratorState.focusPairKey && now < (autoNarratorState.focusStickyUntilMs || 0));
    const focusPair = autoNarratorState.focusPairKey || '';
    let focus = null;

    if (focusPair) {
      focus = battles.find(b => b && b.pairKey === focusPair) || null;
      // si ya no existe o se abri demasiado, lo soltamos
      if (!focus || !isFinite(focus.secNum) || focus.secNum > 1.60) {
        autoNarratorState.focusPairKey = '';
        autoNarratorState.focusStage = '';
        focus = null;
      }
    }

    // 2) si no hay foco, elegimos uno (podio y cierres pesan ms)
    if (!focus) {
      let best = null;
      let bestScore = -1e9;
      for (const b of battles) {
        if (!b || !isFinite(b.score)) continue;
        const mentionedMs = (b.lastMentionMs || 0);
        const penalty = (now - mentionedMs < 14000) ? 1.2 : 0;
        const metaBonus = ((Number(b.encounters || 0) >= 3) ? 0.9 : 0) + ((Number(b.hotTicks || 0) >= 4) ? 0.8 : 0) + ((Number(b.activeMs || 0) >= 22000) ? 0.5 : 0);
        const s = b.score - penalty + metaBonus;
        if (s > bestScore) { bestScore = s; best = b; }
      }
      if (!best) return null;

      autoNarratorState.focusPairKey = best.pairKey;
      autoNarratorState.focusPos = best.pos;
      autoNarratorState.focusDefender = best.defender;
      autoNarratorState.focusAttacker = best.attacker;
      autoNarratorState.focusSinceMs = now;
      autoNarratorState.focusLastSec = best.secNum;
      autoNarratorState.focusStage = 'intro';
      autoNarratorState.focusStickyUntilMs = now + ((Number(best.encounters || 0) >= 3) ? 36000 : 28000); // hilo más largo si ya es duelo recurrente
      focus = best;
    }

    if (!focus) return null;

    // 3) construir update segn tendencia
    const sec = Number(focus.secNum);
    const prev = (autoNarratorState.focusLastSec != null) ? Number(autoNarratorState.focusLastSec) : null;
    const stageNow = autoStageFromSec(sec);
    const stagePrev = String(autoNarratorState.focusStage || '');

    const delta = (prev != null && isFinite(prev)) ? (sec - prev) : 0;
    const absDelta = Math.abs(delta);

    // decidir si hablar: cambio real o etapa nueva o pas mucho
    const sinceSpeak = now - (autoNarratorState.focusLastSpeakMs || 0);
    const stageChanged = (stageNow && stageNow !== stagePrev && stagePrev !== 'intro');

    if (sinceSpeak < 15000 && !stageChanged && absDelta < 0.12) return null;

    let stage = stageNow || 'closing';
    if (stagePrev === 'intro') stage = 'closing';

    // si se abri, usar "opening"
    if (prev != null && isFinite(prev) && delta > 0.09) stage = 'opening';

    const secStr = gapToSpeechBare(sec, 'focus');
    const deltaStr = (prev != null && isFinite(prev)) ? gapDeltaSpeech(Math.abs(delta)) : '';
    const style = (autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || autoCommentatorMode === 'narrativo') ? autoCommentatorMode : 'pro';

    const fromSec = (prev != null && isFinite(prev)) ? gapToSpeechBare(prev, 'focus') : '';
    const toSec = secStr;

    const text = autoFocusMsg((stagePrev === '' ? 'intro' : stage), {
      pos: focus.pos,
      attacker: focus.attacker,
      defender: focus.defender,
      sec: secStr,
      secNum: sec,
      deltaStr,
      fromSec,
      toSec,
      encounters: Number(focus.encounters || 0),
      hotTicks: Number(focus.hotTicks || 0),
      activeMs: Number(focus.activeMs || 0)
    }, style);

    // score: focus manda pero no todo el tiempo
    let score = 6.4;
    score += clamp01((1.20 - sec) / 1.20) * 2.2;
    if (focus.pos <= 3) score += 1.4;
    if (focus.pos === 1) score += 0.8;
    if (progress > 0.80 && focus.pos <= 5) score += 0.6;
    if (Number(focus.encounters || 0) >= 3) score += 0.8;
    if (Number(focus.hotTicks || 0) >= 4) score += 0.8;
    if (Number(focus.activeMs || 0) >= 22000) score += 0.4;

    // manga: menos frecuencia
    if (isMangaSess) score -= 0.7;

    const sig = 'auto:story:' + focus.pairKey + ':' + stage;
    const key = 'auto_story_' + focus.pairKey;

    return {
      type: 'story',
      score,
      text,
      key,
      sig,
      sigCooldownMs: isMangaSess ? 24000 : 20000,
      priority: 5,
      onCommit: () => {
        autoNarratorState.focusLastSpeakMs = now;
        autoNarratorState.focusLastSec = sec;
        autoNarratorState.focusStage = stage;
        autoNarratorState.lastSpokenType = 'story';
        autoNarratorState.lastSpokenMs = now;
        autoMarkPairMention(focus.pairKey, now);
      }
    };
  } catch(e) {
    return null;
  }
}

    const AUTO_PHRASES_PRO = {
      leaderChange: [
        (c) => 'Cambio de líder. ' + c.winner + ' toma P1. ' + c.loser + ' queda P2.',
        (c) => 'Cambio de líder: ' + c.winner + ' se pone al frente. ' + c.loser + ' a perseguir.',
        (c) => 'Nueva punta. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => c.winner + ' recupera la punta. ' + c.loser + ' baja a segundo.',
        (c) => 'Intercambio en P1. ' + c.winner + ' adelante. ' + c.loser + ' segundo.',
        (c) => 'Se mueve la cabeza: ' + c.winner + ' manda. ' + c.loser + ' responde en P2.',
        (c) => 'Liderato para ' + c.winner + '. ' + c.loser + ' pierde P1.',
        (c) => 'Punta nueva: ' + c.winner + '. ' + c.loser + ' se queda a rueda.',
        (c) => 'Swap en la punta. ' + c.winner + ' P1, ' + c.loser + ' P2.',
        (c) => 'Cambio arriba. ' + c.winner + ' primero. ' + c.loser + ' segundo.',
        (c) => 'Golpe de autoridad: ' + c.winner + ' toma P1. ' + c.loser + ' a reorganizar.',
        (c) => 'Actualizacion punta: ' + c.winner + ' lidera. ' + c.loser + ' queda P2.'
      ],

      pass: [
        (c) => 'Rebase confirmado. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => c.winner + ' ejecuta el pase y asegura P' + c.newPos + '. ' + c.loser + ' baja a P' + c.oldPos + '.',
        (c) => 'Cambio de posición. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' queda P' + c.oldPos + '.',
        (c) => 'Movimiento limpio: ' + c.winner + ' por delante. Ahora P' + c.newPos + '.',
        (c) => 'Pase hecho. ' + c.winner + ' gana el lugar en P' + c.newPos + '.',
        (c) => 'Rebase con calma. ' + c.winner + ' se instala en P' + c.newPos + '.',
        (c) => 'Posición ganada: ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' pierde el sitio.',
        (c) => 'Se concreta el intercambio. ' + c.winner + ' arriba a P' + c.newPos + '.',
        (c) => 'Adelantamiento al conteo. ' + c.winner + ' sube. ' + c.loser + ' baja.',
        (c) => 'P' + c.newPos + ' cambia de manos. ' + c.winner + ' toma la plaza.',
        (c) => 'Buen pase. ' + c.winner + ' ya esta delante de ' + c.loser + '. P' + c.newPos + '.',
        (c) => 'Rebase cerrado: ' + c.winner + ' gana P' + c.newPos + ', ' + c.loser + ' a P' + c.oldPos + '.'
      ],

      battle: [
        (c) => 'Duelo en P' + c.pos + '. ' + c.attacker + ' a rueda de ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en pelea. ' + c.attacker + ' presiona a ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Ojo P' + c.pos + '. ' + c.attacker + ' trae el ataque. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' caliente. ' + c.defender + ' defiende, ' + c.attacker + ' insiste. ' + c.sec + '.',
        (c) => 'Rango de pase en P' + c.pos + '. ' + c.attacker + ' pegado. ' + c.sec + '.',
        (c) => 'Camara a P' + c.pos + '. ' + c.attacker + ' en el espejo de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Separacion minima en P' + c.pos + ': ' + c.sec + '. ' + c.attacker + ' encima.',
        (c) => 'P' + c.pos + ' sin aire. ' + c.attacker + ' no se despega. ' + c.sec + '.',
        (c) => 'Atencion P' + c.pos + '. ' + c.attacker + ' busca hueco con ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en mano a mano. ' + c.attacker + ' contra ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Duelo directo. P' + c.pos + ' con gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' bajo fuego. ' + c.attacker + ' viene encima. ' + c.sec + '.'
      ],

      battlePodium: [
        (c) => 'Podio en juego en P' + c.pos + '. ' + c.attacker + ' presiona. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por trofeo. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Zona de podio. ' + c.defender + ' defiende. ' + c.attacker + ' insiste. ' + c.sec + '.',
        (c) => 'Podio apretado. Gap ' + c.sec + '. ' + c.attacker + ' con opcion.',
        (c) => 'Pelea de podio: ' + c.attacker + ' a tiro de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por podio con gap ' + c.sec + '. Esto puede cambiar.',
        (c) => 'Ojo al podio. ' + c.attacker + ' trae ritmo sobre ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Trofeo en la mira. ' + c.attacker + ' ya lo trae. ' + c.sec + '.',
        (c) => 'Podio sin margen. ' + c.sec + '. ' + c.defender + ' aguantando.',
        (c) => 'P' + c.pos + ' de podio: ' + c.attacker + ' en espejo. ' + c.sec + '.',
        (c) => 'Batalla por el podio. ' + c.attacker + ' quiere P' + c.pos + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por podio. Ventana de pase abierta. ' + c.sec + '.'
      ],

      // closing = cierre de gap (trend)
      closing: [
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Recorte en P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + '.',
        (c) => 'Gap en P' + c.pos + ' cae: ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se acerca en P' + c.pos + '. ' + c.attacker + ' ya esta a ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Tendencia positiva P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + '.',
        (c) => 'Ojo P' + c.pos + '. ' + c.attacker + ' recorta ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre confirmado. P' + c.pos + ' ahora ' + c.toSec + '.',
        (c) => 'Se aprieta P' + c.pos + '. ' + c.attacker + ' trae el gap en ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se esta cerrando. ' + c.toSec + ' entre ellos.',
        (c) => 'Recorte constante. P' + c.pos + ' de ' + c.fromSec + ' a ' + c.toSec + '.'
      ],

      gap: [
        (c) => 'Gap P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Separacion P' + c.pos + ': ' + c.sec + 's. ' + c.defender + ' adelante.',
        (c) => 'P' + c.pos + ' entre ' + c.defender + ' y ' + c.attacker + ': ' + c.sec + 's.',
        (c) => 'Distancia P' + c.pos + '. ' + c.attacker + ' marca ' + c.sec + 's.',
        (c) => 'Gap estable en P' + c.pos + ': ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con ' + c.sec + 's de diferencia.',
        (c) => 'Referencia P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'Tiempo entre autos P' + c.pos + ': ' + c.sec + 's.',
        (c) => 'Brecha P' + c.pos + ': ' + c.sec + 's.',
        (c) => 'Gap P' + c.pos + ' = ' + c.sec + 's.'
      ],

      pressure: [
        (c) => 'Presin en P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' defendiendo. ' + c.defender + ' con ' + c.attacker + ' pegado.',
        (c) => 'Ataque en P' + c.pos + '. ' + c.attacker + ' con opcion.',
        (c) => 'P' + c.pos + ' sin margen. ' + c.attacker + ' lo trae.',
        (c) => 'Defensa activa en P' + c.pos + '. ' + c.defender + ' aguanta.',
        (c) => 'P' + c.pos + ' bajo presin. Ojo en la siguiente curva.',
        (c) => 'P' + c.pos + ' en modo espejo. ' + c.attacker + ' no suelta.',
        (c) => 'Sombra en P' + c.pos + '. ' + c.attacker + ' pegado.',
        (c) => 'P' + c.pos + ' con ataque constante de ' + c.attacker + '.',
        (c) => 'Presin sostenida en P' + c.pos + '. No hay respiro.'
      ],

      top3: [
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Arriba van: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Punta y podio: ' + c.p1 + ' lidera, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Tabla de punta: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Frente de carrera: ' + c.p1 + ' al frente. ' + c.p2 + ' y ' + c.p3 + ' atrs.',
        (c) => 'Orden actual: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Podio provisional: ' + c.p1 + ' / ' + c.p2 + ' / ' + c.p3 + '.',
        (c) => 'Lder ' + c.p1 + '. Segundo ' + c.p2 + '. Tercero ' + c.p3 + '.',
        (c) => 'P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'As va el Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'En la punta: ' + c.p1 + ' lidera. Detras ' + c.p2 + ' y ' + c.p3 + '.'
      ],

      train: [
        (c) => 'Paquete P2 a P4. ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. Nadie regala.',
        (c) => 'Tren por el podio. ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. Error y se voltean.',
        (c) => 'Grupo compacto. ' + c.p2 + ' adelante, ' + c.p3 + ' y ' + c.p4 + ' pegados.',
        (c) => 'P2 a P4 en fila: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. Ventana de pase.',
        (c) => 'Tres autos en paquete. P2 a P4 muy cerrados.',
        (c) => 'P2 a P4 sin aire. ' + c.p2 + ' con ' + c.p3 + ' encima y ' + c.p4 + ' esperando.',
        (c) => 'Cluster por el podio. Nadie parpadee.',
        (c) => 'Paquete apretado P2 a P4. Cualquier curva cambia todo.',
        (c) => 'Tren formado. P2 a P4 en rango. Precision.',
        (c) => 'P2 a P4 en modo acordeon. Se viene el swap.',
        (c) => 'Grupo P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. Alto riesgo.',
        (c) => 'Paquete por P2-P4. No hay espacio para fallar.'
      ],

      record: [
        (c) => 'Mejor vuelta. ' + c.pilot + ' marca ' + c.best + '.',
        (c) => 'Nueva mejor vuelta para ' + c.pilot + ': ' + c.best + '.',
        (c) => 'Referencia de ritmo: ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Se apunta best lap. ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Mejor vuelta del stint: ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Tiempo top para ' + c.pilot + ': ' + c.best + '.',
        (c) => 'Mejor vuelta registrado: ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Ritmo fuerte. ' + c.pilot + ' clava ' + c.best + '.',
        (c) => 'Mejor vuelta. ' + c.pilot + ' firma ' + c.best + '.',
        (c) => 'Se actualiza best lap: ' + c.pilot + ' ' + c.best + '.'
      ],

      qualiBest: [
        (c) => 'En clasificacin, ' + c.pilot + ' marca ' + c.best + '.',
        (c) => 'Tiempo fuerte en quali: ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Clasificación: ' + c.pilot + ' mejora con ' + c.best + '.',
        (c) => 'Queda el registro. ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Buen intento. ' + c.pilot + ' suelta ' + c.best + '.',
        (c) => 'Clasificación se mueve. ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Queda la vuelta. ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Queda el tiempo: ' + c.pilot + ' ' + c.best + '.',
        (c) => 'Ojo ese ritmo. ' + c.pilot + ' con ' + c.best + '.',
        (c) => 'Clasificación al detalle. ' + c.pilot + ' marca ' + c.best + '.'
      ],

      qualiPole: [
        (c) => 'Pelea por la pole. ' + c.p1 + ' y ' + c.p2 + ' separados por ' + c.sec + '.',
        (c) => 'Pole en juego. ' + c.p1 + ' contra ' + c.p2 + ', gap ' + c.sec + '.',
        (c) => 'Se aprieta la pole. ' + c.p1 + ' y ' + c.p2 + ' a ' + c.sec + '.',
        (c) => 'Clasificación caliente. ' + c.p1 + ' vs ' + c.p2 + ', ' + c.sec + '.'
      ],
};


    const AUTO_PHRASES_PICANTE = {
      leaderChange: [
        (c) => 'Cambio de líder. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Cambio de líder. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Cambio de líder. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Cambio de líder. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Cambio de líder. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Cambio de líder. ' + c.winner + ' al frente. ' + c.loser + ' con presin encima.',
        (c) => 'Cambio de líder. ' + c.loser + ' pierde la punta. ' + c.winner + ' líder.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Nuevo jefe en pista. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' al frente. ' + c.loser + ' con presin encima.',
        (c) => 'Nuevo jefe en pista. ' + c.loser + ' pierde la punta. ' + c.winner + ' líder.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Se volte la tortilla. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Se volte la tortilla. ' + c.winner + ' al frente. ' + c.loser + ' con presin encima.',
        (c) => 'Se volte la tortilla. ' + c.loser + ' pierde la punta. ' + c.winner + ' líder.',
        (c) => 'Golpe en la punta. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Golpe en la punta. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Golpe en la punta. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Golpe en la punta. P1 ' + c.winner + '. P2 ' + c.loser + '.'
      ],
      pass: [
        (c) => 'Rebase con colmillo. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Rebase con colmillo. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Se la cobra. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Puesto robado. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.'
      ],
      battle: [
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est que arde. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presin brava. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.'
      ],
      battlePodium: [
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' ya se asom. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' ya se asom. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' ya se asom. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' ya se asom. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. Gap ' + c.sec + '. Aquí se gana con cabeza fra.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' ya se asom. ' + c.sec + '.'
      ],
      closing: [
        (c) => 'Se est cerrando P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se est cerrando P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est encima.',
        (c) => 'Se est cerrando P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Se est cerrando P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se est cerrando P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Se est cerrando P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est encima.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' se cocina. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' ya está ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'Atencin en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Atencin en P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est encima.',
        (c) => 'Atencin en P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Atencin en P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Atencin en P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Atencin en P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est encima.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' en recorte serio. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.'
      ],
      top3: [
        (c) => 'Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Top 3: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Top 3: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Arriba va as: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Arriba va as: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Arriba va as: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Arriba va as: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Arriba va as: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Los de la punta: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Los de la punta: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Los de la punta: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Los de la punta: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Los de la punta: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Podio provisional: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Podio provisional: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Podio provisional: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Podio provisional: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Podio provisional: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'As est el frente: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'As est el frente: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'As est el frente: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'As est el frente: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'As est el frente: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.'
      ],
      train: [
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Aquí nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Aquí nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Aquí nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Aquí nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Pista chica, orgullo grande.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Aquí nadie respira.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Esto se decide en una curva.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Pista chica, orgullo grande.'
      ]
    };

// ====== EXPANSION: catalogo extra de frases (estilo picante TRM) ======
(function(){
  try {
    AUTO_PHRASES_PICANTE.leaderChange = (AUTO_PHRASES_PICANTE.leaderChange||[]).concat([
      (c) => 'Se prende la punta. ' + c.winner + ' toma P1 y ' + c.loser + ' se queda masticando polvo.',
      (c) => 'Punta nueva. ' + c.winner + ' al frente. ' + c.loser + ' no se despega.',
      (c) => 'La cima cambia de dueo. ' + c.winner + ' manda. ' + c.loser + ' a remar.'
    ]);

    AUTO_PHRASES_PICANTE.pass = (AUTO_PHRASES_PICANTE.pass||[]).concat([
      (c) => 'Pase quirurgico. ' + c.winner + ' se mete a P' + c.newPos + '. ' + c.loser + ' se reacomoda.',
      (c) => 'Le cerro la puerta tarde. ' + c.winner + ' gana P' + c.newPos + '.',
      (c) => 'Con permiso y gracias. ' + c.winner + ' toma P' + c.newPos + '.'
    ]);

    AUTO_PHRASES_PICANTE.battle = (AUTO_PHRASES_PICANTE.battle||[]).concat([
      (c) => 'P' + c.pos + ' apretadisimo. ' + c.attacker + ' viene con hambre. ' + c.sec + '.',
      (c) => 'P' + c.pos + ' sin respiro. ' + c.defender + ' trae espejo lleno. ' + c.sec + '.',
      (c) => 'Esto es duelo real en P' + c.pos + '. ' + c.attacker + ' lo trae medido. ' + c.sec + '.'
    ]);

    AUTO_PHRASES_PICANTE.closing = (AUTO_PHRASES_PICANTE.closing||[]).concat([
      (c) => 'Cierre serio en P' + c.pos + '. ' + c.attacker + ' ya lo trae en la bolsa. ' + c.toSec + '.',
      (c) => 'Se viene el golpe en P' + c.pos + '. ' + c.attacker + ' ya esta a ' + c.toSec + '.',
      (c) => 'P' + c.pos + ' en zona de error cero. ' + c.defender + ' con ' + c.attacker + ' encima. ' + c.toSec + '.'
    ]);

    AUTO_PHRASES_PICANTE.top3 = (AUTO_PHRASES_PICANTE.top3||[]).concat([
      (c) => 'Arriba estan con manos. ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
      (c) => 'Punta caliente. ' + c.p1 + ' lidera. ' + c.p2 + ' lo trae en la mira. ' + c.p3 + ' espera el error.',
      (c) => 'Top 3 en orden. ' + c.p1 + '. ' + c.p2 + '. ' + c.p3 + '.'
    ]);
  } catch(e) {}
})();

    const AUTO_PHRASES_ENGINEER = {
      leaderChange: [
        (c) => 'Update punta. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Update punta. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Update punta. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Update punta. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecucin.',
        (c) => 'Update punta. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Update punta. P1 para ' + c.winner + '. ' + c.loser + ' queda detrs.',
        (c) => 'Update punta. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Cambio en P1. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Cambio en P1. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Cambio en P1. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Cambio en P1. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecucin.',
        (c) => 'Cambio en P1. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Cambio en P1. P1 para ' + c.winner + '. ' + c.loser + ' queda detrs.',
        (c) => 'Cambio en P1. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Telemetra: nuevo líder. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Telemetra: nuevo líder. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Telemetra: nuevo líder. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Telemetra: nuevo líder. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecucin.',
        (c) => 'Telemetra: nuevo líder. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Telemetra: nuevo líder. P1 para ' + c.winner + '. ' + c.loser + ' queda detrs.',
        (c) => 'Telemetra: nuevo líder. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Estado de carrera. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Estado de carrera. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Estado de carrera. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Estado de carrera. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecucin.'
      ],
      pass: [
        (c) => 'Overtake confirmado. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Overtake confirmado. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Overtake confirmado. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Overtake confirmado. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Overtake confirmado. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Overtake confirmado. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Overtake confirmado. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Cambio de posición. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de posición. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Cambio de posición. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Cambio de posición. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Cambio de posición. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Cambio de posición. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Cambio de posición. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Swap de posición. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Swap de posición. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Swap de posición. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Swap de posición. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Swap de posición. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Swap de posición. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Swap de posición. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Movimiento de ranking. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Movimiento de ranking. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Movimiento de ranking. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Movimiento de ranking. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.'
      ],
      battle: [
        (c) => 'Duelo P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'Duelo P' + c.pos + '. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'Duelo P' + c.pos + '. Rango crtico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. Rango crtico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. Rango crtico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. Rango crtico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' bajo presin. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.'
      ],
      battlePodium: [
        (c) => 'Podio P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Podio P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Podio P' + c.pos + '. Delta ' + c.sec + 's por el podio.',
        (c) => 'Podio P' + c.pos + '. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'Podio P' + c.pos + '. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' por trofeo. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' por trofeo. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' por trofeo. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' por trofeo. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' por trofeo. Rango de pase: ' + c.sec + 's.',
        (c) => 'Zona de podio P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Zona de podio P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Zona de podio P' + c.pos + '. Delta ' + c.sec + 's por el podio.',
        (c) => 'Zona de podio P' + c.pos + '. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'Zona de podio P' + c.pos + '. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' crtico para podio. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' crtico para podio. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' crtico para podio. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' crtico para podio. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' crtico para podio. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' de podio en disputa. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' de podio en disputa. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' de podio en disputa. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' de podio en disputa. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' de podio en disputa. Rango de pase: ' + c.sec + 's.'
      ],
      closing: [
        (c) => 'Cierre en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Cierre en P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Tendencia P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Tendencia P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Delta en P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Delta en P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. ' + c.attacker + ' ya está ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'P' + c.pos + ' con recorte. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con recorte. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. ' + c.attacker + ' ya está ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Gap bajando en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.'
      ],
      
      gap: [
        (c) => 'Gap P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Gap P' + c.pos + '. ' + c.defender + ' adelante, ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' gap ' + c.sec + 's. ' + c.attacker + ' viene detrs.',
        (c) => 'P' + c.pos + '. Separacin ' + c.sec + 's entre ' + c.defender + ' y ' + c.attacker + '.',
        (c) => 'P' + c.pos + '. ' + c.attacker + ' marca ' + c.sec + 's al de adelante.'
      ],
      pressure: [
        (c) => 'Presin en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' bajo presin. ' + c.attacker + ' a ' + c.sec + 's. Ojo defensa.',
        (c) => 'Defensa en P' + c.pos + '. ' + c.defender + ' se sostiene con ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en modo defensa. ' + c.attacker + ' est encima, ' + c.sec + 's.'
      ],
      top3: [
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Top 3: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.',
        (c) => 'Tabla de punta: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Tabla de punta: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.',
        (c) => 'Estado del podio: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Estado del podio: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.',
        (c) => 'Orden actual: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Orden actual: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.',
        (c) => 'Lectura de top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Lectura de top 3: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detrs.'
      ],
      train: [
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta mnimo. ') + 'La siguiente curva es clave.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Alto riesgo de swap.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Ventana de pase abierta.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Cualquier error altera la tabla.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Delta mnimo, decisin rápida.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'La siguiente curva es clave.'
      ]
    };

    const AUTO_PHRASES_NARRATIVO = Object.assign({}, AUTO_PHRASES_PRO, {
      // Finales: mas hilo, mas variedad, menos repeticion.
      leaderChange: [
        (c) => 'Cambio de líder. ' + (c.winner||c.attacker) + ' roba P1. ' + (c.loser||c.defender) + ' cae a P2.',
        (c) => 'Se volteo la pelicula. ' + (c.winner||c.attacker) + ' toma la punta. ' + (c.loser||c.defender) + ' a remar.',
        (c) => 'Swap arriba. ' + (c.winner||c.attacker) + ' manda. ' + (c.loser||c.defender) + ' queda segundo.',
        (c) => 'P1 cambia de manos. ' + (c.winner||c.attacker) + ' al frente. ' + (c.loser||c.defender) + ' no lo suelta.',
        (c) => 'Que golpe. ' + (c.winner||c.attacker) + ' se queda con P1. ' + (c.loser||c.defender) + ' se acomoda P2.',
        (c) => 'La punta tiene nuevo dueno: ' + (c.winner||c.attacker) + '.',
        (c) => 'Arriba se mueven. P1 ' + (c.winner||c.attacker) + ', P2 ' + (c.loser||c.defender) + '.',
        (c) => 'Cambio de guion. ' + (c.winner||c.attacker) + ' lidera. ' + (c.loser||c.defender) + ' responde.',
        (c) => 'Se reescribe la Final. ' + (c.winner||c.attacker) + ' primero. ' + (c.loser||c.defender) + ' segundo.',
        (c) => 'Nueva punta. ' + (c.winner||c.attacker) + ' arriba. ' + (c.loser||c.defender) + ' detras.',
        (c) => 'Punta para ' + (c.winner||c.attacker) + '. Esto esta vivo.',
        (c) => 'Cambio en la cima. ' + (c.winner||c.attacker) + ' se queda con P1.'
      ],

      pass: [
        (c) => 'Pase confirmado. ' + (c.winner||c.attacker) + ' ya esta en P' + (c.newPos||c.pos) + '.',
        (c) => 'Lo hizo. ' + (c.winner||c.attacker) + ' se mete por dentro y gana la plaza.',
        (c) => 'Movimiento limpio. ' + (c.winner||c.attacker) + ' pasa a ' + (c.loser||c.defender) + '. P' + (c.newPos||c.pos) + '.',
        (c) => 'Se concreta el intercambio. ' + (c.winner||c.attacker) + ' por delante.',
        (c) => 'Pase con autoridad. ' + (c.winner||c.attacker) + ' toma P' + (c.newPos||c.pos) + '.',
        (c) => 'Buen rebase. ' + (c.winner||c.attacker) + ' asegura la posicion.',
        (c) => 'Cambio de posicion en vivo. ' + (c.winner||c.attacker) + ' sube.',
        (c) => 'Lo cierra y lo firma. ' + (c.winner||c.attacker) + ' gana el lugar.',
        (c) => 'P' + (c.newPos||c.pos) + ' cambia de manos. ' + (c.winner||c.attacker) + ' se lo queda.',
        (c) => 'Pase al limite. ' + (c.winner||c.attacker) + ' por delante.',
        (c) => 'Rebase completo. ' + (c.winner||c.attacker) + ' ya esta arriba.',
        (c) => 'Se confirma el pase. ' + (c.winner||c.attacker) + ' gana la plaza.'
      ],

      battle: [
        (c) => 'Camara a P' + c.pos + '. ' + c.attacker + ' en el espejo de ' + c.defender + '. Gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' al rojo. ' + c.attacker + ' lo trae pegado. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' en mano a mano. ' + c.attacker + ' buscando el hueco. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Duelo real. ' + c.defender + ' defendiendo, ' + c.attacker + ' atacando. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Esto puede cambiar en P' + c.pos + '. Gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' sin respiro. ' + c.attacker + ' no suelta. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Rango de ataque en P' + c.pos + '. ' + c.attacker + ' con opcion.',
        (c) => 'Ojo esa pelea. ' + c.attacker + ' trae mejor linea sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en la mira. ' + c.attacker + ' esta listo.',
        (c) => 'Se ven espejos. P' + c.pos + ' con gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' apretado. Todo se decide por milimetros.',
        (c) => 'Duelo continuo en P' + c.pos + '. ' + (c.sec||c.deltaStr) + '.'
      ],

      battlePodium: [
        (c) => 'Podio en juego. P' + c.pos + ' con gap ' + (c.sec||c.deltaStr) + '. ' + c.attacker + ' presiona.',
        (c) => 'Trofeo en la mira. ' + c.attacker + ' encima de ' + c.defender + '. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' por podio. ' + c.defender + ' se defiende con el retrovisor lleno.',
        (c) => 'Zona de podio al limite. ' + c.attacker + ' con opcion clara.',
        (c) => 'Esto huele a swap por el podio. Gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Pelea de podio. ' + c.attacker + ' no perdona. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' por trofeo, sin margen. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Podio provisional temblando. ' + c.attacker + ' lo quiere.',
        (c) => 'P' + c.pos + ' en disputa. Cualquier error y cambia el podio.',
        (c) => 'Podio en fuego. ' + c.attacker + ' a tiro. ' + (c.sec||c.deltaStr) + '.',
        (c) => 'Se aprieta el podio. Gap ' + (c.sec||c.deltaStr) + '.',
        (c) => 'P' + c.pos + ' por podio. Esto esta bravo.'
      ],

      closing: [
        (c) => 'Recorte. P' + c.pos + ' de ' + c.fromSec + ' a ' + c.toSec + '. ' + c.attacker + ' se acerca.',
        (c) => 'Se viene. ' + c.attacker + ' baja a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Gap cayendo en P' + c.pos + '. ' + c.toSec + ' ahora.',
        (c) => 'Cierre confirmado. P' + c.pos + ' ya esta en ' + c.toSec + '.',
        (c) => 'Tendencia clara. ' + c.attacker + ' recorta y pone presion.',
        (c) => 'Atencion. P' + c.pos + ' se aprieta rapido.',
        (c) => 'Se compacta P' + c.pos + '. Se huele el pase.',
        (c) => 'Recorte constante. ' + c.attacker + ' viene con ritmo.',
        (c) => 'De ' + c.fromSec + ' a ' + c.toSec + '. Eso es recortar.',
        (c) => 'P' + c.pos + ' ahora en rango. ' + c.toSec + '.'
      ],

      train: [
        (c) => 'Tren por el podio. ' + (c.p2 ? (c.p2 + ', ' + c.p3 + ', ' + c.p4 + '.') : 'P2 a P4 en paquete.') + ' Nadie respira.',
        (c) => 'Paquete compacto. Una curva y cambia todo.',
        (c) => 'P2 a P4 en fila india. Ventana de pase abierta.',
        (c) => 'Tres autos pegados por el podio. Precision pura.',
        (c) => 'Cluster por el podio. Se viene el swap.',
        (c) => 'P2 a P4 sin aire. Error y se voltean.',
        (c) => 'Paquete por P2-P4. Nadie regala.',
        (c) => 'Tren formado. Ojo con el toque.',
        (c) => 'P2 a P4: aquí se gana con cabeza fria.',
        (c) => 'Grupo compacto. Todo se decide en la proxima chicana.',
        (c) => 'Trenecito armado. El podio tiembla.',
        (c) => 'Paquete apretado. Se siente la presion.'
      ]
    });


    const AUTO_PHRASES_BY_STYLE = {
      pro: AUTO_PHRASES_PRO,
      picante: AUTO_PHRASES_PICANTE,
      engineer: AUTO_PHRASES_ENGINEER,
      narrativo: AUTO_PHRASES_NARRATIVO
    };

function autoDecorate(text, type, style) {
  const t = String(text || '').trim();
  if (!t) return '';
  // Micro-variacin (pocas veces, para que no suene payaso)
  const r = Math.random();
  const st = String(style || 'pro');
  const tp = String(type || 'x');

  const prefixes = (st === 'engineer')
    ? ['Dato.', 'Info.', 'Control.']
    : (st === 'picante')
      ? ['Ojo.', 'Atencin.', 'Se prende.']
      : (st === 'narrativo')
        ? ['Ahora.', 'Cambiamos cmara.', 'Seguimos.', 'Atencin.', 'Foco.']
        : ['Ojo.', 'Atencin.', 'Momento.'];

  const suffixes = (st === 'engineer')
    ? ['Sin margen.', 'Sigue as.']
    : (st === 'picante')
      ? ['Se puso bueno.', 'Sin piedad.']
      : (st === 'narrativo')
        ? ['No se sueltan.', 'Se viene el pase.', 'Sin respiro.', 'Esto est vivo.']
        : ['Esto se pone bueno.', 'Ojo ah.'];

  // Narrativo: un poquito ms de "hilo", pero sin spam
  const pRate = (st === 'narrativo') ? 0.22 : 0.18;
  const sRate = (st === 'narrativo') ? 0.40 : 0.30;

  if (r < pRate) {
    const p = autoRandPick(prefixes, 'decorP:' + st + ':' + tp);
    return p ? (p + ' ' + t) : t;
  }
  if (r < sRate) {
    const s = autoRandPick(suffixes, 'decorS:' + st + ':' + tp);
    return s ? (t + ' ' + s) : t;
  }
  return t;
}

    function autoIsUsableText(s, type) {
      try {
        const t = String(s || '').replace(/\s+/g,' ').trim();
        if (!t || t.length < 3) return false;
        if (/\b(undefined|null|nan)\b/i.test(t)) return false;
        // Si menciona gap/delta pero no trae numero, mejor callar.
        if (/\b(gap|delta)\b/i.test(t) && !/\d/.test(t)) return false;
        // No deberian quedar llaves sin reemplazar
        if (/[{}]/.test(t)) return false;
        // Evita frases con comas dobles por datos faltantes
        if (/,\s*,/.test(t)) return false;
        return true;
      } catch(e) {
        return false;
      }
    }


    
function autoPickStyleForType(type) {
  const lock = (autoCommentatorMode === 'pro' || autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || autoCommentatorMode === 'narrativo')
    ? autoCommentatorMode : 'pro';

  // Mapeo por evento: usa TODOS los estilos de forma inteligente (sin perder tu modo base)
  const map = {
    leaderChange: 'pro',
    top3: 'pro',
    pass: 'picante',
    battle: 'picante',
    battlePodium: 'picante',
    closing: 'picante',
    pressure: 'picante',
    gap: 'engineer',
    train: 'engineer',
    record: 'narrativo',
    qualiBest: 'pro',
    qualiPole: 'pro'
  };

  const preferred = map[type] || lock;

  // Mezcla: 65% preferido por evento, 35% modo fijo (si el usuario lo cambió)
  const r = Math.random();
  if (lock !== preferred && r < 0.35) return lock;

  // Rotación suave: cada 5 anuncios cambia a un estilo vecino si existe
  try {
    autoStyleMixCounter = (Number(autoStyleMixCounter) || 0) + 1;
    if ((autoStyleMixCounter % 5) === 0) {
      const ring = ['pro','engineer','picante','narrativo'];
      const i = ring.indexOf(preferred);
      if (i >= 0) return ring[(i + 1) % ring.length];
    }
  } catch(e) {}
  return preferred;
}
let autoStyleMixCounter = 0;

function autoBuildMessage(type, ctx) {
      const style = (typeof autoPickStyleForType === 'function')
        ? autoPickStyleForType(type)
        : ((autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || autoCommentatorMode === 'narrativo') ? autoCommentatorMode : 'pro');

      // Motor contextual inteligente: decide al vuelo que decir segun carrera, gap y continuidad
      try {
        const smartOut = ttsSmartComposeAuto(type, ctx || {}, style);
        if (smartOut && autoIsUsableText(smartOut, type)) {
          return autoDecorate(smartOut, type, style);
        }
      } catch(e) {}

      // Motor generativo despues: plantillas + variantes = miles de combinaciones
      try {
        const genOut = ttsGenAutoCompose(type, ctx || {}, style);
        if (genOut && autoIsUsableText(genOut, type)) {
          return autoDecorate(genOut, type, style);
        }
      } catch(e) {}

      const dict = (AUTO_PHRASES_BY_STYLE && AUTO_PHRASES_BY_STYLE[style]) ? AUTO_PHRASES_BY_STYLE[style] : AUTO_PHRASES_PRO;
      const bank = (dict && dict[type]) ? dict[type] : (AUTO_PHRASES_PRO[type] || []);
      const keyBase = style + ':' + type;

      // Intento 1 + re-roll 1 vez si la frase queda incompleta (sin datos)
      for (let attempt = 0; attempt < 2; attempt++) {
        const fn = autoRandPick(bank, keyBase);
        if (typeof fn !== 'function') break;
        const out = String(fn(ctx) || '').trim();
        if (!autoIsUsableText(out, type)) continue;
        return autoDecorate(out, type, style);
      }
      return '';
    }

    // =========================
// BLUE FLAG (Auto Locutor)
// - Se anuncia solo en Auto Locutor (sin piloto seleccionado)
// - Lgica: si el líder ya te sac 1 vuelta (lapDiff>=1 o gap "+1 V"), pide cortesa
// - Anti-spam: 1 por tick, cooldown global y por piloto, y repetir mximo cada 2 vueltas del líder
// =========================
const __autoBlueLatch = new Map(); // pilotKey -> { lastLeaderLap, lastSpeakMs }
let __autoBlueLastGlobalMs = 0;

function __autoParseLapDiff(raw){
  try{
    const s0 = String(raw || '').trim();
    if (!s0) return 0;
    const mV = s0.match(/([+-]?\s*\d+)\s*v/i);
    if (mV){
      const n = parseInt(String(mV[1]).replace(/\s+/g,''), 10);
      if (isFinite(n)) return Math.abs(n);
    }
    const s = s0.toLowerCase();
    const mMas = s.match(/m[a]s\s+(\d+)\s+vueltas?/i);
    if (mMas){
      const n = parseInt(mMas[1], 10);
      if (isFinite(n) && n > 0) return n;
    }
  }catch(e){}
  return 0;
}
function __autoSafeName(r){
  const n = (r && (r.racerName || r.name || r.pilotName || r.piloto || r.driverName)) || '';
  return String(n).replace(/\s+/g,' ').trim();
}

function __autoBlueFlagCheck(arr, leader, nowMs, vs){
  try{
    if (!vs || !vs.blueflag) return;
    if (!arr || arr.length < 2) return;
    if (!lastPassEvents || typeof lastPassEvents.get !== 'function') return;

    const BLUE_PROX_MS = 800; // fijo (0.8s)
    const sessionType = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
    const isMangaSess = (sessionType === 'MANGA' || sessionType === 'TRAIN');
    const isFinalSess = (sessionType === 'FINAL');

    // Evita spam al inicio (espera un poco de carrera)
    const leaderLap = Number(leader && leader.lapcount) || 0;
    const minLap = isMangaSess ? 4 : 3;
    if (leaderLap < minLap) return;

    // Cooldown global (Final mas reactivo, Manga mas conservador)
    const globalCd = isFinalSess ? 7000 : (isMangaSess ? 11000 : 9000);
    if (nowMs - __autoBlueLastGlobalMs < globalCd) return;

    const sorted = arr.slice().filter(r => r && (r.pos != null));
    sorted.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));

    const top3 = sorted.filter(r => {
      const p = Number(r.pos)||999;
      return p >= 1 && p <= 3;
    }).slice(0,3);
    if (!top3.length) return;

    const topKeys = new Set(top3.map(p => getPilotKey(p)).filter(Boolean));

    // Recorremos rezagados y buscamos si algun Top3 lo esta lapeando MUY cerca por meta.
    for (const r of sorted){
      if (!r) continue;
      const rk = getPilotKey(r);
      if (!rk || topKeys.has(rk)) continue;

      const re = lastPassEvents.get(rk);
      if (!re || !isFinite(re.time)) continue;
      const rLap = Number(re.lap) || 0;
      if (rLap <= 0) continue;

      let best = null;
      for (const laper of top3){
        const lk = getPilotKey(laper);
        if (!lk) continue;
        const le = lastPassEvents.get(lk);
        if (!le || !isFinite(le.time)) continue;
        if (le.time <= re.time) continue;

        const delta = le.time - re.time;
        if (delta <= 0 || delta > BLUE_PROX_MS) continue;

        const laperLap = Number(le.lap) || 0;
        const lapDiff = laperLap - rLap;
        if (lapDiff < 1) continue;

        if (!best || delta < best.delta) {
          best = { laper, lk, le, delta, laperLap, lapDiff };
        }
      }
      if (!best) continue;

      let st = __autoBlueLatch.get(rk) || {
        lastLeaderLap: -999,
        lastSpeakMs: 0,
      lastBasicSpeakMs: 0,
        blueHits: 0,
        blueWindowMs: 0
      };

      // repetir max cada 2 vueltas del lapeador (Top3)
      if (best.laperLap && (best.laperLap - st.lastLeaderLap) < 2) continue;

      // cooldown por piloto
      const pilotCd = isFinalSess ? 16000 : 18000;
      if (nowMs - (st.lastSpeakMs || 0) < pilotCd) continue;

      const name = __autoSafeName(r);
      if (!name) continue;
      const laperPos = Number(best.laper && best.laper.pos) || 0;
      const laperName = __autoSafeName(best.laper);
      if (!laperName) continue;
      const who = (laperPos === 1) ? ('el líder P1 ' + laperName) : ('P' + laperPos + ' ' + laperName);

      const baseMsg = isFinalSess
        ? `Bandera azul. ${name}, detras viene ${who}. Abre en la recta.`
        : `Bandera azul. ${name}, detras viene ${who}. Abre en la recta.`;

      // Azul crtica en Finales: si en 30s ya son 2 veces, sube tono
      st.blueHits = st.blueHits || 0;
      st.blueWindowMs = st.blueWindowMs || 0;
      if (!st.blueWindowMs || (nowMs - st.blueWindowMs) > 30000) {
        st.blueWindowMs = nowMs;
        st.blueHits = 0;
      }
      st.blueHits++;
      const useCrit = isFinalSess && st.blueHits >= 2 && (nowMs - st.blueWindowMs) <= 30000;
      const finalMsg = useCrit
        ? `Azul critica. ${name}, suelta en la recta. Detras viene ${who}.`
        : baseMsg;

      enqueueSpeech(finalMsg, {
        key: `auto_blue_${rk}`,
        priority: 6,
        cooldownMs: 8000,
        postDelayMs: 260
      });

      st.lastLeaderLap = best.laperLap || st.lastLeaderLap;
      st.lastSpeakMs = nowMs;
      __autoBlueLatch.set(rk, st);
      __autoBlueLastGlobalMs = nowMs;
      break; // 1 por tick
    }
  }catch(e){}
}

function handleAutoCommentator() {
      try {
        if (!raceData || !Array.isArray(raceData.classification)) return;
        if (selectedPilotKey) return; // modo espectador
        // AI: en Auto Locutor, si el usuario no ha tocado VOZ, activamos voz automticamente
        if (!voiceMasterEnabled) {
          try { if (!userVoiceOverride) setVoiceMaster(true, { silent:true, auto:true }); } catch(e) {}
        }
        if (!voiceMasterEnabled) return;

        const vs = (typeof voiceSettings !== 'undefined' && voiceSettings) ? voiceSettings : {};
        const isBasicAuto = !!(typeof basicModeEnabled !== 'undefined' && basicModeEnabled);
        // Si el usuario apaga TODO menos laps, no inventamos. En BÁSICO sí hablamos (P1).
        const autoOn = !!(vs.pos || vs.podium || vs.pelea || vs.gaps || vs.leadergap || vs.bestlap || vs.estlap || vs.attack || vs.defense || vs.front06 || vs.back06 || vs.ritmo || vs.total || vs.blueflag || vs.cons10 || vs.netgain);
        if (!autoOn && !isBasicAuto) return;

        const arr = raceData.classification.slice().filter(r => r && (r.pos != null));
        // Auto Locutor: ciclo de vida (espera a que arranque, silencio al terminar)
        try { __autoUpdateLifecycle(raceData); } catch(e) {}
        if (__autoPhase === 'WAIT_START') return; // ya se anunci, ahora silencio hasta que arranque
        if (__autoPhase === 'FINISHED') return;   // carrera terminada, espera siguiente raceName
        if (!arr.length) return;

        arr.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));

        // Auto Locutor: al cumplirse el tiempo de la final, anunciar quienes van finalizando
        try { __autoAnnounceFinishers(); } catch(e) {}

        // En cierre: solo 'finalizo' y silencio (no narrar peleas ni swaps)
        if (__autoPhase === 'CLOSING') return;

        const leader = arr.find(r => Number(r.pos) === 1) || arr[0];
        const leaderLap = Number(leader && leader.lapcount) || 0;

        // ====== BÁSICO en AUTO: solo P1 (laps + última vuelta)
        if (isBasicAuto) {
          const leaderKey = getPilotKey(leader) || '';
          const leaderName = safeRacerName(leader && leader.racerName) || 'P1';
          const leaderChanged = (leaderKey && commentatorAutoState.lastLeaderKey && leaderKey !== commentatorAutoState.lastLeaderKey);
          const lapAdvanced = (leaderLap > 0 && leaderLap !== (commentatorAutoState.lastLeaderLap || 0));

          let lastMs = 0;
          try {
            lastMs = Number(leader && leader.lastLapMs) ||
              normalizeLapMs(parseTimeToMs((leader && (leader.lastLapTime || leader.lastLap || leader.lastTime)) || 0));
            if (!isFinite(lastMs) || lastMs < 0) lastMs = 0;
          } catch(e) { lastMs = 0; }

          const lastTxt = (lastMs > 0) ? msToMinSec(lastMs) : '';
          const nowBasic = Date.now();
          const sinceBasic = nowBasic - (Number(commentatorAutoState.lastBasicSpeakMs || 0) || 0);

          if ((leaderChanged || lapAdvanced) && leaderLap > 0 && sinceBasic > 2500) {
            let msg = (leaderName ? ('P1 ' + leaderName + '.') : 'P1.');
            if (leaderChanged) msg = ('Nuevo líder. ' + msg);
            if (lastTxt) msg = (msg + ' Última ' + lastTxt + '.');
            speakWithLaps(leaderLap, msg, { voiceURI: nextAutoVoiceURI(), key: 'basic_auto_' + leaderKey + '_' + leaderLap, priority: 4, cooldownMs: 1200, dedupe: true, mood:'calm' });
            commentatorAutoState.lastBasicSpeakMs = nowBasic;
          }

          commentatorAutoState.lastLeaderKey = leaderKey || commentatorAutoState.lastLeaderKey;
          commentatorAutoState.lastLeaderKeyName = leaderName || commentatorAutoState.lastLeaderKeyName;
          commentatorAutoState.lastLeaderLap = leaderLap || commentatorAutoState.lastLeaderLap;

          // snapshot (para que al salir de BÁSICO no se vuelvan locos los pases)
          try {
            const prevPos = new Map();
            const prevByPos = [];
            for (let i = 0; i < arr.length; i++) {
              const r = arr[i];
              const k = getPilotKey(r);
              const p = Number(r.pos) || (i+1);
              if (k) { prevPos.set(k, p); prevByPos[p-1] = k; }
            }
            commentatorAutoState.prevPosByKey = prevPos;
            commentatorAutoState.prevKeyByPos = prevByPos;
          } catch(e) {}
          return;
        }

        const progress = autoRaceProgress(leaderLap);


        // ====== Top5 stability gate (para anunciar pases en posiciones bajas)
        try {
          const top5 = arr.slice(0, 5);
          const top5Sig = top5.map(r => String(getPilotKey(r) || '')).join('|');
          if (leaderLap && leaderLap !== (commentatorAutoState.lastTop5Lap || 0)) {
            if (top5Sig && top5Sig === (commentatorAutoState.lastTop5Sig || '')) {
              commentatorAutoState.stableTop5Laps = (Number(commentatorAutoState.stableTop5Laps) || 0) + 1;
            } else {
              commentatorAutoState.stableTop5Laps = 0;
            }
            commentatorAutoState.lastTop5Sig = top5Sig;
            commentatorAutoState.lastTop5Lap = leaderLap;
          }
        } catch(e) {}
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

        // ====== bandera azul (Auto Locutor)
        try { __autoBlueFlagCheck(arr, leader, now, vs); } catch(e) {}

        // ====== candidatos (score decide)
        const candidates = [];
        const battles = [];
        const addCand = (c) => { if (c && c.text && isFinite(c.score)) candidates.push(c); };


        // ====== RECORD / BEST LAP (carrera): usa banco 'record' cuando mejora la mejor vuelta global
        try {
          const _stype = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
          const isMangaSess = (_stype === 'MANGA' || _stype === 'TRAIN');
          if (!isMangaSess && vs.bestlap) {
            let bestMs = null;
            let bestKey = '';
            let bestName = '';
            for (let i = 0; i < Math.min(arr.length, 12); i++) {
              const r = arr[i];
              const k = getPilotKey(r);
              const b = Number(r && r.best) || 0;
              if (!k || !b || !isFinite(b)) continue;
              if (bestMs == null || b < bestMs) { bestMs = b; bestKey = k; bestName = safeRacerName(r.racerName) || ''; }
            }
            if (bestMs != null && isFinite(bestMs) && bestMs > 0) {
              const prev = (commentatorAutoState.bestOverallRaceMs == null) ? null : Number(commentatorAutoState.bestOverallRaceMs);
              const improved = (prev == null) ? false : (bestMs < (prev - 20)); // 20ms para evitar ruido
              const since = Date.now() - (Number(commentatorAutoState.lastRecordSpeakMs || 0) || 0);
              if (improved && since > 12000) {
                const best = msToVoiceTime(bestMs);
                const pilot = bestName || 'un piloto';
                const text = autoBuildMessage('record', { pilot, best });
                addCand({
                  type:'record',
                  score: 7.2 + (leaderLap > 5 ? 0.4 : 0),
                  text,
                  key: 'auto_record',
                  sig: 'auto:record:' + String(bestKey || ''),
                  sigCooldownMs: 24000,
                  priority: 6,
                  onCommit: () => {
                    commentatorAutoState.bestOverallRaceMs = bestMs;
                    commentatorAutoState.bestOverallRaceKey = bestKey;
                    commentatorAutoState.lastRecordSpeakMs = Date.now();
                  }
                });
              } else if (prev == null) {
                // inicializa sin hablar
                commentatorAutoState.bestOverallRaceMs = bestMs;
                commentatorAutoState.bestOverallRaceKey = bestKey;
              }
            }
          }
        } catch(e) {}


        // ====== cambios de líder / posiciones
        const leaderKey = getPilotKey(leader);
        if (leaderKey && commentatorAutoState.lastLeaderKey && leaderKey !== commentatorAutoState.lastLeaderKey) {
          if (vs.pos || vs.leadergap || vs.podium) {
            const prevLeaderName = safeRacerName((commentatorAutoState.lastLeaderKeyName || ''));
            const winner = safeRacerName(leader.racerName) || 'el líder nuevo';
            const loser = prevLeaderName || 'el líder anterior';
            const text = autoBuildMessage('leaderChange', { winner, loser });
            addCand({
              type:'leaderChange',
              score: 10.0 + (progress > 0.75 ? 0.6 : 0),
              text,
              key: 'auto_leader_change',
              sig: 'auto:leaderChange',
              sigCooldownMs: 9000,
              priority: 9
            });
          }
        }
        // guardar nombre del líder para el siguiente tick
        commentatorAutoState.lastLeaderKeyName = safeRacerName(leader && leader.racerName);

        // Overtakes por swap de posiciones
        if (commentatorAutoState.prevKeyByPos && commentatorAutoState.prevKeyByPos.length) {
          // detecta swaps simples: key actual en pos i y key previa diferente
          for (let i = 0; i < Math.min(arr.length, 10); i++) {
            const curr = arr[i];
            const currPos = Number(curr.pos) || (i+1);
            const currKey = getPilotKey(curr);
            if (!currKey) continue;
            const prevKeyAtThisPos = commentatorAutoState.prevKeyByPos[currPos-1];
            if (prevKeyAtThisPos && prevKeyAtThisPos !== currKey) {
              const prevPos = commentatorAutoState.prevPosByKey.get(currKey);
              // solo si realmente gan posiciones
              if (prevPos && currPos < prevPos) {
                const loserKey = prevKeyAtThisPos;
                if (!loserKey || loserKey === currKey) continue;

                // Snapshot de posiciones previas (tick anterior) para un pase consistente:
                // - winnerPrevPos: de dnde vena el ganador
                // - loserPrevPos: dnde iba el perdedor (debe coincidir con currPos para un swap simple)
                const winnerPrevPos = prevPos;
                const loserPrevPos = commentatorAutoState.prevPosByKey.get(loserKey);

                // Solo narramos swaps simples (evita anunciar cosas raras y evita "P1...P1"):
                if (loserPrevPos && loserPrevPos !== currPos) continue;

                // Nueva posición del perdedor: cae al lugar de donde vena el ganador
                let loserNewPos = winnerPrevPos || (currPos + 1);
                // Guardrail: nunca narrar que ambos quedaron en la misma posición
                if (loserNewPos === currPos) loserNewPos = currPos + 1;

                const winner = safeRacerName(curr.racerName) || 'un piloto';
                const loser = safeRacerName((arr.find(x => getPilotKey(x)===loserKey)||{}).racerName) || 'otro piloto';

                const text = autoBuildMessage('pass', { winner, loser, newPos: currPos, oldPos: loserNewPos });


                // Gate: cambios en posiciones bajas solo si Top5 sin cambios en 3 vueltas
                try {
                  const stable = Number(commentatorAutoState && commentatorAutoState.stableTop5Laps) || 0;
                  if (Number(currPos) > 5 && stable < 3) {
                    continue;
                  }
                } catch(e) {}
                let s = 8.8;
                if (currPos <= 3) s += 0.9;
                if (currPos === 1) s += 0.6;
                if (progress > 0.75 && currPos <= 5) s += 0.6;

                addCand({
                  type:'pass',
                  score: s,
                  text,
                  key: 'auto_pass_' + currKey + '_' + currPos,
                  sig: 'auto:pass:' + currKey + ':' + currPos,
                  sigCooldownMs: 12000,
                  priority: 8
                });
              }
            }
          }
        }

        // ====== top 3 (resumen inteligente: solo cuando aporta)
        if (vs.pos || vs.podium || vs.leadergap) {
          if (arr.length >= 3) {
            const p1 = safeRacerName(arr[0].racerName) || 'P1';
            const p2 = safeRacerName(arr[1].racerName) || 'P2';
            const p3 = safeRacerName(arr[2].racerName) || 'P3';

            const sig = `${p1}|${p2}|${p3}`;
            const hadSig = !!(commentatorAutoState.lastTop3Sig);
            const orderChanged = hadSig && (sig !== commentatorAutoState.lastTop3Sig);

            // milestones para no repetir sin sentido
            const msArr = [0.25, 0.50, 0.75, 0.90];
            let hitMilestone = 0;
            for (const m0 of msArr) {
              if (progress >= m0 && (commentatorAutoState.lastMilestone || 0) < m0) { hitMilestone = m0; break; }
            }

            const stableCooldownMs = 35000;// C: mas frecuente (30-40s) // si no cambia nada, habla mucho menos
            const shouldByChange = orderChanged;
            const shouldByMilestone = !!hitMilestone;
            const shouldByTime = (now - (commentatorAutoState.lastTop3Ms || 0) > stableCooldownMs);

            if ((shouldByChange || shouldByMilestone || shouldByTime) && leaderLap > 0) {
              const lapNow = leaderLap || 0;
              const lapTotal = Number(raceData.lapCount) || 0;
              const text = autoBuildMessage('top3', { p1, p2, p3, lapNow, lapTotal });

              let s = 3.3;
              if (orderChanged) s += 1.3;
              if (hitMilestone) s += 0.7;
              if (progress > 0.80) s += 0.4;

              addCand({
                type:'top3',
                score: s,
                text,
                key:'auto_top3',
                sig:'auto:top3',
                sigCooldownMs: commentatorAutoCfg.top3CooldownMs,
                priority: 3,
                onCommit: () => {
                  commentatorAutoState.lastTop3Ms = now;
                  commentatorAutoState.lastTop3Sig = sig;
                  if (hitMilestone) commentatorAutoState.lastMilestone = hitMilestone;
                  commentatorTop3LastLeaderLap = leaderLap || commentatorTop3LastLeaderLap;
                }
              });
            }
          }
        }

        // ====== batallas cerradas (<=0.5s) y trenecito
        if (vs.pelea) {
          // trenecito podio: P2-P4 muy juntos
          if (arr.length >= 4) {
            const a2 = arr[1], a3 = arr[2], a4 = arr[3];
            const k2 = getPilotKey(a2), k3 = getPilotKey(a3), k4 = getPilotKey(a4);
            const sameLap = (Number(a2.lapcount)||0)===(Number(a3.lapcount)||0) && (Number(a3.lapcount)||0)===(Number(a4.lapcount)||0);
            if (sameLap && a2.time!=null && a3.time!=null && a4.time!=null) {
              const d23 = (a3.time - a2.time)/1000;
              const d34 = (a4.time - a3.time)/1000;
              if (d23>0 && d34>0 && d23<=0.60 && d34<=0.60) {
                const p2n = safeRacerName(a2.racerName) || 'P2';
                const p3n = safeRacerName(a3.racerName) || 'P3';
                const p4n = safeRacerName(a4.racerName) || 'P4';
                const text = autoBuildMessage('train', { p2: p2n, p3: p3n, p4: p4n });
                addCand({
                  type:'train',
                  score: 7.2 + (progress>0.75?0.6:0),
                  text,
                  key:'auto_train_podium',
                  sig:'auto:train',
                  sigCooldownMs: 18000,
                  priority: 7
                });
              }
            }
          }

          for (let i = 0; i < arr.length - 1; i++) {
            const ahead = arr[i];
            const behind = arr[i + 1];
            if (!ahead || !behind) continue;

            const aKey = getPilotKey(ahead);
            const bKey = getPilotKey(behind);
            if (!aKey || !bKey) continue;

            const aLaps = Number(ahead.lapcount) || 0;
            const bLaps = Number(behind.lapcount) || 0;
            const pairKey = autoPairKey(aKey, bKey);

            // si no estan en la misma vuelta, rearmar latch
            if (aLaps !== bLaps) {
              if (commentatorBattleLatch && commentatorBattleLatch.has(pairKey)) commentatorBattleLatch.delete(pairKey);
              continue;
            }

            if (ahead.time == null || behind.time == null) continue;
            const diffMs = (behind.time - ahead.time);
            if (!diffMs || diffMs <= 0) continue;

const sec = diffMs / 1000;

const posFight = Number(ahead.pos) || (i + 1);

// Pool para narracin con hilo (seguimos la pelea aunque no est en 0.50 exacto)
const defenderName = safeRacerName(ahead.racerName) || 'el de adelante';
const attackerName = safeRacerName(behind.racerName) || 'el de atrs';
const secNum = sec;

// Tendencia (si el atacante viene ms rápido en la última vuelta, pesa ms)
const aLast = Number(ahead.lastTime) || 0;
const bLast = Number(behind.lastTime) || 0;
const attackerFaster = (aLast > 0 && bLast > 0) ? ((aLast - bLast) / 1000) : 0; // >0 = el de atrs viene ms rápido

const rem = autoRememberPair(pairKey, secNum, leaderLap, now);
const trendBonus = (rem.deltaSec < -0.08) ? 0.8 : (rem.deltaSec < -0.04 ? 0.4 : 0);

// Score base para el pool
let poolScore = 4.0 + clamp01((1.25 - secNum) / 1.25) * 4.2;
if (posFight <= 3) poolScore += 1.3;
if (posFight === 1) poolScore += 0.7;
if (progress > 0.80 && posFight <= 5) poolScore += 0.5;
poolScore += trendBonus;
if (attackerFaster > 0.10) poolScore += 0.5;

if (secNum <= 1.25) {
  battles.push({
    pairKey,
    pos: posFight,
    defender: defenderName,
    attacker: attackerName,
    secNum,
    score: poolScore,
    lastMentionMs: rem.lastMentionMs || 0
  });
}

// histeresis: rearmar cuando se abre
            const prevLatch = commentatorBattleLatch ? commentatorBattleLatch.get(pairKey) : null;
            if (prevLatch && prevLatch.active) {
              if (sec >= 0.72) commentatorBattleLatch.delete(pairKey);
              else continue;
            }

            if (sec <= 0.50) {
              const defender = safeRacerName(ahead.racerName) || 'el de adelante';
              const attacker = safeRacerName(behind.racerName) || 'el de atrs';
              const secStr = gapToSpeech(sec, 'battle');

              const closeness = clamp01((0.50 - sec) / 0.50);
              let score = 6.0 + closeness * 3.0;
              if (posFight <= 3) score += 1.6;
              if (posFight === 1) score += 0.8;
              if (progress > 0.80 && posFight <= 5) score += 0.7;

              const type = (posFight <= 3) ? 'battlePodium' : 'battle';
              const text = autoBuildMessage(type, { pos: posFight, attacker, defender, sec: secStr });

              addCand({
                type,
                secNum: secNum,
                score,
                text,
                key: 'auto_duel_' + pairKey,
                sig: 'auto:duel:' + pairKey,
                sigCooldownMs: 12000,
                priority: 6
              });

              if (commentatorBattleLatch) commentatorBattleLatch.set(pairKey, { active: true, lastLeadLap: leaderLap });
            }
          }
        }

        // ====== se cierra (0.5 a 1.6, baja gap fuerte)
        // Nota: POS ya no dispara cierres (para evitar duplicados). Cierres=ATAQUE/DEFENSA, gaps=nmeros.
        if (vs.attack || vs.defense || vs.front06 || vs.back06 || vs.gaps) {
          for (let i = 0; i < arr.length - 1; i++) {
            const ahead = arr[i];
            const behind = arr[i + 1];
            if (!ahead || !behind) continue;

            const aKey = getPilotKey(ahead);
            const bKey = getPilotKey(behind);
            if (!aKey || !bKey) continue;

            const aLaps = Number(ahead.lapcount) || 0;
            const bLaps = Number(behind.lapcount) || 0;
            const pairKey = autoPairKey(aKey, bKey);

            if (aLaps !== bLaps) {
              if (commentatorGapHistory && commentatorGapHistory.has(pairKey)) commentatorGapHistory.delete(pairKey);
              continue;
            }

            if (ahead.time == null || behind.time == null) continue;
            const diffMs = (behind.time - ahead.time);
            if (!diffMs || diffMs <= 0) continue;
            const sec = diffMs / 1000;

            const hist = commentatorGapHistory ? commentatorGapHistory.get(pairKey) : null;
            const lastTrailLap = hist ? (hist.lastTrailLap || 0) : 0;
            if (hist && lastTrailLap === bLaps) continue;

            const newHist = {
              lastGapMs: diffMs,
              lastTrailLap: bLaps,
              lastSpokenTrailLap: hist ? (hist.lastSpokenTrailLap || 0) : 0
            };
            if (commentatorGapHistory) commentatorGapHistory.set(pairKey, newHist);

            if (sec < 0.35 || sec > 1.35) continue;
            if (!hist || !hist.lastGapMs) continue;

            const deltaMs = (hist.lastGapMs - diffMs); // positivo: se acerca
            if (deltaMs < 260) continue;

            // no hablar cada vuelta
            if (newHist.lastSpokenTrailLap && bLaps <= (newHist.lastSpokenTrailLap + 1)) continue;

const posFight = Number(ahead.pos) || (i + 1);
const defender = safeRacerName(ahead.racerName) || 'el de adelante';
const attacker = safeRacerName(behind.racerName) || 'el de atrs';
const fromSec = gapToSpeechBare(hist.lastGapMs / 1000, 'close');
const toSec = gapToSpeechBare(sec, 'close');

// Pool de narracin: cuando se cierra fuerte, conviene seguirlo
try {
  const rem2 = autoRememberPair(pairKey, sec, leaderLap, now);
  let poolScore2 = 4.0 + clamp01((1.25 - sec) / 1.25) * 3.6;
  poolScore2 += clamp01(deltaMs / 700) * 1.2;
  if (posFight <= 3) poolScore2 += 1.1;
  if (progress > 0.80 && posFight <= 5) poolScore2 += 0.5;
  if (sec <= 1.25) {
    battles.push({
      pairKey,
      pos: posFight,
      defender,
      attacker,
      secNum: sec,
      score: poolScore2 + 0.6,
      lastMentionMs: rem2.lastMentionMs || 0,
      encounters: rem2.encounterCount || 0,
      closeTicks: rem2.closeTicks || 0,
      hotTicks: rem2.hotTicks || 0,
      activeMs: rem2.activeMs || 0
    });
  }
} catch(e) {}

            let score = 4.6 + clamp01(deltaMs / 600) * 2.5;
            if (posFight <= 3) score += 1.1;
            if (progress > 0.80 && posFight <= 5) score += 0.5;

            const deltaStr = gapDeltaSpeech(Math.max(0, deltaMs)/1000);

            // ATAQUE: tendencia de recorte (ms narrativa)
            if (vs.attack) {
              const text = autoBuildMessage('closing', { pos: posFight, attacker, defender, fromSec, toSec, delta: deltaStr });
              addCand({
                type:'closing',
                score,
                text,
                key:'auto_close_' + pairKey,
                sig:'auto:close:' + pairKey,
                sigCooldownMs: 9000,
                priority: 4
              });
            }

            // GAPS: solo nmeros (sin hype), con cooldown largo para no spamear
            if (vs.gaps && posFight <= 6 && sec <= 2.0) {
              const text = autoBuildMessage('gap', { pos: posFight, attacker, defender, sec: gapToSpeech(sec, 'gap') });
              addCand({
                type:'gap',
                score: Math.max(2.8, score - 1.9),
                text,
                key:'auto_gap_' + pairKey,
                sig:'auto:gap:' + pairKey,
                sigCooldownMs: 22000,
                priority: 2
              });
            }

            // DEFENSA: presin real (<=0.6) para el de adelante
            if ((vs.defense || vs.back06) && posFight <= 8 && sec <= 0.60) {
              const text = autoBuildMessage('pressure', { pos: posFight, attacker, defender, sec: gapToSpeech(sec, 'pressure') });
              addCand({
                type:'pressure',
                score: 6.2,
                text,
                key:'auto_pressure_' + pairKey,
                sig:'auto:press:' + pairKey,
                sigCooldownMs: 16000,
                priority: 5
              });
            }

            newHist.lastSpokenTrailLap = bLaps;
            if (commentatorGapHistory) commentatorGapHistory.set(pairKey, newHist);
          }
        }

// ====== modo de sesin
const sessionType = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
const isMangaSess = (sessionType === 'MANGA' || sessionType === 'TRAIN');
const isFinalSess = (sessionType === 'FINAL');

// Auto-estilo por sesion (default): MANGA=SERIO (pro), FINALES=HYPE (narrativo)
if (!autoModeUserOverride && !basicModeEnabled) {
  const wantMode = isFinalSess ? 'narrativo' : (isMangaSess ? 'pro' : autoCommentatorMode);
  if (wantMode && autoCommentatorMode !== wantMode) {
    autoCommentatorMode = wantMode;
    try { prefSet('autoCommentatorMode', wantMode); } catch(e) {}
    try { updateAutoCommentatorButtons(); } catch(e) {}
  }
}

// ====== narracin con hilo: elegimos una pelea y la seguimos con contexto
if ((voiceSettings.pelea || voiceSettings.attack || voiceSettings.defense) && battles && battles.length) {
  const sc = autoBuildStoryCandidate({ battles, now, leaderLap, progress, isMangaSess });
  if (sc) addCand(sc);
}

// ====== MANGA (clasificacin): pole/best lap (menos ruido, ms sustancia)
if (isMangaSess) {
  const wantBest = !!vs.bestlap;
  const wantPoleFight = !!(vs.bestlap || vs.pelea);

  try {
    // Mejor vuelta global
    if (wantBest) {
      let bestMs = null;
      let bestKey = '';
      let bestName = '';
      for (let i = 0; i < Math.min(arr.length, 12); i++) {
        const r = arr[i];
        const k = getPilotKey(r);
        const b = Number(r && r.best) || 0;
        if (!k || !b || !isFinite(b)) continue;
        if (bestMs == null || b < bestMs) {
          bestMs = b; bestKey = k; bestName = safeRacerName(r.racerName) || '';
        }
      }

      if (bestMs != null && isFinite(bestMs) && bestMs > 0) {
        const improved = (autoQualiState.bestOverallMs == null) ? true : (bestMs < (autoQualiState.bestOverallMs - 20));
        const since = now - (autoQualiState.lastBestSpeakMs || 0);

        if (improved && since > 10000) {
          const t = msToVoiceTime(bestMs); // ya aplica regla flat/precision
          const pilot = bestName || 'un piloto';
          const best = t;
          const txt = autoBuildMessage('qualiBest', { pilot, best });
          addCand({
            type: 'qualiBest',
            score: 6.8,
            text: txt,
            key: 'auto_quali_best',
            sig: 'auto:qualiBest:' + String(bestKey || ''),
            sigCooldownMs: 24000,
            priority: 6,
            onCommit: () => {
              autoQualiState.bestOverallMs = bestMs;
              autoQualiState.bestOverallKey = bestKey;
              autoQualiState.lastBestSpeakMs = now;
            }
          });
        }
      }
    }

    // Pelea por la pole (Top2)
    if (wantPoleFight) {
      if (arr.length >= 2) {
        const r1 = arr[0], r2 = arr[1];
        const b1 = Number(r1 && r1.best) || 0;
        const b2 = Number(r2 && r2.best) || 0;
        const n1 = safeRacerName(r1 && r1.racerName) || 'P1';
        const n2 = safeRacerName(r2 && r2.racerName) || 'P2';
        if (b1 > 0 && b2 > 0 && isFinite(b1) && isFinite(b2)) {
          const gap = Math.abs(b2 - b1) / 1000;
          const sincePF = now - (autoQualiState.lastPoleFightSpeakMs || 0);
          if (gap <= 0.10 && sincePF > 14000) {
            const g = gapToSpeech(gap, 'pole');
            const p1 = n1; const p2 = n2; const sec = g;
            const txt = autoBuildMessage('qualiPole', { p1, p2, sec });
            addCand({
              type: 'qualiPole',
              score: 6.1,
              text: txt,
              key: 'auto_quali_pole',
              sig: 'auto:qualiPole',
              sigCooldownMs: 16000,
              priority: 5,
              onCommit: () => { autoQualiState.lastPoleFightSpeakMs = now; }
            });
          }
        }
      }
    }
  } catch(e) {}
}

// ====== si no hay accion real, mini resumen (C: Top5 + pelea mas cerrada)
        try {
          let maxScore = 0;
          for (const c of candidates) maxScore = Math.max(maxScore, Number(c && c.score) || 0);

          const quietCooldownMs = Number(commentatorAutoState.nextQuietCooldownMs || 0) || Math.floor((commentatorAutoCfg.quietMinMs || 30000) + Math.random() * Math.max(0, (commentatorAutoCfg.quietMaxMs || 40000) - (commentatorAutoCfg.quietMinMs || 30000)));
          const sinceQuiet = now - (commentatorAutoState.lastQuietMs || 0);

          const allowMini = !!(vs.pos || vs.podium || vs.total || vs.leadergap || vs.pelea);
          const sinceSpeak = now - (commentatorAutoState.lastSpeakMs || 0);

          // Solo si ya arranco y no hay "accion fuerte"; evita perico, pero mantiene narrativa.
          if (allowMini && sinceQuiet > quietCooldownMs && maxScore < (commentatorAutoCfg.baseThresholdScore || 4.6) && sinceSpeak > 26000 && leaderLap > 0) {
            // Top 5 (con pausas)
            const top = arr.slice(0, 5);
            const names = top.map((r, idx) => safeRacerName(r && r.racerName) || ('P' + String((Number(r && r.pos) || (idx + 1))))).filter(Boolean);
            let topTxt = '';
            if (names.length) topTxt = 'Top cinco. ' + names.map(n => String(n)).join('. ') + '.';

            // Pelea mas cerrada en Top10 (misma vuelta y <= 1.5s)
            let battleTxt = '';
            try {
              let best = null;
              for (let i = 0; i < Math.min(arr.length, 10) - 1; i++) {
                const a = arr[i], b = arr[i + 1];
                if (!a || !b) continue;
                const la = Number(a.lapcount) || 0;
                const lb = Number(b.lapcount) || 0;
                if (la !== lb) continue;
                if (a.time == null || b.time == null) continue;
                const sec = (Number(b.time) - Number(a.time)) / 1000;
                if (!isFinite(sec) || sec <= 0) continue;
                if (sec > 1.50) continue;
                if (!best || sec < best.sec) {
                  best = {
                    sec,
                    pos: Number(a.pos) || (i + 1),
                    defender: safeRacerName(a.racerName) || 'el de adelante',
                    attacker: safeRacerName(b.racerName) || 'el de atras'
                  };
                }
              }
              if (best) {
                const g = gapToSpeech(best.sec, 'close');
                battleTxt = `Pelea ms cerrada. ${best.attacker} viene ${g} de ${best.defender} por la P${best.pos}.`;
              }
            } catch (e) {}

            // Tiempo restante si aplica
            let leftTxt = '';
            try {
              const dur = Number(currentSessionInfo && currentSessionInfo.durationMs) || 0;
              const elapsed = Number(leader && leader.time) || 0;
              if (dur > 0 && elapsed > 0) {
                const left = Math.max(0, dur - elapsed);
                leftTxt = formatClockMs(left);
              }
            } catch (e) {}

            // Mini resumen con estilo (pro/picante/engineer/narrativo)
            const styleMini = (autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || autoCommentatorMode === 'narrativo') ? autoCommentatorMode : 'pro';

            const MINI_HDR = {
              pro: {
                manga: ['Clasificacion.', 'Clasificacion en vivo.', 'Como va la clasificación.'],
                final: ['Carrera.', 'Carrera en vivo.', 'Como va la carrera.'],
                other: ['Seguimos.', 'Actualizacion.', 'Estado.']
              },
              picante: {
                manga: ['Clasificacion.', 'Clasificacion, sin llorar.', 'Clasificacion, a ver quien trae manos.'],
                final: ['Carrera.', 'Carrera, sin piedad.', 'Carrera, esto ya se prendio.'],
                other: ['Seguimos.', 'Ojo.', 'Atencion.']
              },
              engineer: {
                manga: ['Clasificacion.', 'Control. Clasificacion.', 'Dato. Clasificacion.'],
                final: ['Carrera.', 'Control. Carrera.', 'Dato. Carrera.'],
                other: ['Control.', 'Dato.', 'Info.']
              },
              narrativo: {
                manga: ['Clasificacion.', 'Cambiamos camara. Clasificacion.', 'Vamos con la clasificación.'],
                final: ['Carrera.', 'Cambiamos camara. Carrera.', 'Vamos con la carrera.'],
                other: ['Seguimos.', 'Cambiamos camara.', 'Atencion.']
              }
            };

            const MINI_TOP = {
              pro: ['Top cinco', 'Top 5', 'Los primeros cinco'],
              picante: ['Top cinco', 'Top cinco, sin regalos', 'Top cinco, a puro control'],
              engineer: ['Top cinco', 'Top cinco. Control', 'Top cinco. Dato'],
              narrativo: ['Top cinco', 'Los cinco del frente', 'Los cinco que mandan']
            };

            const MINI_BATTLE = {
              pro: [
                (b) => `Pelea ms cerrada. ${b.attacker} viene ${b.g} de ${b.defender} por la P${b.pos}.`,
                (b) => `Cierre en P${b.pos}. ${b.attacker} a ${b.g} de ${b.defender}.`,
                (b) => `Ojo P${b.pos}. ${b.attacker} trae a tiro a ${b.defender}. ${b.g}.`
              ],
              picante: [
                (b) => `Pelea ms cerrada. ${b.attacker} viene ${b.g} de ${b.defender} por la P${b.pos}.`,
                (b) => `P${b.pos} al rojo vivo. ${b.attacker} trae a tiro a ${b.defender}. ${b.g}.`,
                (b) => `Cierre con colmillo en P${b.pos}. ${b.attacker} ya lo huele. ${b.g}.`,
                (b) => `P${b.pos} sin respiro. ${b.defender} con espejo lleno. ${b.g}.`
              ],
              engineer: [
                (b) => `Gap minimo en P${b.pos}. ${b.attacker} a ${b.g} de ${b.defender}.`,
                (b) => `Cierre en P${b.pos}. Delta ${b.g}.`,
                (b) => `P${b.pos}. ${b.defender} vs ${b.attacker}. ${b.g}.`
              ],
              narrativo: [
                (b) => `La pelea ms cerrada esta en P${b.pos}. ${b.attacker} viene ${b.g} de ${b.defender}.`,
                (b) => `En P${b.pos} se respira tension. ${b.attacker} a ${b.g} de ${b.defender}.`,
                (b) => `Cierre en P${b.pos}. ${b.attacker} no se despega. ${b.g}.`
              ]
            };

            const MINI_TIME = {
              pro: ['Quedan', 'Tiempo restante', 'Restan'],
              picante: ['Quedan', 'Tiempo, ojo', 'Restan'],
              engineer: ['Quedan', 'Restan', 'Tiempo'],
              narrativo: ['Quedan', 'Nos quedan', 'Tiempo restante']
            };

            const hb = MINI_HDR[styleMini] || MINI_HDR.pro;
            const header = autoRandPick(isMangaSess ? hb.manga : isFinalSess ? hb.final : hb.other, 'miniHdr:' + styleMini) || (isMangaSess ? 'Clasificacion.' : isFinalSess ? 'Carrera.' : 'Seguimos.');
            const topIntro = autoRandPick((MINI_TOP[styleMini] || MINI_TOP.pro), 'miniTopIntro:' + styleMini) || 'Top cinco';

            let msg = (header + ' ' + ((topTxt && names.length) ? (topIntro + '. ' + names.map(n => String(n)).join('. ') + '.') : (topTxt || ''))).trim();

            if (battleTxt) {
              // battleTxt viene armado, pero aquí le damos variacion
              try {
                const fn = autoRandPick((MINI_BATTLE[styleMini] || MINI_BATTLE.pro), 'miniBattle:' + styleMini);
                if (fn && typeof fn === 'function') {
                  // extrae datos del string actual (ya tenemos best)
                  // si falla, usamos battleTxt directo
                  msg = (msg + ' ' + String(fn({ attacker: best.attacker, defender: best.defender, pos: best.pos, g: gapToSpeech(best.sec, 'close') }) || battleTxt)).trim();
                } else {
                  msg = (msg + ' ' + battleTxt).trim();
                }
              } catch(e) {
                msg = (msg + ' ' + battleTxt).trim();
              }
            }

            if (leftTxt) {
              const tW = autoRandPick((MINI_TIME[styleMini] || MINI_TIME.pro), 'miniTime:' + styleMini) || 'Quedan';
              msg = (msg + ' ' + tW + ' ' + leftTxt + '.').trim();
            }

            addCand({
              type: 'mini',
              score: 3.2 + (progress > 0.85 ? 0.2 : 0),
              text: msg,
              key: 'auto_mini',
              sig: 'auto:mini',
              sigCooldownMs: quietCooldownMs,
              priority: 2,
              onCommit: () => {
                commentatorAutoState.lastQuietMs = now;
                commentatorAutoState.nextQuietCooldownMs = Math.floor((commentatorAutoCfg.quietMinMs || 30000) + Math.random() * Math.max(0, (commentatorAutoCfg.quietMaxMs || 40000) - (commentatorAutoCfg.quietMinMs || 30000)));
              }
            });
          }
        } catch (e) {}

// ====== elegir el mejor mensaje \(1 por tick\)
        if (!candidates.length) {
          // silencio es oro
          commentatorAutoState.lastLeaderKey = leaderKey || commentatorAutoState.lastLeaderKey;
          commentatorAutoState.lastLeaderLap = leaderLap || commentatorAutoState.lastLeaderLap;
        } else {
          
// MANGA: reduce ruido (menos swaps, ms info til)
if (isMangaSess && candidates && candidates.length) {
  // Top3 + cierres + trenes. Lo dems en manga suele ser "ruido" por salida escalonada.
  const allow = new Set(['top3','closing','train','story','qualiBest','qualiPole','mini']);
  const filtered = [];
  for (const c of candidates) {
    if (c && c.type && allow.has(c.type)) filtered.push(c);
  }
  if (filtered.length) {
    candidates.length = 0;
    for (const c of filtered) candidates.push(c);
  }
}

// Conflict rule: pass vs battle. Prefer battle only if gap <= 0.30s, else pass.
try {
  let hasPass = false;
  let hasBattle = false;
  let minBattleSec = Infinity;
  for (const c of candidates) {
    if (!c) continue;
    if (c.type === 'pass') hasPass = true;
    if (c.type === 'battle' || c.type === 'battlePodium') {
      hasBattle = true;
      const s = Number(c.secNum);
      if (isFinite(s)) minBattleSec = Math.min(minBattleSec, s);
    }
  }
  if (hasPass && hasBattle) {
    const battleWins = isFinite(minBattleSec) && minBattleSec <= 0.30;
    for (const c of candidates) {
      if (!c) continue;
      if (battleWins) {
        if (c.type === 'pass') { c.score -= 3.5; }
        if (c.type === 'battle' || c.type === 'battlePodium') { c.score += 2.0; c.priority = Math.max(Number(c.priority)||0, 9); }
      } else {
        if (c.type === 'pass') { c.score += 1.5; c.priority = Math.max(Number(c.priority)||0, 9); }
        if (c.type === 'battle' || c.type === 'battlePodium') { c.score -= 2.5; }
      }
    }
  }
} catch(e) {}

candidates.sort((a,b) => (b.score - a.score) || (b.priority - a.priority));

for (const c of candidates) {
            const sigCd = Number(c.sigCooldownMs || 0) || commentatorAutoCfg.sigDefaultCooldownMs;
            if (!autoCanSpeak(c.score, c.sig, sigCd, now)) continue;

            // hablar
            speakWithLaps(leaderLap, c.text, { voiceURI: nextAutoVoiceURI(), key: c.key || c.sig || ('auto_' + c.type), priority: c.priority || 0, cooldownMs: 2500, dedupe: true,
              mood: (c.type==='battle' || c.type==='closing' || c.type==='leaderChange' || c.type==='pass' || c.type==='pressure' || c.type==='train') ? 'hype' : (c.type==='qualiBest' || c.type==='qualiPole') ? 'serious' : 'calm' });

            commentatorAutoState.lastSpeakMs = now;
            commentatorAutoState.window.push(now);
            autoMarkSig(c.sig, now);
            try { if (typeof c.onCommit === 'function') c.onCommit(); } catch(e) {}
            break;
          }

          commentatorAutoState.lastLeaderKey = leaderKey || commentatorAutoState.lastLeaderKey;
          commentatorAutoState.lastLeaderLap = leaderLap || commentatorAutoState.lastLeaderLap;
        }

        // ====== actualizar snapshot de posiciones
        const prevPos = new Map();
        const prevByPos = [];
        for (let i = 0; i < arr.length; i++) {
          const r = arr[i];
          const k = getPilotKey(r);
          const p = Number(r.pos) || (i+1);
          if (k) {
            prevPos.set(k, p);
            prevByPos[p-1] = k;
          }
        }
        commentatorAutoState.prevPosByKey = prevPos;
        commentatorAutoState.prevKeyByPos = prevByPos;

      } catch (e) {
        console.error('handleAutoCommentator', e);
      }
    }

function handleVoiceAndBeeps() {
      if (!raceData || !Array.isArray(raceData.classification)) return;
      if (!selectedPilotKey) return;

      const p = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey);
      if (!p) return;

      // Beep tenue al primer detect del piloto seleccionado
      if (!selectedPilotFirstDetectBeeped) {
        selectedPilotFirstDetectBeeped = true;
        try { if (selectedPilotKey) firstDetectBeepedByPilot.set(selectedPilotKey, true); } catch(e) {}

        try { if (voiceMasterEnabled) playBeep('soft'); } catch(e) {}
      }

      const lapsNow = Number(p.lapcount) || 0;
      const idx = findPilotIndexByKey(selectedPilotKey);
      const hist = lapHistory.get(selectedPilotKey) || { lastLapcount: 0, times: [] };

      const lapMsNow = normalizeLapMs(p.lastTime);

      

      // Track de cambios de posición en este tick
      let posChangedTick = false;
      let posFrom = null;
      let posTo = null;
      let posDelta = 0;
// Helper
      const say = (m, opts) => speakWithLaps(lapsNow, m, opts);

      // Actualiza el modo desde raceName (ya viene de Firebase)
      if (raceData && raceData.raceName) {
        currentSessionInfo = parseSessionFromRaceName(raceData.raceName);
       try { applyLapChartPreset(); } catch(e) {}
try { maybeAutoApplySessionPreset(currentSessionInfo); } catch(e) {}
      }

      const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
      const isFinal = currentSessionInfo && currentSessionInfo.type === 'FINAL';

      // =========================
      // 1) Detecta eventos y genera pendientes (no habla aquí)
      // =========================

      // Posición (evento)
      if (p.pos && p.pos > 0) {
        if (lastKnownPos == null) lastKnownPos = p.pos;
        if (startPosForSelected == null) startPosForSelected = p.pos;

        // MANGA: estabilidad de posición (evita flip-flop en ranking por salida escalonada)
        if (isManga) {
          const curPos = Math.floor(p.pos);
          if (mangaPosStability.lastSeenPos == null) {
            mangaPosStability.lastSeenPos = curPos;
            mangaPosStability.stablePos = curPos;
            mangaPosStability.stableCount = 1;
          } else if (curPos === mangaPosStability.lastSeenPos) {
            mangaPosStability.stableCount = Math.min(10, (mangaPosStability.stableCount || 0) + 1);
            if (mangaPosStability.stableCount >= 2) mangaPosStability.stablePos = curPos;
          } else {
            mangaPosStability.lastSeenPos = curPos;
            mangaPosStability.stableCount = 1;
          }
        }

        if (p.pos !== lastKnownPos) {
          posChangedTick = true;
          posFrom = lastKnownPos;
          posTo = p.pos;
          posDelta = (Math.floor(posTo) - Math.floor(posFrom)); // + = cae, - = sube
        }
        // BASIC: estabilidad de posicion (no spam, solo cambios estables)
        if (!isManga && basicModeEnabled && voiceSettings.pos) {
          try{
            const curPosInt = Math.max(1, Math.floor(Number(p.pos) || 0));
            if (basicPosStability.candidatePos == null) {
              basicPosStability.candidatePos = curPosInt;
              basicPosStability.candidateCount = 1;
            } else if (curPosInt === basicPosStability.candidatePos) {
              basicPosStability.candidateCount = Math.min(6, (basicPosStability.candidateCount || 0) + 1);
            } else {
              basicPosStability.candidatePos = curPosInt;
              basicPosStability.candidateCount = 1;
            }

            if (basicPosStability.candidateCount >= 2 && basicPosStability.lastAnnouncedStablePos !== curPosInt) {
              basicPosStability.pendingStablePos = curPosInt;
            }

            const lapWillSpeak = (lapsNow > lastAnnouncedLapcount);
            if (lapWillSpeak && basicPosStability.pendingStablePos != null && basicPosStability.pendingStablePos !== basicPosStability.lastAnnouncedStablePos) {
              const stable = basicPosStability.pendingStablePos;
              pendingPosChange = {
                pos: stable,
                opts: { key: 'pos_basic_' + stable, priority: 75, cooldownMs: 1200, dedupe: true },
                expLap: lapsNow + 2
              };
              basicPosStability.lastAnnouncedStablePos = stable;
              basicPosStability.pendingStablePos = null;
            }
          }catch(e){}
        }

        // Mensaje corto de posicion: solo se agenda en paso por meta.
        // En MANGA (quali) NO se anuncia inmediato: se usa ventana de asentamiento post-cruce (start/tickMangaPosSettle).
        if (!basicModeEnabled && voiceSettings.pos && p.pos !== lastKnownPos) {
          const lapWillSpeak = (lapsNow > lastAnnouncedLapcount); // tu cruce por meta pendiente
          if (lapWillSpeak && !isManga) {
            const curPos = Math.floor(p.pos);
            pendingPosChange = {
              pos: curPos,
              opts: { key: 'pos_' + curPos, priority: 75, cooldownMs: 900, dedupe: true },
              expLap: lapsNow + 2
            };
          }
        }
        lastKnownPos = p.pos;
      }

      // NetGain (evento)
      if (voiceSettings.netgain && p.pos && p.pos > 0) {
        if (startPosForSelected == null) startPosForSelected = p.pos;
        const net = startPosForSelected - p.pos;
        if (lastNetGainValue == null) lastNetGainValue = net;

        if (net !== lastNetGainValue) {
          let t = '';
          if (net > 0) t = `Vas +${Math.floor(net)}`;
          else if (net < 0) t = `Vas ${Math.floor(net)}`; // net ya es negativo
          else t = 'Regresas a tu posición de salida';

          pendingNetGain = {
            text: t,
            opts: { key: 'netgain_' + lapsNow, priority: 35, cooldownMs: 2500, dedupe: true },
            expLap: lapsNow + 3,
            value: net
          };
          lastNetGainValue = net;
        }
      }
      // MANGA: cronmetro por piloto (salida escalonada)
      if (isManga) {
        updateMangaPilotStartsFromClassification((raceData && raceData.classification) ? raceData.classification : []);
      } else {
        if (mangaClockTimer) stopMangaClock();
      }
// Best lap (evento)
      if (voiceSettings.bestlap && lapMsNow && lapsNow > 0 && lapsNow !== lastBestAnnouncedLap) {
        const isNewBest = (lastBestAnnouncedMs == null) ? true : (lapMsNow < (lastBestAnnouncedMs - 30));
        if (isNewBest) {
          pendingBestLap = {
            text: msgv2Compose('bestlap', { best: tiempoATexto(lapMsNow), isFinal: !!isFinal, isManga: !!isManga, pilotKey: (typeof selectedPilotKey !== 'undefined' ? selectedPilotKey : '') }),
            opts: { key: 'bestlap_' + lapsNow, priority: 75, cooldownMs: 1500, dedupe: true },
            expLap: lapsNow + 2,
            ms: lapMsNow
          };
          lastBestAnnouncedMs = lapMsNow;
        }
        lastBestAnnouncedLap = lapsNow;
      }

      // Estimacin (evento, no spamea)
      if (voiceSettings.estlap) {
        const est = Number(p.estLap) || 0;
        if (est > 0) {
          // Solo si cambi contra la última estimacin hablada (no contra la vista)
          const estInt = Math.floor(est);
          const lastInt = (lastSpokenEstLap == null) ? null : Math.floor(lastSpokenEstLap);
          const changedEnough = (lastInt == null) ? true : (Math.abs(estInt - lastInt) >= 2);
          const spaced = (lapsNow - lastEstLapSpokenLap) >= 8;
          if ((changedEnough && spaced) || (spaced && (lapsNow - lastEstLapSpokenLap) >= 12)) {
            const palabra = est === 1 ? 'vuelta' : 'vueltas';
            pendingEstLap = {
              text: `Estimacin ${estInt} ${palabra}`,
              opts: { dedupe: true },
              expLap: lapsNow + 6,
              est: est
            };
          }
        }
      }

      // Bandera azul (pendiente que ya arma el detector por pasos de meta)
      if (voiceSettings.blueflag) {
        updateBlueFlagFromPassEvents();
      }

      // Expira pendientes viejas
      if (pendingPosChange && pendingPosChange.expLap != null && lapsNow > pendingPosChange.expLap) pendingPosChange = null;
      if (pendingNetGain && pendingNetGain.expLap != null && lapsNow > pendingNetGain.expLap) pendingNetGain = null;
      if (pendingBestLap && pendingBestLap.expLap != null && lapsNow > pendingBestLap.expLap) pendingBestLap = null;
      if (pendingEstLap && pendingEstLap.expLap != null && lapsNow > pendingEstLap.expLap) pendingEstLap = null;

      // MANGA: ventana de asentamiento de posicion (ranking por tiempo)
      if (isManga && voiceSettings.pos) {
        tickMangaPosSettle(lapsNow, (p && p.pos != null) ? p.pos : null);
      }

      // =========================
      // 2) Laps siempre primero (bloqueado)
      // =========================
      const lapCrossed = (voiceSettings.laps && lapsNow > 0 && lapsNow !== lastAnnouncedLapcount);

      if (lapCrossed) {
        // Beep SIEMPRE en seguimiento al cerrar vuelta:
        // - Agudo si mejoras vs tu vuelta anterior
        // - Grave si empeoras
        // - Si no hay referencia, agudo (marca cierre de vuelta)
        let __didLapBeep = false;
        if (lapMsNow) {
          if (lastSpokenLastTime && lastSpokenLastTime > 0) {
            if (lapMsNow < (lastSpokenLastTime - 20)) { playBeep('lapUp'); __didLapBeep = true; }
            else if (lapMsNow > (lastSpokenLastTime + 20)) { playBeep('lapDown'); __didLapBeep = true; }
          }
          if (!__didLapBeep) { try { playBeep('lapUp'); } catch(e) {} }
          say(tiempoATexto(lapMsNow), { key: 'lap_' + lapsNow, priority: 90, dedupe: true });
          flashLastLap();
          lastSpokenLastTime = lapMsNow;
        } else {
          // Sin tiempo, igual marcamos cierre de vuelta con beep.
          try { playBeep('lapUp'); } catch(e) {}
        }
        lastAnnouncedLapcount = lapsNow;

        // MANGA: ventana de asentamiento para posición (ranking por tiempo)
        if (isManga && voiceSettings.pos) {
          startMangaPosSettle(lapsNow, p && p.pos != null ? p.pos : null);
        }

      } else {
        // Sin paso por meta: en MANGA normalmente nos quedamos callados (la tabla brinca por salida escalonada).
        // EXCEPCION: si ya vencio la ventana de asentamiento, podemos decir la posicion estable aun sin cruce.
        if (isManga && voiceSettings.pos && pendingPosChange && pendingPosChange.pos) {
          try {
            const sp = Math.floor(pendingPosChange.pos);
            say('P' + sp, (pendingPosChange.opts || { key: 'pos_manga_' + sp + '_' + lapsNow, priority: 65, cooldownMs: 1400, dedupe: true }));
            mangaPosStability.lastAnnouncedStablePos = sp;
          } catch(e) {}
          pendingPosChange = null;
        }

        // En FINAL podemos avisar breve si te mueven de posicion sin tu cruce.
        if (!isManga && !basicModeEnabled && posChangedTick && voiceSettings.pos) {
          handlePositionChangeNoLap(posFrom, posTo, posDelta);
        }
        return;
      }

      // =========================
      // 3) AI Director: elige 1 o 2 mensajes extra post-Laps (segn situacin)
      // =========================
      const candidates = [];

      const pushCand = (id, score, text, opts, onCommit) => {
        if (!text) return;
        candidates.push({ id, score, text, opts: (opts || {}), onCommit });
      };

      // Contexto front/back
      const ctx = (idx >= 0) ? getFrontBackContext(idx) : null;

      // Marca de batalla en Lap Chart (ATK/DEF/DUEL) - se marca SOLO en cruce de meta
try {
  if (lapCrossed && ctx && selectedPilotKey) {
    const isManga = (currentSessionInfo && currentSessionInfo.type === 'MANGA');
    const thr = isManga ? 0.55 : 0.60;

    const f = (ctx.sameFrontLap && ctx.frontSec != null && isFinite(ctx.frontSec)) ? Number(ctx.frontSec) : null;
    const b = (ctx.sameBackLap  && ctx.backSec  != null && isFinite(ctx.backSec))  ? Number(ctx.backSec)  : null;

    const atk = (f != null && f <= thr);
    const def = (b != null && b <= thr);

    let tag = null;
    if (atk && def) tag = 'DUEL';
    else if (atk) tag = 'ATK';
    else if (def) tag = 'DEF';

    if (tag) setLastLapMark(selectedPilotKey, tag);
  }
} catch (e) {}

      // Azul (si hay pendiente para este piloto)
      if (voiceSettings.blueflag &&
          pendingBlueFlagForPilotKey &&
          pendingBlueFlagForPilotKey === selectedPilotKey &&
          pendingBlueFlagMessage) {
        pushCand('blueflag', isFinal ? 100 : 90, pendingBlueFlagMessage,
          { key: 'blueflag_' + lapsNow, priority: 80, cooldownMs: 4000, dedupe: true, interrupt: false },
          () => {
            pendingBlueFlagForPilotKey = '';
            pendingBlueFlagMessage = '';
            lastBlueFlagPilotLap = lapsNow;
          }
        );
      }

      // Pendientes (eventos)
      if (voiceSettings.bestlap && pendingBestLap) {
        pushCand('bestlap', isManga ? 98 : 75, pendingBestLap.text, pendingBestLap.opts, () => {
          pendingBestLap = null;
        });
      }

      if (pendingPosChange && voiceSettings.pos) {
        // Posición con nombres (adelante/atrs) para que sea realmente til
        const ppos = (pendingPosChange.pos != null) ? pendingPosChange.pos : (p && p.pos ? Math.floor(p.pos) : 0);
        let extra = '';
        if (ctx && !basicModeEnabled) {
          const fn = ctx.frontName ? safeRacerName(ctx.frontName) : '';
          const bn = ctx.backName ? safeRacerName(ctx.backName) : '';
          if (fn && bn) extra = `. Adelante ${fn}, atrs ${bn}`;
          else if (fn) extra = `. Adelante ${fn}`;
          else if (bn) extra = `. Atrs ${bn}`;
        }
        const text = ppos ? (`P${ppos}${extra}`) : (pendingPosChange.text || '');
        pushCand('pos', isFinal ? 92 : 35, text, (pendingPosChange.opts || { key:'pos_'+lapsNow, priority:75, cooldownMs:900, dedupe: true }), () => {
          if (isManga && pendingPosChange && pendingPosChange._mangaStablePos != null) {
            mangaPosStability.lastAnnouncedStablePos = pendingPosChange._mangaStablePos;
          }
          pendingPosChange = null;
        });
      }

      if (voiceSettings.netgain && pendingNetGain) {
        pushCand('netgain', isFinal ? 45 : 25, pendingNetGain.text, pendingNetGain.opts, () => {
          pendingNetGain = null;
          lastNetGainSpokenLap = lapsNow;
        });
      }

      if (voiceSettings.estlap && pendingEstLap) {
        pushCand('estlap', isManga ? 55 : 30, pendingEstLap.text, pendingEstLap.opts, () => {
          lastSpokenEstLap = pendingEstLap.est;
          lastEstLapSpokenLap = lapsNow;
          pendingEstLap = null;
        });
      }

      // Adelante y atras < 0.6 (con latch)
      if (ctx && voiceSettings.front06 && ctx.sameFrontLap && ctx.frontSec != null) {
        const sec = ctx.frontSec;
        const otherKey = ctx.frontKey || 'front';
        if (ahead06Latch.active) {
          if (ahead06Latch.otherKey !== otherKey || sec >= 0.80 || !ctx.sameFrontLap) {
            ahead06Latch.active = false;
          }
        }
        if (!ahead06Latch.active && sec < 0.6) {
          const secStr = toFixedFloor(sec, decimalPrecision);
          const nm = ctx.frontName || '';
          const txt = nm ? ('Adelante a tiro. ' + nm + ' a ' + secStr + ' segundos') : ('Adelante a tiro. A ' + secStr + ' segundos');
          pushCand('front06', isFinal ? 70 : 18, txt,
            { key: 'front06_' + otherKey, priority: 55, cooldownMs: 2500, dedupe: true },
            () => {
              ahead06Latch.active = true;
              ahead06Latch.otherKey = otherKey;
              ahead06Latch.lap = lapsNow;
              lastAheadAlertMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
            }
          );
        }
      }

      if (ctx && voiceSettings.back06 && ctx.sameBackLap && ctx.backSec != null) {
        const sec = ctx.backSec;
        const otherKey = ctx.backKey || 'back';
        if (behind06Latch.active) {
          if (behind06Latch.otherKey !== otherKey || sec >= 0.80 || !ctx.sameBackLap) {
            behind06Latch.active = false;
          }
        }
        if (!behind06Latch.active && sec < 0.6) {
          const secStr = toFixedFloor(sec, decimalPrecision);
          const nm = ctx.backName || '';
          const txt = nm ? ('Atras presin. ' + nm + ' a ' + secStr + ' segundos') : ('Atras presin. A ' + secStr + ' segundos');
          pushCand('back06', isFinal ? 70 : 18, txt,
            { key: 'back06_' + otherKey, priority: 55, cooldownMs: 2500, dedupe: true },
            () => {
              behind06Latch.active = true;
              behind06Latch.otherKey = otherKey;
              behind06Latch.lap = lapsNow;
              lastBehindAlertMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
            }
          );
        }
      }

      // Ataque / Defensa / DUEL (EMA + histeresis)
      // - Usa ctx.duelActive + ctx.duelKind (ATTACK/DEFEND)
      // - Gap suavizado: ctx.frontSecEma / ctx.backSecEma
      if (ctx && (voiceSettings.attack || voiceSettings.defense) && ctx.duelActive) {
        // ATTACK
        if (voiceSettings.attack && ctx.duelKind === 'ATTACK' && ctx.sameFrontLap && ctx.frontSecEma != null) {
          const sec = ctx.frontSecEma;
          const otherKey = ctx.frontKey || 'front';
          if (attackLatch.active) {
            if (attackLatch.otherKey !== otherKey || !ctx.duelActive || ctx.duelKind !== 'ATTACK') {
              attackLatch.active = false;
            }
          }
          if (!attackLatch.active) {
            const secStr = gapToSpeech(sec, 'attack');
            const nm = ctx.frontName || '';
            const txt = msgv2Compose('attack', { otherName: nm, gapStr: secStr, isFinal: !!isFinal, isManga: !!isManga, pilotKey: (typeof selectedPilotKey !== 'undefined' ? selectedPilotKey : '') });
            pushCand('attack', isFinal ? 88 : 22, txt,
              { key: 'attack_' + Math.floor(lapsNow/2), priority: 70, cooldownMs: 4200, dedupe: true },
              () => {
                attackLatch.active = true;
                attackLatch.otherKey = otherKey;
                attackLatch.lap = lapsNow;
              }
            );
          }
        } else {
          attackLatch.active = false;
        }

        // DEFEND
        if (voiceSettings.defense && ctx.duelKind === 'DEFEND' && ctx.sameBackLap && ctx.backSecEma != null) {
          const sec = ctx.backSecEma;
          const otherKey = ctx.backKey || 'back';
          if (defenseLatch.active) {
            if (defenseLatch.otherKey !== otherKey || !ctx.duelActive || ctx.duelKind !== 'DEFEND') {
              defenseLatch.active = false;
            }
          }
          if (!defenseLatch.active) {
            const secStr = gapToSpeech(sec, 'defense');
            const nm = ctx.backName || '';
            const txt = msgv2Compose('defense', { otherName: nm, gapStr: secStr, isFinal: !!isFinal, isManga: !!isManga, pilotKey: (typeof selectedPilotKey !== 'undefined' ? selectedPilotKey : '') });
            pushCand('defense', isFinal ? 88 : 22, txt,
              { key: 'defense_' + Math.floor(lapsNow/2), priority: 70, cooldownMs: 4200, dedupe: true },
              () => {
                defenseLatch.active = true;
                defenseLatch.otherKey = otherKey;
                defenseLatch.lap = lapsNow;
              }
            );
          }
        } else {
          defenseLatch.active = false;
        }
      } else {
        attackLatch.active = false;
        defenseLatch.active = false;
      }

      // Pelea cerrada (encajonado) - usa gaps suavizados cuando esten disponibles
      if (ctx && voiceSettings.pelea && ctx.sameFrontLap && ctx.sameBackLap) {
        const f = (ctx.frontSecEma != null ? ctx.frontSecEma : ctx.frontSec);
        const b = (ctx.backSecEma  != null ? ctx.backSecEma  : ctx.backSec);
        const inFight = (f != null && b != null && f < 0.70 && b < 0.70);
        if (fightLatch.active) {
          if (!inFight || (f != null && f >= 1.10) || (b != null && b >= 1.10)) {
            fightLatch.active = false;
          }
        }
        if (!fightLatch.active && inFight) {
          pushCand('fight', isFinal ? 78 : 18, msgv2Compose('fight', { isFinal: !!isFinal, isManga: !!isManga, pilotKey: (typeof selectedPilotKey !== 'undefined' ? selectedPilotKey : '') }),
            { key: 'fight_' + Math.floor(lapsNow/2), priority: 66, cooldownMs: 5200, dedupe: true },
            () => {
              fightLatch.active = true;
              fightLatch.lap = lapsNow;
            }
          );
        }
      } else {
        fightLatch.active = false;
      }

      // Podio (solo si tiene sentido)
      if (voiceSettings.podium && isFinal && lapsNow > 0 && p.pos && p.pos > 3) {
        if (lapsNow % 3 === 0 && (!lastPodiumSpokenLap || (lapsNow - lastPodiumSpokenLap) >= 3)) {
          const third = raceData.classification.find(r => r.pos === 3);
          if (third && third.time != null && p.time != null) {
            const meLaps = (p.lapcount != null) ? p.lapcount : 0;
            const thirdLaps = (third.lapcount != null) ? third.lapcount : 0;
            const lapDiff = thirdLaps - meLaps;

            if (lapDiff !== 0) {
              const v = Math.abs(lapDiff);
              const palabra = (v === 1) ? 'una vuelta' : (v + ' vueltas');
              pushCand('podium', 55, 'Podio mas ' + palabra,
                { key: 'podio_laps_' + lapsNow, priority: 60, cooldownMs: 2500, dedupe: true },
                () => { lastPodiumSpokenLap = lapsNow; }
              );
            } else {
              const diffMs = p.time - third.time;
              if (diffMs && diffMs > 0) {
                const sec = diffMs / 1000;
                if (sec <= 3.0) {
                  const secStr = gapToSpeech(sec, 'podium');
                  pushCand('podium', 65, 'Podio ' + secStr,
                    { key: 'podio_' + Math.floor(lapsNow/3), priority: 60, cooldownMs: 2500, dedupe: true },
                    () => { lastPodiumSpokenLap = lapsNow; }
                  );
                }
              }
            }
          }
        }
      }

      // Diferencia adelante/atrs (cada 3 vueltas)
      if (voiceSettings.gaps && idx >= 0 && lapsNow > 0 && ((isManga && (lapsNow % 4 === 0)) || (!isManga && (lapsNow % 3 === 0)))) {
        const msg = buildGapSummaryForPilotIndex(idx);
        if (msg) {
          pushCand('gaps', isFinal ? 40 : 15, msg,
            { key: 'gaps_' + Math.floor(lapsNow/3), priority: 40, cooldownMs: 1800, dedupe: true },
            () => { lastGapInfoLap = lapsNow; }
          );
        }
      }

      // Referencia al líder (cada 3 vueltas)
      if (voiceSettings.leadergap && lapsNow > 0 && ((isManga && (lapsNow % 5 === 0)) || (!isManga && (lapsNow % 3 === 0)))) {
        const leader = raceData.classification.find(r => r.pos === 1);
        if (leader && leader.time != null && p.time != null) {
          const meLaps = (p.lapcount != null) ? p.lapcount : 0;
          const lLaps  = (leader.lapcount != null) ? leader.lapcount : 0;
          const lapDiff = lLaps - meLaps;

          let msg = '';
          if (lapDiff !== 0) {
            const v = Math.abs(lapDiff);
            msg = (v === 1) ? 'Lider mas una vuelta' : ('Lider mas ' + v + ' vueltas');
          } else {
            const diffMs = p.time - leader.time;
            if (diffMs && diffMs > 0) {
              const sec = diffMs / 1000;
              const secStr = gapToSpeech(sec, 'leader');
              msg = 'Lider ' + secStr;
            }
          }
          if (msg) {
            pushCand('leader', isFinal ? 38 : 12, msg,
              { dedupe: true },
              () => { lastLeaderGapSpokenLap = lapsNow; }
            );
          }
        }
      }

      // Ritmo (cada 3 vueltas, sin palabreria)
      if (voiceSettings.ritmo && lapsNow > 0 && lapsNow % 3 === 0) {
        const t = (hist.times || []).filter(isLapPlausible);
        const last3 = t.slice(-3);
        const prev3 = t.slice(-6, -3);
        if (last3.length === 3 && prev3.length === 3) {
          const avgLast = last3.reduce((a,b)=>a+b,0) / 3;
          const avgPrev = prev3.reduce((a,b)=>a+b,0) / 3;
          const diff = avgPrev - avgLast; // positivo = mejoraste
          if (diff > 120) {
            pushCand('ritmo_up', isManga ? 72 : 28, msgv2Compose('ritmo_up', { deltaMs: diff, isFinal: !!isFinal, isManga: !!isManga, pilotKey: (typeof selectedPilotKey !== 'undefined' ? selectedPilotKey : '') }),
              { key: 'ritmo_up_' + Math.floor(lapsNow/3), priority: 30, cooldownMs: 2500, dedupe: true },
              () => { lastTrendSpokenLap = lapsNow; }
            );
          } else if (diff < -120) {
            pushCand('ritmo_down', isManga ? 72 : 28, msgv2Compose('ritmo_down', { deltaMs: diff, isFinal: !!isFinal, isManga: !!isManga, pilotKey: (typeof selectedPilotKey !== 'undefined' ? selectedPilotKey : '') }),
              { key: 'ritmo_down_' + Math.floor(lapsNow/3), priority: 30, cooldownMs: 2500, dedupe: true },
              () => { lastTrendSpokenLap = lapsNow; }
            );
          }
        }
      }

      // Total (cada 1 minuto)
      if (voiceSettings.total && p.time && p.time > 0) {
        const totalSeconds = Math.floor(p.time / 1000);
        if (totalSeconds - lastTotalTimeAnnouncedSeconds >= 60) {
          const texto = tiempoATexto(p.time);
          pushCand('total', isManga ? 32 : 18, 'Total ' + texto,
            { key: 'total_' + Math.floor(totalSeconds/60), priority: 20, dedupe: true },
            () => { lastTotalTimeAnnouncedSeconds = totalSeconds; }
          );
        }
      }

      // Consistencia (cada 10 vueltas)
      if (voiceSettings.cons10 && lapsNow >= 10 && (lapsNow % 10 === 0) && (lapsNow !== lastConsistencySpokenLap)) {
        const pct = getConsistencyFromFirebase(p);
        if (pct) {
          pushCand('cons10', isManga ? 60 : 24, 'Consistencia ' + pct + ' por ciento',
            { key: 'cons10_' + lapsNow, priority: 28, cooldownMs: 2500, dedupe: true },
            () => { lastConsistencySpokenLap = lapsNow; }
          );
        }
      }

      // Box (cada 20 vueltas o cada 2 min, lo que llegue primero)
      if (voiceSettings.box) {
        const totalSeconds = p.time ? Math.floor(p.time / 1000) : 0;
        const byTime = totalSeconds && (totalSeconds - lastAutoSummaryAnnouncedSeconds >= 120);
        const byLap  = lapsNow > 0 && (lapsNow % 20 === 0);

        if (byTime || byLap) {
          const posTxt = (p.pos && p.pos > 0) ? ('P ' + Math.floor(p.pos)) : '';
          const gapTxt = formatoGapVueltas(p.gap) ? ('Gap ' + formatoGapVueltas(p.gap)) : '';
          const bestTxt = p.best ? msToMinSec(p.best) : '';
          let msg = '';
          if (posTxt) msg += posTxt + '. ';
          if (gapTxt) msg += gapTxt + '. ';
          if (bestTxt) msg += 'Mejor vuelta ' + bestTxt + '. ';
          msg = msg.trim();
          if (msg) {
            pushCand('box', isFinal ? 22 : 40, msg,
              { key: 'box_' + Math.floor(totalSeconds/120) + '_' + Math.floor(lapsNow/20), priority: 18, cooldownMs: 2500, dedupe: true },
              () => { lastAutoSummaryAnnouncedSeconds = totalSeconds; }
            );
          }
        }
      }

      // Si no hay nada, listo
      if (!candidates.length) return;

      
      // RD anti-repeat penalty: baja score si acaba de decir lo mismo (sin bloquear crticos)
      const rdModeLocal = (raceDirectorMode === 'minimal' || raceDirectorMode === 'stratega' || raceDirectorMode === 'coach') ? raceDirectorMode : 'stratega';
      const ttlId = (rdModeLocal === 'minimal') ? 4 : 2;
      const ttlTxt = (rdModeLocal === 'minimal') ? 4 : 3;
      const criticalIds = isManga
        ? new Set(['blueflag','podium'])
        : new Set(['blueflag','pos','back06','front06','fight','attack','defense','podium','leader']);
      for (const c of candidates) {
        if (!c) continue;
        if (!criticalIds.has(c.id)) {
          const lastId = rdLastIdLap.get(c.id) || 0;
          if (lapsNow > 0 && (lapsNow - lastId) > 0 && (lapsNow - lastId) < ttlId) c.score -= 12;
          const lastTx = rdLastTextLap.get(c.text) || 0;
          if (lapsNow > 0 && (lapsNow - lastTx) > 0 && (lapsNow - lastTx) < ttlTxt) c.score -= 10;
        }
      }

// Orden: mayor score, luego mayor prioridad
      candidates.sort((a,b) => (b.score - a.score) || (((b.opts && b.opts.priority) ? b.opts.priority : 0) - ((a.opts && a.opts.priority) ? a.opts.priority : 0)));

      // Filtro editorial follow/RD:
      // - si ya hubo voz hace nada, baja el ruido y deja solo lo realmente útil
      try {
        const sinceLastSpeech = Date.now() - ((__ttsLastEndAt || commentatorAutoState.lastSpeakMs || 0) || 0);
        const keep = [];
        for (const c of candidates) {
          if (!c) continue;
          const cat = __speechCatFromOpts(c.opts || {}, (c.opts && c.opts.key) || c.id || '', c.text || '');
          const pr = Number((c.opts && c.opts.priority) || 0) || 0;
          const noisy = __speechIsNoisyCat(cat);
          if (sinceLastSpeech < 3200 && noisy && pr < 80) continue;
          if (sinceLastSpeech < 5200 && cat === 'leader' && pr < 80) continue;
          keep.push(c);
        }
        if (keep.length) {
          candidates.length = 0;
          for (const c of keep) candidates.push(c);
        }
      } catch(e) {}

      // =========================
      // Manual (RD OFF): habla lo encendido, con lmite para no spamear
      // =========================
      const rdOn = !!raceDirectorEnabled;

      if (!rdOn) {
        // MANGA: no hablar entre metas (salida escalonada + 1 sensor)
        if (isManga && !lapCrossed) return;
        const maxSpoken = 1;// Arbiter: 1 extra max
        let spoken = 0;
        for (const c of candidates) {
          if (!c || !c.text) continue;
          if (c.score < 18) continue;

          const tTry = rdTrimWords(c.text, 16);

          // MANGA: anti-repeat por TEXTO aunque el evento cambie
          if (isManga) {
            const lastTxtLap = rdLastTextLap.get(tTry) || 0;
            if (lastTxtLap && (lapsNow - lastTxtLap) > 0 && (lapsNow - lastTxtLap) < 4) continue;
          }

          say(tTry, c.opts || {});
          rdLastIdLap.set(c.id, lapsNow);
          rdLastTextLap.set(tTry, lapsNow);

          try { if (typeof c.onCommit === 'function') c.onCommit(); } catch (e) {}
          spoken++;
          if (spoken >= maxSpoken) break;
        }
        return;
      }

      // =========================
      
      // =========================
      // RD ON: elige 1 o 2 mensajes segn situacin (humano, no metralleta)
      // MANGA: solo hablar en tu cruce por meta
      if (isManga && !lapCrossed) return;

      // =========================
      const posNowRD = Number(p.position) || 0;
      const tierRD = (posNowRD > 0 && posNowRD <= 3) ? 'front' : ((posNowRD > 0 && posNowRD <= 10) ? 'mid' : 'back');

      // Anti-repeticin dura (por id y por texto). No bloquea crticos.
      const ttlById = (id) => (id === 'estlap' ? 10 : (id === 'pos' ? 2 : ttlId));
      const ttlByTxt = (id) => (id === 'estlap' ? 10 : ttlTxt);

      const tooSoonId = (id) => {
        const last = rdLastIdLap.get(id) || 0;
        const ttl = ttlById(id);
        return last && (lapsNow - last) > 0 && (lapsNow - last) < ttl;
      };
      const tooSoonTxt = (id, text) => {
        const last = rdLastTextLap.get(text) || 0;
        const ttl = ttlByTxt(id);
        return last && (lapsNow - last) > 0 && (lapsNow - last) < ttl;
      };

      // Pick 1
      let pick1 = null;
      let t1 = '';
      for (const c of candidates) {
        if (!c || !c.text) continue;
        const tTry = rdTrimWords(rdMakeText(c.id, c.text, rdBuildCtx({ tier: tierRD, isManga, ...ctx }, p)), 12);
        if (!criticalIds.has(c.id)) {
          if (tooSoonId(c.id)) continue;
          if (tooSoonTxt(c.id, tTry)) continue;
        }
        pick1 = c;
        t1 = tTry;
        break;
      }

      if (pick1) {
        say(t1, pick1.opts || {});
        rdLastIdLap.set(pick1.id, lapsNow);
        rdLastTextLap.set(t1, lapsNow);
        try { if (typeof pick1.onCommit === 'function') pick1.onCommit(); } catch (e) {}
        // Arbitro: 1 solo mensaje extra por cruce (ademas del lap time).
        return;
      }
      return;
    }

speakBtn.addEventListener('click', () => {
      if (!raceData || !Array.isArray(raceData.classification) || !selectedPilotKey) return;
      const p = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey);
      if (!p) return;

      // Beep tenue al primer detect del piloto seleccionado
      if (!selectedPilotFirstDetectBeeped) {
        selectedPilotFirstDetectBeeped = true;
        try { if (selectedPilotKey) firstDetectBeepedByPilot.set(selectedPilotKey, true); } catch(e) {}

        try { if (voiceMasterEnabled) playBeep('soft'); } catch(e) {}
      }
      const pos = p.pos || '-';
      const laps = p.lapcount != null ? p.lapcount : 0;
      const key = getPilotKey(p);
      const hist = lapHistory.get(key) || { lastLapcount: 0, times: [] };
      const times = (hist.times || []).filter(isLapPlausible);
      const computed = statsFromTimes(times);
      const consPct = getConsistencyFromFirebase(p);

      // Mostrar consistencia (feed) y  (historial lap chart)
      try {
        if (consistencyValEl) consistencyValEl.textContent = consPct ? (consPct + '%') : '--%';
      } catch(e) {}
      try {
        const sig = (computed && computed.sigma && isFinite(computed.sigma)) ? (computed.sigma / 1000) : NaN;
        if (sigmaValEl) sigmaValEl.textContent = (isFinite(sig) && sig > 0) ? sig.toFixed(3) : '-.---';
      } catch(e) {}

      let bestMsFinal = isLapPlausible(p.best) ? p.best : (computed.best || 0);
      if (computed.best && (!bestMsFinal || computed.best < bestMsFinal)) bestMsFinal = computed.best;

      const meanMsFinal = isLapPlausible(p.mean) ? p.mean : (computed.mean || 0);

      const bestTxt = bestMsFinal ? tiempoATexto(bestMsFinal) : '';
      const meanTxt = meanMsFinal ? tiempoATexto(meanMsFinal) : '';
      const gapTxt = formatoGapVueltas(p.gap);
      let msg = `Posición ${pos}. `;
      if (bestTxt) msg += `Best lap ${bestTxt}. `;
      if (meanTxt) msg += `Promedio ${meanTxt}. `;
      if (gapTxt) msg += `Diferencia ${gapTxt}. `;
      if (consPct) msg += `Consistencia ${consPct} por ciento.`;
      speakText(msg);
    });

        // =========================
    // Modo de sesin (AUTO desde raceName)
    // =========================
    var currentSessionInfo = { type: 'UNKNOWN', main: '', durationMs: 0, label: 'MODO -' };
    // =========================
    // LapChart scale preset por modo (MANGA vs FINAL A vs Finales bajas)
    // =========================
    var _lapChartPresetKey = '';
    function getLapChartPreset(){
      const info = currentSessionInfo || {};
      const type = String(info.type || '').toUpperCase();
      const main = String(info.main || '').toUpperCase();

      // Defaults
      let N = 40;         // ventana de vueltas en la grafica
      let pad = 2200;     // margen vertical (ms) para escala
      let maxCap = 130000;// cap maximo de escala vertical (ms)
      let cssH = 120;     // alto visual del canvas (px)

      if (type === 'MANGA') {
        // Qualy: zoom mas apretado y ventana mas corta (cambios rapidos)
        N = 28;
        pad = 2000;
        maxCap = 130000;
        cssH = 120;
      } else if (type === 'FINAL') {
        if (main === 'A') {
          // Final A: mas vueltas, grafica mas alta
          N = 55;
          pad = 3200;
          maxCap = 150000;
          cssH = 140;
        } else {
          // Finales bajas (B/C/D): mas variacion, margen mas amplio
          N = 45;
          pad = 4200;
          maxCap = 160000;
          cssH = 132;
        }
      }
      return { N, pad, maxCap, cssH };
    }

    // LapChart - Eje X por TIEMPO (no por vueltas)
    // - Manga: 3:00 + fraccion
    // - Finales bajas: 4:00 + fraccion
    // - Final A: 6:00 + fraccion
    // Nota: usamos currentSessionInfo.durationMs como base y agregamos un margen para cubrir la "fraccion".
    function getLapChartXMaxMs(lastElapsedMs){
      const info = currentSessionInfo || {};
      const type = String(info.type || '').toUpperCase();
      const main = String(info.main || '').toUpperCase();
      const base = Number(info.durationMs) || 0;

      let extra = 0;
      if (type === 'MANGA') extra = 15000;                 // +15s
      else if (type === 'FINAL') extra = (main === 'A') ? 25000 : 20000; // +25s A, +20s bajas

      let xMax = base ? (base + extra) : 0;

      const last = Number(lastElapsedMs) || 0;
      if (!xMax) xMax = Math.max(120000, last + 2000); // fallback 2:00 min
      else if (last > xMax) xMax = Math.max(xMax, last + 2000);

      return xMax;
    }


    function applyLapChartPreset(){
      try{
        const p = getLapChartPreset();
        const key = `${p.N}|${p.pad}|${p.maxCap}|${p.cssH}`;
        if (key === _lapChartPresetKey) return;
        _lapChartPresetKey = key;
        // Ajusta alto del canvas via CSS var (sin tocar layout global)
        document.documentElement.style.setProperty('--lapchart-h', `${p.cssH}px`);
      } catch(e){}
    }


    function parseSessionFromRaceName(raceName) {
      const name = String(raceName || '').toUpperCase();
      const isManga = /MANGA/.test(name) || /Q\d/.test(name) || /QUALY|QUALI|CLASIF|CLASIFIC/.test(name) || /HEAT|ROUND/.test(name);
      const isFinal = /FINAL/.test(name) || /A\s*MAIN|B\s*MAIN|C\s*MAIN/.test(name) || /\bMAIN\b/.test(name);

      let main = '';
      // Busca "MANGA A" o "FINAL A" o "A MAIN" (soporta tambien D)
      const m1 = name.match(/\bMANGA\s*([A-D])\b/);
      const m2 = name.match(/\bFINAL\s*([A-D])\b/);
      const m3 = name.match(/\b([A-D])\s*MAIN\b/);
      if (m1 && m1[1]) main = m1[1];
      else if (m2 && m2[1]) main = m2[1];
      else if (m3 && m3[1]) main = m3[1];

      let type = 'UNKNOWN';
      if (isManga && !isFinal) type = 'MANGA';
      else if (isFinal && !isManga) type = 'FINAL';
      else if (isFinal && isManga) type = 'FINAL'; // preferimos FINAL si viene mezclado
      else if (isManga) type = 'MANGA';

      let durationMs = 0;
      if (type === 'MANGA') durationMs = 3 * 60 * 1000;
      if (type === 'FINAL') {
        // Final A = 6:00, Finales B/C/D... = 4:00
        const m = String(main || '').toUpperCase();
        durationMs = (m === 'A') ? (6 * 60 * 1000) : (4 * 60 * 1000);
      }

let label = 'MODO -';
      if (type === 'MANGA') label = 'MODO MANGA 3:00';
      if (type === 'FINAL') {
        const m = String(main || '').toUpperCase();
        const d = (m === 'A') ? '6:00' : '4:00';
        label = m ? ('MODO FINAL ' + m + ' ' + d) : ('MODO FINAL ' + d);
      }

      // Spoken title (para TTS)
      let spokenTitle = '';
      const serieM = name.match(/\bSERIE\s*(\d+)\b/);
      const serie = (serieM && serieM[1]) ? String(serieM[1]) : '';

      // Qx y Manga X (para TTS en titulo)
      const qM = name.match(/\bQ\s*(\d+)\b/);
      const q = (qM && qM[1]) ? String(qM[1]) : '';
      // MANGA 1 / HEAT 1 / ROUND 1 (fallback numerico)
      const mangaM = name.match(/\bMANGA\s*(\d+)\b/) || name.match(/\bHEAT\s*(\d+)\b/) || name.match(/\bROUND\s*(\d+)\b/);
      const mangaNo = (mangaM && mangaM[1]) ? String(mangaM[1]) : '';

      // Spoken title (TTS) - sin acentos (mejor compat iOS/Android)
      if (type === 'MANGA') {
        const parts = ['Clasificacion'];
        if (q) parts.push('Q' + q);
        if (main) parts.push('Manga ' + main);
        else if (mangaNo) parts.push('Manga ' + mangaNo);
        if (serie) parts.push('Serie ' + serie);
        spokenTitle = parts.join(', ');
      } else if (type === 'FINAL') {
        const parts = [main ? ('Final ' + main) : 'Final'];
        if (serie) parts.push('Serie ' + serie);
        spokenTitle = parts.join(', ');
      } else {
        spokenTitle = '';
      }

      return { type, main, durationMs, label, spokenTitle, serie, q, mangaNo };
    }

// =========================
// FIN DE SESIN (por duracin)
// - MANGA: 3:00 -> "Termin la clasificacin"
// - FINAL: segn modo (A=6:00, otras=4:00) -> "Carrera terminada" + posición + resumen
// Dispara SOLO cuando tu tiempo total cruza el lmite EN UNA NUEVA VUELTA.
// =========================
let sessionFinishSig = '';
let sessionFinishAnnounced = false;
let sessionFinishPrevByKey = new Map(); // key -> { laps, totalMs }

function getRowTotalMs(row) {
  try {
    return parseTimeToMs(
      (typeof row.time !== 'undefined' ? row.time :
       (typeof row.totalTime !== 'undefined' ? row.totalTime :
        (typeof row.totalMs !== 'undefined' ? row.totalMs :
         (typeof row.totalTimeMs !== 'undefined' ? row.totalTimeMs :
          (typeof row.estTime !== 'undefined' ? row.estTime : 0)))))
    ) || 0;
  } catch(e) { return 0; }
}

function getBestMsForRow(row) {
  let bestMs = 0;
  try {
    if (row && isLapPlausible(row.best)) bestMs = row.best;
  } catch(e) {}
  try {
    const k = getPilotKey(row);
    const hist = k ? lapHistory.get(k) : null;
    const hb = hist && hist.bestMs ? hist.bestMs : 0;
    if (isLapPlausible(hb) && (!bestMs || hb < bestMs)) bestMs = hb;
  } catch(e) {}
  return bestMs || 0;
}

function buildSessionFinishMessage(row) {
  const info = currentSessionInfo || {};
  const type = String(info.type || '').toUpperCase();
  const isManga = (type === 'MANGA');
  const isFinal = (type === 'FINAL');

  const posNum = row && row.pos ? Number(row.pos) : 0;
  const laps = Number(row && (row.lapcount ?? row.laps ?? 0)) || 0;
  const totalMs = getRowTotalMs(row) || 0;

  let msg = isManga ? 'Termin la clasificacin.' : 'Carrera terminada.';

  // Resultado (si sabemos posición)
  if (posNum > 0) msg += ' P' + posNum + '.';

  // Vueltas y tiempo total (si existen)
  if (laps > 0) msg += ' ' + laps + ' vueltas.';
  if (totalMs > 0) msg += ' Tiempo total ' + formatClockMs(totalMs) + '.';

  // Resumen extra para finales cuando hay podio
  if (isFinal && posNum > 0) {
    if (posNum === 1) msg += ' Felicidades, campeón.';
    else if (posNum === 2) msg += ' Segundo lugar. Podio.';
    else if (posNum === 3) msg += ' Tercer lugar. Podio.';
    else if (posNum <= 10) msg += ' Top 10. Buen cierre.';
  }

  // Best lap si existe
  const bestMs = getBestMsForRow(row);
  if (bestMs) msg += ' Mejor vuelta ' + tiempoATexto(bestMs) + '.';

  return msg;
}

function checkSessionFinishOnLap() {
  try {
    if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) return;

    const rn = String(raceData.raceName || '');
    if (rn !== sessionFinishSig) {
      sessionFinishSig = rn;
      sessionFinishAnnounced = false;
      sessionFinishPrevByKey = new Map();
    }

    const info = currentSessionInfo || {};
    const dur = Number(info.durationMs) || 0;
    if (!dur) return;

    // Elegimos piloto seleccionado; si no hay, usamos líder
    let row = null;
    if (selectedPilotKey) {
      row = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey) || null;
    }
    if (!row) row = raceData.classification.find(r => r.pos === 1) || raceData.classification[0];
    if (!row) return;

    const key = getPilotKey(row) || '__';
    const laps = Number(row.lapcount) || 0;
    const totalMs = getRowTotalMs(row) || 0;

    const prev = sessionFinishPrevByKey.get(key) || { laps: 0, totalMs: 0 };
    sessionFinishPrevByKey.set(key, { laps, totalMs });

    if (sessionFinishAnnounced) return;
    if (!isFinite(totalMs) || totalMs <= 0) return;

    // Solo disparar cuando sube una vuelta
    if (laps <= (prev.laps || 0)) return;

    // Condicin: cruz el lmite en la última vuelta
    if (totalMs < dur) return;

    const msg = buildSessionFinishMessage(row);
    enqueueSpeech(msg, {
      key: 'session_finish_' + sessionFinishSig,
      priority: 97,
      cooldownMs: 0,
          dedupe: true
    });

    sessionFinishAnnounced = true;
  } catch(e) {
    console.error('checkSessionFinishOnLap', e);
  }
}

    function updateSessionInfo(r) {
      const rn = (r && r.raceName) ? String(r.raceName) : '';
      currentSessionInfo = parseSessionFromRaceName(rn);

      try { applyLapChartPreset(); } catch(e) {}
// AI Spotter: aplica perfil automatico SIEMPRE (tambien en Auto Locutor)
      try { maybeAutoApplySessionPreset(currentSessionInfo); } catch(e) {}

      // Reset de referencias (mejora/best) cuando cambia la sesin
      if (rn && rn !== lastSessionSigForBest) {
        prevBestByKey.clear();
        try { lapDiffSpeakGuard.clear(); } catch(e) {}
        lastSessionSigForBest = rn;
      }
    }

    function updateHeaderFromRace(r) {
      if (!r) return;

      updateSessionInfo(r);

      // Auto Locutor: al cambiar carrera, anunciar nombre + participantes
      try { __maybeAnnounceAutoIntro(r); } catch(e) {}

      function __formatRaceTitleForHeader(name) {
        let s = (name == null) ? '' : String(name);
        // Sanitiza saltos de linea/tabs del feed (a veces llegan con \n y rompen el header)
        s = s.replace(/[\r\n\t]+/g, ' ');
        s = s.replace(/\s{2,}/g, ' ').trim();
        if (!s) return '';
        // 1) Evita que el guion quede al inicio de linea (pega el guion al texto anterior)
        //    "A - B" => "A\u00A0- B"
        s = s.replace(/\s-\s/g, '\u00A0- ');
        // 2) Evita que "SERIE 1" se parta dejando el "1" huerfano
        s = s.replace(/\b(SERIE)\s+(\d+)\b/ig, '$1\u00A0$2');
        return s;
      }

      function __escapeHtml(str){
        const s = (str==null) ? '' : String(str);
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
      }
      function __normForCountry(str){
        let s = (str==null) ? '' : String(str);
        try { s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[-]/g,''); } catch(e) {}
        s = s.toUpperCase();
        // homogeniza guiones y separadores
        s = s.replace(/[-]/g,'-');
        return s;
      }
      function __detectFlagSvgCode(title){
        const n = __normForCountry(title);
        // Twemoji SVG codes (regional indicators)
        const pairs = [
          ['REINO UNIDO','1f1ec-1f1e7'], ['UK','1f1ec-1f1e7'], ['UNITED KINGDOM','1f1ec-1f1e7'],
          ['MEXICO','1f1f2-1f1fd'], ['CKA','1f1f2-1f1fd'],
          ['COSTA RICA','1f1e8-1f1f7'],
          ['ITALIA','1f1ee-1f1f9'],
          ['EUA','1f1fa-1f1f8'], ['USA','1f1fa-1f1f8'], ['ESTADOS UNIDOS','1f1fa-1f1f8'], ['UNITED STATES','1f1fa-1f1f8'],
          ['BRASIL','1f1e7-1f1f7'], ['BRAZIL','1f1e7-1f1f7'],
          ['PERU','1f1f5-1f1ea'],
          ['POLONIA','1f1f5-1f1f1'], ['POLAND','1f1f5-1f1f1'],
          ['SUIZA','1f1e8-1f1ed'], ['SWITZERLAND','1f1e8-1f1ed'],
          ['ESPANA','1f1ea-1f1f8'], ['SPAIN','1f1ea-1f1f8'],
          ['FRANCIA','1f1eb-1f1f7'], ['FRANCE','1f1eb-1f1f7'],
          ['ALEMANIA','1f1e9-1f1ea'], ['GERMANY','1f1e9-1f1ea'],
          ['ARGENTINA','1f1e6-1f1f7'],
          ['COLOMBIA','1f1e8-1f1f4'],
          ['CHILE','1f1e8-1f1f1']
        ];
        for (const [k,code] of pairs){
          if (n.includes(k)) return code;
        }
        return '';
      }

      const __TWEMOJI_FLAG_BASE = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/';

      const rawTitle = r.raceName || 'Spotter_5.0.1';
      const fmtTitle = __formatRaceTitleForHeader(rawTitle) || rawTitle;
      const flagSvg = __detectFlagSvgCode(rawTitle);
      const safeTitle = __escapeHtml(fmtTitle);
      const htmlTitle = flagSvg ? (`<img class="flagImg" alt="" src="${__TWEMOJI_FLAG_BASE}${flagSvg}.svg"/>` + safeTitle) : safeTitle;

      if (raceTitleText) {
        raceTitleText.innerHTML = htmlTitle;
      } else if (raceTitleMain) {
        // fallback: si no existe el span interno, usa el contenedor
        raceTitleMain.textContent = fmtTitle;
      }

      if (raceModeBadge) {
        // Texto compacto para el botn MODO (siempre visible y sin depender del label largo)
        let modeTxt = 'MODO -';
        const t0 = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
        if (t0 === 'TRAIN' || t0 === 'PRACTICE' || t0 === 'PRUEBA' || t0 === 'LIBRE' || t0 === 'WARMUP') {
          modeTxt = 'Train';
        } else if (t0 === 'MANGA' || t0 === 'QUALI') {
          modeTxt = 'Manga 3m';
        } else if (t0.startsWith('FINAL')) {
          const mins = Math.round(((currentSessionInfo && currentSessionInfo.durationMs) || 0) / 60000) || 0;
          modeTxt = mins ? (`Final ${mins}m`) : 'Final';
        }
        raceModeBadge.textContent = modeTxt;
// Colorea el badge por tipo de sesin
        raceModeBadge.classList.remove('mode-train','mode-manga','mode-final','mode-finalA','mode-finalB');
        if (currentSessionInfo && currentSessionInfo.type) {
          const t = String(currentSessionInfo.type).toUpperCase();
          if (t === 'TRAIN' || t === 'PRACTICE' || t === 'PRUEBA' || t === 'LIBRE' || t === 'WARMUP') {
            raceModeBadge.classList.add('mode-train');
          } else if (t === 'MANGA' || t === 'QUALI') {
            raceModeBadge.classList.add('mode-manga');
          } else if (t === 'FINAL_A') {
            raceModeBadge.classList.add('mode-finalA');
          } else if (t === 'FINAL_B' || t === 'FINAL_C' || t === 'FINAL_D') {
            raceModeBadge.classList.add('mode-finalB');
          } else if (t.startsWith('FINAL')) {
            raceModeBadge.classList.add('mode-final');
          }
        }
      }
    }

    function setLastUpdateNow() {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      if (lastUpdateInfo) {
        lastUpdateInfo.textContent = `Actualizado ${hh}:${mm}:${ss}`;
      }
    }

    function __parseRawRacePayload(rawJson) {
      try {
        if (typeof rawJson !== 'string') return null;
        const trimmed = rawJson.trim();
        if (!trimmed) return null;
        if (trimmed.length > 900000) {
          console.warn('rawJson descartado por tamaño');
          return null;
        }
        const parsed = JSON.parse(trimmed);
        if (!parsed || typeof parsed !== 'object' || !Array.isArray(parsed.classification)) return null;
        if (parsed.classification.length > 200) {
          parsed.classification = parsed.classification.slice(0, 200);
        }
        return parsed;
      } catch (e) {
        console.error('Error parseando rawJson', e);
        return null;
      }
    }

    async function loadRaceFromFirebase(_snapDataOverride) {
      // iOS/WebView a veces reporta document.hidden erroneamente; no bloquees la lectura del feed.
      if (!__firebaseOk || !db) { setLiveStatus(false); return; }

      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      if (isLoading) {
        // Si una lectura se colg por red, no dejes el spotter muerto.
        if (now - loadingSince < 4500) return;
        console.warn('Lectura anterior tard demasiado, reseteando isLoading');
        isLoading = false;
      }

      isLoading = true;
      loadingSince = now;

      try {        let data = _snapDataOverride || null;

        if (!data) {
          const ref = doc(db, 'races', 'currentRace');

          // Timeout duro para que getDoc no congele el loop (iOS/red chueca)
          const snap = await Promise.race([
            getDoc(ref),
            new Promise((_, rej) => setTimeout(() => rej(new Error('timeout getDoc')), 3500))
          ]);
          if (!snap.exists()) {
            setLiveStatus(false);
            isLoading = false;
            return;
          }
          data = snap.data() || {};
        }

        setLiveStatus(true);

        let rawRace = null;
        if (data.parsed && Array.isArray(data.parsed.classification)) {
          rawRace = data.parsed;
        } else if (data.rawJson) {
          rawRace = __parseRawRacePayload(data.rawJson);
        }

        if (!rawRace || !Array.isArray(rawRace.classification)) {
          try { if (raceInfo) raceInfo.textContent = 'Sin datos (feed sin parsed/rawJson valido)'; } catch(e) {}
          isLoading = false;
          return;
        }

        const newRaceName = rawRace.raceName || '';
        if (newRaceName !== lastRaceName) {
          previousClassification = null;
          lastSpokenLastTime = null; 
      lastAnnouncedLapcount = 0;
          lastKnownPos = null;
          lastTotalTimeAnnouncedSeconds = 0;
          lastBestAnnouncedMs = null;
          lastBestAnnouncedLap = 0;
          lastTrendSpokenLap = 0;
          lastAheadAlertMs = 0;
          behind06Latch = { active:false, otherKey:'', lap:-1 };
          ahead06Latch  = { active:false, otherKey:'', lap:-1 };

          attackLatch  = { active:false, otherKey:'', lap:-1 };
          defenseLatch = { active:false, otherKey:'', lap:-1 };
          fightLatch   = { active:false, lap:-1 };
          startPosForSelected = null;
          lastNetGainValue = null;
          lastNetGainSpokenLap = 0;
          lastLeaderGapSpokenLap = 0;
          lastPodiumSpokenLap = 0;
          lastAutoSummaryAnnouncedSeconds = 0;
          resetAutoCommentatorState();
          // Reset fin de sesin
          sessionFinishSig = newRaceName;
          sessionFinishAnnounced = false;
          sessionFinishPrevByKey = new Map();
          lastRaceName = newRaceName;

          // Auto-skin por sesion (MANGA vs FINAL)
          try { maybeApplyAutoThemeByRaceName(newRaceName); } catch(e) {}

          stopMangaClock();
          try { __stopSessionClockTicker(); } catch(e) {}
          if (lastPassEvents && typeof lastPassEvents.clear === 'function') {
            lastPassEvents.clear();
          }
          if (lapHistory && typeof lapHistory.clear === 'function') { lapHistory.clear(); }
          pendingBlueFlagForPilotKey = '';
          pendingBlueFlagMessage = '';
          lastBlueFlagPilotLap = 0;
        }

        
        // Guard anti-parpadeo: a veces el feed manda un "paquete cero" (laps=0, time=0) por un tick.
        // No reseteamos UI a ceros si la carrera NO cambi y ya tenamos datos reales.
        try {
          const sameRace = (String(newRaceName||'') === String(lastRaceName||''));
          const cls0 = (rawRace && Array.isArray(rawRace.classification)) ? rawRace.classification : [];
          const looksZero = cls0.length > 0 && cls0.every(rr => {
            const lap0 = (Number(rr && (rr.lapcount ?? rr.laps ?? 0)) || 0) === 0;
            const tm = (typeof rr.timeMs === 'number') ? rr.timeMs : parseTimeToMs(rr.time);
            const t0 = (Number(tm)||0) === 0;
            const best = parseTimeToMs(rr.best ?? rr.bestMs ?? rr.bestLapTime ?? rr.bestLapTimeMs ?? rr.bestTime ?? 0);
            const mean = parseTimeToMs(rr.mean ?? rr.meanMs ?? rr.meanLapTime ?? rr.meanLapTimeMs ?? 0);
            const est  = parseTimeToMs(rr.estTime ?? 0);
            return lap0 && t0 && ((best||0)===0) && ((mean||0)===0) && ((est||0)===0);
          });

          const hadReal = (previousClassification && Array.isArray(previousClassification) && previousClassification.some(pp => {
            const l = Number(pp && (pp.lapcount ?? pp.laps ?? 0)) || 0;
            const tm = Number(pp && pp.time) || 0;
            return l > 0 || tm > 0;
          }));

          if (sameRace && looksZero && hadReal) {
            isLoading = false;
            return; // ignorar tick cero
          }
        } catch(e) {}
        // Q TABLA: snapshot de clasificacin (UI only)
        try { recordQualiSnapshotIfNeeded(rawRace); } catch(e) {}
raceData = normalizeRaceData(rawRace);
        // Nuevo feed: reloj global (elapsed) para anuncios de tiempo restante (incluye practica)
        try { __updateSessionClockFromFeed(rawRace, raceData); } catch(e) {}
        updateLapHistoryAll();
        refreshSessionBestCache();
        updateRecordCarreraUI();
        updateHeaderFromRace(raceData);

        // Activity signature: detecta si el estado realmente cambia
        try {
          const cls = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
          cls.sort((a,b) => (Number(a.pos||999)-Number(b.pos||999)));
          const top3 = cls.slice(0,3).map(p => {
            const pk = getPilotKey(p);
            const laps = Number(p.lapcount ?? p.laps ?? 0) || 0;
            const gap = String(p.gap ?? p.diff ?? p.interval ?? '').trim();
            return [pk, Number(p.pos||0)||0, laps, gap];
          });
          const leader = cls[0] || null;
          const leaderLaps = leader ? (Number(leader.lapcount ?? leader.laps ?? 0) || 0) : 0;
          let selPos = null, selLaps = null;
          if (selectedPilotKey) {
            const sp = cls.find(r => getPilotKey(r) === selectedPilotKey) || null;
            if (sp) {
              selPos = Number(sp.pos||0)||0;
              selLaps = Number(sp.lapcount ?? sp.laps ?? 0) || 0;
            }
          }
          const sigObj = { rn: String(newRaceName||''), leaderLaps, top3, selPos, selLaps };
          __setActivitySig(JSON.stringify(sigObj));
        } catch(e) {}

        try { restoreLastPilotSelectionIfNeeded(); } catch(e) {}
        setLastUpdateNow();
        __lastGoodTickMs = Date.now();
        __feedTickCount = (__feedTickCount||0) + 1;
        try { if (lastUpdateInfo) lastUpdateInfo.textContent = 'tick ' + __feedTickCount + ' - ' + new Date().toLocaleTimeString(); } catch(e) {}
        __lastReadErr = '';
        if (!isSelectingPilot) {
          updatePilotOptions();
        }
        if (selectedPilotKey) {
          let p = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey) || null;

          // Si el piloto guardado ya no existe en esta carrera, volvemos a Auto Locutor
          if (!p) {
            try { selectPilotByKey('', { announce:true, source:'auto-clear' }); } catch(e) {}
            p = null;
          }

          renderPilotCard(p || null);
          try { renderAutoTop3MiniGrid(); } catch(e) {}
          try { checkSessionFinishOnLap(); } catch(e) {}
      if (p && p.pos && p.pos > 0 && (startPosForSelected == null)) { startPosForSelected = p.pos; lastNetGainValue = 0; }
        } else {
          renderPilotCard(null);
        try { renderAutoTop3MiniGrid(); } catch(e) {}
        try { checkSessionFinishOnLap(); } catch(e) {}
        }

        // --- Gate de voz: despues de practica, silencio hasta que el reloj elapsed arranque ---
        try{
          const pNow = (normRace && normRace.practice != null) ? Number(normRace.practice) : null;
          const prNow = (pNow === 1) ? 1 : 0; // null -> carrera
          const elapsedNow = __pickElapsedClockMs(rawRace);
          if (__prevPracticeFlag === null) __prevPracticeFlag = prNow;

          // Transicion: practica -> carrera (o armando manga/final). Silencia y limpia cola.
          if (__prevPracticeFlag === 1 && prNow === 0){
            __silenceUntilClockRuns = true;
            try { speechQueue.length = 0; } catch(e){}
            try { if (window.speechSynthesis && typeof window.speechSynthesis.cancel === 'function') window.speechSynthesis.cancel(); } catch(e){}
          }

          // Si el reloj ya arranco, se permite locucion otra vez.
          if (__silenceUntilClockRuns && elapsedNow >= 250){
            __silenceUntilClockRuns = false;
          }

          __prevPracticeFlag = prNow;

          if (!__silenceUntilClockRuns){
            handleVoiceAndBeeps();
            handleAutoCommentator();
          }
        } catch(e){
          // En caso de error, no mates el spotter: deja la logica original
          try { handleVoiceAndBeeps(); } catch(_){}
          try { handleAutoCommentator(); } catch(_){}
        }

} catch (e) {
        console.error('Error leyendo Firebase', e);
        __lastReadErr = (e && e.message) ? String(e.message) : String(e);
        try { if (raceInfo) raceInfo.textContent = 'Sin datos (error leyendo): ' + __lastReadErr; } catch(x) {}
        setLiveStatus(false);
      } finally {
        isLoading = false;
      }
    }

    


    // =========================
    // Realtime listener (onSnapshot) - mejora background en Chrome/Android/Safari
    // =========================
    let __raceUnsub = null;
    let __pendingSnapData = null;
    let __snapScheduled = false;
    let __fallbackPollTimer = 0;
    let __fallbackPollStep = 0;
    let __fallbackPollSchedule = [1000, 2000, 5000, 10000];

    function stopFallbackPolling() {
      try {
        if (__fallbackPollTimer) {
          clearTimeout(__fallbackPollTimer);
          __fallbackPollTimer = 0;
        }
      } catch(e) {}
    }

    function __scheduleFallbackPolling(reason = '') {
      try {
        __lastFallbackReason = String(reason || '').trim();
        if (__fallbackPollTimer) return;
        const idx = Math.max(0, Math.min(__fallbackPollStep, __fallbackPollSchedule.length - 1));
        const delay = __fallbackPollSchedule[idx];
        __fallbackPollTimer = setTimeout(async () => {
          __fallbackPollTimer = 0;
          try { await loadRaceFromFirebase(); } catch(e) {}
          const stale = !__lastGoodTickMs || ((Date.now() - __lastGoodTickMs) > 4000);
          if (stale) {
            __fallbackPollStep = Math.min(__fallbackPollStep + 1, __fallbackPollSchedule.length - 1);
            __scheduleFallbackPolling(reason || 'stale');
          } else {
            __fallbackPollStep = 0;
          }
        }, delay);
      } catch(e) {}
    }

    function __bumpFallbackPolling(reason = '') {
      try {
        __lastFallbackReason = String(reason || '').trim();
        try { pushTtsEvent('fallback', __lastFallbackReason || 'fallback', 'feed'); } catch(e) {}
        __fallbackPollStep = Math.min(__fallbackPollStep + 1, __fallbackPollSchedule.length - 1);
        stopFallbackPolling();
        __scheduleFallbackPolling(reason);
      } catch(e) {}
    }

    function startRaceRealtime() {
      try {
        if (!__firebaseOk || !db || typeof onSnapshot !== 'function' || typeof doc !== 'function') return false;
        const ref = doc(db, 'races', 'currentRace');
        try { if (__raceUnsub) __raceUnsub(); } catch(e) {}

        __raceUnsub = onSnapshot(ref, (snap) => {
          try {
            if (!snap || !snap.exists()) {
              setLiveStatus(false);
              __bumpFallbackPolling('snap-empty');
              return;
            }
            __fallbackPollStep = 0;
            stopFallbackPolling();
            __pendingSnapData = snap.data() || {};
            if (__snapScheduled) return;
            __snapScheduled = true;
            setTimeout(() => {
              __snapScheduled = false;
              const d = __pendingSnapData;
              __pendingSnapData = null;
              try { loadRaceFromFirebase(d); } catch(e) { __bumpFallbackPolling('snap-load-error'); }
            }, 0);
          } catch(e) {
            __bumpFallbackPolling('snap-handler-error');
          }
        }, (err) => {
          try {
            console.warn('onSnapshot error', err);
          } catch(e) {}
          __bumpFallbackPolling('snapshot-error');
        });

        return true;
      } catch(e) {
        console.warn('startRaceRealtime fallo', e);
        __bumpFallbackPolling('realtime-init-fail');
        return false;
      }
    }
// =========================
    // Bootstrap (arranque)
    // =========================
    window.addEventListener('unhandledrejection', (ev) => {
      console.error('UnhandledRejection', ev.reason);
    });

    (async () => {
      const ok = await initFirebaseRuntime();
      if (!ok) {
        setLiveStatus(false);
        if (raceInfo) raceInfo.textContent = 'Firebase OFF - revisa conexin, CSP o bloqueadores.';
        return;
      }
      loadRaceFromFirebase();
      const __rtOk = startRaceRealtime();
      if (!__rtOk) {
        __scheduleFallbackPolling('bootstrap-no-realtime');
      }
      try { bindRuntimeProfileCards(); } catch(e) {}
      try { applyRuntimeProfile(runtimeProfileKey, { silent:true }); } catch(e) {}
      try { startRuntimeWatchdog(); } catch(e) {}
      try { startRuntimeDiagTicker(); } catch(e) {}
      try { updateRuntimeDiagUI(); } catch(e) {}
      try { renderTtsEventLog(); } catch(e) {}

    })();

// Best lap global: actualizado desde raceData.classification (ver refreshSessionBestCache)
    // =========================
    // Q TABLA (Clasificación) - UI only (NO toca lgica de carrera)
    // =========================
    const QUALI_STORE_KEY = 'trm_quali_store_v1';

    // =========================
    // Q TABLA - Leader callouts (TRM)
    // - Anuncia cambios de P1 provisional durante mangas/clasificación
    // - Usa la tabla general (bestByPilot) como fuente de verdad
    // =========================
    let __qualiLeaderState = {
      leaderKey: '',
      leaderName: '',
      leaderLaps: 0,
      leaderTimeMs: 0,
      lastAnnounceTs: 0,
      lastImproveTs: 0,
      lastCloseTs: 0
    };

    function __qualiRankTuple(it){
      const laps = Number((it && it.laps) || 0) || 0;
      const tmsRaw = Number(it && it.timeMs);
      const timeMs = (isFinite(tmsRaw) && tmsRaw > 0 && tmsRaw < Number.MAX_SAFE_INTEGER) ? tmsRaw : Number.MAX_SAFE_INTEGER;
      return { laps, timeMs };
    }

    function __qualiIsValidLeader(it){
      if (!it) return false;
      const t = __qualiRankTuple(it);
      return (t.laps > 0) && (t.timeMs < Number.MAX_SAFE_INTEGER);
    }

    function __fmtGapMs(ms){
      try{
        const v = Number(ms);
        if (!isFinite(v) || v <= 0) return '';
        const s = v / 1000;
        return s.toFixed(2) + ' segundos';
      }catch(e){ return ''; }
    }

    function __maybeAnnounceQualiLeaderFromStore(raw, store){
      try{
        if (!raw || !store) return;
        if (!voiceMasterEnabled) return;

        // Anti-perico: en FOLLOW (piloto seleccionado) no cantamos la pole provisional.
        // Esto es para el modo AUTO LOCUTOR (sin piloto seleccionado).
        try { if (selectedPilotKey) return; } catch(e) {}
        try { if (basicModeEnabled) return; } catch(e) {}

        // Solo mangas/clasificación
        if (!isMangaRaceName(raw.raceName)) return;

        const info = parseSessionFromRaceName(raw.raceName) || {};
        if (String(info.type || '').toUpperCase() !== 'MANGA') return;

        const list = computeQualiList(store);
        if (!list || list.length < 1) return;

        const leader = list[0];
        if (!__qualiIsValidLeader(leader)) return;

        const leaderName = String(leader.racerName || '').trim();
        if (!leaderName) return;

        const nk = normalizeNameKey(leaderName);
        const leaderKey = nk ? ('P' + nk) : String(leader.pilotKey || leader.racerNumber || leaderName).trim();

        const lT = __qualiRankTuple(leader);
        const lLaps = lT.laps;
        const lTimeMs = lT.timeMs;

        const now = Date.now();

        // Cooldowns (anti-spam)
        const changeCooldown = 9000;
        const improveCooldown = 14000;
        const closeCooldown = 18000;

        const prevKey = String(__qualiLeaderState.leaderKey || '');
        const prevTime = Number(__qualiLeaderState.leaderTimeMs || 0) || 0;
        const prevLaps = Number(__qualiLeaderState.leaderLaps || 0) || 0;

        const firstTime = (!prevKey);

        // 2do lugar para comentarios de pelea
        const second = (list.length >= 2) ? list[1] : null;
        const secondName = second ? String(second.racerName || '').trim() : '';
        const sT = second ? __qualiRankTuple(second) : { laps: 0, timeMs: Number.MAX_SAFE_INTEGER };

        // Update state ya, para evitar dobles anuncios por tormenta de snapshots
        __qualiLeaderState.leaderKey = leaderKey;
        __qualiLeaderState.leaderName = leaderName;
        __qualiLeaderState.leaderLaps = lLaps;
        __qualiLeaderState.leaderTimeMs = lTimeMs;

        // Primera vez: no grites al boot
        if (firstTime){
          __qualiLeaderState.lastAnnounceTs = now;
          return;
        }

        // Cambio de P1 provisional
        const changed = (prevKey && prevKey !== leaderKey);
        if (changed && (now - (Number(__qualiLeaderState.lastAnnounceTs || 0)) > changeCooldown)){
          const t = msToMinSec(lTimeMs);
          enqueueSpeech(
            `Atención, nueva pole provisional. ${leaderName} se pone líder con ${lLaps} vueltas en ${t}.`,
            { key: 'quali_leader_change', cooldownMs: changeCooldown, semanticCategory: 'leader', priority: 30 }
          );
          __qualiLeaderState.lastAnnounceTs = now;

          // Follow: pelea cerrada si aplica (misma cantidad de vueltas y gap muy chico)
          if (second && secondName && sT.laps === lLaps){
            const gap = sT.timeMs - lTimeMs;
            if (isFinite(gap) && gap > 0 && gap <= 90 && (now - (Number(__qualiLeaderState.lastCloseTs || 0)) > closeCooldown)){
              enqueueSpeech(
                `Y ojo, ${secondName} está a ${__fmtGapMs(gap)} del líder.`,
                { key: 'quali_close', cooldownMs: closeCooldown, semanticCategory: 'quali', priority: 12 }
              );
              __qualiLeaderState.lastCloseTs = now;
            }
          }
          return;
        }

        // Mismo líder: mejora (baja tiempo o sube vueltas)
        const lapGain = (lLaps > prevLaps);
        const timeDrop = (prevTime > 0 && lTimeMs < prevTime);
        const dropMs = timeDrop ? (prevTime - lTimeMs) : 0;

        if ((lapGain || (dropMs >= 40)) && (now - (Number(__qualiLeaderState.lastImproveTs || 0)) > improveCooldown)){
          if (lapGain){
            enqueueSpeech(
              `El líder aprieta. ${leaderName} sube a ${lLaps} vueltas.`,
              { key: 'quali_leader_improve', cooldownMs: improveCooldown, semanticCategory: 'leader', priority: 18 }
            );
          } else {
            enqueueSpeech(
              `El líder mejora. ${leaderName} baja su tiempo.`,
              { key: 'quali_leader_improve', cooldownMs: improveCooldown, semanticCategory: 'leader', priority: 18 }
            );
          }
          __qualiLeaderState.lastImproveTs = now;
        }

        // Comentario de pelea cerrada (sin cambio de líder)
        if (second && secondName && sT.laps === lLaps){
          const gap = sT.timeMs - lTimeMs;
          if (isFinite(gap) && gap > 0 && gap <= 90 && (now - (Number(__qualiLeaderState.lastCloseTs || 0)) > closeCooldown)){
            enqueueSpeech(
              `Esto está apretado. ${secondName} a ${__fmtGapMs(gap)} del líder.`,
              { key: 'quali_close', cooldownMs: closeCooldown, semanticCategory: 'quali', priority: 10 }
            );
            __qualiLeaderState.lastCloseTs = now;
          }
        }
      }catch(e){}
    }


    function qSafeJsonParse(s){
      try { return JSON.parse(s); } catch(e) { return null; }
    }
    function qEscapeHtml(s){
      const str = (s === null || s === undefined) ? '' : String(s);
      return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;');
    }
    function getLocalDateKey(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function getRaceBaseFromRaceName(raceName){
      // Objetivo: llave estable para guardar Qs (Q1/Q2/Q3...) sin que se resetee por cambios menores del raceName.
      // NO toca lgica de carrera: solo normaliza texto para el storage de Q TABLA.
      const raw = (raceName == null) ? '' : String(raceName);
      let s = raw.trim();
      if (!s) return '';

      // Si viene con separadores tipo " - ", a veces el prefijo es el EVENTO (OK),
      // pero otras veces el prefijo es "CLASIFICACION" (malo). Solo recortamos si el prefijo
      // NO parece ser un tipo de sesion.
      const dashIdx = s.indexOf(' - ');
      if (dashIdx > 2){
        const pref = s.slice(0, dashIdx).trim();
        if (!/^(CLASIFIC|MANGA|FINAL)\b/i.test(pref)) s = pref;
      }

      // Q / Manga / Serie suelen cambiar: quitarlos para que la key permanezca estable
      let k = s;
      k = k.replace(/\bQ\s*[-:]?\s*\d+\b/ig, ' ');
      k = k.replace(/\b(MANGA|HEAT|ROUND|RND)\s*[-:]?\s*\d+\b/ig, ' ');
      k = k.replace(/\bSERIE\s*[-:]?\s*\d+\b/ig, ' ');

      // Limpieza de separadores comunes
      k = k.replace(/[|,]+/g, ' ');
      k = k.replace(/\s+/g, ' ').trim();

      // Fallback si qued vaco
      return k || raw.trim();
    }
    function getQualiIdFromRaceName(raceName){
      // Key para Q TABLA:
      // - Siempre incluye Q#
      // - Si la carrera trae "Manga A/B/C/D" lo agrega para NO pisar Q1A vs Q1B
      // - Si trae "Serie #" lo agrega para NO pisar series diferentes
      try{
        const info = parseSessionFromRaceName(raceName) || {};
        const q = String(info.q || '').trim();
        if (q){
          let key = 'Q' + q;
          const type = String(info.type || '').toUpperCase();
          const main = String(info.main || '').toUpperCase();
          const serie = String(info.serie || '').trim();
          if (type === 'MANGA' && main && /^[A-D]$/.test(main)) key += main;
          if (serie && /^\d+$/.test(serie)) key += ('S' + serie);
          return key;
        }
      }catch(e){}

      // Fallback simple por regex
      const s = String(raceName||'').toUpperCase();
      const qm = s.match(/\bQ\s*(\d+)\b/);
      if (!qm) return '';
      let key = 'Q' + qm[1];

      const mm = s.match(/\bMANGA\s*([A-D])\b/);
      if (mm && mm[1]) key += String(mm[1]).toUpperCase();

      const sm = s.match(/\bSERIE\s*(\d+)\b/);
      if (sm && sm[1]) key += ('S' + sm[1]);

      return key;
    }


    function normalizeNameKey(v){
      if (v == null) return '';
      let s = String(v).trim().toLowerCase();
      s = s.replace(/\s+/g, ' ');
      try { s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch(e) {}
      s = s.replace(/[^a-z0-9 ]+/g, '');
      s = s.replace(/\s+/g, ' ').trim();
      return s;
    }

    function pickBetterQuali(a,b){
      if (!a) return b;
      if (!b) return a;
      const al = Number(a.laps || 0);
      const bl = Number(b.laps || 0);
      if (bl > al) return b;
      if (bl < al) return a;
      const at = Number(a.timeMs || Number.MAX_SAFE_INTEGER);
      const bt = Number(b.timeMs || Number.MAX_SAFE_INTEGER);
      return (bt < at) ? b : a;
    }

    function getQualiNameKey(r){
      const nm = normalizeNameKey(r && (r.racerName ?? r.name));
      return nm || '';
    }
    function getQualiNumberKey(r){
      try{
        const num = (r && r.racerNumber != null) ? String(r.racerNumber).trim() :
                    (r && r.number != null) ? String(r.number).trim() : '';
        if (num && num !== '0' && num !== '-') return 'N' + num;
      }catch(e){}
      return '';
    }

    function getQualiPilotKey(r, store){
      // IMPORTANTE:
      // En el feed, racerNumber puede reiniciarse por Manga/Grupo (Q1A vs Q1B),
      // si lo usamos como llave se "pisan" pilotos y la tabla queda incompleta.
      // Para Q TABLA usamos SOLO racerName (normalizado) como llave estable.
      const nameKey = getQualiNameKey(r);
      if (!nameKey) return '';
      if (store){
        if (!store.bestByPilot || typeof store.bestByPilot !== 'object') store.bestByPilot = {};
      }
      return 'P' + nameKey;
    }

    function loadQualiStoreFor(raceName){
      const today = getLocalDateKey();
      const raceBase = getRaceBaseFromRaceName(raceName);
      let store = qSafeJsonParse((typeof lsGet === 'function' ? lsGet(QUALI_STORE_KEY) : localStorage.getItem(QUALI_STORE_KEY)) || '');
      if (!store || typeof store !== 'object') store = null;

      if (!store || store.date !== today || store.raceBase !== raceBase) {
        store = { date: today, raceBase, sessions: {}, bestByPilot: {}, aliasByName: {}, _pilotKeyMode: 'name' };
        try {
          if (typeof lsSet === 'function') lsSet(QUALI_STORE_KEY, JSON.stringify(store));
          else localStorage.setItem(QUALI_STORE_KEY, JSON.stringify(store));
        } catch(e) {}
      } else {
        if (!store.sessions || typeof store.sessions !== 'object') store.sessions = {};
        if (!store.bestByPilot || typeof store.bestByPilot !== 'object') store.bestByPilot = {};
        if (!store.aliasByName || typeof store.aliasByName !== 'object') store.aliasByName = {};

// SANITIZA legacy: Best Lap absurdos guardados por versiones viejas (ej. 0:00.007)
try{
  const isOkBL = (ms)=>{ ms = Number(ms)||0; return ms >= 5000 && ms <= 60000; };
  for (const k of Object.keys(store.bestByPilot || {})){
    const r = store.bestByPilot[k];
    if (!r) continue;
    if (r.bestMs && !isOkBL(r.bestMs)) { r.bestMs = 0; r.bestRaw = ''; r.bestKey = ''; }
  }
}catch(e){}

        // MIGRACION: antes se usaba racerNumber como llave (se pisaban pilotos entre mangas).
        // Re-construimos bestByPilot desde sessions usando SOLO racerName.
        const km = String(store._pilotKeyMode || '');
        if (km !== 'name') {
          const rebuilt = {};
          try{
            const keys = Object.keys(store.sessions || {});
            for (const qid of keys){
              const sess = store.sessions[qid];
              const rows = (sess && Array.isArray(sess.rows)) ? sess.rows : [];
              for (const row of rows){
                if (!row) continue;
                const nm = String(row.racerName || '').trim();
                const nk = normalizeNameKey(nm);
                if (!nk) continue;
                const k = 'P' + nk;
                const cand = {
                  pilotKey: k,
                  q: qid,
                  racerNumber: row.racerNumber ?? '',
                  racerName: nm,
                  laps: Number(row.laps || 0) || 0,
                  timeMs: Number(row.timeMs || Number.MAX_SAFE_INTEGER),
                  timeRaw: String(row.timeRaw ?? ''),
                  bestMs: Number(row.bestMs || 0) || 0,
                  bestRaw: String(row.bestRaw ?? '')
                };
                rebuilt[k] = pickBetterQuali(rebuilt[k], cand);
              }
            }
          }catch(e){}
          store.bestByPilot = rebuilt;
          store._pilotKeyMode = 'name';
          try{
            if (typeof lsSet === 'function') lsSet(QUALI_STORE_KEY, JSON.stringify(store));
            else localStorage.setItem(QUALI_STORE_KEY, JSON.stringify(store));
          }catch(e){}
        }
      }
      return store;
    }
    function saveQualiStore(store){
      try {
        if (typeof lsSet === 'function') lsSet(QUALI_STORE_KEY, JSON.stringify(store));
        else localStorage.setItem(QUALI_STORE_KEY, JSON.stringify(store));
      } catch(e) {}
    }

    // Guarda un snapshot por Q cuando detecta que estamos en MANGA + Qx.
    function isMangaRaceName(raceName){
      // Q TABLA debe guardar SOLO mangas / clasificación (nunca finales).
      const s = String(raceName || '').toUpperCase();
      if (!s) return false;
      // Si dice FINAL/A MAIN/B MAIN/C MAIN, no es manga.
      if (/(\bFINAL\b|\bA\s*MAIN\b|\bB\s*MAIN\b|\bC\s*MAIN\b)/.test(s)) return false;
      // Señales típicas de manga/clasificación
      if (/(\bMANGA\b|\bQUALI\b|\bCLASIF\b|\bCLASIFIC\b|\bQ\s*\d+\b|\bHEAT\b|\bROUND\b|\bRND\b)/.test(s)) return true;
      return false;
    }

        // ---------------------------------
        // Q TABLA - Best Lap (del feed, sin calcular)
        // - Soporta ms / segundos / microsegundos y strings tipo "0:09.103"
        // - Filtra valores absurdos tipo 0:00.007 y evita agarrar "bestLap" cuando parece ser indice de vuelta
        // ---------------------------------
        function __q_parseBestToMs(v){
          try{
            if (v == null) return 0;
            if (typeof v === 'number'){
              if (!isFinite(v) || v <= 0) return 0;
              // microsegundos (ej 9103000)
              if (v > 600000 && v < 60000000) return Math.round(v / 1000);
              // segundos (ej 9.103)
              if (v < 60) return Math.round(v * 1000);
              // ms directos (ej 9103)
              if (v >= 1000 && v < 600000) return Math.round(v);
              // fallback: si viene 60..999, tratamos como segundos (raro)
              if (v < 1000) return Math.round(v * 1000);
              return Math.round(v);
            }
            const s0 = String(v || '').trim();
            if (!s0) return 0;
            const s = s0.replace(/,/g, '.');
            if (s.includes(':')) {
              const ms = parseTimeToMs(s);
              return (isFinite(ms) && ms > 0) ? ms : 0;
            }
            const num = Number(s);
            if (isFinite(num)) return __q_parseBestToMs(num);
            const ms2 = parseTimeToMs(s);
            return (isFinite(ms2) && ms2 > 0) ? ms2 : 0;
          }catch(e){ return 0; }
        }
        function __q_isPlausibleBestMs(ms){
          return (ms >= 5000 && ms <= 60000); // 5s..60s (Turbo Racing 1/76 tipico 8-20s)
        }
        function __q_looksLikeLapIndex(v, laps){
          try{
            if (!laps || laps <= 0) return false;
            // numero entero <= laps suele ser indice, no tiempo
            if (typeof v === 'number' && isFinite(v) && Number.isInteger(v) && v > 0 && v <= laps && v <= 200) return true;
            if (typeof v === 'string'){
              const s = v.trim();
              if (!s) return false;
              if (/^\d+$/.test(s)){
                const n = parseInt(s,10);
                if (isFinite(n) && n > 0 && n <= laps && n <= 200) return true;
              }
            }
          }catch(e){}
          return false;
        }
        function __q_pickBestLapFromFeedRow(r, laps){
          try{
            if (!r) return { ms:0, raw:'', key:'' };
    
            const entries = [
          // SOLO campos de tiempo reales del feed (NO usar bestLap/best porque a veces son índices)
          ['bestMs', r.bestMs],
          ['bestLapMs', r.bestLapMs],
          ['bestLapTimeMs', r.bestLapTimeMs],
          ['bestTimeMs', r.bestTimeMs],
          ['fastestLapMs', r.fastestLapMs],

          // Strings ya formateados si existen
          ['bestTimeFmt', r.bestTimeFmt],
          ['bestLapTimeFmt', r.bestLapTimeFmt],
          ['bestLapTime', r.bestLapTime],
          ['bestTime', r.bestTime]
        ];
    
            // Pass 1: evitar indices tipo "7" cuando hay laps>=7 (comun en algunos feeds)
            for (const [k,v] of entries){
              if (__q_looksLikeLapIndex(v, laps)) continue;
              const ms = __q_parseBestToMs(v);
              if (__q_isPlausibleBestMs(ms)) return { ms, raw: (v!=null? v:''), key:k };
            }
    
            // Pass 2: si no hubo nada plausible, aceptamos el primer ms razonable (>=1000) para no dejar guion
            for (const [k,v] of entries){
              const ms = __q_parseBestToMs(v);
              if (ms >= 1000) return { ms, raw: (v!=null? v:''), key:k };
            }
    
            return { ms:0, raw:'', key:'' };
          }catch(e){
            return { ms:0, raw:'', key:'' };
          }
        }

    function recordQualiSnapshotIfNeeded(raw){
      try{
        if (!raw || !raw.raceName || !Array.isArray(raw.classification)) return;

        // Solo mangas/clasificación
        if (!isMangaRaceName(raw.raceName)) return;

        const info = parseSessionFromRaceName(raw.raceName) || {};
        if (String(info.type || '').toUpperCase() !== 'MANGA') return;

        const qid = getQualiIdFromRaceName(raw.raceName);
        if (!qid) return;

        const store = loadQualiStoreFor(raw.raceName);

        // IMPORTANT: siempre actualizar bestByPilot (aunque el Q ya exista).
        // Guardamos "rows" al storage con throttle para no escribir 60 veces por segundo.
        const already = !!(store.sessions[qid] && store.sessions[qid].raceName);
        const now = Date.now();
        const lastSave = (store.sessions[qid] && store.sessions[qid].savedAt) ? Number(store.sessions[qid].savedAt) : 0;
        const shouldSaveRows = (!already) || (now - lastSave > 1200);

        const rows = [];
        let anyReal = false;

        for (const r of raw.classification){
          if (!r) continue;

          const laps = Number(r.lapcount ?? r.laps ?? r.lapCount ?? 0) || 0;

          const timeRaw = (r.time ?? r.total ?? r.totalTime ?? r.total_time ?? r.totalTimeMs ?? r.totalMs ?? '');
          let timeMsParsed = 0;
          if (typeof timeRaw === 'number') timeMsParsed = timeRaw;
          else timeMsParsed = parseTimeToMs(timeRaw);
          const timeMs = (isFinite(timeMsParsed) && timeMsParsed > 0) ? timeMsParsed : Number.MAX_SAFE_INTEGER;
          const __bestLapPick = __q_pickBestLapFromFeedRow(r, laps);
          const bestRaw = (__bestLapPick && __bestLapPick.raw != null) ? __bestLapPick.raw : '';
          const bestMs = (__bestLapPick && __bestLapPick.ms) ? __bestLapPick.ms : 0;


          const bestKey = (__bestLapPick && __bestLapPick.key) ? __bestLapPick.key : '';
          const pilotKey = getQualiPilotKey(r, store);
          if (!pilotKey) continue;

          const isRowReal = (laps > 0) || (timeMs < Number.MAX_SAFE_INTEGER) || (bestMs > 0);
          if (!isRowReal) continue;
          anyReal = true;

          // Snapshot rows (throttled)
          if (shouldSaveRows){
            rows.push({
              pilotKey,
              racerNumber: r.racerNumber ?? r.number ?? '',
              racerName: r.racerName ?? r.name ?? '',
              laps,
              timeMs,
              timeRaw: String(timeRaw ?? ''),
              bestRaw: String(bestRaw ?? ''),
              bestMs,
              bestKey
            });
          }

          // Best-per-pilot (solo si hay datos reales)
          const prev = store.bestByPilot[pilotKey];
          const candidate = {
            pilotKey,
            q: qid,
            racerNumber: r.racerNumber ?? r.number ?? '',
            racerName: r.racerName ?? r.name ?? '',
            laps,
            timeMs,
            timeRaw: String(timeRaw ?? ''),
            bestMs,
            bestRaw: String(bestRaw ?? ''),
            bestKey
          };
          const __bestPick = pickBetterQuali(prev, candidate);
// Best Lap: conserva siempre el menor tiempo plausible aunque laps/total no mejoren
try {
  const pBest = (prev && __q_isPlausibleBestMs(prev.bestMs)) ? Number(prev.bestMs) : 0;
  const cBest = (__q_isPlausibleBestMs(candidate.bestMs)) ? Number(candidate.bestMs) : 0;
  if (cBest && (!pBest || cBest < pBest)) {
    __bestPick.bestMs = cBest;
    __bestPick.bestRaw = candidate.bestRaw;
    __bestPick.bestKey = candidate.bestKey;
  } else if (pBest && __bestPick && (!__bestPick.bestMs || !__q_isPlausibleBestMs(__bestPick.bestMs))) {
    __bestPick.bestMs = pBest;
    __bestPick.bestRaw = (prev && prev.bestRaw) ? prev.bestRaw : (__bestPick.bestRaw || '');
    __bestPick.bestKey = (prev && prev.bestKey) ? prev.bestKey : (__bestPick.bestKey || '');
  }
} catch(e) {}
store.bestByPilot[pilotKey] = __bestPick;
}

        // Persistencia (throttle)
        const lastPersist = Number(store._lastPersist || 0) || 0;
        const allowPersist = (now - lastPersist > 1200);

        if (shouldSaveRows && anyReal){
          store.sessions[qid] = {
            raceName: raw.raceName,
            savedAt: now,
            rows
          };
        }

        if ((allowPersist || shouldSaveRows) && anyReal){
          store._lastPersist = now;
          saveQualiStore(store);
        }

        // TRM: anuncio de cambio de P1 usando la tabla general
        try{ __maybeAnnounceQualiLeaderFromStore(raw, store); }catch(e){}

        try{
          const bd = document.getElementById('qualiBackdrop');
          if (bd && bd.classList.contains('open')) renderQualiTable();
        }catch(e){}
      }catch(e){}
    }

    function computeQualiList(store){
      if (!store || !store.bestByPilot) return [];
      const rawAll = Object.values(store.bestByPilot).map(x => ({...x}));
      const raw = rawAll.filter(it => {
        if (!it) return false;
        const laps = Number(it.laps || 0) || 0;
        const tms = Number(it.timeMs || 0);
        const bms = Number(it.bestMs || 0) || 0;
        return (laps > 0) || (isFinite(tms) && tms < Number.MAX_SAFE_INTEGER) || (bms > 0);
      });
      const grouped = {};
      for (const it of raw){
        if (!it) continue;
        const nk = normalizeNameKey(it.racerName || '');
        const gk = nk ? ('P' + nk) : (String(it.pilotKey || it.racerNumber || '').trim());
        if (!gk) continue;
        const __prevG = grouped[gk];
const __pickG = pickBetterQuali(__prevG, it);
// Best Lap: conserva el menor tiempo plausible aunque el "mejor run" se defina por laps/total
try {
  const pBest = (__prevG && __q_isPlausibleBestMs(__prevG.bestMs)) ? Number(__prevG.bestMs) : 0;
  const cBest = (__q_isPlausibleBestMs(it.bestMs)) ? Number(it.bestMs) : 0;
  if (cBest && (!pBest || cBest < pBest)) {
    __pickG.bestMs = cBest;
    __pickG.bestRaw = it.bestRaw;
    __pickG.bestKey = it.bestKey;
  } else if (pBest && __pickG && (!__pickG.bestMs || !__q_isPlausibleBestMs(__pickG.bestMs))) {
    __pickG.bestMs = pBest;
    __pickG.bestRaw = (__prevG && __prevG.bestRaw) ? __prevG.bestRaw : (__pickG.bestRaw || '');
    __pickG.bestKey = (__prevG && __prevG.bestKey) ? __prevG.bestKey : (__pickG.bestKey || '');
  }
} catch(e) {}
grouped[gk] = __pickG;
}
      const arr = Object.values(grouped).map(x => ({...x}));
      arr.sort((a,b)=>{
        const al = Number(a.laps || 0);
        const bl = Number(b.laps || 0);
        if (bl !== al) return bl - al;
        return Number(a.timeMs || Number.MAX_SAFE_INTEGER) - Number(b.timeMs || Number.MAX_SAFE_INTEGER);
      });
      return arr;
    }
    function msToLapStr(ms){
      const m = Number(ms || 0);
      if (!isFinite(m) || m <= 0) return '-';
      const mm = Math.round(m);
      // Para lap times, si es menor a 1 minuto mostramos solo segundos.mmm (ej. 9.103)
      if (mm < 60000){
        const s = Math.floor(mm / 1000);
        const rem = mm - s * 1000;
        return `${s}.${String(rem).padStart(3,'0')}`;
      }
      return msToMinSec(mm);
    }



    function cellHtml(r){
      if (!r) return '<span class="qcell-empty">-</span>';
      const laps = Number(r.laps || 0);
      const tms = Number(r.timeMs || 0);
      const bms = Number(r.bestMs || 0);
      const tmsOk = (isFinite(tms) && tms > 0 && tms < Number.MAX_SAFE_INTEGER);
      if ((!laps || laps <= 0) && !tmsOk && (!bms || bms <= 0)) return '<span class="qcell-empty">-</span>';
      const t = (isFinite(tms) && tms < Number.MAX_SAFE_INTEGER) ? msToMinSec(tms) : '-';
      const b = (bms > 0) ? msToLapStr(bms) : '-';
      return `<div class="qmain">${laps}v - ${qEscapeHtml(t)}</div><div class="qbest">${qEscapeHtml(b)}</div>`;
    }

    function renderQualiTable(){
      const qualiMeta = document.getElementById('qualiMeta');
      const thead = document.getElementById('qualiThead');
      const tbody = document.getElementById('qualiTbody');
      const viewSel = document.getElementById('qualiViewSel');
      const metaEvent = document.getElementById('qualiMetaEvent');
      const metaDate = document.getElementById('qualiMetaDate');
      const metaSessions = document.getElementById('qualiMetaSessions');

      if (!qualiMeta || !thead || !tbody) return;

      const rn = (raceData && raceData.raceName) ? raceData.raceName : (lastRaceName || '');
      const store = loadQualiStoreFor(rn);

      const sessions = (store && store.sessions) ? store.sessions : {};
      const sessionKeys = Object.keys(sessions || {})
        .filter((k)=> isMangaRaceName((sessions && sessions[k] && sessions[k].raceName) ? sessions[k].raceName : ''))
        .sort((a,b)=>{
          const parseKey = (k)=>{
            const s = String(k||'').toUpperCase();
            const qn = parseInt((s.match(/\d+/)||['0'])[0],10) || 0;
            const mainM = s.match(/Q\d+([A-D])\b/);
            const main = (mainM && mainM[1]) ? mainM[1] : '';
            const serieM = s.match(/S(\d+)\b/);
            const serie = (serieM && serieM[1]) ? (parseInt(serieM[1],10)||0) : 0;
            return { qn, main, serie };
          };
          const pa = parseKey(a);
          const pb = parseKey(b);

          if (pa.qn !== pb.qn) return pa.qn - pb.qn;

          // Orden A,B,C,D (vacío al final)
          const ord = (c)=> c ? (('ABCD'.indexOf(c) + 1) || 99) : 99;
          const oa = ord(pa.main);
          const ob = ord(pb.main);
          if (oa !== ob) return oa - ob;

          if (pa.serie !== pb.serie) return pa.serie - pb.serie;

          return String(a).localeCompare(String(b));
        });

      const raceBase = (store && store.raceBase) ? store.raceBase : '';
      const dateKey  = (store && store.date) ? store.date : getLocalDateKey();

      if (metaEvent) metaEvent.textContent = `Evento: ${raceBase || '-'}`;
      if (metaDate) metaDate.textContent = `Fecha: ${dateKey || '-'}`;
      if (metaSessions) metaSessions.textContent = `Sesiones: ${sessionKeys.length ? sessionKeys.join(', ') : '-'}`;

      const view = viewSel ? String(viewSel.value || 'best') : 'best';

      const __qnOf = (label)=>{
        const s = String(label||'').toUpperCase();
        const m = s.match(/Q(\d+)/);
        const qn = m ? (parseInt(m[1],10)||0) : (parseInt((s.match(/\d+/)||['0'])[0],10)||0);
        return qn || 0;
      };
      const __qClassOf = (label)=>{
        const qn = __qnOf(label);
        return qn ? ('qcol-q' + qn) : '';
      };
      const __qTagClassOf = (label)=>{
        const qn = __qnOf(label);
        return qn ? ('qtag-q' + qn) : '';
      };



      if (view === 'byq'){
        // Armar mapa piloto -> por Q
        const pilots = {};
        for (const qid of sessionKeys){
          const sess = sessions[qid];
          const rows = (sess && Array.isArray(sess.rows)) ? sess.rows : [];
          for (const row of rows){
            if (!row) continue;
            const nm = (row.racerName ?? '');
            const nk = normalizeNameKey(nm);
            if (!nk) continue;

            if (!pilots[nk]){
              pilots[nk] = { name: nm, byQ: {}, bestQ: '', bestRow: null };
            } else {
              if (String(nm).length > String(pilots[nk].name || '').length) pilots[nk].name = nm;
            }
            pilots[nk].byQ[qid] = row;
          }
        }

        // Mejor global por piloto
        const list = [];
        for (const k in pilots){
          const p = pilots[k];
          let bestRow = null;
          let bestQ = '';
          for (const qid of sessionKeys){
            const r = p.byQ[qid];
            if (!r) continue;
            bestRow = pickBetterQuali(bestRow, { laps:r.laps, timeMs:r.timeMs, racerName:r.racerName, racerNumber:r.racerNumber, bestMs:r.bestMs });
            if (bestRow && bestRow.timeMs === r.timeMs && Number(bestRow.laps||0) === Number(r.laps||0)) bestQ = qid;
          }
          p.bestRow = bestRow;
          p.bestQ = bestQ;
          list.push(p);
        }

        list.sort((a,b)=>{
          const al = Number(a.bestRow && a.bestRow.laps || 0);
          const bl = Number(b.bestRow && b.bestRow.laps || 0);
          if (bl !== al) return bl - al;
          return Number(a.bestRow && a.bestRow.timeMs || Number.MAX_SAFE_INTEGER) - Number(b.bestRow && b.bestRow.timeMs || Number.MAX_SAFE_INTEGER);
        });

        // Thead
        let th = `<tr><th class="qcol-pos">Pos</th><th class="qcol-name">Piloto</th><th class="qcol-q">Mejor</th><th class="qcol-time">Mejor (laps-tiempo)</th>`;
        for (const qid of sessionKeys){
          const qcls = __qClassOf(qid);
          th += `<th class="qcol-q ${qcls}">${qid}</th>`;
        }
        th += `</tr>`;
        thead.innerHTML = th;

        // Rows
        let out = '';
        for (let i=0;i<list.length;i++){
          const p = list[i];
          const bestQ = p.bestQ || '';
          const br = p.bestRow || null;
          const bestMain = br ? `${Number(br.laps||0)}v - ${qEscapeHtml(msToMinSec(Number(br.timeMs||0)))}` : '-';
          const __bestQcls = __qTagClassOf(bestQ);
          out += `<tr><td>${i+1}</td><td>${qEscapeHtml(p.name||'')}</td><td><span class="qtag ${__bestQcls}">${qEscapeHtml(bestQ||'-')}</span></td><td class="qcell-best">${bestMain}</td>`;
          for (const qid of sessionKeys){
            const r = p.byQ[qid];
            const cls = (qid === bestQ) ? 'qcell-best' : '';
            const empty = (!r) ? 'qcell-empty' : '';
            const qcls = __qClassOf(qid);
            out += `<td class="${qcls} ${cls} ${empty}">${cellHtml(r)}</td>`;
          }
          out += `</tr>`;
        }
        tbody.innerHTML = out || `<tr><td colspan="${4+sessionKeys.length}" class="qcell-empty">Sin datos aun</td></tr>`;
        return;
      }

      // Vista: mejor por piloto
      const list = computeQualiList(store);


      const __bestVals = list.map(r => Number(r.bestMs || 0)).filter(ms => isFinite(ms) && ms > 0);
      const __minBest = __bestVals.length ? Math.min(...__bestVals) : 0;
      thead.innerHTML = `<tr>
        <th class="qcol-pos">Pos</th>
        <th class="qcol-name">Piloto</th>
        <th class="qcol-q">Q</th>
        <th class="qcol-laps">Vueltas</th>
        <th class="qcol-time">Tiempo</th>
        <th class="qcol-best">Best Lap</th>
      </tr>`;

      let out = '';
      for (let i=0;i<list.length;i++){
        const r = list[i];
        const laps = Number(r.laps || 0);
        const t = (isFinite(r.timeMs) && r.timeMs < Number.MAX_SAFE_INTEGER) ? msToMinSec(Number(r.timeMs)) : '-';
        const b = (Number(r.bestMs||0) > 0) ? msToLapStr(Number(r.bestMs||0)) : '-';
        const isFastestBL = (__minBest && Number(r.bestMs||0) === __minBest);
        const bestLapCellClass = 'qcell-bestlap' + (b==='-' ? ' qcell-empty' : '') + (isFastestBL ? ' qcell-best' : '');
        out += `<tr>
          <td>${i+1}</td>
          <td>${qEscapeHtml(r.racerName || '')}</td>
          <td><span class=\"qtag ${__qTagClassOf(r.q)}\">${qEscapeHtml(r.q || '-')}</span></td>
          <td class=\"qcell-laps\">${laps}</td>
          <td class=\"qcell-time\">${qEscapeHtml(t)}</td>
          <td class=\"${bestLapCellClass}\"><span class=\"qbest\" title=\"src:${qEscapeHtml(r.bestKey||'')}\">${qEscapeHtml(b)}</span></td>
        </tr>`;
      }
      tbody.innerHTML = out || `<tr><td colspan="6" class="qcell-empty">Sin datos aun</td></tr>`;
    }

    function openQuali(){
      const bd = document.getElementById('qualiBackdrop');
      if (!bd) return;
      try { renderQualiTable(); } catch(e) {}
      bd.classList.add('open');
      bd.setAttribute('aria-hidden','false');
    }
    function closeQuali(){
      const bd = document.getElementById('qualiBackdrop');
      if (!bd) return;
      bd.classList.remove('open');
      bd.setAttribute('aria-hidden','true');
    }

    // Bind UI (una sola vez)
    (function initQualiUI(){
      try{
        const btn = document.getElementById('qTableBtn');
        const bd  = document.getElementById('qualiBackdrop');
        const closeBtn = document.getElementById('qualiCloseBtn');
        const viewSel  = document.getElementById('qualiViewSel');

        if (btn) btn.addEventListener('click', openQuali);
        if (closeBtn) closeBtn.addEventListener('click', closeQuali);
        if (viewSel) viewSel.addEventListener('change', ()=>{ try{ renderQualiTable(); }catch(e){} });

        if (bd) bd.addEventListener('click', (ev)=>{
          if (ev && ev.target === bd) closeQuali();
        });
        document.addEventListener('keydown', (ev)=>{
          if (ev && ev.key === 'Escape'){
            const bdx = document.getElementById('qualiBackdrop');
            if (bdx && bdx.classList.contains('open')) closeQuali();
          }
        });
      }catch(e){}
    })();

/* ---- merged script ---- */

/* LayoutGuard - shows a small badge if the header overflows (useful for iOS Pro/Max and large-text settings) */
(function(){
  try {
    const html = document.documentElement;
    const header = document.querySelector('.app-header');
    if (!header) return;

    const badge = document.createElement('div');
    badge.id = 'layoutGuardBadge';
    badge.style.cssText = [
      'position:absolute',
      'right:8px',
      'bottom:6px',
      'z-index:9999',
      'padding:3px 6px',
      'border-radius:999px',
      'font-size:11px',
      'font-weight:800',
      'letter-spacing:0.2px',
      'background:rgba(255,0,0,0.85)',
      'color:#fff',
      'box-shadow:0 2px 10px rgba(0,0,0,0.45)',
      'display:none',
      'pointer-events:none'
    ].join(';');
    badge.textContent = 'HDR OVERFLOW';
    header.appendChild(badge);

    const check = () => {
      const overW = (header.scrollWidth - header.clientWidth) > 1;
      const overH = (header.scrollHeight - header.clientHeight) > 1;
      if (overW || overH) {
        html.classList.add('layout-overflow');
        badge.style.display = 'inline-block';
        badge.textContent = overW && overH ? 'HDR OVR W+H' : (overW ? 'HDR OVR W' : 'HDR OVR H');
      } else {
        html.classList.remove('layout-overflow');
        badge.style.display = 'none';
      }
    };

    const rafCheck = () => requestAnimationFrame(check);
    window.addEventListener('resize', rafCheck, { passive: true });
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', rafCheck, { passive: true });
      window.visualViewport.addEventListener('scroll', rafCheck, { passive: true });
    }
    document.addEventListener('DOMContentLoaded', () => setTimeout(check, 200));
    setTimeout(check, 500);
    setInterval(check, 2500);
  } catch(e) {
    // no-op
  }
})();



}

</script>
</body>
</html>