<!--
Spotter_5.2.22 - BASE estable (rollback controlado)
Fecha: 2026-01-11
Origen: Spotter_5.0.1.html

Changelog:
- 5.1.92: Bandera azul re-implementada con l√≥gica simple por cruces (usa timestamp local abs cuando existe).
- v7.60: Auditor√≠a de narraciones: panel de uso por categor√≠a (esta sesi√≥n) + limpieza de checkboxes legacy (ya no se usaban).
- v7.50: Polling adaptativo | v7.51: Cache m√©tricas por piloto (BLOQUE 2.1) - menos CPU (250ms activo, 0.9-1.2s idle, y backoff en errores) para bajar costo/bater√≠a sin perder 'en vivo'.
- v7.5: Fix Auto Locutor: ya no depende de RD, usa POS para top3/peleas por defecto, umbral ajustado para evitar silencio, y no resetea tus voiceSettings.
- v7.4: Auto Locutor PRO narrativo: seguimiento de pelea (focus) con contexto, tendencia de gap, y modo MANGA mejorado (pole/best lap) con menos 'robot'.
- v7.3: Locutor mejorado: frases tipo shuffle-bag (anti repetici√≥n real), manga batalla con nombres+gaps, y micro-variaci√≥n en Auto Locutor.
- v7.2: UI piloto + voz: pilotSelect 2x, color por posici√≥n, gapInfo blanco grande, extras m√°s compacto, y clon mini de bot√≥n de voz junto al piloto.
- v7.1: TTS (Web Speech API) reforzado: selector de voz visible, bot√≥n de prueba, carga de voces con reintentos, y respeto a la voz elegida en la cola.
- v7.0: Nuevo toggle "Modo background" (no pausa al quedar oculta la pesta√±a/ventana) + reenganche al volver (visibilitychange) + wake lock se reintenta al regresar.
Nota: En iPhone/iOS, el sistema puede pausar TTS cuando la app se va a background real (pantalla apagada o cambiar de app). En Windows/Chrome, si la ventana queda tapada, a veces hay throttling del navegador.
-->


<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Spotter_5.2.22</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    :root {
      --bg-dark: #040406;
      --card-dark: #080a0f;
      --card-dark-2: #05070c;
      --text-main: #f2f5ff;
      --text: var(--text-main);
      --text-muted: #a3adbd;

      --accent-red: #ff2b2b;
      --accent-red-soft: rgba(255,43,43,0.55);

      --accent-orange: #ff7a18;
      --accent-orange-soft: rgba(255,122,24,0.55);

      --accent-blue: #2d6bff;
      --accent-blue-soft: rgba(45,107,255,0.55);

      --accent-cyan: #2d6bff;
      --border-soft: rgba(148,163,184,0.38);

      --radius-lg: 16px;
      --radius-pill: 999px;

      --shadow-strong: 0 0 16px rgba(255,43,43,0.42);
      --shadow-soft: 0 0 12px rgba(255,122,24,0.26);
      /* Header (app-header) theme */
      --hdr-grad-a: rgba(255,40,40,0.14);
      --hdr-grad-b: rgba(255,140,0,0.16);
      --hdr-stripe-a: #0b1220;
      --hdr-stripe-b: #05070d;
      --hdr-border: rgba(255,90,0,0.24);
      --hdr-border-2: rgba(255,140,0,0.18);
      --hdr-glow: 0 0 18px rgba(255,90,0,0.14);

      /* Badge MODO theme (auto por sesi√≥n) */
      --mode-bg-neutral: rgba(0,0,0,0.25);
      --mode-brd-neutral: rgba(255,255,255,0.14);
      --mode-bg-manga: linear-gradient(135deg, rgba(0,229,255,.92), rgba(0,140,255,.75));
      --mode-bg-final: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75));
      --mode-bg-finalA: linear-gradient(135deg, rgba(255,215,0,.96), rgba(255,140,0,.80));

    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Roboto", sans-serif;
      background-color: var(--bg-dark);
      color: var(--text-main);
      background-image:
        radial-gradient(circle at 20% 10%, rgba(45,107,255,0.14), transparent 55%),
        radial-gradient(circle at 80% 0%, rgba(255,122,24,0.14), transparent 55%),
        radial-gradient(circle at 70% 95%, rgba(255,43,43,0.14), transparent 60%),
        repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0, rgba(255,255,255,0.02) 2px, rgba(0,0,0,0.0) 2px, rgba(0,0,0,0.0) 6px);
      background-blend-mode: screen;
      min-height: 100vh;
    }

    body.no-scroll {
      overflow: hidden !important;
    }


    .app {
      max-width: 480px;
      margin: 0 auto;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 10px 12px 12px;
      gap: 8px;
    }

    .app-header {
      flex-shrink: 0;
      padding: 10px 14px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--hdr-border);
      box-shadow: var(--shadow-soft), var(--hdr-glow);
      background-image:
        radial-gradient(120% 180% at 0% 0%, rgba(0,229,255,0.22), transparent 55%),
        radial-gradient(120% 180% at 100% 0%, rgba(255,140,0,0.18), transparent 55%),
        linear-gradient(135deg, var(--hdr-grad-a), var(--hdr-grad-b)),
        repeating-linear-gradient(45deg, var(--hdr-stripe-a) 0, var(--hdr-stripe-a) 2px, var(--hdr-stripe-b) 2px, var(--hdr-stripe-b) 4px),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 6px);
      background-blend-mode: screen, screen, normal, normal, overlay;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .header-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .header-title-main {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      flex-wrap: wrap;
    }

    
    #trLogo {
      height: 22px;
      width: auto;
      max-width: 220px;
      object-fit: contain;
      display: inline-block;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.65));
    }

.badge-mode {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      border: 1px solid var(--mode-brd-neutral);
      background: var(--mode-bg-neutral);
      white-space: nowrap;
      box-shadow: 0 0 10px rgba(0,0,0,0.25);
    }
    .badge-mode.mode-manga{
      background: var(--mode-bg-manga);
      border-color: rgba(255,255,255,0.14);
      color: #071018;
      box-shadow: 0 0 12px rgba(0,229,255,0.25);
    }
    .badge-mode.mode-final{
      background: var(--mode-bg-final);
      border-color: rgba(255,255,255,0.14);
      color: #0b0f14;
      box-shadow: 0 0 12px rgba(255,140,0,0.22);
    }
    .badge-mode.mode-finalA{
      background: var(--mode-bg-finalA);
      border-color: rgba(255,255,255,0.16);
      color: #101015;
      box-shadow: 0 0 14px rgba(255,215,0,0.22);
    }

    .header-title-sub {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent-blue, #00e5ff);
      text-shadow: 0 1px 2px rgba(0,0,0,0.85);
    }

    .header-subline {
      font-size: 10px;
      color: var(--text-muted);
    }

    .header-mini {
      font-size: 9px;
      color: var(--text-muted);
    }

    .header-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    .badge-live {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 9px;
      border-radius: var(--radius-pill);
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 0 10px rgba(34,197,94,0.8);
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
    }

    .badge-live-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background-color: #bbf7d0;
    }

    .badge-live.live-off {
      background: #4b5563;
      box-shadow: none;
    }

    .badge-live.live-off .badge-live-dot {
      background-color: #9ca3af;
    }

    .header-version {
      font-size: 10px;
      color: var(--text-muted);
    }

    .app-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
    }

    .pilot-card {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background-image:
        linear-gradient(145deg, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      border: 1px solid rgba(249,115,22,0.7);
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .pilot-card-top-strip {
      height: 4px;
      border-radius: 999px;
      background-image:
        linear-gradient(90deg, #b91c1c, var(--accent-orange), #b91c1c),
        repeating-linear-gradient(45deg, #111827 0, #111827 2px, #020617 2px, #020617 4px);
      background-blend-mode: overlay;
    }

    .pilot-row-heading {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .pilot-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .pilot-name {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .pilot-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    .pilot-select {
      flex: 1;
      margin-top: 4px;
    }

    .pilot-select select {
      width: 100%;
      padding: 12px 14px; /* +100% */
      border-radius: 999px;
      border: 1px solid var(--border-soft);
      background: rgba(15,23,42,0.95);
      color: var(--text-main);
      font-size: 18px; /* +100% */
      font-weight: 800;
      outline: none;
      transition: background 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease, color 0.12s ease;
    }

    .pilot-select-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 6px;
    }

    .btn-voice-mini {
      flex: 0 0 50%;
      padding: 6px 8px;
      font-size: 11px;
      letter-spacing: 0.06em;
    }

    /* Color del selector por posici√≥n */
    
    :root { color-scheme: dark; }

    /* Pilot select - evitar fondo blanco en Chrome/Android */
    #pilotSelect {
      background: rgba(11, 15, 20, 0.92);
      color: var(--text-main);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    #pilotSelect option {
      background: #0b0f14;
      color: #e8eefc;
    }

#pilotSelect.pos-none {
      border-color: var(--border-soft);
      box-shadow: none;
    }
    #pilotSelect.pos-1 {
      background: linear-gradient(135deg, rgba(255,215,0,0.96), rgba(255,140,0,0.82));
      border-color: rgba(255,215,0,0.55);
      box-shadow: 0 0 14px rgba(255,215,0,0.18);
      color: #0b0f14;
    }
    #pilotSelect.pos-2 {
      background: linear-gradient(135deg, rgba(229,231,235,0.96), rgba(156,163,175,0.74));
      border-color: rgba(229,231,235,0.46);
      box-shadow: 0 0 14px rgba(229,231,235,0.12);
      color: #0b0f14;
    }
    #pilotSelect.pos-3 {
      background: linear-gradient(135deg, rgba(251,146,60,0.96), rgba(180,83,9,0.78));
      border-color: rgba(251,146,60,0.46);
      box-shadow: 0 0 14px rgba(251,146,60,0.14);
      color: #0b0f14;
    }
    #pilotSelect.pos-top5 {
      border-color: rgba(34,197,94,0.42);
      box-shadow: 0 0 14px rgba(34,197,94,0.12);
      background: linear-gradient(135deg, rgba(34,197,94,0.20), rgba(16,185,129,0.14));
    }
    #pilotSelect.pos-other {
      border-color: rgba(45,107,255,0.40);
      box-shadow: 0 0 12px rgba(45,107,255,0.10);
    }

    @media (max-width: 430px){
      .btn-voice-mini { flex-basis: 55%; }
      .pilot-select select { font-size: 16px; padding: 10px 12px; }
    }


    .pilot-pos-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 4px;
    }

    .pos-pill {
      padding: 5px 14px;
      border-radius: var(--radius-pill);
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      box-shadow: var(--shadow-strong);
    }

    .pos-info {
      font-size: 14px;
      color: #ffffff;
      font-weight: 700;
      text-align: right;
    }

    .pilot-timings {
      margin-top: 6px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .timing-item {
      padding: 6px 6px 7px;
      border-radius: 12px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.95), rgba(3,7,18,0.98));
      border: 1px solid rgba(15,23,42,0.9);
    }

    .timing-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-muted);
      margin-bottom: 2px;
    }

    .timing-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent-cyan);
      transition: transform 0.2s ease, text-shadow 0.2s ease;
    }

    .timing-value.flash {
      transform: scale(1.22);
      text-shadow: 0 0 12px rgba(34,211,238,0.9);
    }

    /* Timing KPIs: tipograf√≠a y tama√±os estandar (√öltima/Mejor/Record se mantienen) */
    .pilot-timings .timing-item:not(.primary-metric) .timing-label{
      font-size: 9px;
      letter-spacing: 0.16em;
    }
    .pilot-timings .timing-item:not(.primary-metric) .timing-value{
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0;
      font-variant-numeric: tabular-nums;
    }

    /* Time en pilot-timings: sin pastilla, mismo estilo que el resto */
    .pilot-timings .manga-clock{
      display: block;
      padding: 0;
      border: 0;
      background: none;
      box-shadow: none;
      gap: 0;
      align-items: initial;
      justify-content: initial;
      letter-spacing: 0;
      color: var(--accent-cyan);
    }

.controls-section {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .controls-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .controls-label {
      font-size: 11px;
      color: var(--text-muted);
    }

    .voice-speed-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .voice-speed-value {
      font-size: 11px;
      color: var(--accent-orange-soft);
      min-width: 40px;
      text-align: right;
    }

    .voice-select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.55);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
    }
    .voice-select option {
      background: #0b1120;
      color: var(--text-main);
    }

    input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(90deg, #111827, var(--accent-orange), #b91c1c);
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-orange);
      box-shadow: 0 0 10px rgba(249,115,22,0.9);
      border: 2px solid #fee2e2;
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-orange);
      box-shadow: 0 0 10px rgba(249,115,22,0.9);
      border: 2px solid #fee2e2;
      cursor: pointer;
    }

    .buttons-row {
      display: flex;
      gap: 8px;
    }

    .rate-row {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
    }
    .rate-label {
      min-width: 120px;
      font-weight: 700;
      letter-spacing: 0.2px;
      opacity: 0.95;
    }
    #rateRange {
      flex: 1;
      accent-color: #ff5a1f;
    }
    .rate-display {
      min-width: 56px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      opacity: 0.95;
    }

    .btn-primary,
    .btn-secondary {
      flex: 1;
      padding: 8px 10px;
      border-radius: var(--radius-pill);
      border: none;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      transition: transform 0.06s ease, box-shadow 0.06s ease, background 0.06s ease;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      box-shadow: var(--shadow-strong);
    }

    .btn-secondary {
      background: transparent;
      color: var(--accent-orange-soft);
      border: 1px solid rgba(248,113,113,0.7);
    }

    .btn-primary:active,
    .btn-secondary:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 0 4px rgba(15,15,15,0.8);
    }

    .btn-primary.voice-on {
      background: linear-gradient(135deg, #16a34a, #22c55e);
      box-shadow: 0 0 12px rgba(34,197,94,0.9);
    }

    .spotter-section {
      border-radius: var(--radius-lg);
      padding: 10px 12px 12px;
      background: linear-gradient(160deg, rgba(15,23,42,0.98), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .spotter-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
    }

    .spotter-btn {
  padding: 6px 7px;
  border-radius: var(--radius-pill);
  font-size: 11px;
  border: 1px solid var(--border-soft);
  background: rgba(15,23,42,0.96);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: pointer;
  transition: background 0.08s ease, box-shadow 0.08s ease, color 0.08s ease, border 0.08s ease;
  user-select: none;

  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;

  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-height: 30px;
}

    .spotter-btn span {
  font-size: 12px;
  flex: 0 0 auto;
}

    .spotter-btn.active {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      border-color: rgba(254,242,242,0.85);
      box-shadow: var(--shadow-soft);
    }

    

    /* Categorias de mensajes */
    .spotter-cat {
      border-radius: 14px;
      padding: 6px 6px 8px;
      border: 1px solid rgba(148,163,184,0.30);
      background: rgba(2,6,23,0.35);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .spotter-cat-head {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: var(--radius-pill);
      font-size: 10px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(148,163,184,0.25);
      user-select: none;
    }

    .spotter-cat .cat-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 0 10px rgba(255,255,255,0.15);
      flex: 0 0 auto;
    }

    .spotter-btn.lock::after {
      content: "üîí";
      font-size: 12px;
      margin-left: 6px;
      opacity: 0.95;
    }

    
    .spotter-cat[data-cat="essential"] {
      border-color: rgba(255,70,70,0.48);
    }
    .spotter-cat[data-cat="essential"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(255,70,70,0.18), rgba(255,140,0,0.14));
      border-color: rgba(255,70,70,0.32);
      color: rgba(255,230,230,0.95);
    }
    .spotter-cat[data-cat="essential"] .cat-dot {
      background: rgba(255,70,70,0.95);
      box-shadow: 0 0 12px rgba(255,70,70,0.55);
    }
    .spotter-cat[data-cat="essential"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(255,70,70,0.95), rgba(255,140,0,0.78));
      box-shadow: 0 0 14px rgba(255,70,70,0.22);
      color: #0b0f14;
      border-color: rgba(255,255,255,0.10);
    }

    .spotter-cat[data-cat="battle"] {
      border-color: rgba(255,170,0,0.46);
    }
    .spotter-cat[data-cat="battle"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(255,170,0,0.18), rgba(255,90,0,0.10));
      border-color: rgba(255,170,0,0.30);
      color: rgba(255,245,220,0.95);
    }
    .spotter-cat[data-cat="battle"] .cat-dot {
      background: rgba(255,170,0,0.95);
      box-shadow: 0 0 12px rgba(255,170,0,0.55);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,140,0,0.80));
      box-shadow: 0 0 14px rgba(255,170,0,0.20);
      color: #0b0f14;
      border-color: rgba(255,255,255,0.10);
    }

    .spotter-cat[data-cat="summary"] {
      border-color: rgba(0,255,140,0.42);
    }
    .spotter-cat[data-cat="summary"] .spotter-cat-head {
      background: linear-gradient(135deg, rgba(0,255,140,0.14), rgba(0,170,90,0.10));
      border-color: rgba(0,255,140,0.26);
      color: rgba(220,255,240,0.95);
    }
    .spotter-cat[data-cat="summary"] .cat-dot {
      background: rgba(0,255,140,0.92);
      box-shadow: 0 0 12px rgba(0,255,140,0.50);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active {
      background: linear-gradient(135deg, rgba(0,255,140,0.92), rgba(0,170,90,0.80));
      box-shadow: 0 0 14px rgba(0,255,140,0.18);
      color: #06110c;
      border-color: rgba(255,255,255,0.10);
    }
.extras-section {
      border-radius: var(--radius-lg);
      padding: 2px 4px 4px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.96), rgba(2,6,23,0.98));
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 1px;
    }

    .precision-row {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .precision-buttons {
      display: flex;
      gap: 4px;
    }

    .precision-badge {
      flex: 1;
      padding: 4px 0;
      border-radius: var(--radius-pill);
      font-size: 10px;
      border: 1px solid var(--border-soft);
      background: rgba(15,23,42,0.96);
      color: var(--text-muted);
      text-align: center;
      cursor: default;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      transition: background 0.08s ease, color 0.08s ease, border 0.08s ease;
    }

    .precision-badge.active {
      background: linear-gradient(135deg, var(--accent-orange), var(--accent-red));
      color: var(--text-main);
      border-color: rgba(254,242,242,0.85);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-top: 1px;
    }

    .toggle-label {
      font-size: 9px;
      color: var(--text-muted);
    }

    .toggle-pill {
      width: 30px;
      height: 15px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid var(--border-soft);
      position: relative;
      cursor: pointer;
      transition: background 0.08s ease, border 0.08s ease;
    }

    .toggle-thumb {
      width: 11px;
      height: 11px;
      border-radius: 999px;
      background: #9ca3af;
      position: absolute;
      top: 1px;
      left: 1px;
      transition: transform 0.12s ease, background 0.12s ease, box-shadow 0.12s ease;
    }

    .toggle-pill.active {
      background: linear-gradient(135deg, var(--accent-orange), var(--accent-red));
      border-color: rgba(254,242,242,0.85);
    }

    .toggle-pill.active .toggle-thumb {
      transform: translateX(18px);
      background: #fef2f2;
      box-shadow: 0 0 8px rgba(248,113,113,0.9);
    }

    .wake-status {
      font-size: 9px;
      color: var(--text-muted);
      text-align: right;
    }

    .grid-button-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 2px;
    }

    .btn-grid{
  appearance:none;
  border:1px solid var(--btn-border);
  border-radius:14px;
  background:var(--btn-bg);
  color: var(--text-main);
  padding:10px 12px;
  min-height:44px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  font-weight:700;
  letter-spacing:.2px;
  cursor:pointer;
  user-select:none;
  transition:transform .06s ease, background .12s ease, border-color .12s ease;
}
.hint-text {
      font-size: 10px;
      color: var(--text-muted);
      text-align: right;
    }

    .grid-sheet-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: flex-end;
      justify-content: center;
      z-index: 30;
    }

    .grid-sheet-backdrop.open {
      display: flex;
    }

    
.grid-sheet {
      width: min(980px, 96vw);
      max-width: 980px;
      max-height: 92vh;
      height: 92vh;
      background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      border-radius: 18px;
      border: 1px solid rgba(248,113,113,0.45);
      box-shadow: 0 18px 40px rgba(0,0,0,0.80);
      padding: 8px 12px 12px;
      overflow: hidden;                 /* el scroll vive en la lista */
      display: flex;
      flex-direction: column;
    }

    /* Si el alto disponible es chico (cel), ancla abajo estilo sheet */
    @media (max-width: 560px) {
      .grid-sheet {
        width: 100%;
        max-width: 560px;
        height: 92vh;
        border-radius: 18px 18px 0 0;
        border-left: 0;
        border-right: 0;
        border-bottom: 0;
      }
    }
.grid-sheet-handle {
      width: 40px;
      height: 4px;
      border-radius: 999px;
      background: rgba(148,163,184,0.7);
      margin: 4px auto 8px;
    }

    
    .grid-sheet-header {
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px 8px;
      margin-bottom: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,140,0,0.22);
      box-shadow: 0 10px 18px rgba(0,0,0,0.55);
      background-image:
        radial-gradient(120% 160% at 0% 0%, rgba(0,229,255,0.18), transparent 55%),
        radial-gradient(120% 160% at 100% 0%, rgba(255,140,0,0.18), transparent 55%),
        linear-gradient(135deg, rgba(255,40,40,0.10), rgba(255,140,0,0.12)),
        repeating-linear-gradient(45deg, rgba(11,18,32,0.85) 0, rgba(11,18,32,0.85) 2px, rgba(5,7,13,0.85) 2px, rgba(5,7,13,0.85) 4px);
      background-blend-mode: screen, screen, normal, normal;
    }

    .grid-sheet-title-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .grid-sheet-title {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      font-weight: 900;
      color: rgba(255,190,120,0.95);
      line-height: 1.05;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .grid-sheet-sub {
      font-size: 10px;
      color: rgba(226,232,240,0.78);
      letter-spacing: 0.04em;
      opacity: 0.95;
    }

    .grid-sheet-hud {
      margin-top: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,140,0,0.14);
    }

    .grid-hud-left {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      min-width: 0;
    }

    .grid-hud-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border-radius: 999px;
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      background: rgba(2,6,23,0.60);
      border: 1px solid rgba(148,163,184,0.28);
      color: rgba(226,232,240,0.92);
      box-shadow: 0 0 10px rgba(0,0,0,0.30);
      white-space: nowrap;
    }

    .grid-hud-chip-mode {
      border-color: rgba(34,211,238,0.22);
      color: rgba(34,211,238,0.95);
      background: rgba(2,6,23,0.55);
    }

    .grid-hud-chip.mode-manga {
      border-color: rgba(0,229,255,0.30);
      color: rgba(0,229,255,0.95);
      background: rgba(0,229,255,0.12);
    }

    .grid-hud-chip.mode-final {
      border-color: rgba(255,140,0,0.32);
      color: rgba(255,180,90,0.96);
      background: rgba(255,140,0,0.12);
    }

    .grid-hud-chip.mode-finalA {
      border-color: rgba(255,215,0,0.35);
      color: rgba(255,215,0,0.96);
      background: rgba(255,215,0,0.12);
    }

    .grid-meta-right {
      font-size: 11px;
      font-weight: 800;
      color: var(--accent-cyan);
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 52%;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(2,6,23,0.45);
      border: 1px solid rgba(34,211,238,0.20);
    }

    .btn-sheet-close {
      width: 34px;
      height: 34px;
      flex: 0 0 auto;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.28);
      background: rgba(2,6,23,0.55);
      color: rgba(226,232,240,0.90);
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0,0,0,0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .btn-sheet-close:hover {
      border-color: rgba(255,140,0,0.30);
      box-shadow: 0 0 12px rgba(255,140,0,0.18);
    }
    
    .grid-list {
      --grid-cols: 1;
      flex: 1 1 auto;
      min-height: 0;
      display: grid;
      grid-template-columns: repeat(var(--grid-cols), minmax(220px, 1fr));
      gap: 8px;
      padding-bottom: 8px;
      overflow-y: auto;                 /* si no cabe, desliza */
      overscroll-behavior: contain;

      scrollbar-width: none;            /* Firefox */
      -ms-overflow-style: none;         /* IE/Edge legacy */
    }
    .grid-list::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }
.grid-row {
      border-radius: 12px;
      padding: 5px 8px;
      background: rgba(15,23,42,0.96);
      border: 1px solid rgba(55,65,81,0.9);
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 11px;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    .grid-row-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .grid-pos {
      font-weight: 700;
      font-size: 12px;
    }

    .grid-name {
      flex: 1;
      font-size: 12px;
    }

    .grid-tags {
      font-size: 10px;
      color: var(--text-muted);
    }

    .grid-row.p1 {
      border-color: #facc15;
    }
    .grid-row.p2 {
      border-color: #e5e7eb;
    }
    .grid-row.p3 {
      border-color: var(--accent-orange);
    }

    .grid-row.selected {
      border-color: var(--accent-cyan);
      box-shadow: 0 0 10px rgba(34,211,238,0.7);
    }

    /* GRID COMPLETO - UI PRO (v5.0.0) */
    .grid-sheet-headleft {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
      flex: 1;
    }

    .grid-row {
      cursor: pointer;
      padding: 9px 10px;
    }
    .grid-row:hover {
      transform: translateY(-1px);
      border-color: rgba(34,211,238,0.35);
      box-shadow: 0 10px 18px rgba(0,0,0,0.45);
    }
    .grid-row-top {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .grid-pos-pill {
      min-width: 42px;
      height: 26px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      font-size: 12px;
      background: rgba(2,6,23,0.70);
      border: 1px solid rgba(148,163,184,0.35);
      color: rgba(226,232,240,0.95);
      flex: 0 0 auto;
    }
    .grid-name-wrap {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .grid-name {
      font-size: 12px;
      font-weight: 900;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      letter-spacing: 0.02em;
    }
    .grid-sub {
      font-size: 10px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.95;
    }

    .grid-metrics {
      display: flex;
      gap: 6px;
      align-items: stretch;
      justify-content: flex-end;
      flex-wrap: wrap;
      flex: 0 0 auto;
    }
    .grid-kpi {
      min-width: 70px;
      padding: 4px 6px;
      border-radius: 10px;
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(34,211,238,0.12);
      text-align: right;
    }
    .grid-kpi .k {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      opacity: 0.9;
    }
    .grid-kpi .v {
      font-size: 11px;
      font-weight: 900;
      color: rgba(226,232,240,0.96);
      letter-spacing: 0.02em;
    }
    .grid-kpi.best .v { color: var(--accent-cyan); }
    .grid-kpi.last .v { color: var(--accent-orange-soft); }
    .grid-kpi.mean .v { color: rgba(226,232,240,0.96); }

    .grid-row-bottom {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }
    .grid-chip {
      font-size: 10px;
      color: rgba(226,232,240,0.78);
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.45);
      border: 1px solid rgba(55,65,81,0.75);
    }
    .grid-chip strong {
      color: rgba(226,232,240,0.96);
      font-weight: 800;
    }

    @media (max-width: 420px) {
      .grid-kpi { min-width: 66px; }
      .grid-meta-right { max-width: 64%; }
    }

    
    .lap-chart-wrap {
      margin-top: 8px;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid rgba(251, 146, 60, 0.22);
      background: linear-gradient(180deg, rgba(2, 6, 23, 0.55), rgba(2, 6, 23, 0.25));
      box-shadow: inset 0 0 0 1px rgba(34,211,238,0.08);
    }
    .lap-chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }
    .lap-chart-title {
      font-size: 12px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.85);
    }
    .lap-chart-meta {
      font-size: 11px;
      color: rgba(148,163,184,0.95);
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 65%;
    }
    .lap-pos-chip.pos1{ border-color: rgba(251,191,36,0.45); color: rgba(255,240,200,0.96); }
    .lap-pos-chip.pos2{ border-color: rgba(255,255,255,0.35); color: rgba(255,255,255,0.92); }
    .lap-pos-chip.pos3{ border-color: rgba(249,115,22,0.45); color: rgba(255,230,210,0.94); }

    .lap-pos-chip.active.pos1{ background: rgba(251,191,36,0.12); border-color: rgba(251,191,36,0.75); }
    .lap-pos-chip.active.pos2{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.70); }
    .lap-pos-chip.active.pos3{ background: rgba(249,115,22,0.12); border-color: rgba(249,115,22,0.78); }

    .top3-mini-grid{
      margin-top: 8px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }
.top3-mini-grid.expanded{ max-height: none; overflow: visible; }
@media (max-width: 380px){
  .top3-mini-grid.expanded{ max-height: none; overflow: visible; }
}
.top3-mini-grid.expanded .top3-mini-row{
  padding: 6px 8px;
  gap: 8px;
}
.top3-mini-grid.expanded .top3-mini-name{
  max-width: 34vw;
}
.top3-mini-grid.expanded .top3-mini-stats{
  max-width: 40vw;
  gap: 6px;
}
    .top3-mini-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 7px 10px;
      border-radius: 12px;
      background: rgba(2,6,23,0.28);
      border: 1px solid rgba(148,163,184,0.22);
      box-shadow: 0 6px 14px rgba(0,0,0,0.20);
    }
    .top3-mini-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .top3-mini-pos{
      width: 34px;
      height: 22px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      font-size: 12px;
      letter-spacing: 0.02em;
      border: 1px solid rgba(148,163,184,0.28);
      flex: 0 0 auto;
    }
    .top3-mini-name{
      font-weight: 750;
      font-size: 12px;
      color: rgba(226,232,240,0.95);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 52vw;
    }
    .top3-mini-right{
      font-weight: 650;
      font-size: 11px;
      color: rgba(148,163,184,0.95);
      flex: 0 0 auto;
      display:flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
      line-height: 1.05;
    }
    .top3-mini-num{
      font-weight: 800;
      font-size: 11px;
      color: rgba(226,232,240,0.92);
    }
    .top3-mini-stats{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
      font-size: 10px;
      color: rgba(148,163,184,0.92);
      flex-wrap: wrap;
      max-width: 46vw;
    }
    .top3-mini-stat{
      display:flex;
      align-items: baseline;
      gap: 3px;
      white-space: nowrap;
    }
    .top3-mini-k{
      font-weight: 900;
      font-size: 9px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.78);
    }
    .top3-mini-row.pos1{ border-color: rgba(251,191,36,0.28); }
    .top3-mini-row.pos2{ border-color: rgba(255,255,255,0.20); }
    .top3-mini-row.pos3{ border-color: rgba(249,115,22,0.26); }

    .top3-mini-pos.pos1{ background: rgba(251,191,36,0.14); border-color: rgba(251,191,36,0.55); color: rgba(255,245,210,0.98); }
    .top3-mini-pos.pos2{ background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.45); color: rgba(255,255,255,0.96); }
    .top3-mini-pos.pos3{ background: rgba(249,115,22,0.14); border-color: rgba(249,115,22,0.55); color: rgba(255,235,220,0.96); }
.top3-mini-row.posN{ border-color: rgba(148,163,184,0.16); }
.top3-mini-pos.posN{ background: rgba(148,163,184,0.10); border-color: rgba(148,163,184,0.30); color: rgba(226,232,240,0.92); }

    /* =========================
       TIMING MINI GRID (v6.5)
       Objetivo: Top3/Top20 con jerarqu√≠a de INT, n√∫meros tabulares, DUEL y barra de gap.
       ========================= */

    /* D√≠gitos parejitos (broadcast vibe) */
    .tgrid-nums{
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1, "ss01" 1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .top3-mini-row{
      padding: 6px 10px;
      gap: 10px;
    }

    /* Caja del # (auto) */
    .tgrid-numbox{
      min-width: 34px;
      height: 18px;
      padding: 0 8px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(148,163,184,0.10);
      border: 1px solid rgba(148,163,184,0.24);
      color: rgba(226,232,240,0.92);
      font-weight: 900;
      font-size: 11px;
      line-height: 1;
    }

    /* Estructura principal */
    .tgrid-main{
      width: 100%;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      min-width: 0;
    }

    .tgrid-left{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
      flex: 1 1 auto;
    }

    .tgrid-namewrap{ min-width: 0; flex: 1 1 auto; }

    .tgrid-name{
      font-weight: 850;
      font-size: 12px;
      color: rgba(226,232,240,0.96);
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      line-height: 1.15;
      word-break: break-word;
    }

    .tgrid-sub{
      margin-top: 2px;
      display:flex;
      align-items:baseline;
      justify-content:flex-start;
      gap: 10px;
      color: rgba(148,163,184,0.92);
      font-size: 10px;
      line-height: 1.05;
      flex-wrap: nowrap;
      white-space: nowrap;
    }

    .tgrid-sub .k{
      font-weight: 900;
      font-size: 9px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.78);
      margin-right: 4px;
    }

    /* Columnas fijas tipo timing screen */
    .tgrid-col{
      display:inline-flex;
      align-items:baseline;
      justify-content:flex-end;
      text-align:right;
      white-space: nowrap;
    }
    .tgrid-col.v{ min-width: 38px; }
    .tgrid-col.bl{ min-width: 96px; }
    .tgrid-col.int{ min-width: 96px; }


    .tgrid-right{
      display:flex;
      flex-direction: column;
      align-items:flex-end;
      justify-content:center;
      gap: 4px;
      flex: 0 0 auto;
    }

    /* INT protagonista */
    .tgrid-intwrap{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
    }

    /* INT block (line + bar) */
    .tgrid-intblock{
      display:flex;
      flex-direction: column;
      align-items:flex-end;
      gap: 4px;
    }

    .tgrid-intline{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 8px;
    }

    /* Compacto: que sea 1 l√≠nea real (Nombre + INT + #) */
    .top3-mini-row.compact .tgrid-right{
      flex-direction: row;
      align-items:center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-intblock{
      flex-direction: row;
      align-items:center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-bar{
      width: 34px;
    }


    .tgrid-int{
      font-weight: 950;
      font-size: 14px;
      letter-spacing: 0.01em;
      line-height: 1;
      color: rgba(226,232,240,0.98);
      min-width: 72px;
      text-align:right;
    }

    .tgrid-int.muted{ color: rgba(148,163,184,0.92); }
    .tgrid-int.lapped{ color: rgba(148,163,184,0.78); }

    .top3-mini-row.duel{
      border-color: rgba(45,107,255,0.42);
      box-shadow: 0 0 16px rgba(45,107,255,0.14);
    }
    .top3-mini-row.duel .tgrid-int{
      color: rgba(45,107,255,0.98);
      text-shadow: 0 0 10px rgba(45,107,255,0.26);
    }

    /* Badge DUEL/ATK/DEF */
    .tgrid-badge{
      height: 16px;
      padding: 0 8px;
      border-radius: 999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight: 950;
      font-size: 9px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(148,163,184,0.18);
      background: rgba(148,163,184,0.08);
      color: rgba(226,232,240,0.90);
    }
    .tgrid-badge.duel{ border-color: rgba(45,107,255,0.45); background: rgba(45,107,255,0.12); }
    .tgrid-badge.atk{ border-color: rgba(255,122,24,0.55); background: rgba(255,122,24,0.12); }
    .tgrid-badge.def{ border-color: rgba(255,43,43,0.55); background: rgba(255,43,43,0.12); }

    /* Mini barra de gap */
    .tgrid-bar{
      width: 42px;
      height: 6px;
      border-radius: 999px;
      background: rgba(148,163,184,0.16);
      border: 1px solid rgba(148,163,184,0.14);
      overflow:hidden;
    }
    .tgrid-bar > i{
      display:block;
      height: 100%;
      width: 0%;
      background: rgba(226,232,240,0.85);
      border-radius: 999px;
    }
    .top3-mini-row.duel .tgrid-bar{ border-color: rgba(45,107,255,0.28); background: rgba(45,107,255,0.12); }
    .top3-mini-row.duel .tgrid-bar > i{ background: rgba(45,107,255,0.95); }

    /* Compacto P4-P20 (1 l√≠nea pro) */
    .top3-mini-grid.expanded .top3-mini-row.compact{ padding: 5px 10px; }
    .top3-mini-row.compact .tgrid-sub{ display:none; }
    .top3-mini-row.compact .tgrid-name{ max-width: 46vw; }
    .top3-mini-row.compact .tgrid-int{ font-size: 13px; min-width: 70px; }

    /* Trend ‚ñ≤ ‚ñº */
    .tgrid-trend{
      font-weight: 900;
      font-size: 11px;
      opacity: 0.95;
      margin-left: 6px;
    }



    #lapChart {
      width: 100%;
      height: 120px;
      display: block;
      border-radius: 12px;
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(34,211,238,0.18);
    }

@media (min-height: 750px) {
      .app {
        padding-top: 12px;
      }
    }
  

    /* ULTRA COMPACT THEME OVERRIDES (v5.0.0) */
    :root {
      --radius-lg: 14px;
      --shadow-strong: none;
      --shadow-soft: none;
      --border-soft: rgba(148,163,184,0.28);
    }

    body {
      background-image: none !important;
      background-color: #050508 !important;
    }

    .app {
      max-width: 460px;
      padding: 8px 10px 10px;
      gap: 8px;
    }

    .app-header {
      padding: 8px 10px;
    }

    .pilot-section {
      padding: 8px 10px 10px;
    }

    .pilot-timings {
      gap: 5px;
      margin-top: 5px;
    }

    .timing-item {
      padding: 5px 6px 6px;
      border-radius: 12px;
      background: rgba(2,6,23,0.78);
    }

    .timing-label {
      font-size: 9px;
      letter-spacing: 0.12em;
      margin-bottom: 1px;
    }

    .timing-value {
      font-size: 13px;
    }

    .lap-chart-wrap {
      margin-top: 6px;
      padding: 6px 8px;
      border-radius: 12px;
      background: rgba(2,6,23,0.62);
    }

    .controls-section {
      padding: 8px 10px 10px;
      gap: 8px;
      background: rgba(2,6,23,0.82);
    }

    .buttons-row {
      gap: 6px;
    }

    .btn-primary, .btn-secondary, .btn-grid {
      padding: 10px 10px;
      border-radius: 14px;
      font-size: 12px;
      letter-spacing: 0.08em;
      box-shadow: none !important;
    }

    .rate-row {
      gap: 8px;
    }

    input[type="range"] {
      height: 3px;
      background: linear-gradient(90deg, #111827, var(--accent-orange), var(--accent-red));
    }

    input[type="range"]::-webkit-slider-thumb {
      width: 14px;
      height: 14px;
      box-shadow: none;
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      box-shadow: none;
    }

    .spotter-section {
      padding: 0;
      background: transparent;
      border: none;
    }

    .spotter-cat {
      padding: 6px 6px 7px;
      gap: 6px;
      background: rgba(2,6,23,0.58);
      border: 1px solid rgba(148,163,184,0.22);
    }

    .spotter-cat-head {
      padding: 4px 8px;
      font-size: 9px;
      letter-spacing: 0.12em;
      border-radius: 12px;
      background: rgba(15,23,42,0.68);
    }

    .spotter-cat .cat-dot {
      width: 7px;
      height: 7px;
      box-shadow: none;
    }

    .spotter-grid {
      gap: 4px;
    }

    .spotter-btn {
      min-height: 26px;
      padding: 5px 6px;
      font-size: 10px;
      letter-spacing: 0.07em;
      border-radius: 12px;
      background: rgba(10,18,32,0.92);
      border-color: rgba(148,163,184,0.22);
      color: rgba(226,232,240,0.72);
    }

    .spotter-btn span {
      font-size: 11px;
    }

    .spotter-btn.active {
      background: rgba(15,23,42,0.92) !important;
      color: rgba(255,255,255,0.96) !important;
      box-shadow: none !important;
    }

    .spotter-cat[data-cat="essential"] .spotter-btn.active {
      border-color: rgba(45,107,255,0.80) !important;
    }

    .spotter-cat[data-cat="battle"] .spotter-btn.active {
      border-color: rgba(255,122,24,0.88) !important;
    }

    .spotter-cat[data-cat="summary"] .spotter-btn.active {
      border-color: rgba(255,43,43,0.78) !important;
    }

    .extras-section {
      padding: 8px 10px 10px;
      gap: 8px;
      background: rgba(2,6,23,0.82);
    }

    .precision-buttons {
      gap: 5px;
    }

    .precision-badge {
      padding: 6px 0;
      font-size: 10px;
      letter-spacing: 0.06em;
      border-radius: 12px;
      box-shadow: none !important;
    }

    .precision-badge.active {
      background: rgba(15,23,42,0.92) !important;
      border-color: rgba(255,122,24,0.88) !important;
      color: rgba(255,255,255,0.96) !important;
    }

    .toggle-row {
      padding: 8px 10px;
      border-radius: 12px;
    }

    .grid-button-row {
      gap: 6px;
    }

    .hint-text {
      display: none;
    }

    /* Small screens: 2 columns for buttons */
    @media (max-width: 420px) {
      .spotter-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

  
    .btn-secondary.off{opacity:0.65;filter:grayscale(0.2);}
  /* Race Director modes */
    .rd-mode-row{
      display:flex;
      gap:10px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .rd-mode{
      flex:1 1 110px;
      min-width:110px;
      text-transform:none;
      letter-spacing:.2px;
      opacity:.82;
    }
    .rd-mode.active{
      opacity:1;
      outline:2px solid rgba(255,255,255,.22);
      box-shadow: 0 0 0 2px rgba(0,0,0,.35) inset;
    }

    /* Botones activos con color fuerte (tipo VOZ ACTIVA) */
    .btn-secondary.active,
    .btn-pill.active,
    .spotter-btn.active,
    .rd-mode.active{
      opacity: 1 !important;
      filter: none !important;
      transform: translateY(-1px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      border-color: rgba(255,255,255,.22);
    }

    /* RD ON/OFF */
    #rdToggleBtn.active{ background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75)); color:#0b0f14; border-color: rgba(255,255,255,.18); }
    #rdToggleBtn:not(.active){ background: rgba(255,255,255,.06); color: rgba(255,255,255,.82); }

    /* Modos - colores por personalidad */
    #rdModeMinimal.active { background: linear-gradient(135deg, rgba(0,229,255,.95), rgba(0,140,255,.75)); color:#071018; }
    #rdModeStratega.active{ background: linear-gradient(135deg, rgba(255,215,0,.95), rgba(255,140,0,.80)); color:#101015; }
    #rdModeCoach.active   { background: linear-gradient(135deg, rgba(255,0,140,.92), rgba(160,80,255,.78)); color:#0b0f14; }

    /* Modos extra - colores por personalidad */
    #rdModeSarca.active    { background: linear-gradient(135deg, rgba(255,40,40,.95), rgba(255,140,0,.80)); color:#101015; }
    #rdModeEngineer.active { background: linear-gradient(135deg, rgba(34,197,94,.92), rgba(0,229,255,.75)); color:#071018; }
    #rdModeHype.active     { background: linear-gradient(135deg, rgba(160,80,255,.92), rgba(255,0,140,.78)); color:#0b0f14; }

    /* Auto Locutor - colores por estilo */
    #autoLocutorPro.active { background: linear-gradient(135deg, rgba(0,229,255,.95), rgba(0,140,255,.75)); color:#071018; }
    #autoLocutorPicante.active { background: linear-gradient(135deg, rgba(255,40,40,.95), rgba(255,140,0,.80)); color:#101015; }
    #autoLocutorEngineer.active { background: linear-gradient(135deg, rgba(34,197,94,.92), rgba(0,229,255,.75)); color:#071018; }
    #autoLocutorNarrativo.active { background: linear-gradient(135deg, rgba(255,0,229,.92), rgba(0,229,255,.65)); color:#071018; }

    /* Bot√≥n Leer resumen */
    #speakBtn.active{ background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,170,0,.70)); color:#0b0f14; }

    /* Desplegables */
    .select-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-top:10px;
      padding:10px 12px;
      background: rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
    }
    .select-label{
      font-weight:700;
      letter-spacing:.2px;
      color: rgba(255,255,255,.92);
    }
    select.spotter-select{
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
      border-radius:10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.95);
      font-weight:800;
      min-width: 180px;
      outline:none;
    }
    select.spotter-select:focus{
      border-color: rgba(0,229,255,.55);
      box-shadow: 0 0 0 3px rgba(0,229,255,.15);
    }
    #precisionSelect{ display:none !important; }

    /* Controles superiores - botones tipo "Activar voz" (compactos) */
    .controls-section .btn-secondary{
      padding: 7px 10px;
      font-size: 12px;
      letter-spacing: 0.06em;
    }
    .btn-hot{
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: var(--shadow-soft);
    }
    .btn-hot:hover{
      background: rgba(255,255,255,0.09);
    }

    /* Voz: OFF (naranja) / ON (verde) */
    .btn-voice{
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: var(--text-main);
      box-shadow: var(--shadow-strong);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .btn-voice.voice-on{
      background: linear-gradient(135deg, rgba(0,255,140,.92), rgba(0,170,90,.80));
      color:#06110c;
      box-shadow: var(--shadow-strong);
      border: 1px solid rgba(255,255,255,0.10);
    }

    /* Leer resumen: se ilumina al presionar */
    .btn-speak{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    .btn-speak.active{
      background: linear-gradient(135deg, rgba(255,70,70,.92), rgba(255,170,0,.75));
      color:#0b0f14;
      box-shadow: var(--shadow-strong);
    }

    /* RD: OFF (gris) / ON (naranja) */
    .btn-rd{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    .btn-rd.active{
      background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75));
      color:#0b0f14;
      box-shadow: var(--shadow-strong);
    }

    /* Modos: base discreta, activo con color por modo */
    .btn-mode{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    #rdModeMinimal.active { background: linear-gradient(135deg, rgba(0,229,255,.92), rgba(0,140,255,.75)); color:#071018; box-shadow: var(--shadow-strong); }
    #rdModeStratega.active{ background: linear-gradient(135deg, rgba(255,215,0,.95), rgba(255,140,0,.80)); color:#101015; box-shadow: var(--shadow-strong); }
    #rdModeCoach.active   { background: linear-gradient(135deg, rgba(255,0,140,.92), rgba(160,80,255,.78)); color:#0b0f14; box-shadow: var(--shadow-strong); }

    /* Mensajes del spotter - color por grupo */
    .spotter-cat[data-cat="essential"] .spotter-btn{ border-color: rgba(255,70,70,0.34); }
    .spotter-cat[data-cat="battle"]    .spotter-btn{ border-color: rgba(255,170,0,0.32); }
    .spotter-cat[data-cat="summary"]   .spotter-btn{ border-color: rgba(0,255,140,0.28); }

    /* === Mensajes del spotter: colores por secci√≥n + botones pintados al encender === */
    :root{
      --cat-ess: rgba(255,60,60,1);      /* rojo */
      --cat-bat: rgba(255,170,0,1);      /* √°mbar */
      --cat-res: rgba(0,220,120,1);      /* verde */
    }

    /* Bordes base por secci√≥n (apagado) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{ border-color: rgba(255,60,60,.55); }
    .spotter-cat[data-cat="battle"]     .spotter-btn{ border-color: rgba(255,170,0,.55); }
    .spotter-cat[data-cat="summary"]    .spotter-btn{ border-color: rgba(0,220,120,.55); }

    /* Texto base (apagado) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{ color: rgba(255,235,235,.92); }
    .spotter-cat[data-cat="battle"]     .spotter-btn{ color: rgba(255,245,225,.92); }
    .spotter-cat[data-cat="summary"]    .spotter-btn{ color: rgba(230,255,242,.92); }

    /* Encendido: pintado completo */
    .spotter-cat[data-cat="essentials"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,60,60,.95), rgba(255,110,60,.75));
      border-color: rgba(255,255,255,.14);
      color:#140606;
      box-shadow: var(--shadow-strong);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,170,0,.95), rgba(255,90,0,.75));
      border-color: rgba(255,255,255,.14);
      color:#141006;
      box-shadow: var(--shadow-strong);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(0,220,120,.92), rgba(0,170,90,.75));
      border-color: rgba(255,255,255,.14);
      color:#04110a;
      box-shadow: var(--shadow-strong);
    }

    /* LAPS siempre encendido: que se vea "bloqueado" pero pintado como su secci√≥n */
    .spotter-btn.locked{
      opacity: .95;
      cursor: default;
    }

    /* Match botones con su secci√≥n (apagado tambi√©n) */
    .spotter-cat[data-cat="essentials"] .spotter-btn{
      background: rgba(255,60,60,0.10);
      border-color: rgba(255,60,60,0.60);
      color: rgba(255,240,240,0.95);
    }
    .spotter-cat[data-cat="battle"] .spotter-btn{
      background: rgba(255,170,0,0.10);
      border-color: rgba(255,170,0,0.60);
      color: rgba(255,248,235,0.95);
    }
    .spotter-cat[data-cat="summary"] .spotter-btn{
      background: rgba(0,220,120,0.10);
      border-color: rgba(0,220,120,0.60);
      color: rgba(235,255,245,0.95);
    }

    /* Hover con m√°s presencia, sin cambiar de secci√≥n */
    .spotter-cat[data-cat="essentials"] .spotter-btn:hover{ background: rgba(255,60,60,0.14); }
    .spotter-cat[data-cat="battle"] .spotter-btn:hover{ background: rgba(255,170,0,0.14); }
    .spotter-cat[data-cat="summary"] .spotter-btn:hover{ background: rgba(0,220,120,0.14); }

    /* Cuando est√° locked (LAPS), que se vea firme */
    .spotter-btn.locked{
      outline: 2px solid rgba(255,255,255,0.06);
    }

    /* FIX: data-cat values (essential/battle/summary) + colores por secci√≥n */
    .spotter-cat[data-cat="essential"] .spotter-btn{
      background: rgba(255,60,60,0.10) !important;
      border-color: rgba(255,60,60,0.60) !important;
      color: rgba(255,240,240,0.95) !important;
    }
    .spotter-cat[data-cat="battle"] .spotter-btn{
      background: rgba(255,170,0,0.10) !important;
      border-color: rgba(255,170,0,0.60) !important;
      color: rgba(255,248,235,0.95) !important;
    }
    .spotter-cat[data-cat="summary"] .spotter-btn{
      background: rgba(0,220,120,0.10) !important;
      border-color: rgba(0,220,120,0.60) !important;
      color: rgba(235,255,245,0.95) !important;
    }

    .spotter-cat[data-cat="essential"] .spotter-btn:hover{ background: rgba(255,60,60,0.14) !important; }
    .spotter-cat[data-cat="battle"] .spotter-btn:hover{ background: rgba(255,170,0,0.14) !important; }
    .spotter-cat[data-cat="summary"] .spotter-btn:hover{ background: rgba(0,220,120,0.14) !important; }

    /* Encendido pintado por secci√≥n (corrige essential) */
    .spotter-cat[data-cat="essential"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,60,60,.95), rgba(255,110,60,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#140606 !important;
      box-shadow: var(--shadow-strong) !important;
    }
    .spotter-cat[data-cat="battle"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(255,170,0,.95), rgba(255,90,0,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#141006 !important;
      box-shadow: var(--shadow-strong) !important;
    }
    .spotter-cat[data-cat="summary"] .spotter-btn.active{
      background: linear-gradient(135deg, rgba(0,220,120,.92), rgba(0,170,90,.75)) !important;
      border-color: rgba(255,255,255,.14) !important;
      color:#04110a !important;
      box-shadow: var(--shadow-strong) !important;
    }

    /* Precisi√≥n - botones como el resto (compactos y con "ON" pintado) */
    .precision-badge{
      padding: 7px 10px !important;
      font-size: 12px !important;
      letter-spacing: 0.06em !important;
      border-radius: 12px !important;
      background: rgba(255,255,255,0.07) !important;
      border: 1px solid rgba(255,255,255,0.14) !important;
      color: rgba(255,255,255,0.92) !important;
      box-shadow: var(--shadow-soft) !important;
      min-width: 108px;
    }
    .precision-badge:hover{
      background: rgba(255,255,255,0.10) !important;
    }
    .precision-badge.active{
      background: linear-gradient(135deg, rgba(255,140,0,.95), rgba(255,60,0,.75)) !important;
      color: #0b0f14 !important;
      border-color: rgba(255,255,255,0.14) !important;
      box-shadow: var(--shadow-strong) !important;
    }

    .app-header{ position: relative; overflow:hidden; }
    .app-header::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      border-radius: inherit;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    .app-header::after{
      content:"";
      position:absolute;
      left:0; right:0; top:0;
      height:2px;
      background: linear-gradient(90deg, rgba(255,40,40,0.0), rgba(255,40,40,0.55), rgba(255,140,0,0.55), rgba(255,140,0,0.0));
      opacity:.75;
      pointer-events:none;
    }

    /* Header layout - t√≠tulo manda */
    .header-left{ gap: 3px; }
    .header-title-main{
      font-size: 20px;
      letter-spacing: 0.06em;
      line-height: 1.12;
      gap: 10px;
      align-items: baseline;
    }
    #raceTitleText{
      display:inline-block;
      white-space: pre-line;
      word-break: break-word;
    }
    .badge-mode{
      font-size: 10px;
      padding: 3px 9px;
      letter-spacing: 0.08em;
    }
    .header-title-sub{
      font-size: 11px;
      letter-spacing: 0.08em;
      opacity: .95;
    }
    .header-subline{
      font-size: 10px;
      color: rgba(255,255,255,0.86);
    }
    .header-mini{
      font-size: 9px;
      opacity: .9;
    }
    .header-right{ gap: 2px; }
    .badge-live{
      padding: 4px 10px;
      font-size: 11px;
    }
    .header-version{
      font-size: 9px;
      opacity: .85;
    }

    /* Timing colors (F1 style) */
    .timing-value.lap-purple{ color: rgb(192,132,252); }
    .timing-value.lap-green{  color: rgb(34,197,94); }
    .timing-value.lap-yellow{ color: rgb(251,191,36); }
    .timing-value.lap-neutral{ color: rgba(255,255,255,0.92); }
    .timing-value.lap-avg{ color: rgba(186,230,253,0.92); }

    /* √öLTIMA m√°s grande */
    #lastLap{
      font-size: 18px;
      font-weight: 800;
      letter-spacing: 0.02em;
    }

    /* Flash solo en la √∫ltima vuelta (pop) - con glow por color */
    #lastLap.flash{ transform: scale(1.28); }
    #lastLap.flash.lap-purple{ text-shadow: 0 0 14px rgba(192,132,252,0.85); }
    #lastLap.flash.lap-green{  text-shadow: 0 0 14px rgba(34,197,94,0.85); }
    #lastLap.flash.lap-yellow{ text-shadow: 0 0 14px rgba(251,191,36,0.85); }
    #lastLap.flash.lap-neutral{ text-shadow: 0 0 12px rgba(255,255,255,0.25); }

    /* Timing KPI sizes */
    #lastLap{ font-size: 22px; letter-spacing: 0.02em; }
    #bestLap, #meanLap{ font-size: 18px; letter-spacing: 0.01em; }
    /* Pop m√°s evidente en √öLTIMA */
    #lastLap.flash{ transform: scale(1.28); text-shadow: 0 0 14px rgba(255,90,0,0.35); }

    /* RD modos - permitir wrap en pantallas chicas */
    .rd-mode-row{ flex-wrap: wrap; }


    /* PATCH v5.0.0 - RD ON verde + consistencia UI */
    #rdToggleBtn.active{
      background: linear-gradient(135deg, #16a34a, #22c55e) !important;
      color: #07120a !important;
      border-color: rgba(34,197,94,.55) !important;
      box-shadow: 0 0 12px rgba(34,197,94,.85) !important;
    }
    #rdToggleBtn.off{
      background: rgba(255,255,255,.06) !important;
      color: rgba(255,255,255,.82) !important;
      box-shadow: none !important;
    }


    /* Manual - modal ayuda (single-file friendly) */
    .header-help{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      padding: 4px 10px;
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      font-size: 10px;
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      user-select: none;
    }
    .header-help:hover{ filter: brightness(1.15); }
    .header-help:active{ transform: translateY(1px); }

    .manual-backdrop{
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .manual-backdrop.open{ display:flex; }
    .manual-panel{
      width: min(980px, 100%);
      max-height: 92vh;
      overflow: auto;
      border-radius: 18px;
      border: 1px solid rgba(249,115,22,0.55);
      background: linear-gradient(145deg, rgba(15,23,42,0.98), rgba(3,7,18,0.98));
      box-shadow: 0 0 0 1px rgba(0,0,0,0.65), 0 20px 60px rgba(0,0,0,0.65);
      padding: 14px;
    }
    .manual-top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .manual-title{
      font-size: 16px;
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .manual-sub{
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    .manual-close{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
      border-radius: 12px;
      padding: 6px 10px;
      font-weight: 900;
      cursor: pointer;
    }
    .manual-close:hover{ filter: brightness(1.15); }
    .manual-grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    
    /* Manual table */
    .manual-wide{ grid-column: 1 / -1; }
    .manual-table-wrap{ overflow-x: auto; border:1px solid rgba(255,255,255,.08); border-radius:12px; }
    .manual-table{ width:100%; border-collapse: collapse; min-width: 860px; }
    .manual-table th, .manual-table td{ text-align:left; padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.07); vertical-align: top; }
    .manual-table th{ font-weight:800; opacity:.95; }
    .manual-table td code{ background: rgba(0,0,0,.35); padding:1px 6px; border-radius:8px; }
    .manual-tip{ margin-top:10px; opacity:.92; font-size:13px; }
@media (max-width: 860px){
      .manual-grid{ grid-template-columns: 1fr; }
    }
    .manual-card{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 10px;
    }
    .manual-card h3{
      margin: 0 0 6px 0;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .manual-card ul{
      margin: 0;
      padding-left: 18px;
      color: rgba(255,255,255,0.88);
      font-size: 12px;
      line-height: 1.35;
    }
    .manual-shot{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.25);
      overflow: hidden;
    }
        .manual-shot figcaption{
      padding: 10px 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.8);
      border-top: 1px solid rgba(255,255,255,0.08);
    }
.manual-shot img{
      display:block;
      width:100%;
      height:auto;
    }
    .manual-shot figcaption{
      padding: 8px 10px;
      font-size: 11px;
      color: var(--text-muted);
    }
    
    
    /* Manual: solo una pesta√±a visible (Pilotos) */
    .manual-tab{ display:none; }
    .manual-tab.active{ display:block; }

    /* ===== HUD badge button ===== */
    .hud-badge-btn{
      cursor:pointer;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-weight: 950;
    }
    .hud-badge-btn:active{ transform: translateY(1px); }

.manual-foot{
      margin-top: 10px;
      font-size: 11px;
      color: var(--text-muted);
    }


    /* MANGA UX: flash verde en contenedor del piloto seguido */
    .pilot-card.flash-green{
      border-color: #2eea7a !important;
      box-shadow: 0 0 0 2px rgba(46,234,122,.25), 0 0 18px rgba(46,234,122,.22) !important;
    }
    .pilot-card.flash-green .pilot-card-top-strip{
      background: linear-gradient(90deg, rgba(46,234,122,.9), rgba(46,234,122,.15)) !important;
    }
    
    .timing-item.timer-only{ display:none; }

    /* MANGA reloj (mismo feeling que badges) */
    .manga-clock{
      --clock-hue: 120;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.06em;
      border: 1px solid hsla(var(--clock-hue), 95%, 60%, .55);
      color: hsl(var(--clock-hue), 95%, 62%);
      background: hsla(var(--clock-hue), 95%, 20%, .18);
      box-shadow: 0 0 0 2px hsla(var(--clock-hue), 95%, 55%, .12), 0 0 18px hsla(var(--clock-hue), 95%, 55%, .12);
      font-variant-numeric: tabular-nums;
    }

    /* Pilot-timings: manga-clock se muestra como timing normal */
    .pilot-timings .manga-clock{ font-size: inherit; font-weight: inherit; }

.manga-clock.flash{
      animation: clockFlash .35s ease-in-out 0s 2;
    }

    @keyframes clockFlash{
      0%{ transform: scale(1); filter:none; }
      50%{ transform: scale(1.12); filter: drop-shadow(0 0 10px rgba(46,234,122,.55)); }
      100%{ transform: scale(1); filter:none; }
    }


    /* Manual button - m√°s visible */
    #manualBtn{
      background: linear-gradient(135deg, rgba(34,197,94,.22), rgba(0,229,255,.18));
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 8px 22px rgba(0,0,0,.32);
    }
    #manualBtn:hover{ filter: brightness(1.06); }
    #manualBtn:active{ transform: translateY(1px); }

    

/* ===== Q TABLA (Clasificaci√≥n) ===== */
/* Q TABLA - compacto y acorde al layout */
#qualiBackdrop .manual-panel{
  width: min(880px, 100%);
  padding: 10px;
  border-radius: 16px;
}
#qualiBackdrop .manual-title{ font-size: 15px; }
#qualiBackdrop .manual-sub{ font-size: 10.5px; }

#qualiBackdrop .qmeta{ gap:6px; margin: 0 0 8px 0; }
#qualiBackdrop .qchip{ padding: 5px 9px; font-size: 11px; }
#qualiBackdrop .qsel{ padding: 5px 7px; font-size: 11px; }

#qualiBackdrop .qtable-wrap{
  max-height: 52vh;
  border-radius: 12px;
}
#qualiBackdrop .qtable{
  font-size: 11.5px;
}
#qualiBackdrop .qtable th{
  padding: 8px 8px;
  font-size: 11px;
}
#qualiBackdrop .qtable td{
  padding: 7px 8px;
}
#qualiBackdrop .qtable tbody tr:nth-child(even) td{
  background: rgba(255,255,255,0.015);
}
#qualiBackdrop .qcol-pos{ width: 46px; }
#qualiBackdrop .qcol-q{ width: 56px; }
#qualiBackdrop .qcol-laps{ width: 82px; }
#qualiBackdrop .qcol-time{ width: 128px; }

/* Q TABLA - estilo pro tipo "timing sheet" */
#qualiBackdrop .qtable-wrap{ overflow:auto; max-height: 60vh; }
#qualiBackdrop .qtable{ font-size: 11px; min-width: 720px; border-collapse: separate; border-spacing: 0; }
#qualiBackdrop .qtable th, #qualiBackdrop .qtable td{ padding: 6px 7px; vertical-align: top; }
#qualiBackdrop .qtable th{
  position: sticky;
  top: 0;
  z-index: 2;
  background: rgba(8,10,15,0.96);
  backdrop-filter: blur(6px);
  border-bottom: 1px solid rgba(148,163,184,0.18);
}
#qualiBackdrop .qmain{ white-space: nowrap; }
#qualiBackdrop .qtag{
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 2px 7px;
  border-radius: 999px;
  font-size: 10px;
  font-weight: 900;
  letter-spacing: .3px;
  border: 1px solid rgba(255,122,24,0.35);
  background: rgba(255,122,24,0.10);
  color: rgba(242,245,255,0.95);
  margin-bottom: 3px;
}
#qualiBackdrop .qbest{
  margin-top: 2px;
  font-size: 10px;
  font-weight: 800;
  color: rgba(255, 45, 255, 0.92);
}
#qualiBackdrop td.qcell-best{
  background: rgba(0, 255, 160, 0.07);
  box-shadow: inset 2px 0 0 rgba(0,255,160,0.55);
}
#qualiBackdrop td.qcell-empty{
  color: rgba(163,173,189,0.65);
}


/* Q TABLA - highlights */
#qualiBackdrop .qtable tbody tr.qrow-selected td{
  background: rgba(0,229,255,0.06) !important;
  box-shadow: inset 2px 0 0 rgba(0,229,255,0.55);
}
#qualiBackdrop .qtable tbody tr.qrow-autoP1 td{
  background: rgba(255,215,0,0.055) !important;
  box-shadow: inset 0 0 0 1px rgba(255,215,0,0.35), inset 2px 0 0 rgba(255,215,0,0.55);
}


#qualiBtn{
  position: relative;
  z-index: 50;
  pointer-events: auto;
  margin-left: 8px;
  padding: 8px 10px;
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.22);
  background: rgba(0,0,0,0.18);
  color: var(--text-main);
  font-weight: 800;
  font-size: 12px;
  letter-spacing: .4px;
  cursor: pointer;
}
#qualiBtn:hover{ filter: brightness(1.06); }
#qualiBtn:active{ transform: translateY(1px); }

.qmeta{ display:flex; flex-wrap:wrap; gap:8px; margin: 2px 0 10px 0; }
.qchip{
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.22);
  background: rgba(0,0,0,0.18);
  color: var(--text-main);
  font-size: 12px;
  font-weight: 700;
}
.qchip b{ font-weight: 900; }
.qsel{
  margin-left:6px;
  padding: 6px 8px;
  border-radius: 10px;
  border: 1px solid rgba(148,163,184,0.24);
  background: rgba(0,0,0,0.18);
  color: var(--text-main);
  font-size: 12px;
  font-weight: 800;
  outline: none;
}
.qsel option{ background: #0b1220; color: #e2e8f0; }
.qtable-wrap{
  max-height: 55vh;
  overflow:auto;
  border-radius: 14px;
  border: 1px solid rgba(148,163,184,0.18);
  background: rgba(2,6,23,0.35);
}
.qtable{
  width:100%;
  border-collapse: collapse;
  font-size: 12px;
}
.qtable th{
  position: sticky;
  top: 0;
  z-index: 2;
  text-align:left;
  padding: 10px 10px;
  background: rgba(2,6,23,0.92);
  border-bottom: 1px solid rgba(148,163,184,0.20);
  color: var(--text-main);
  font-weight: 900;
  letter-spacing: .3px;
}
.qtable td{
  padding: 9px 10px;
  border-bottom: 1px solid rgba(148,163,184,0.12);
  color: var(--text-main);
}
.qtable tr:hover td{ background: rgba(255,255,255,0.03); }
.qcol-pos{ width: 52px; }
.qcol-q{ width: 52px; }
.qcol-num{ width: 70px; }
.qcol-laps{ width: 90px; }
.qcol-time{ width: 140px; }

/* Master toggle */
    .spotter-master{
      padding: 8px 10px 2px 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .spotter-master-btn{
      flex: 1 1 120px;
      width: auto;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.90);
      font-weight: 800;
      letter-spacing: .4px;
      cursor: pointer;
      user-select: none;
    }
    .spotter-master-btn.preset{
      background: rgba(255,255,255,.05);
    }
    .spotter-master-btn.active{
      background: linear-gradient(135deg, rgba(251,191,36,.92), rgba(249,115,22,.75));
      color: rgba(10,14,18,.92);
      border-color: rgba(255,255,255,.20);
    }

    /* Top3 mini grid - anim y flash */
    .top3-mini-row{ will-change: transform; }
    .top3-mini-row.lap-flash{
      background: rgba(34,197,94,.22);
      box-shadow: 0 0 0 1px rgba(34,197,94,.35) inset, 0 10px 24px rgba(0,0,0,.28);
    }


    /* =========================
       TIMING MINI GRID - layout fix (v6.5)
       Alineaci√≥n tipo timing screen: columnas fijas, 1 columna en Top20, lapeados cortos.
       ========================= */

    .tgrid-main{
      width: 100%;
      display: grid;
      grid-template-columns: 40px 1fr 176px 46px;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .tgrid-namewrap{ min-width: 0; }
    .tgrid-name{ max-width: none; }

    .tgrid-sub{
      display: grid;
      grid-template-columns: 34px 92px 92px 66px;
      gap: 10px;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
    }
    .tgrid-sub .tgrid-col{
      min-width: 0 !important;
    }
    .tgrid-col{ justify-content: flex-end; }
    .tgrid-col.v{ justify-content: flex-start; text-align: left; }

    .tgrid-intblock{
      justify-self: end;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
      min-width: 176px;
    }

    .top3-mini-row.compact .tgrid-intblock{
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }
    .top3-mini-row.compact .tgrid-bar{ width: 34px; margin-left: 6px; }

    .tgrid-int{ min-width: 88px; text-align: right; }

    .tgrid-numbox{
      justify-self: end;
      min-width: 38px;
      padding: 0 10px;
    }



    /* iPhone / pantallas angostas - FIX nombre vertical en Grid Completo */
    @media (max-width: 430px){
      /* Dar mas aire al nombre y recortar con ellipsis (no letras en columna) */
      .tgrid-main{
        grid-template-columns: 38px minmax(140px, 1fr) minmax(92px, 34vw) 44px;
        gap: 8px;
      }
      .tgrid-name{
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        word-break: normal;
      }
      .tgrid-int{ min-width: 58px; }
    }


    /* === Mini Grid v2 (TOP 3 / TOP 20) - clean table style === */
    .btn-mini{
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(2,6,23,0.30);
      color: rgba(226,232,240,0.92);
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      line-height: 1;
      user-select: none;
    }
    .btn-mini:hover{ filter: brightness(1.10); }
    .btn-mini:active{ transform: translateY(1px); }

    .lap-chart-header{ display:block; }
    .lap-chart-header-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 8px;
    }
    .lap-chart-meta{ margin-top: 4px; }

    .top3-mini-grid{
      margin-top: 8px !important;
      display:block !important;
      border-radius: 14px;
      overflow:hidden;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(2,6,23,0.22);
    }
    .tgrid-head,
    .tgrid-row{
      display:grid;
      grid-template-columns: 38px 1fr 52px 76px 76px 64px;
      gap: 6px;
      align-items:center;
      padding: 7px 10px;
    }
    .tgrid-head{
      background: rgba(15,23,42,0.55);
      border-bottom: 1px solid rgba(148,163,184,0.16);
      font-size: 10px;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.75);
      font-weight: 900;
    }
    .tgrid-row{
      font-size: 12px;
      border-top: 1px solid rgba(148,163,184,0.10);
    }
    .tgrid-row.pos1{ background: rgba(251,191,36,0.08); }
    .tgrid-row.pos2{ background: rgba(255,255,255,0.06); }
    .tgrid-row.pos3{ background: rgba(249,115,22,0.08); }

    .tgrid-cell{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .tgrid-pos{
      width: 34px;
      text-align:center;
      border-radius: 999px;
      padding: 4px 0;
      font-weight: 950;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(148,163,184,0.08);
      color: rgba(226,232,240,0.92);
    }
    .tgrid-name{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width:0;
    }
    .tgrid-num{
      opacity: 0.70;
      font-weight: 800;
      font-size: 11px;
    }
    .tgrid-driver{
      min-width:0;
      font-weight: 900;
    }
    .tgrid-mono{
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      text-align:right;
    }
    @media (max-width: 420px){
      .tgrid-head,
      .tgrid-row{
        grid-template-columns: 34px 1fr 48px 68px 68px 58px;
        padding: 7px 8px;
      }
      .tgrid-row{ font-size: 11px; }
    }


    /* Mini timing screen (Top3/Top20) - Opci√≥n A */
    .top3-mini-grid{ width: 100%; }
    .top3-mini-grid.expanded{ max-height: none; overflow: visible; }
    .top3-mini-grid .mini-timing{
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    .top3-mini-grid .mini-timing thead th{
      position: sticky;
      top: 0;
      z-index: 2;
      background: rgba(10,15,25,0.96);
      color: rgba(226,232,240,0.92);
      font-size: 12px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      border-bottom: 1px solid rgba(148,163,184,0.20);
      padding: 6px 8px;
    }
    .top3-mini-grid .mini-timing tbody td{
      border-bottom: 1px solid rgba(148,163,184,0.10);
      padding: 4px 6px;
      font-size: 12px;
      color: rgba(226,232,240,0.92);
      vertical-align: middle;
    }
    .top3-mini-grid .mini-timing tbody tr.pos1{ background: rgba(251,191,36,0.08); }
    .top3-mini-grid .mini-timing tbody tr.pos2{ background: rgba(255,255,255,0.05); }
    .top3-mini-grid .mini-timing tbody tr.pos3{ background: rgba(249,115,22,0.07); }
    .top3-mini-grid .mini-timing tbody tr:hover{ background: rgba(45,107,255,0.08); }
    .top3-mini-grid .mini-timing tbody tr.pos1 .mt-p{ color: rgba(251,191,36,0.95); font-weight: 900; }
    .top3-mini-grid .mini-timing tbody tr.pos2 .mt-p{ color: rgba(203,213,225,0.95); font-weight: 900; }
    .top3-mini-grid .mini-timing tbody tr.pos3 .mt-p{ color: rgba(205,127,50,0.95); font-weight: 900; }

    .top3-mini-grid .mt-pos{ width: 30px; }
    .top3-mini-grid .mt-laps{ width: 36px; }
    .top3-mini-grid .mt-last{ width: 76px; }
    .top3-mini-grid .mt-gap{ width: 66px; }
    .top3-mini-grid .mt-st{ width: 56px; text-align: right; }

    .top3-mini-grid .mt-name{ width: auto; }
    .top3-mini-grid .mt-driver{
      display: block;
      max-width: 100%;
      white-space: normal;
      line-height: 1.08;
    }
    .top3-mini-grid .mt-line{
      display: block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .top3-mini-grid .mt-num{
      display: inline-block;
      margin-left: 6px;
      font-size: 11px;
      opacity: 0.85;
    }
    .top3-mini-grid .mt-mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-variant-numeric: tabular-nums;
      text-align: right;
    }
    .top3-mini-grid .mt-p{
      display: inline-flex;
      min-width: 22px;
      justify-content: center;
      font-weight: 900;
    }
    .top3-mini-grid .mt-badge{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 44px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 900;
      letter-spacing: 0.05em;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(148,163,184,0.10);
      color: rgba(226,232,240,0.95);
    }
    .top3-mini-grid .mt-atk{ border-color: rgba(255,122,24,0.55); background: rgba(255,122,24,0.12); }
    .top3-mini-grid .mt-def{ border-color: rgba(255,43,43,0.55); background: rgba(255,43,43,0.12); }
    .top3-mini-grid .mt-duel{ border-color: rgba(45,107,255,0.45); background: rgba(45,107,255,0.12); }


    /* ===== Configuraci√≥n activa + Presets por sesi√≥n ===== */
    /* ===== UI Mode BASIC/PRO ===== */
    body[data-ui-mode="BASIC"]:not(.show-advanced) .mode-pro-only{ display:none !important; }
    body[data-ui-mode="PRO"] .mode-basic-only{ display:none !important; }

    /* ===== Control Strip (BASIC/PRO + Voz) ===== */
    .control-strip{
      display:flex;
      align-items: stretch;
      gap:10px;
      margin: 10px 0 6px;
      flex-wrap: wrap;
    }
    .cbtn{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-weight: 900;
      letter-spacing: 0.06em;
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 12px;
      min-height: 44px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.18);
      text-transform: uppercase;
    }
    .cbtn:active{ transform: translateY(1px) scale(0.995); }
    .cbtn-voice{
      flex: 1 1 200px;
      justify-content: space-between;
      padding-left: 14px;
      padding-right: 14px;
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      border-color: rgba(255,255,255,0.14);
    }
    .cbtn-ic{ font-size: 16px; }
    .cbtn-txt{ font-size: 12px; }
    .cbtn-sub{
      font-size: 11px;
      font-weight: 950;
      letter-spacing: 0.10em;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.26);
    }
    .cbtn-voice[data-voice="on"] .cbtn-sub{
      background: rgba(0,0,0,0.18);
      border-color: rgba(0,255,163,0.35);
    }

    .segmented{
      flex: 0 0 auto;
      display:flex;
      align-items: stretch;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.30);
      overflow:hidden;
      min-height: 44px;
    }
    .seg-btn{
      padding: 10px 14px;
      border: none;
      background: transparent;
      color: rgba(255,255,255,0.86);
      font-weight: 950;
      letter-spacing: 0.10em;
      cursor: pointer;
      min-width: 92px;
      text-transform: uppercase;
    }
    .seg-btn + .seg-btn{
      border-left: 1px solid rgba(255,255,255,0.10);
    }
    .seg-btn.active{
      background: rgba(255,166,0,0.14);
      color: rgba(255,255,255,0.98);
    }
    body[data-ui-mode="PRO"] .seg-btn.active{
      background: rgba(0,255,163,0.14);
    }

    .cbtn-rd, .cbtn-speak{
      flex: 0 0 auto;
      padding: 10px 12px;
      min-width: 120px;
    }

    .strip-hint{
      font-size: 12px;
      color: rgba(226,232,240,0.86);
      opacity: 0.95;
      margin: 0 0 6px;
    }

    .basic-quick{
      margin: 8px 0 10px;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.03));
      box-shadow: 0 10px 22px rgba(0,0,0,0.24);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .basic-quick-title{
      font-weight: 950;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(255,255,255,0.92);
    }
    .basic-toggles{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
      flex: 1 1 240px;
    }
    .basic-toggle{
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      text-align:center;
      font-size: 12px;
      min-height: 38px;
      min-width: 92px;
    }
    
        /* BASIC panel: show/hide toggles by narration mode */
    body[data-ui-mode="BASIC"] .basic-toggle.mode-tv{
      display:none;
    }
    body[data-narr-mode="TV"] .basic-toggle.mode-tv{
      display:inline-flex;
    }
.basic-toggle.active{
      border-color: rgba(0, 255, 163, 0.45);
      background: rgba(0, 255, 163, 0.12);
    }
    .basic-toggle.lock{
      border-color: rgba(255, 166, 0, 0.55);
      background: rgba(255, 166, 0, 0.12);
    }

    @media (max-width: 520px){
      .cbtn-rd, .cbtn-speak{ min-width: 110px; }
      .seg-btn{ min-width: 84px; }
      .basic-toggle{ min-width: 88px; }
    }

    .ui-mode-switch{
      display:flex;
      gap:10px;
      margin: 10px 0 10px;
    }
    .ui-mode-btn{
      flex:1;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-weight: 900;
      letter-spacing: 0.3px;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(0,0,0,0.18);
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    .ui-mode-btn:active{ transform: scale(0.99); }
    .ui-mode-btn.active{
      border-color: rgba(255, 166, 0, 0.55);
      background: rgba(255, 122, 24, 0.18);
    }
    .ui-mode-hint{
      font-size: 11px;
      opacity: 0.75;
      font-weight: 700;
      margin-top: -2px;
      margin-bottom: 8px;
    }

    .basic-panel{
      margin: 10px 0 12px;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.03));
      box-shadow: 0 10px 22px rgba(0,0,0,0.24);
    }
    .basic-panel-title{
      font-weight: 950;
      letter-spacing: 0.3px;
      font-size: 13px;
      margin-bottom: 2px;
    }
    .basic-panel-sub{
      font-size: 11px;
      opacity: 0.78;
      font-weight: 700;
      margin-bottom: 10px;
    }
    .basic-toggles{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .basic-toggle{
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      text-align:center;
      box-shadow: 0 10px 18px rgba(0,0,0,0.18);
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    .basic-toggle:active{ transform: scale(0.99); }
    .basic-toggle.active{
      border-color: rgba(0, 255, 163, 0.45);
      background: rgba(0, 255, 163, 0.12);
    }
    .basic-toggle.lock{
      border-color: rgba(255, 166, 0, 0.55);
      background: rgba(255, 166, 0, 0.12);
    }
    
    .config-status-card{
      margin: 10px 0 14px;
      padding: 12px 12px 10px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 10px 22px rgba(0,0,0,0.25);
    }
    .config-status-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .config-status-title{
      font-weight: 800;
      letter-spacing: 0.4px;
      font-size: 13px;
      opacity: 0.96;
    }
    .config-status-badges{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
    .cfg-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 5px 8px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 800;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
    }
    .cfg-pill-session{border-color: rgba(0, 255, 163, 0.25);}
    .cfg-pill-auto{border-color: rgba(255, 166, 0, 0.30);}
    .config-status-line{
      font-size: 12px;
      opacity: 0.95;
      display:flex;
      flex-wrap:wrap;
      gap:6px 8px;
      align-items:center;
    }
    .cfg-label{opacity:0.70; font-weight:700;}
    .cfg-value{font-weight:900;}
    .cfg-sep{opacity:0.35; padding: 0 4px;}
    .session-presets{margin-top:10px;}
    .session-presets-header{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;}
    .session-presets-title{font-size: 12px; font-weight: 900; opacity:0.9;}
    .session-presets-note{font-size: 11px; opacity:0.65; font-weight:700;}
    .session-preset-grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 10px;
    }
    .session-preset-card{
      text-align:left;
      padding: 10px 10px 8px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.28);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      min-height: 108px;
    }
    .session-preset-card:hover{transform: translateY(-1px); border-color: rgba(255,255,255,0.18);}
    .session-preset-card.active{
      border-color: rgba(255, 166, 0, 0.55);
      background: rgba(255, 166, 0, 0.10);
      box-shadow: 0 10px 18px rgba(0,0,0,0.25);
    }
    .spc-head{display:flex; justify-content:space-between; align-items:center; gap:8px;}
    .spc-name{font-size:12px; font-weight:900;}
    .spc-tag{
      font-size: 10px;
      font-weight: 900;
      opacity:0.75;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .spc-sub{font-size: 10.5px; opacity:0.70; margin-top:4px; line-height:1.2;}
    .spc-toggles, .session-now-toggles{
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
      margin-top: 8px;
    }
    .toggle-pill{
      font-size: 10px;
      font-weight: 900;
      padding: 4px 7px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      opacity: 0.55;
    }
    .toggle-pill.on{
      opacity: 0.95;
      border-color: rgba(0, 255, 163, 0.28);
      background: rgba(0, 255, 163, 0.12);
    }
    .toggle-pill.off{
      opacity: 0.35;
      border-style: dashed;
    }
    .session-now{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed rgba(255,255,255,0.12);
    }
    .session-now-title{
      font-size: 11px;
      font-weight: 900;
      opacity: 0.80;
      margin-bottom: 6px;
    }
    @media (max-width: 520px){
      .session-preset-grid{grid-template-columns: 1fr;}
      .session-preset-card{min-height: auto;}
    }

    /* ===== UI Clarity Patch (Config + Presets) ===== */
    .config-status-card{
      background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.35));
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow: 0 14px 28px rgba(0,0,0,0.35);
    }
    .config-status-title{
      font-size: 15px;
      opacity: 1;
      letter-spacing: 0.2px;
    }
    .config-status-line{
      font-size: 13px;
      opacity: 1;
      gap: 8px 10px;
      line-height: 1.25;
    }
    .cfg-label{opacity:0.85;}
    .cfg-value{font-weight: 950;}
    .cfg-pill{
      padding: 6px 10px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.55);
    }
    .cfg-pill-session{border-color: rgba(0,255,163,0.45);}
    .cfg-pill-auto{border-color: rgba(255,166,0,0.55);}

    .session-presets-title{font-size: 13px; opacity: 1;}
    .session-presets-note{font-size: 12px; opacity: 0.85;}

    /* Make cards readable on phone (1 column), tablet (2), desktop (3) */
    .session-preset-grid{gap: 12px;}
    @media (max-width: 860px){
      .session-preset-grid{grid-template-columns: repeat(2, minmax(0,1fr));}
    }
    @media (max-width: 560px){
      .session-preset-grid{grid-template-columns: 1fr;}
    }

    .session-preset-card{
      padding: 12px 12px 10px;
      min-height: unset;
      background: rgba(0,0,0,0.42);
      border: 1px solid rgba(255,255,255,0.14);
    }
    .session-preset-card.active{
      border-color: rgba(255,166,0,0.75);
      background: rgba(255,166,0,0.14);
      box-shadow: 0 16px 26px rgba(0,0,0,0.35);
    }
    .spc-name{font-size: 13px;}
    .spc-sub{font-size: 12px; opacity: 0.88;}
    .spc-tag{
      font-size: 11px;
      opacity: 0.92;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
    }

    .toggle-pill{
      font-size: 12px;
      padding: 5px 10px;
      border-width: 1px;
      opacity: 1;
      line-height: 1;
    }
    .toggle-pill.on{
      border-color: rgba(0,255,163,0.55);
      background: rgba(0,255,163,0.16);
      box-shadow: inset 0 0 0 1px rgba(0,255,163,0.14);
    }
    .toggle-pill.off{
      opacity: 0.72;
      border-style: dashed;
      background: rgba(255,255,255,0.04);
      border-color: rgba(148,163,184,0.28);
    }

    .session-now-title{font-size: 12px; opacity: 0.95;}
    .session-now-toggles{gap: 8px; padding-top: 6px;}
    .session-now-toggles .toggle-pill{font-size: 12px; padding: 5px 10px;}

  
    /* =========================
       HUD v2 (sin pills, m√°s claro)
       ========================= */
    .config-status-card.hud{
      padding: 12px 12px 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.40);
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
    }
    .config-status-card.hud .hud-top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .config-status-card.hud .hud-title{
      font-size: 16px;
      font-weight: 900;
      letter-spacing: .2px;
    }
    .config-status-card.hud .hud-badges{
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
      justify-content:flex-end;
    }
    .config-status-card.hud .hud-badge{
      display:inline-flex;
      align-items:center;
      padding: 5px 9px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 900;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      white-space:nowrap;
    }
    .config-status-card.hud .hud-badge-session{ border-color: rgba(0,255,163,0.26); }
    .config-status-card.hud .hud-badge-preset{ border-color: rgba(255,255,255,0.18); }
    .config-status-card.hud .hud-badge-auto{ border-color: rgba(255,166,0,0.30); }

    .config-status-card.hud .hud-kpis{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap: 8px;
      margin-bottom: 10px;
    }
    .config-status-card.hud .hud-kpi{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.28);
      border-radius: 12px;
      padding: 8px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .config-status-card.hud .hud-kpi span{ font-size: 12px; opacity: .85; font-weight: 800; }
    .config-status-card.hud .hud-kpi b{ font-size: 12px; font-weight: 950; letter-spacing: .3px; }

    .config-status-card.hud .hud-presets-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin: 2px 0 8px;
    }
    .config-status-card.hud .hud-presets-title{
      font-size: 13px;
      font-weight: 900;
      opacity: .95;
    }
    .config-status-card.hud .hud-presets-note{
      font-size: 12px;
      opacity: .80;
    }

        .config-status-card.hud .hud-seg{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 6px;
      margin-bottom: 10px;
    }
    /* Botones de preset: compactos, con texto visible y highlight cuando activo */
    .config-status-card.hud .session-preset-card.hud-seg-btn{
      text-align:left;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: rgba(255,255,255,0.92);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease, box-shadow .12s ease;
      min-height: 52px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap: 2px;
    }
    .config-status-card.hud .session-preset-card.hud-seg-btn:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,0.26);
      background: rgba(255,255,255,0.06);
    }
    .config-status-card.hud .session-preset-card.hud-seg-btn.active{
      border-color: rgba(255,166,0,0.70);
      background: linear-gradient(180deg, rgba(255,166,0,0.26), rgba(255,166,0,0.10));
      box-shadow: 0 10px 18px rgba(0,0,0,0.28), 0 0 0 1px rgba(255,166,0,0.20) inset;
    }
    .config-status-card.hud .session-preset-card.hud-seg-btn.active .hud-seg-name{
      color: rgba(255,255,255,0.98);
    }
    .config-status-card.hud .hud-seg-name{
      font-size: 12px;
      font-weight: 950;
      letter-spacing: .2px;
      line-height: 1.05;
    }
    .config-status-card.hud .hud-seg-meta{
      font-size: 10px;
      opacity: .82;
      font-weight: 800;
      line-height: 1.10;
    }

    .config-status-card.hud .hud-lists{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .config-status-card.hud .hud-block{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
      border-radius: 14px;
      padding: 10px;
    }
    .config-status-card.hud .hud-block-title{
      font-size: 12px;
      font-weight: 900;
      opacity: .90;
      margin-bottom: 6px;
    }
    .config-status-card.hud .hud-line{
      display:flex;
      gap: 8px;
      align-items:flex-start;
      margin: 4px 0;
    }
    .config-status-card.hud .hud-tag{
      flex: 0 0 auto;
      font-size: 11px;
      font-weight: 950;
      padding: 2px 7px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      margin-top: 1px;
    }
    .config-status-card.hud .hud-tag.on{ border-color: rgba(0,255,163,0.30); }
    .config-status-card.hud .hud-tag.off{ border-color: rgba(255,255,255,0.14); opacity: .85; }
    .config-status-card.hud .hud-text{
      font-size: 12px;
      line-height: 1.25;
      opacity: .95;
      word-break: break-word;
    }

    @media (max-width: 520px){
      .config-status-card.hud .hud-kpis{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      .config-status-card.hud .hud-seg{ grid-template-columns: 1fr; }
      .config-status-card.hud .hud-lists{ grid-template-columns: 1fr; }
    }


    /* ===== Control Strip Compact Pro (v7.41) ===== */
/* En BASIC, controles PRO quedan ocultos para mantener la UI limpia.
   Si activas ‚öôÔ∏è (Ajustes avanzados), se habilitan para configuraci√≥n. */
body[data-ui-mode="BASIC"]:not(.show-advanced) .mode-pro-only{
  display: none !important;
}
body.show-advanced .mode-pro-only{
  display: inline-flex !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  filter: none !important;
}
.control-strip{
      display: grid !important;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
      margin: 10px 0 8px;
      align-items: stretch;
    }

    .control-strip .cbtn{
      min-height: 40px;
      padding: 8px 8px;
      border-radius: 12px;
      gap: 6px;
      letter-spacing: 0.05em;
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
      min-width: 0;          /* clave: evita overflow */
      overflow: hidden;      /* clave: nada se encima */
    }
    .cbtn-ic{ font-size: 15px; }
    .cbtn-txt{ font-size: 11px; }

    /* VOZ: verde cuando est√° ON, badge fijo adentro (no se encima con BASIC/PRO) */
    /* Forzar oculto: wakeLock/background (siempre ON internamente) */
    #wakeLockRow, #backgroundRow, #wakeLockStatus, #backgroundStatus{ display:none !important; }
        
    .cbtn-voice{
      position: relative;
      justify-content: center;
      background: rgba(0,0,0,0.34);
      white-space: nowrap;
    }
    .cbtn-voice[data-voice="on"], .cbtn-voice.voice-on{
      background: linear-gradient(135deg, rgba(0,255,163,0.32), rgba(0,184,120,0.32));
      border-color: rgba(0,255,163,0.45);
    }
    .cbtn-voice[data-voice="off"]{
      background: linear-gradient(135deg, rgba(0,0,0,0.38), rgba(0,0,0,0.25));
      border-color: rgba(255,255,255,0.14);
    }
    .cbtn-voice .cbtn-sub{
      position: absolute;
      top: 6px;
      right: 8px;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.26);
      max-width: 46px;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    .cbtn-voice[data-voice="on"] .cbtn-sub{
      border-color: rgba(0,255,163,0.35);
    }

    .cbtn-basic, .cbtn-pro, .cbtn-mode, .cbtn-rd, .cbtn-speak{
      justify-content: center;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Active highlight for BASIC/PRO buttons */
    .cbtn.mode-active{
      border-color: rgba(255,255,255,0.22);
      background: rgba(255,166,0,0.14);
    }
    body[data-ui-mode="PRO"] .cbtn.cbtn-pro.mode-active{
      background: rgba(0,255,163,0.14);
      border-color: rgba(0,255,163,0.35);
    }
    body[data-ui-mode="BASIC"] .cbtn.cbtn-basic.mode-active{
      background: rgba(255,166,0,0.14);
      border-color: rgba(255,166,0,0.28);
    }


    /* Active highlight for BASIC/PRO buttons */
    .cbtn.mode-active{
      border-color: rgba(255,255,255,0.22);
      background: rgba(255,166,0,0.14);
    }
    body[data-ui-mode="PRO"] .cbtn.cbtn-pro.mode-active{
      background: rgba(0,255,163,0.14);
      border-color: rgba(0,255,163,0.35);
    }
    body[data-ui-mode="BASIC"] .cbtn.cbtn-basic.mode-active{
      background: rgba(255,166,0,0.14);
      border-color: rgba(255,166,0,0.28);
    }

    /* Make hint line tighter */
    .strip-hint{ margin-bottom: 8px; }

    /* Extras panel compact (no overlaps) */
    .extras-section .toggle-row{
      padding: 6px 0;
      gap: 10px;
    }
    .extras-section .toggle-label{
      font-size: 13px;
      opacity: 0.92;
    }
    .rate-row{
      gap: 10px;
    }
    .rate-label{ font-size: 13px; }
    .select-label{ font-size: 13px; }


    /* Panel compacto (settings) */
    #ttsTestBtn { padding: 6px 10px; font-size: 12px; }
    #btnOpenGrid { padding: 6px 10px; font-size: 12px; }
    #voiceSelect { padding: 8px 10px; min-height: 36px; }
    .rate-row { gap: 10px; }
    .rate-label { font-size: 12px; }
    .rate-display { font-size: 12px; }

/* Hide VOZ ON/OFF text: status indicated by color only */
#voiceStripState{display:none!important;}

/* UI CLEANUP v5.1.94 (UI limpia, TODO sigue existiendo bajo Ajustes) */
/* UI CLEANUP v5.1.94 (2 estilos: BASE/TV) */
.rd-mode-row{display:none!important;}
#presetRdProBtn,#presetRdShowBtn,#masterAllOnBtn,#masterAllOnBtn2,#masterAllOnBtn3{display:none!important;}
#messagesPanel .spotter-master{display:none!important;}
/* Avanzado mas limpio: oculta KPIs/presets (todo sigue funcionando por dentro) */
.hud-kpis{display:none!important;}
.hud-lists{display:none!important;}
.session-presets{display:none!important;}

/* Ocultar botones de estilos legacy dentro de mensajes */
#rdModeMinimal,#rdModeStratega,#rdModeCoach,#rdModeSarca,#rdModeEngineer,#rdModeHype{display:none!important;}
/* En vista limpia, esconder botones avanzados extra */
body:not(.show-advanced) #msgsToggleBtn{display:none!important;}
body:not(.show-advanced) #rdToggleBtn, body:not(.show-advanced) #speakBtn, body:not(.show-advanced) #diagToggleBtn{display:none!important;}

body:not(.show-advanced) #rdToggleBtn,
body:not(.show-advanced) #speakBtn,
body:not(.show-advanced) #diagToggleBtn{ display:none !important; }

/* Mensajes panel (categor√≠as) */
.cbtn-msgs{ background: rgba(255,255,255,0.07); }
.cbtn-msgs.active{
  background: linear-gradient(135deg, rgba(255,166,0,.95), rgba(255,80,0,.70));
  color:#071018;
  box-shadow: var(--shadow-strong);
}
body:not(.show-advanced) #msgsToggleBtn{ display:none !important; }
body:not(.show-msgs) #messagesPanel{ display:none !important; }


/* Ocultar estilos legacy y botones redundantes (solo usamos algunos modos RD) */
#rdModeMinimal,#rdModeStratega,#rdModeCoach,#rdModeSarcastico,#rdModeIngeniero,#rdModeHype{ display:none !important; }
#presetRdProBtn,#presetRdShowBtn,#masterAllOnBtn{ display:none !important; }

/* Ocultar textos/ayuda legacy que mencionan modos viejos */
.legacy-modes-hint{ display:none !important; }


    /* DIAG panel (PRO) */
    .cbtn-diag{
      background: rgba(255,255,255,0.07);
      color: rgba(255,255,255,.92);
    }
    .cbtn-diag.active{
      background: linear-gradient(135deg, rgba(0,229,255,.95), rgba(0,140,255,.70));
      color:#071018;
      box-shadow: var(--shadow-strong);
    }
    
/* Q TABLA (bot√≥n en la barra principal) */
.cbtn-q{
  background: rgba(255,255,255,0.07);
  border-color: rgba(0,229,255,0.34);
  white-space: nowrap;
}
.cbtn-q:hover{ filter: brightness(1.10); }
.diag-panel{
      position: fixed;
      right: 10px;
      bottom: 10px;
      width: min(360px, calc(100vw - 20px));
      max-height: 55vh;
      overflow: auto;
      padding: 10px 10px 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.78);
      box-shadow: 0 10px 26px rgba(0,0,0,0.45);
      z-index: 9999;
      display: none;
      backdrop-filter: blur(6px);
    }
    .diag-panel.on{ display:block; }
    .diag-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight: 950;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.92);
      margin-bottom: 8px;
    }
    .diag-sub{
      font-size: 10px;
      color: rgba(255,255,255,0.70);
      font-weight: 800;
      letter-spacing: 0.02em;
      margin-top: -4px;
      margin-bottom: 8px;
    }
    .diag-grid{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-size: 11px;
      line-height: 1.2;
    }
    .diag-k{
      color: rgba(255,255,255,0.70);
      font-weight: 800;
    }
    .diag-v{
      color: rgba(255,255,255,0.94);
      font-weight: 900;
      text-align:right;
      white-space:nowrap;
    }
    .diag-log{
      margin-top: 8px;
      padding: 8px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      line-height: 1.25;
      color: rgba(255,255,255,0.88);
      white-space: pre-wrap;
    }
    .rescue-banner{
      margin-top: 6px;
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,120,0,0.35);
      background: rgba(255,120,0,0.12);
      color: rgba(255,210,170,0.95);
      font-weight: 900;
      font-size: 12px;
      display: none;
    }
    .rescue-banner.on{ display: inline-block; }

    .diag-badge{
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      font-size: 10px;
      font-weight: 950;
      letter-spacing: 0.06em;
    }

  

    /* ===== Temas (BLOQUE 3.1) ===== */
    .hud-theme{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.10);
    }
    .hud-theme-head{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .hud-theme-title{
      font-weight: 800;
      letter-spacing: 0.2px;
      color: rgba(255,255,255,0.92);
    }
    .hud-theme-note{
      font-size: 12px;
      color: rgba(255,255,255,0.55);
      white-space: nowrap;
    }
    .hud-theme-row{
      display:flex;
      gap: 10px;
      align-items: center;
    }
    .hud-select{
      flex: 1;
      min-width: 220px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      outline: none;
    }
    .hud-select:focus{
      border-color: rgba(45,107,255,0.55);
      box-shadow: 0 0 0 2px rgba(45,107,255,0.18);
    }
    .hud-mini-btn{
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.90);
      cursor: pointer;
    }
    .hud-mini-btn:hover{
      border-color: rgba(255,122,24,0.55);
      box-shadow: 0 0 14px rgba(255,122,24,0.18);
    }

    /* Tema base: Pitlane Red (default) */
    body[data-theme="pitlane-red"]{
      --bg-dark: #040406;
      --card-dark: #080a0f;
      --card-dark-2: #05070c;
      --accent-red: #ff2b2b;
      --accent-red-soft: rgba(255,43,43,0.55);
      --accent-orange: #ff7a18;
      --accent-orange-soft: rgba(255,122,24,0.55);
      --accent-blue: #2d6bff;
      --accent-blue-soft: rgba(45,107,255,0.55);
      --accent-cyan: #2d6bff;
      --shadow-strong: 0 0 16px rgba(255,43,43,0.42);
      --shadow-soft: 0 0 12px rgba(255,122,24,0.26);
      --hdr-grad-a: rgba(255,40,40,0.14);
      --hdr-grad-b: rgba(255,140,0,0.16);
    }

    /* Final A Gold */
    body[data-theme="final-gold"]{
      --bg-dark: #040406;
      --card-dark: #080a0f;
      --card-dark-2: #05070c;
      --accent-red: #ff3b3b;
      --accent-red-soft: rgba(255,59,59,0.45);
      --accent-orange: #ffd166;
      --accent-orange-soft: rgba(255,209,102,0.55);
      --accent-blue: #2d6bff;
      --accent-blue-soft: rgba(45,107,255,0.50);
      --accent-cyan: #ffd166;
      --shadow-strong: 0 0 18px rgba(255,209,102,0.28);
      --shadow-soft: 0 0 12px rgba(255,122,24,0.18);
      --hdr-grad-a: rgba(255,209,102,0.14);
      --hdr-grad-b: rgba(255,43,43,0.10);
    }


    body[data-theme="carbon-neon"]{
      --bg-dark: #030307;
      --card-dark: #070a12;
      --card-dark-2: #050611;
      --accent-red: #ff3b6b;
      --accent-red-soft: rgba(255,59,107,0.48);
      --accent-orange: #ffa31a;
      --accent-orange-soft: rgba(255,163,26,0.42);
      --accent-blue: #00e5ff;
      --accent-blue-soft: rgba(0,229,255,0.38);
      --accent-cyan: #00e5ff;
      --shadow-strong: 0 0 16px rgba(0,229,255,0.22);
      --shadow-soft: 0 0 12px rgba(255,163,26,0.18);
      --hdr-grad-a: rgba(0,229,255,0.12);
      --hdr-grad-b: rgba(255,163,26,0.14);
    }

    body[data-theme="oled-black"]{
      --bg-dark: #000000;
      --card-dark: #050505;
      --card-dark-2: #020202;
      --accent-red: #ff2b2b;
      --accent-red-soft: rgba(255,43,43,0.45);
      --accent-orange: #ff7a18;
      --accent-orange-soft: rgba(255,122,24,0.40);
      --accent-blue: #2d6bff;
      --accent-blue-soft: rgba(45,107,255,0.45);
      --accent-cyan: #2d6bff;
      --shadow-strong: 0 0 14px rgba(255,43,43,0.30);
      --shadow-soft: 0 0 10px rgba(255,122,24,0.20);
      --hdr-grad-a: rgba(255,40,40,0.10);
      --hdr-grad-b: rgba(255,140,0,0.12);
    }

    body[data-theme="toreo-blue"]{
      --bg-dark: #04060b;
      --card-dark: #07101c;
      --card-dark-2: #050a12;
      --accent-blue: #2d6bff;
      --accent-blue-soft: rgba(45,107,255,0.58);
      --accent-cyan: #2d6bff;
      --accent-red: #ff3b3b;
      --accent-red-soft: rgba(255,59,59,0.42);
      --accent-orange: #ffb020;
      --accent-orange-soft: rgba(255,176,32,0.38);
      --shadow-strong: 0 0 16px rgba(45,107,255,0.26);
      --shadow-soft: 0 0 12px rgba(255,176,32,0.18);
      --hdr-grad-a: rgba(45,107,255,0.16);
      --hdr-grad-b: rgba(255,176,32,0.12);
    }

    body[data-theme="cotorritos-crimson"]{
      --bg-dark: #060205;
      --card-dark: #12060b;
      --card-dark-2: #0b0407;
      --accent-red: #ff2b2b;
      --accent-red-soft: rgba(255,43,43,0.62);
      --accent-orange: #ff7a18;
      --accent-orange-soft: rgba(255,122,24,0.46);
      --accent-blue: #7c4dff;
      --accent-blue-soft: rgba(124,77,255,0.40);
      --accent-cyan: #7c4dff;
      --shadow-strong: 0 0 16px rgba(255,43,43,0.36);
      --shadow-soft: 0 0 12px rgba(255,122,24,0.22);
      --hdr-grad-a: rgba(255,43,43,0.16);
      --hdr-grad-b: rgba(124,77,255,0.12);
    }

    body[data-theme="streamer-purple"]{
      --bg-dark: #03020a;
      --card-dark: #0b0618;
      --card-dark-2: #060311;
      --accent-blue: #a855f7;
      --accent-blue-soft: rgba(168,85,247,0.44);
      --accent-cyan: #a855f7;
      --accent-red: #ff2b2b;
      --accent-red-soft: rgba(255,43,43,0.38);
      --accent-orange: #ffcc33;
      --accent-orange-soft: rgba(255,204,51,0.30);
      --shadow-strong: 0 0 16px rgba(168,85,247,0.22);
      --shadow-soft: 0 0 12px rgba(255,204,51,0.16);
      --hdr-grad-a: rgba(168,85,247,0.14);
      --hdr-grad-b: rgba(255,204,51,0.10);
    }

    body[data-theme="high-contrast"]{
      --bg-dark: #000000;
      --card-dark: #0a0a0a;
      --card-dark-2: #050505;
      --text-main: #ffffff;
      --text-muted: rgba(255,255,255,0.75);
      --border-soft: rgba(255,255,255,0.38);
      --accent-red: #ff2b2b;
      --accent-red-soft: rgba(255,43,43,0.62);
      --accent-orange: #ffb020;
      --accent-orange-soft: rgba(255,176,32,0.52);
      --accent-blue: #2d6bff;
      --accent-blue-soft: rgba(45,107,255,0.62);
      --accent-cyan: #2d6bff;
      --shadow-strong: 0 0 18px rgba(255,43,43,0.34);
      --shadow-soft: 0 0 14px rgba(255,176,32,0.22);
      --hdr-grad-a: rgba(255,255,255,0.12);
      --hdr-grad-b: rgba(255,176,32,0.10);
    }

    body[data-theme="retro-90s"]{
      --bg-dark: #07120a;
      --card-dark: #0b1f12;
      --card-dark-2: #06150c;
      --accent-blue: #00ff6a;
      --accent-blue-soft: rgba(0,255,106,0.34);
      --accent-cyan: #00ff6a;
      --accent-red: #ff2b9d;
      --accent-red-soft: rgba(255,43,157,0.40);
      --accent-orange: #ffee33;
      --accent-orange-soft: rgba(255,238,51,0.28);
      --shadow-strong: 0 0 16px rgba(0,255,106,0.16);
      --shadow-soft: 0 0 12px rgba(255,238,51,0.16);
      --hdr-grad-a: rgba(0,255,106,0.12);
      --hdr-grad-b: rgba(255,43,157,0.10);
    }

  

/* =========================
   THEME LINK PATCH (v5.0.92)
   - Conecta los temas a la UI real (cards, header, botones)
   - Sin dependencias raras, puro CSS vars
   ========================= */

body{
  background-color: var(--bg-dark);
  background-image:
    radial-gradient(circle at 20% 10%, var(--accent-blue-soft), transparent 58%),
    radial-gradient(circle at 80% 0%, var(--accent-orange-soft), transparent 60%),
    radial-gradient(circle at 70% 95%, var(--accent-red-soft), transparent 62%),
    repeating-linear-gradient(45deg, rgba(255,255,255,0.018), rgba(255,255,255,0.018) 7px, transparent 7px, transparent 14px);
}

.app-header{
  background-color: var(--card-dark);
  background-image:
    linear-gradient(135deg, var(--hdr-grad-a), var(--hdr-grad-b)),
    repeating-linear-gradient(45deg, rgba(255,255,255,0.028), rgba(255,255,255,0.028) 8px, transparent 8px, transparent 16px);
  border-color: var(--hdr-border);
}

/* Cards principales */
.pilot-card{
  background-color: var(--card-dark);
  background-image: linear-gradient(145deg, var(--card-dark), var(--card-dark-2));
  border-color: var(--accent-orange-soft);
}

.extras-section{
  background: radial-gradient(circle at top, var(--card-dark), var(--card-dark-2));
  border-color: var(--border-soft);
}

/* Contenedores de categorias */
.spotter-cat{
  border-color: var(--border-soft);
  background: rgba(0,0,0,0.22);
}

/* Botones (base) */
.spotter-btn,
.spotter-master-btn,
.cbtn,
.seg-btn,
.ui-mode-btn,
.hud-mini-btn,
.hud-select{
  background: rgba(0,0,0,0.26);
  border-color: var(--border-soft);
  color: var(--text-muted);
}

.spotter-btn:hover,
.spotter-master-btn:hover,
.cbtn:hover,
.seg-btn:hover,
.ui-mode-btn:hover,
.hud-mini-btn:hover{
  background: rgba(0,0,0,0.34);
  color: var(--text-main);
}

/* Botones activos */
.cbtn.on,
.seg-btn.active,
.ui-mode-btn.active{
  background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
  border-color: rgba(255,255,255,0.16);
  color: var(--text-main);
  box-shadow: var(--shadow-soft);
}

/* Voz ON destacado */
.cbtn-voice.on{
  background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
  border-color: rgba(255,255,255,0.18);
  color: var(--text-main);
  box-shadow: var(--shadow-soft);
}

/* Texto general */
body, .app, .main, .pilot-card, .extras-section{
  color: var(--text-main);
}


    /* Uso de narraciones (auditor√≠a) */
    .usage-panel{
      margin-top: 10px;
      padding: 10px 10px 8px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.26);
      background: rgba(0,0,0,0.22);
    }
    .usage-title{
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .usage-grid{
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }
    .usage-item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.22);
      background: rgba(0,0,0,0.24);
      font-size: 12px;
    }
    .usage-k{ color: var(--text-main); opacity: 0.92; }
    .usage-v{ color: var(--text-main); }
    .usage-empty{ font-size: 12px; color: var(--text-muted); padding: 4px 0; }

  
/* ===== UI CLEAN: Advanced drawer ===== */
.cbtn.cbtn-settings { min-width: 92px; }
.cbtn-settings .cbtn-ic { display:inline-block; }
.cbtn-settings.active { filter: brightness(1.15); }
body:not(.show-advanced) .mode-pro-only { display:none !important; }
/* Hide heavy panels unless Advanced is ON */
body:not(.show-advanced) #configStatusCard { display:none !important; }
body:not(.show-advanced) .hud-presets { display:none !important; }
body:not(.show-advanced) .rd-mode-row.mode-pro-only { display:none !important; }
body:not(.show-advanced) .controls-label.mode-pro-only { display:none !important; }
body:not(.show-advanced) .precision-row.mode-pro-only { display:none !important; }
body:not(.show-advanced) section.spotter-section.mode-pro-only { display:none !important; }
body:not(.show-advanced) .spotter-master { display:none !important; }
body:not(.show-advanced) .usage-panel { display:none !important; }
/* When Advanced is OFF, keep essentials visible and add a subtle divider */
body:not(.show-advanced) .strip-hint::after { content: "  -  ‚öôÔ∏è para m√°s"; opacity: .8; }


/* Hide legacy style selector rows permanently (ya no aportan valor) */
.rd-mode-row.mode-pro-only { display:none !important; }

/* ===== Homogeneidad + Compacto (v5.1.94) ===== */
:root{
  --ui-gap: 8px;
  --ui-radius: 14px;
  --ui-radius-sm: 12px;
  --ui-border: rgba(148,163,184,0.20);
  --ui-bg: rgba(0,0,0,0.22);
}
.app{ padding: 10px; }
.app-main{ gap: var(--ui-gap); }
.pilot-card, .extras-section, .usage-panel, .basic-quick, .config-status-card{
  border-radius: var(--ui-radius);
}

/* POS badge: tama√±o fijo (no cambia entre P1 y P10), centrado y listo para rotaci√≥n */
:root{ --pos-size: 62px; --pos-letter: 12px; --pos-num: 24px; }
@media (max-width: 480px){ :root{ --pos-size: 58px; --pos-letter: 11px; --pos-num: 22px; } }

.pos-pill{
  width: var(--pos-size);
  height: var(--pos-size);
  padding: 0 !important;
  border-radius: 999px !important;
  display: flex !important;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  white-space: nowrap;
  line-height: 1.05;
  font-weight: 900;
  font-variant-numeric: tabular-nums;
}
.pos-pill .pos-letter{
  font-size: var(--pos-letter);
  letter-spacing: .12em;
  opacity: .95;
}
.pos-pill .pos-num{
  font-size: var(--pos-num);
  margin-top: 2px;
}
.pos-pill.is-avg{
  flex-direction: row;
  gap: 6px;
}
.pos-pill.is-avg .pos-num{
  margin-top: 0;
  font-size: 16px;
}

/* Q TABLA modal - un toque m√°s fino */
#qualiBackdrop .manual-panel{
  border: 1px solid var(--ui-border);
}
#qualiBackdrop .qtable-wrap{
  border: 1px solid var(--ui-border);
}
#qualiBackdrop .qtable th{
  letter-spacing: .4px;
}

/* Mobile first: compacto pero tocable */
@media (max-width: 480px){
  .app{ padding: 8px; }
  .app-main{ gap: 8px; }
  .app-header{ padding: 8px 10px; }
  .header-title-main{ gap: 8px; }
  .header-title-main img{ height: 22px; }

  .pilot-card{ padding: 9px 10px 10px; gap: 8px; }
  .pilot-name{ font-size: 18px; }
  .pilot-select select{ font-size: 15px; padding: 10px 12px; }
  .btn-voice-mini{ flex: 0 0 100%; }

  .control-strip{ gap: 8px; margin: 8px 0 4px; }
  .cbtn{
    min-height: 40px;
    padding: 8px 10px;
    border-radius: var(--ui-radius-sm);
  }
  .cbtn-ic{ font-size: 14px; }
  .cbtn-txt{ font-size: 11px; }
  .cbtn-sub{ font-size: 10px; padding: 3px 6px; }

  .cbtn-voice{ flex: 1 1 100%; padding-left: 12px; padding-right: 12px; }
  .cbtn-rd, .cbtn-speak, .cbtn-diag, .cbtn-msgs, .cbtn-settings, .cbtn-q, .cbtn-mode{ min-width: 94px; }

  .basic-quick{ padding: 8px 10px; border-radius: var(--ui-radius); gap: 8px; }
  .basic-toggle{ min-height: 34px; padding: 7px 9px; font-size: 11px; min-width: 78px; }
  /* pos-pill size fijo via --pos-size */
.pos-info{ font-size: 13px; }

  /* Q TABLA modal en m√≥vil */
  #qualiBackdrop .manual-panel{ padding: 8px; border-radius: 14px; }
  #qualiBackdrop .qtable-wrap{ max-height: 58vh; border-radius: 12px; }
  #qualiBackdrop .qtable{ font-size: 11px; }
  #qualiBackdrop .qtable th{ padding: 7px 7px; font-size: 10.5px; }
  #qualiBackdrop .qtable td{ padding: 6px 7px; }
}



/* =========================================================
   CONTROL STRIP - TRMX PRO (v5.1.94)
   - Grid responsivo sin solapes
   - Botones homog√©neos, elegantes, tocables
   - ON = prendido con led + glow (colores TRMX)
   ========================================================= */
:root{
  --tr-red:#ff2b2b;
  --tr-orange:#ff8c1a;
  --tr-blue:#2d6bff;
  --tr-green:#28d86c;

  --tr-btn-bg: rgba(255,255,255,0.05);
  --tr-btn-bg-hi: rgba(255,255,255,0.08);
  --tr-btn-br: rgba(255,255,255,0.14);
  --tr-btn-br-hi: rgba(255,255,255,0.22);
}

.control-strip{
  display:grid !important;
  grid-template-columns: repeat(auto-fit, minmax(112px, 1fr));
  gap: 10px;
  align-items: stretch;
}

@media (max-width: 420px){
  .control-strip{
    grid-template-columns: repeat(auto-fit, minmax(96px, 1fr));
    gap: 8px;
  }
}

.cbtn{
  --on1: var(--tr-orange);
  --on2: var(--tr-red);

  width: 100%;
  min-width: 0 !important;
  min-height: 44px;

  padding: 10px 10px;
  border-radius: 14px;
  border: 1px solid var(--tr-btn-br);

  background: var(--tr-btn-bg);
  color: rgba(245,247,255,0.92);

  box-shadow: 0 10px 22px rgba(0,0,0,0.35);

  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;

  font-weight: 900;
  letter-spacing: 0.06em;
  text-transform: uppercase;

  line-height: 1.05;
  text-align: center;
  white-space: normal;

  position: relative;
  overflow: hidden;
  user-select: none;
}

.cbtn:hover{
  background: var(--tr-btn-bg-hi);
  border-color: var(--tr-btn-br-hi);
}

.cbtn:active{
  transform: translateY(0.5px);
}

.cbtn::before{
  content:"";
  position:absolute;
  inset:0;
  background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.00) 60%);
  opacity: .70;
  pointer-events: none;
}

.cbtn::after{
  content:"";
  position:absolute;
  right: 10px;
  top: 10px;
  width: 10px;
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.18);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.16);
  opacity: .95;
  pointer-events: none;
}

.cbtn .cbtn-sub{ display:none !important; }
.cbtn .cbtn-ic{ font-size: 14px; }
.cbtn .cbtn-txt{ font-size: 11px; }

@media (max-width: 420px){
  .cbtn{
    min-height: 42px;
    padding: 9px 9px;
    border-radius: 13px;
  }
  .cbtn .cbtn-txt{ font-size: 10px; }
}

.cbtn.cbtn-rd{ --on1: var(--tr-green); --on2: var(--tr-green); }
.cbtn.cbtn-voice{ --on1: var(--tr-green); --on2: var(--tr-orange); }
.cbtn.cbtn-diag{ --on1: var(--tr-red); --on2: var(--tr-orange); }
.cbtn.cbtn-mode{ --on1: var(--tr-orange); --on2: var(--tr-red); }
.cbtn.cbtn-q{ --on1: var(--tr-orange); --on2: var(--tr-red); }
.cbtn.cbtn-settings{ --on1: var(--tr-orange); --on2: var(--tr-blue); }
.cbtn.cbtn-msgs{ --on1: var(--tr-blue); --on2: var(--tr-orange); }
.cbtn.cbtn-speak{ --on1: var(--tr-red); --on2: var(--tr-orange); }

.cbtn.on,
.cbtn.active,
.cbtn.is-on,
.cbtn.voice-on,
.cbtn[data-voice="on"],
.cbtn[aria-pressed="true"]{
  background: linear-gradient(135deg, var(--on1), var(--on2)) !important;
  color: rgba(10,14,18,0.95) !important;
  border-color: rgba(255,255,255,0.18) !important;
  box-shadow:
    0 0 0 1px rgba(255,255,255,0.22) inset,
    0 14px 28px rgba(0,0,0,0.45),
    0 0 18px rgba(255,255,255,0.05) !important;
}

.cbtn.on::after,
.cbtn.active::after,
.cbtn.is-on::after,
.cbtn.voice-on::after,
.cbtn[data-voice="on"]::after,
.cbtn[aria-pressed="true"]::after{
  background: rgba(255,255,255,0.92);
  box-shadow:
    0 0 0 1px rgba(0,0,0,0.25) inset,
    0 0 14px var(--on1),
    0 0 26px var(--on2);
}

/* VOZ homog√©neo con el resto (sin spans) */
.cbtn-voice{ grid-column: auto; }


/* ===== TRMX: botones secundarios homog√©neos (RD modes, Auto Locutor, mini VOZ, BASIC toggles) ===== */
.btn-secondary.btn-hot,
.basic-toggle,
.spotter-master-btn{
  --on1: var(--tr-orange);
  --on2: var(--tr-blue);
  border-radius: 14px !important;
  border: 1px solid rgba(255,255,255,0.14) !important;
  background: var(--tr-btn-bg) !important;
  color: rgba(255,255,255,0.92) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.18) !important;
  min-height: 40px !important;
  padding: 10px 12px !important;
  font-weight: 900 !important;
  letter-spacing: 0.06em !important;
  position: relative !important;
  overflow: hidden !important;
}

.btn-secondary.btn-hot:hover,
.basic-toggle:hover,
.spotter-master-btn:hover{
  background: var(--tr-btn-bg-hi) !important;
  border-color: var(--tr-btn-br-hi) !important;
}

.btn-secondary.btn-hot::before,
.basic-toggle::before,
.spotter-master-btn::before{
  content:"";
  position:absolute;
  left:-30%;
  top:-50%;
  width: 140%;
  height: 160%;
  background: radial-gradient(circle at 20% 30%, rgba(255,255,255,0.14), transparent 55%);
  transform: rotate(-8deg);
  pointer-events:none;
  opacity: .75;
}

.btn-secondary.btn-hot::after,
.basic-toggle::after,
.spotter-master-btn::after{
  content:"";
  position:absolute;
  right: 10px;
  top: 10px;
  width: 10px;
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.18);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.16);
  opacity: .95;
  pointer-events:none;
}

/* colores por tipo */
.btn-secondary.btn-hot.btn-voice{ --on1: var(--tr-red); --on2: var(--tr-orange); }
.btn-secondary.btn-hot.rd-mode{ --on1: var(--tr-orange); --on2: var(--tr-blue); }
.spotter-master-btn{ --on1: var(--tr-orange); --on2: var(--tr-blue); }
.basic-toggle{ --on1: var(--tr-green); --on2: var(--tr-blue); }

/* estado ON */
.btn-secondary.btn-hot.active,
.btn-secondary.btn-hot.on,
.btn-secondary.btn-hot[aria-pressed="true"],
.basic-toggle.active,
.basic-toggle.on,
.basic-toggle.lock,
.spotter-master-btn.active{
  background: linear-gradient(135deg, var(--on1), var(--on2)) !important;
  color: rgba(10,14,18,0.95) !important;
  border-color: rgba(255,255,255,0.18) !important;
  box-shadow:
    0 0 0 1px rgba(255,255,255,0.22) inset,
    0 14px 28px rgba(0,0,0,0.45),
    0 0 18px rgba(255,255,255,0.05) !important;
}

.btn-secondary.btn-hot.active::after,
.btn-secondary.btn-hot.on::after,
.btn-secondary.btn-hot[aria-pressed="true"]::after,
.basic-toggle.active::after,
.basic-toggle.lock::after,
.spotter-master-btn.active::after{
  background: rgba(255,255,255,0.92);
  box-shadow:
    0 0 0 1px rgba(0,0,0,0.25) inset,
    0 0 14px var(--on1),
    0 0 26px var(--on2);
}

/* RD mode row: que se acomode bonito */
.rd-mode-row{ gap: 10px !important; }
.rd-mode-row .btn-secondary.btn-hot{ flex: 1 1 120px; }

/* ===== TRMX: PRO panel homog√©neo (Precisi√≥n + Categor√≠as) ===== */
.precision-row .precision-buttons{
  gap: 10px !important;
}

.precision-badge{
  --on1: var(--tr-orange);
  --on2: var(--tr-blue);
  cursor: pointer !important;
  position: relative !important;
  overflow: hidden !important;
  border: 1px solid rgba(255,255,255,0.14) !important;
  background: var(--tr-btn-bg) !important;
  color: rgba(255,255,255,0.90) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.18) !important;
  font-weight: 900 !important;
  letter-spacing: 0.06em !important;
}
.precision-badge:hover{
  background: var(--tr-btn-bg-hi) !important;
  border-color: var(--tr-btn-br-hi) !important;
}
.precision-badge::after{
  content:"";
  position:absolute;
  top:7px;
  right:7px;
  width:8px;
  height:8px;
  border-radius:999px;
  background: rgba(255,255,255,0.22);
  box-shadow: 0 0 0 1px rgba(0,0,0,0.35) inset;
}
.precision-badge.active{
  background: linear-gradient(135deg, var(--on1), var(--on2)) !important;
  color: rgba(10,14,18,0.95) !important;
  border-color: rgba(255,255,255,0.18) !important;
  box-shadow:
    0 0 0 1px rgba(255,255,255,0.22) inset,
    0 14px 28px rgba(0,0,0,0.45),
    0 0 18px rgba(255,255,255,0.05) !important;
}
.precision-badge.active::after{
  background: rgba(255,255,255,0.92);
  box-shadow:
    0 0 0 1px rgba(0,0,0,0.25) inset,
    0 0 14px var(--on1),
    0 0 26px var(--on2);
}

/* categor√≠as de mensajes: mismo look "prendido" que TRMX */
.spotter-btn{
  --on1: var(--tr-orange);
  --on2: var(--tr-blue);
  position: relative !important;
  overflow: hidden !important;
  border: 1px solid rgba(255,255,255,0.14) !important;
  background: var(--tr-btn-bg) !important;
  color: rgba(255,255,255,0.90) !important;
  box-shadow: 0 10px 20px rgba(0,0,0,0.16) !important;
}
.spotter-btn:hover{
  background: var(--tr-btn-bg-hi) !important;
  border-color: var(--tr-btn-br-hi) !important;
}
.spotter-btn::before{
  content:"";
  position:absolute;
  top:6px;
  right:6px;
  width:8px;
  height:8px;
  border-radius:999px;
  background: rgba(255,255,255,0.22);
  box-shadow: 0 0 0 1px rgba(0,0,0,0.35) inset;
}
.spotter-btn.active{
  background: linear-gradient(135deg, var(--on1), var(--on2)) !important;
  color: rgba(10,14,18,0.95) !important;
  border-color: rgba(255,255,255,0.18) !important;
  box-shadow:
    0 0 0 1px rgba(255,255,255,0.22) inset,
    0 14px 28px rgba(0,0,0,0.40),
    0 0 18px rgba(255,255,255,0.05) !important;
}
.spotter-btn.active::before{
  background: rgba(255,255,255,0.92);
  box-shadow:
    0 0 0 1px rgba(0,0,0,0.25) inset,
    0 0 14px var(--on1),
    0 0 26px var(--on2);
}

/* ultra angosto: que no se amontone PRO */
@media (max-width: 380px){
  .spotter-grid{ gap: 6px !important; }
  .spotter-btn{ font-size: 10px !important; padding: 6px 6px !important; letter-spacing: 0.06em !important; }
  .precision-badge{ font-size: 10px !important; padding: 6px 0 !important; }
}




/* ===== FIX 5.1.53: mini "ACTIVAR VOZ" debe ponerse VERDE aunque use .btn-hot ===== */
.btn-hot.btn-voice.voice-on,
.btn-hot.btn-voice.voice-on:hover,
#voiceToggleBtnMini.voice-on{
  background: linear-gradient(135deg, rgba(0,255,140,.92), rgba(0,170,90,.80)) !important;
  color: #06110c !important;
  border-color: rgba(255,255,255,0.18) !important;
  box-shadow:
    0 0 0 1px rgba(255,255,255,0.20) inset,
    0 14px 28px rgba(0,0,0,0.45),
    0 0 18px rgba(34,197,94,0.35) !important;
}


    body.no-anim * { transition: none !important; animation: none !important; }
</style>
</head>
<body>
  <div class="app">
    <header class="app-header">
      <div class="header-left">
        <div class="header-title-main" id="raceTitleMain"><img id="trLogo" alt="Turbo Racing M√©xico" src="data:image/png;base64,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E3C83gOfSHuQjK8NAjFuzv/9j9fGaL5k0yLSpBznX0pkTMmZgkoosodq1269oIpjOSRAAiRAAiRAAiRAAiRAAiRAAhklwLBJgARIgARIgARIgARIgARIgARST8DJP3TLp6mPkgG2SiDOjXrsJ9vEab9M298oz/tLmXmCSN5JuW77IApiGSRAAiRAAiRAAiRAAiRAAiRAAtklwMhJgARIgARIgARIgARIgARIgATST8BJf4iMsA0CsW4Wt6nGveL422J1okTjItKgtJ5SYvJgkznOqVrrIcEWytJIgARIgARIgARIgARIgARIgAQyRIChkgAJkAAJkAAJkAAJkAAJkAAJZICAozbcTsvQ4U0ZiJUhNksg3pXa0znvg5c2+fqJJ2ri9aQ065LP36dERpaWOtBUW6C0blAKCZAACZAACZAACZAACZAACZAACfggwCwkQAIkQAIkQAIkQAIkQAIkQAJZIOCoDvkFIuqqLATLGJshYMEq6dB58Cp1Y8+2wJXSXHDdyUg4ExqtuO5qWutctEZpjQRIgARIgARIgARIgARIgARIIBUEGAQJkAAJkAAJkAAJkAAJkAAJkEAmCDhy8vWN7lcf/DsT0TLIFQjYsELXzemkn7pzMz1zZhcb/GnLB8nnb1EiT7aVLvDtjnMTymwPpZAACZAACZAACZAACZAACZAACZBAWQSYmARIgARIgARIgARIgARIgARIIBsEnGyEyShbIGDHaq2Vl8uv595z6R52OFSCF677L6SaCI1SesDY2lAKCZAACZAACZAACZAACZAACZAACZRDgGlJgARIgARIgARIgARIgARIgAQyQmDRAIC1N1fSf9WMhMww/0fAnk9SN3eA/uDF9e3xqHVPJJ9/CCm+h0YrWo+K1iCtkQAJkAAJkAAJkAAJkAAJkAAJJJ8AIyABEiABEiABEiABEiABEiABEsgKgYUDAKq22+cH1X/wi1kJmnEuJmDTwi0q6dj5qOIfT9jHJrda9UXkF9g+FxqlbBGlMdoiARIgARIgARIgARIgARIgARJIAQGGQAIkQAIkQAIkQAIkQAIkQAIkkBkCCwcAqG1Hf+t9/MY9mYmagS4kYNsfPXNKP+/jl3vZ5ldL/ojIp0rksZa2h7Vee95TYZXNckmABEiABEiABEiABEiABEiABNJHgBGRAAmQAAmQAAmQAAmQAAmQAAlk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ARIgARIgARIggRAIcABACBDpggRIgARIgASySYC+SYAESIAESIAESIAESIAESIAESIAEmj4BlpAESIAESIAESIAEwiDAAQBhUKQPEiABEiABEsgeAXomARIgARIgARIgARIgARIgARIgARJo+gRYQhIgARIgARIgARIIhQAHAISCkU5IgARIgARIIFsE6JcESIAESIAESIAESIAESIAESIAESKDpE2AJSYAESIAESIAESCAcAhwAEA5HeiEBEiABEiCB7BCgVxIgARIgARIgARIgARIgARIgARIggaZPgCUkARIgARIgARIggZAIcABASCDphgRIgARIgASyQYA+SYAESIAESIAESIAESIAESIAESIAEmj4BlpAESIAESIAESIAEwiLAAQBhkaQfEiABEiABEgifAD2SAAmQAAmQAAmQAAmQAAmQAAmQAAk0fQIsIQmQAAmQAAmQAAmERoADAEJDSUckQAIkQAIkEDYB+iMBEiABEiABEiABEiABEiABEiABEmj6BFhCEiABEiABEiABEgiPAAcAhMeSnkiABEiABEggXAL0RgIkQAIkQAIkQAIkQAIkQAIkQAIk0PQJsIQkQAIkQAIkQAIkECIBDgAIESZdkQAJkAAJkECYBOiLBEiABEiABEiABEiABEiABEiABEig6RNgCUmABEiABEiABEggTAIcABAmTfoiARIgARIggfAI0BMJkAAJkAAJkAAJkAAJkAAJkAAJkEDTJ8ASkgAJkAAJkAAJkECoBDgAIFScdEYCJEACJEACYRGgHxIgARIgARIgARIgARIgARIgARIggaZPgCUkARIgARIgARIggXAJ/D8AAAD//3Dt0DQAAAAGSURBVAMAGJHSNE2klfEAAAAASUVORK5CYII="><span id="raceTitleText">Spotter_5.2.22</span><span class="badge-mode" id="raceModeBadge">MODO -</span></div>
        <div class="header-title-sub" id="raceSubtitle">Turbo Racing M√©xico - x-vic!</div>
        <div class="header-subline" id="raceInfo">Esperando datos en vivo</div>
        <div class="header-subline rescue-banner" id="rescueBanner"></div>
        <div class="header-mini" id="lastUpdateInfo"></div>
      </div>
      <div class="header-right">
        <div class="badge-live live-off" id="liveIndicator">
          <span class="badge-live-dot"></span>
          <span>Offline</span>
        </div>
                <button class="header-help" id="manualBtn" type="button" title="Manual y ayuda">MANUAL</button>
<div class="header-version" id="appVersion">Spotter_5.2.22</div>
      </div>
    </header>

    <main class="app-main">
      <section class="pilot-card">
        <div class="pilot-card-top-strip"></div>
        <div class="pilot-row-heading">
          <div>
            <div class="pilot-label">Piloto seguido</div>
            <div class="pilot-name" id="pilotName">Auto Locutor</div>
            <div class="pilot-meta" id="pilotMeta">Selecciona un piloto para activar el spotter</div>
          </div>
        </div>
        <div class="pilot-select" style="margin-top:6px;">
          <select id="pilotSelect">
            <option value="">Sin piloto seleccionado</option>
          </select>
        </div>
        <div class="pilot-select-actions">
          <button class="btn-secondary btn-hot btn-voice btn-voice-mini" id="voiceToggleBtnMini" data-voice-toggle type="button">
            üîä ACTIVAR VOZ
          </button>
        </div>
        <div class="pilot-pos-row">
          <div class="pos-pill" id="posText"><span class="pos-letter">P</span><span class="pos-num">-</span></div>
          <div class="pos-info" id="gapInfo">Diferencia l√≠der ¬∑ vueltas ¬∑ estado</div>
        </div>
        <div class="pilot-timings">
          <div class="timing-item last-lap primary-metric">
            <div class="timing-label">√öltima</div>
            <div class="timing-value" id="lastLap">-:--.---</div>
          </div>
          <div class="timing-item primary-metric">
            <div class="timing-label">Mejor</div>
            <div class="timing-value" id="bestLap">-:--.---</div>
          </div>

          <!-- Record carrera (mejor vuelta global) -->
          <div class="timing-item primary-metric">
            <div class="timing-label">Record carrera</div>
            <div class="timing-value" id="bestOverallLap">-:--.---</div>
            <div class="timing-meta" id="bestLapHolder" style="font-size:10px; color:var(--text-muted);">-</div>
          </div>
<div class="timing-item">
            <div class="timing-label">Media</div>
            <div class="timing-value" id="meanLap">-:--.---</div>
          </div>

          <div class="timing-item">
            <div class="timing-label">EstLap</div>
            <div class="timing-value" id="estLapVal">--</div>
          </div>
          <div class="timing-item">
            <div class="timing-label">Consistency</div>
            <div class="timing-value" id="consistencyVal">--%</div>
          </div>
<div class="timing-item mode-pro-only">
            <div class="timing-label">Pace 3</div>
            <div class="timing-value" id="pace3Val">-:--.---</div>
          </div>
          <div class="timing-item mode-pro-only">
            <div class="timing-label">Racha</div>
            <div class="timing-value" id="streakVal">--</div>
          </div>
<div class="timing-item timer-only" id="mangaClockItem">
            <div class="timing-label">Time</div>
            <div class="timing-value manga-clock" id="mangaClock">--:--.---</div>
          </div>

        </div>
      
        <div class="lap-chart-wrap">
          <div class="lap-chart-header">
            <div class="lap-chart-header-row">
              <div class="lap-chart-title">Lap chart</div>
              <button class="btn-mini" id="top3ToggleBtn" type="button" title="Alternar Top 3 / Top 20">TOP 3</button>
            </div>
            <div class="lap-chart-meta" id="lapChartMeta">Sin datos</div>
          </div>
          <canvas id="lapChart" width="600" height="180"></canvas>
          <div class="top3-mini-grid" id="top3MiniGrid" aria-label="Top 3 grid"></div>
        </div>

      </section>

      <section class="extras-section">

        

        <div class="toggle-row" id="wakeLockRow" style="display:none">
          <div class="toggle-label">Mantener pantalla despierta</div>
          <div class="toggle-pill active" id="wakeLockToggle">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="wake-status" id="wakeLockStatus" style="display:none"></div>

        <div class="toggle-row" id="backgroundRow" style="display:none">
          <div class="toggle-label">Modo background</div>
          <div class="toggle-pill" id="backgroundToggle" title="Si est√° ON, el spotter sigue leyendo datos aunque la pesta√±a no est√© al frente.">
            <div class="toggle-thumb"></div>
          </div>
        </div>
        <div class="wake-status" id="backgroundStatus" style="display:none"></div>


        <div class="rate-row" style="margin-top:8px;">
          <div class="rate-label">Velocidad voz</div>
          <input type="range" id="rateRange" min="1.0" max="2.5" step="0.1" value="1.5" />
          <div class="rate-display" id="rateDisplay">1.5x</div>
        </div>

        <div class="select-row">
          <div class="select-label">Voz</div>
          <div style="display:flex;gap:8px;align-items:center;justify-content:flex-end;flex-wrap:wrap;">
            <select id="voiceSelect" class="spotter-select" title="Selecciona voz del sistema (depende del dispositivo)"></select>
            <button class="btn-secondary btn-hot" id="ttsTestBtn" type="button" title="Probar voz">üé§ Test</button>
          </div>
        </div>


        <div class="grid-button-row">
          <button class="btn-grid" id="btnOpenGrid">
            üìã TOP 3
          </button>
</div>
      </section>



      <section class="controls-section">
        

        
        <div class="control-strip" aria-label="Controles principales">
          <button class="cbtn cbtn-voice" id="voiceToggleBtn" data-voice-toggle type="button">
            <span class="cbtn-ic">üîä</span>
            <span class="cbtn-txt">Voz</span>
            <span class="cbtn-sub" id="voiceStripState">OFF</span>
          </button>

          <button id="uiModeBtn" class="cbtn cbtn-mode" type="button" title="Modo de narraci√≥n">
            <span class="cbtn-ic">üì∫</span>
            <span class="cbtn-txt">TV</span>
          </button>


<button class="cbtn cbtn-settings" id="advancedToggleBtn" type="button" title="Ajustes avanzados">
            <span class="cbtn-ic">‚öôÔ∏è</span>
            <span class="cbtn-txt">Ajustes</span>
            <span class="cbtn-sub" id="advStripState">OFF</span>
          </button>

          <button class="cbtn cbtn-msgs" id="msgsToggleBtn" type="button" title="Mensajes (categor√≠as)">
            <span class="cbtn-ic">üì£</span>
            <span class="cbtn-txt">Msgs</span>
            <span class="cbtn-sub" id="msgsStripState">OFF</span>
          </button>


          <button class="cbtn cbtn-q" id="qualiBtn" type="button" title="Tabla general de clasificaci√≥n (mejor por piloto, Q1 en adelante)">
            <span class="cbtn-ic">üßæ</span>
            <span class="cbtn-txt">Q Tabla</span>
          </button>
<button class="cbtn cbtn-rd" id="rdToggleBtn" type="button" title="Race Director">
            <span class="cbtn-ic">ü§ñ</span>
            <span class="cbtn-txt">RD</span>
          </button>
          <button class="cbtn cbtn-speak" id="speakBtn" type="button">
            <span class="cbtn-ic">üì£</span>
            <span class="cbtn-txt">RES</span>
          </button>
          <button class="cbtn cbtn-diag" id="diagToggleBtn" type="button" title="Diagn√≥stico">
            <span class="cbtn-ic">üõ†</span>
            <span class="cbtn-txt">DIAG</span>
          </button>
        </div>

        <div class="strip-hint" id="uiModeHintLine">
          TV: transmisi√≥n. BASE: cero ruido. BASIC/PRO: simple vs completo.
        </div>

        <div class="basic-quick mode-basic-only" id="basicPanel" aria-label="BASIC - ajustes r√°pidos">
          <div class="basic-quick-title">BASIC</div>
          <div class="basic-toggles">
            <button class="basic-toggle active lock" data-flag="laps" type="button">‚è± LAPS</button>
            <button class="basic-toggle" data-flag="blueflag" type="button">üü¶ AZUL</button>
                        <button class="basic-toggle" data-flag="courtesy" type="button">ü§ù CORTESIA</button>
<button class="basic-toggle" data-flag="pos" type="button">üèÅ POS/RANK</button>
            <button class="basic-toggle mode-tv" data-flag="gaps" type="button">‚è± GAP</button>
            <button class="basic-toggle mode-tv" data-flag="pelea" type="button">‚öîÔ∏è PELEA</button>
            <button class="basic-toggle mode-tv" data-flag="bestlap" type="button">üèÜ BEST</button>
</div>
        </div>

<div class="config-status-card hud" id="configStatusCard" aria-label="Configuraci√≥n activa">
          <div class="hud-top">
            <div class="hud-title">‚öôÔ∏è Modo</div>
            <div class="hud-badges">
              <span class="hud-badge hud-badge-session" id="cfgSessionPill">Sesi√≥n: -</span>
              <span class="hud-badge hud-badge-preset" id="cfgPresetPill">Preset: -</span>
              <span class="hud-badge hud-badge-auto" id="sessionPresetNote">Auto: ON</span>
              <button class="hud-badge hud-badge-btn mode-pro-only" id="copyDiagBtn" type="button" title="Copiar diagn√≥stico">üìã Copiar DIAG</button>
            </div>
          </div>

          <div class="hud-kpis">
            <div class="hud-kpi"><span>RD</span><b id="cfgRdMode">-</b></div>
            <div class="hud-kpi"><span>Locutor</span><b id="cfgAutoMode">-</b></div>
            <div class="hud-kpi"><span>Prec</span><b id="cfgPrec">-</b></div>
            <div class="hud-kpi"><span>Voz</span><b id="cfgVoices">ES</b></div>
                      <div class="hud-kpi"><span>Tema</span><b id="cfgTheme">-</b></div>
</div>

          <div class="hud-theme" aria-label="Tema">
            <div class="hud-theme-head">
              <div class="hud-theme-title">üé® Tema</div>
              <div class="hud-theme-note">Se guarda en este dispositivo</div>
            </div>
            <div class="hud-theme-row">
              <select id="themeSelect" class="hud-select" aria-label="Seleccionar tema">
                <option value="auto">Auto (por sesi√≥n)</option>
                <option value="carbon-neon">Carbon Neon</option>
                <option value="oled-black">OLED Black</option>
                <option value="pitlane-red">Pitlane Red</option>
                <option value="final-gold">Final A Gold</option>
                <option value="toreo-blue">Toreo Blue</option>
                <option value="cotorritos-crimson">Cotorritos Crimson</option>
                <option value="streamer-purple">Streamer Purple</option>
                <option value="high-contrast">High Contrast</option>
                <option value="retro-90s">Retro 90s</option>
              </select>
              <button class="hud-mini-btn" id="themeCycleBtn" type="button" title="Cambiar tema">‚ü≥</button>
            </div>
          </div>

          <div class="hud-presets">
            <div class="hud-presets-head">
              <div class="hud-presets-title">Presets por sesi√≥n</div>
              <div class="hud-presets-note" id="hudPresetNote">Toca para aplicar</div>
            </div>

            <div class="hud-seg" role="group" aria-label="Presets por sesi√≥n">
              <button class="session-preset-card hud-seg-btn" id="presetCardTrain" data-session="TRAIN" type="button">
                <div class="hud-seg-name">Entrenamiento</div>
                <div class="hud-seg-meta" id="presetTrainMeta">-</div>
              </button>
              <button class="session-preset-card hud-seg-btn" id="presetCardManga" data-session="MANGA" type="button">
                <div class="hud-seg-name">Manga</div>
                <div class="hud-seg-meta" id="presetMangaMeta">-</div>
              </button>
              <button class="session-preset-card hud-seg-btn" id="presetCardFinal" data-session="FINAL" type="button">
                <div class="hud-seg-name">Final</div>
                <div class="hud-seg-meta" id="presetFinalMeta">-</div>
              </button>
            </div>

            <div class="hud-lists">
              <div class="hud-block">
                <div class="hud-block-title">Preset (voz)</div>
                <div class="hud-line"><span class="hud-tag on">ON</span><span class="hud-text" id="presetOnText">-</span></div>
                <div class="hud-line"><span class="hud-tag off">OFF</span><span class="hud-text" id="presetOffText">-</span></div>
              </div>
              <div class="hud-block">
                <div class="hud-block-title">Ahora (voz)</div>
                <div class="hud-line"><span class="hud-tag on">ON</span><span class="hud-text" id="nowOnText">-</span></div>
                <div class="hud-line"><span class="hud-tag off">OFF</span><span class="hud-text" id="nowOffText">-</span></div>
              </div>
            </div>
          </div>
        </div>

        <div class="rd-mode-row mode-pro-only" role="group" aria-label="Modo del Race Director">
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeMinimal" title="Pro Minimal">A Minimal</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeStratega" title="Pro Estratega">B Estratega</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeCoach" title="Pro Coach">C Coach</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeSarca" title="Sarc√°stico">D Sarc√°stico</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeEngineer" title="Ingeniero">E Ingeniero</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="rdModeHype" title="Hype">F Hype</button>
        </div>


        <div class="controls-label mode-pro-only">üéôÔ∏è Auto Locutor (sin piloto)</div>
        <div class="rd-mode-row mode-pro-only" role="group" aria-label="Modo del Auto Locutor">
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorPro" title="Locutor PRO serio">PRO</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorPicante" title="Picante light">Picante</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorEngineer" title="Ingeniero de carrera">Ingeniero</button>
          <button class="btn-secondary btn-hot rd-mode btn-mode" id="autoLocutorNarrativo" title="Locutor TV (narrativa pro)">TV</button>
        </div>


        <div class="precision-row mode-pro-only">
                  <div class="controls-label">Precisi√≥n de lectura del tiempo</div>
                  <div class="precision-buttons">
                    <div class="precision-badge active" data-precision="1">1 d√©cima</div>
                    <div class="precision-badge" data-precision="2">2 d√©cimas</div>
                    <div class="precision-badge" data-precision="3">3 d√©cimas</div>
                  </div>
                  <select id="precisionSelect" class="spotter-select" style="display:none">
                    <option value="1" selected>1 d√©cima</option>
                    <option value="2">2 d√©cimas</option>
                    <option value="3">3 d√©cimas</option>
                  </select>
                </div>

      </section>

      <section class="spotter-section mode-pro-only" id="messagesPanel">
  <div class="controls-label" style="margin-bottom:2px;">Mensajes del spotter</div>

  
  <div class="spotter-master">
    <button id="presetRdProBtn" type="button" class="spotter-master-btn preset" title="Preset: RD PRO limpio (habla lo importante, sin spam)">RD PRO</button>
    <button id="presetRdShowBtn" type="button" class="spotter-master-btn preset" title="Preset: RD SHOW (m√°s emoci√≥n, m√°s narrativa)">RD SHOW</button>
    <button id="toggleAllMsgsBtn" type="button" class="spotter-master-btn" title="Prender o apagar todos los mensajes (excepto Laps)">TODO</button>
  </div>

  <div class="usage-panel" id="usagePanel" style="display:none;">
    <div class="usage-title">Uso (esta sesi√≥n)</div>
    <div class="usage-grid" id="usageGrid"></div>
  </div>

<div class="spotter-cat" data-cat="essential">
    <div class="spotter-cat-head"><span class="cat-dot"></span>Esenciales</div>
    <div class="spotter-grid">
      <div class="spotter-btn active lock" data-flag="laps"><span>‚è±</span>Laps</div>
<div class="spotter-btn active" data-flag="blueflag" title="Azul: avisa lapeos/trafico (bandera azul)"><span>üü¶</span>Azul</div>
      <div class="spotter-btn active" data-flag="ritmo" title="Ritmo: avisa si vienes mejorando o si te caes (comparado con tu promedio reciente)"><span>üìâ</span>Ritmo +/-</div>
<div class="spotter-btn" data-flag="streak" title="Racha: avisa cuando haces una racha consistente dentro de +0.2/+0.5s de tu best"><span>üéØ</span>Racha</div>
<div class="spotter-btn" data-flag="estlap" title="Est: tiempo estimado al final (si el feed lo trae)"><span>üßÆ</span>Est</div>
      <div class="spotter-btn" data-flag="leadergap" title="Lider: gap al lider, cambios de lider y contexto de punta"><span>üëë</span>Lider</div>
      <div class="spotter-btn" data-flag="podium" title="Podio: llamadas enfocadas al Top 3 (en Finales, suele ser lo mas caliente)"><span>üèÖ</span>Podio</div>
    </div>
  </div>

  <div class="spotter-cat" data-cat="battle">
    <div class="spotter-cat-head"><span class="cat-dot"></span>Batalla</div>
    <div class="spotter-grid">
      <div class="spotter-btn" data-flag="pos" title="Pos: cambios de posicion (ganas/pierdes), y pases importantes en Auto"><span>üèÅ</span>Pos</div>
      <div class="spotter-btn" data-flag="gaps" title="Diferencia: gap con el de adelante y con el de atras (segundos o vueltas)"><span>üìè</span>Gap</div>
<div class="spotter-btn" data-flag="attack" title="Ataque: narrativa cuando tu gap al de adelante cae y estas para intentarlo"><span>üî•</span>Ataque</div>
      <div class="spotter-btn" data-flag="defense" title="Defensa: narrativa cuando te vienen recortando y toca aguantar"><span>üõ°Ô∏è</span>Defensa</div>
    </div>
  </div>

  <div class="spotter-cat" data-cat="summary">
    <div class="spotter-cat-head"><span class="cat-dot"></span>Resumen</div>
    <div class="spotter-grid">
      <div class="spotter-btn" data-flag="total"><span>‚è≥</span>Total</div>
<div class="spotter-btn" data-flag="bestlap"><span>üèÜ</span>Best</div>
      <div class="spotter-btn" data-flag="box"><span>üßæ</span>Box</div>
      <div class="spotter-btn" data-flag="pelea"><span>ü§º</span>Pelea</div>
</div>
  </div>
</section>


    </main>
  </div>

    <!-- Manual modal -->
  <div class="manual-backdrop" id="manualBackdrop" aria-hidden="true">
    <div class="manual-panel" role="dialog" aria-modal="true" aria-label="Manual del Spotter">
      <div class="manual-top">
        <div>
          <div class="manual-title">Manual - Spotter_5.2.22</div>
          <div class="manual-sub">TV para transmisi√≥n. BASE para correr con bajo ruido. SUPER solo laptime + posici√≥n. ADV abre extras.</div>
        </div>
        <button class="manual-close" id="manualCloseBtn" type="button">Cerrar</button>
      </div>

      

      <div class="manual-tab active" id="manualTabPilot" role="tabpanel" aria-label="Manual para pilotos">
        <div class="manual-grid">
        <div class="manual-card">
          <h3>1) Arranque r√°pido (60s)</h3>
          <ul>
            <li>Selecciona tu piloto (se guarda y se auto-selecciona al volver).</li>
            <li>Toca <b>VOZ</b>. Debe decir "Audio listo". Si no, toca <b>TEST</b> y vuelve a tocar <b>VOZ</b>.</li>
            <li>Para correr: usa <b>BASE</b> (bajo ruido) o <b>SUPER</b> (solo laptime + posici√≥n).</li>
            <li>Si no hay movimiento en 20s, se calla. Cuando vuelve el movimiento, regresa solo.</li>
          </ul>
        </div>

        <div class="manual-card">
          <h3>2) Modos de narraci√≥n: TV, BASE y SUPER</h3>
          <ul>
            <li><b>TV</b>: narrativa para transmisi√≥n (Auto Locutor permitido).</li>
            <li><b>BASE</b>: esencial para correr (sin Auto Locutor global).</li>
            <li><b>SUPER</b>: ultra b√°sico, solo <b>laptime</b> y <b>posici√≥n</b>.</li>
            <li>Se cambia con el bot√≥n <b>TV/BASE/SUPER</b> de la barra superior.</li>
          </ul>
        </div>

        <div class="manual-card">
          <h3>3) Interfaz: BASICA vs AVANZADA (ADV)</h3>
          <ul>
            <li><b>BASICA</b>: lo m√≠nimo, limpio y r√°pido.</li>
            <li><b>ADV</b>: abre extras (Race Director, modos, precisi√≥n, etc.).</li>
            <li>Para correr, BASICA. Para configurar o stream, ADV.</li>
          </ul>
        </div>

        <div class="manual-card">
          <h3>4) Botones clave</h3>
          <ul>
            <li><b>RD</b>: filtra y prioriza mensajes (evita metralleta).</li>
            <li><b>RES</b>: una sola lectura del estado actual (sin spam).</li>
            <li><b>Q TABLA</b>: tabla general de clasificaci√≥n (mejor por piloto) desde Q1 en adelante.</li>
            <li><b>DIAG</b>: diagn√≥stico r√°pido. √ösalo si ves LIVE pero no llegan datos.</li>
          </ul>
        </div>

        <div class="manual-card">
          <h3>5) Reglas de lectura (para que no te enga√±e el cerebro)</h3>
          <ul>
            <li>En <b>MANGA/Clasificaci√≥n</b> la posici√≥n es por tiempo (cada piloto contra su reloj).</li>
            <li>Si el gap viene como <b>"+1 V"</b>, se lee "m√°s una vuelta".</li>
            <li>Si la cent√©sima es 0 (ej. 9.103), se lee "9 punto 1 flat".</li>
          </ul>
        </div>

        <div class="manual-card">
          <h3>6) Tips de pits</h3>
          <ul>
            <li>Stream: <b>TV</b> (y si quieres, RD ON).</li>
            <li>Carrera: <b>BASE</b> o <b>SUPER</b>.</li>
            <li>Problemas: abre <b>DIAG</b> y usa <b>üìã Copiar</b> para compartir el diagn√≥stico.</li>
          </ul>
        </div>
</div>
        </div>
      </div>

      


      <div class="manual-foot">
        Tip: para correr, usa BASE o SUPER y no te distraigas. Para stream, TV y a narrar rico.
      </div>
    </div>
  </div>

  
  <!-- DIAG panel (PRO) -->
  <div class="diag-panel" id="diagPanel" aria-label="Diagn√≥stico">
    <div class="diag-title">
      <div>üõ† DIAG</div>
      <div class="diag-badge" id="diagModeBadge">DIAG</div>
    </div>
    <div class="diag-sub" id="diagSubLine">Estado en vivo</div>
    <div class="diag-grid">
      <div class="diag-k">Live</div><div class="diag-v" id="diagLive">-</div>
      <div class="diag-k">Firebase</div><div class="diag-v" id="diagFirebase">-</div>
            <div class="diag-k">HTTPS</div><div class="diag-v" id="diagHttps">-</div>
      <div class="diag-k">Host</div><div class="diag-v" id="diagHost">-</div>
      <div class="diag-k">Event Key</div><div class="diag-v" id="diagKey">-</div>
<div class="diag-k">√öltima lectura</div><div class="diag-v" id="diagFetch">-</div>
      <div class="diag-k">Intervalo</div><div class="diag-v" id="diagInterval">-</div>
      <div class="diag-k">Errores seguidos</div><div class="diag-v" id="diagErr">-</div>
      <div class="diag-k">Rescate</div><div class="diag-v" id="diagRescue">-</div>
      <div class="diag-k">√öltimo error</div><div class="diag-v" id="diagLastErr">-</div>
      <div class="diag-k">Hidden</div><div class="diag-v" id="diagHidden">-</div>
      <div class="diag-k">Wake Lock</div><div class="diag-v" id="diagWake">-</div>
      <div class="diag-k">TTS</div><div class="diag-v" id="diagTTS">-</div>
      <div class="diag-k">Voz</div><div class="diag-v" id="diagVoice">-</div>
      <div class="diag-k">Ticks/min</div><div class="diag-v" id="diagTicks">-</div>
      <div class="diag-k">√öltimo cambio</div><div class="diag-v" id="diagChange">-</div>

      <div class="diag-k">Race</div><div class="diag-v" id="diagRace">-</div>
      <div class="diag-k">Sesi√≥n</div><div class="diag-v" id="diagSessionType">-</div>
      <div class="diag-k">Pilotos</div><div class="diag-v" id="diagPilots">-</div>
      <div class="diag-k">Est feed</div><div class="diag-v" id="diagEstFeed">-</div>
      <div class="diag-k">Gap/V</div><div class="diag-v" id="diagGapV">-</div>
      <div class="diag-k">Sesi√≥n</div><div class="diag-v" id="diagSessionType">-</div>
    </div>
    <pre class="diag-log" id="diagLog" aria-label="Log"></pre>
  </div>

  <!-- Q TABLA modal -->
  <div class="manual-backdrop" id="qualiBackdrop" aria-hidden="true">
    <div class="manual-panel" role="dialog" aria-modal="true" aria-label="Tabla general de clasificaci√≥n">
      <div class="manual-top">
        <div>
          <div class="manual-title">Clasificaci√≥n del d√≠a</div>
          <div class="manual-sub" id="qualiSub">Q1+ acumulado por vueltas/tiempo.</div>
        </div>
        <button class="manual-close" id="qualiCloseBtn" type="button">Cerrar</button>
      </div>

      <div style="padding:8px 12px;">
        <div class="qmeta" id="qualiMeta"></div>
        
        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin:8px 0 10px 0;">
          <div class="qchip">Mejor por piloto (Q1-Qn)</div>
        </div>
<div class="qtable-wrap">
          <table class="qtable" id="qualiTable">
            <thead>
              <tr id="qualiHeadRow"></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="muted" style="margin-top:8px; font-size:10.5px; color:var(--text-muted);">
          Se guarda al cruzar el l√≠mite de 3:00 en una nueva vuelta (solo Q (Q1 en adelante)). Se resetea al cambiar de d√≠a o al cambiar el evento.
        </div>
      </div>
    </div>
  </div>





  <script type="module">

    // =========================
    // VERSION
    // =========================
    const SPOTTER_VERSION = "5.2.22";
    const APP_NAME = `Spotter_${SPOTTER_VERSION}`;
    const APP_LABEL = APP_NAME;

    // =========================
    // SECURITY (operativo)
    // =========================
    // Nota: la seguridad real se define en Firestore Rules + App Check.
    // Esto solo agrega "guardrails" y visibilidad (DIAG) del lado cliente.
    const SECURITY_CFG = {
      requireEventKey: false,          // default OFF (no rompe tu flujo actual)
      eventKeyParam: 'k',              // ejemplo: ?k=ABC123
      eventKeyStorage: 'trm_event_key',
      appCheckClientConfigured: false  // placeholder informativo
    };

    function getEventKey(){
      try {
        const url = new URL(location.href);
        const k = url.searchParams.get(SECURITY_CFG.eventKeyParam);
        if (k && k.trim()) {
          try { localStorage.setItem(SECURITY_CFG.eventKeyStorage, k.trim()); } catch(e) {}
          return k.trim();
        }
      } catch(e) {}
      try {
        const k2 = localStorage.getItem(SECURITY_CFG.eventKeyStorage);
        return (k2 && k2.trim()) ? k2.trim() : '';
      } catch(e) {}
      return '';
    }




    // =========================
    // DIAG (PRO)
    // =========================
    let diagEnabled = false;
    let diagLastFetchMs = 0;
    let diagLastFetchAt = 0;
    let diagTickCount = 0;
    let diagTickWindowStart = Date.now();
    let diagTicksPerMin = 0;
    let diagLastRaceChangeAt = 0;

    let diagLastErrorStr = '';
    let diagLastErrorAt = 0;
    let diagLogRing = [];
    const DIAG_LOG_MAX = 50;

    function diagLogPush(msg){
      try {
        const t = new Date();
        const hh = String(t.getHours()).padStart(2,'0');
        const mm = String(t.getMinutes()).padStart(2,'0');
        const ss = String(t.getSeconds()).padStart(2,'0');
        const line = `${hh}:${mm}:${ss} ${msg}`;
        diagLogRing.push(line);
        if (diagLogRing.length > DIAG_LOG_MAX) diagLogRing = diagLogRing.slice(-DIAG_LOG_MAX);
      } catch(e) {}
    }

    function setDiagError(msg){
      try {
        const m = msg || '';
        if (m === diagLastErrorStr) return;
        diagLastErrorStr = m;
        diagLastErrorAt = m ? Date.now() : 0;
        if (m) diagLogPush('ERR ' + m);
      } catch(e) {}
    }


    function fmtAgo(msAgo){
      if (msAgo == null || !isFinite(msAgo)) return '-';
      const s = Math.max(0, Math.round(msAgo/1000));
      if (s < 60) return s + 's';
      const m = Math.floor(s/60);
      const r = s%60;
      return m + 'm ' + r + 's';
    }

    function setDiagEnabled(on){
      diagEnabled = !!on;
      try { localStorage.setItem('spotter_diag_enabled', diagEnabled ? '1' : '0'); } catch(e) {}
      const p = document.getElementById('diagPanel');
      const b = document.getElementById('diagToggleBtn');
      if (p) p.classList.toggle('on', diagEnabled);
      if (b) b.classList.toggle('active', diagEnabled);
      if (diagEnabled) { try { updateDiagPanel(); } catch(e) {} }
    }

    function loadDiagPref(){
      try {
        const v = localStorage.getItem('spotter_diag_enabled');
        setDiagEnabled(v === '1');
      } catch(e) {
        setDiagEnabled(false);
      }
    }

    function updateDiagPanel(){
      if (!diagEnabled) return;
      const now = Date.now();

      const elLive = document.getElementById('diagLive');
      const elFb   = document.getElementById('diagFirebase');
      const elHttps= document.getElementById('diagHttps');
      const elHost = document.getElementById('diagHost');
      const elKey  = document.getElementById('diagKey');
      const elFetch= document.getElementById('diagFetch');
      const elInt  = document.getElementById('diagInterval');
      const elErr  = document.getElementById('diagErr');
      const elHid  = document.getElementById('diagHidden');
      const elWake = document.getElementById('diagWake');
      const elTTS  = document.getElementById('diagTTS');
      const elRaceX = document.getElementById('diagRace');
      const elSesType = document.getElementById('diagSession');
      const elPilX  = document.getElementById('diagPilots');
      const elEstFX = document.getElementById('diagEstFeed');
      const elGapVX = document.getElementById('diagGapV');

const elVoice= document.getElementById('diagVoice');
      const elTicks= document.getElementById('diagTicks');
      const elChg  = document.getElementById('diagChange');
      const elSes  = document.getElementById('diagSessionType');
      const elRes  = document.getElementById('diagRescue');
      const elLErr = document.getElementById('diagLastErr');
      const elLog  = document.getElementById('diagLog');

      try { if (elLive) elLive.textContent = (typeof liveDot !== 'undefined' && liveDot && liveDot.classList.contains('on')) ? 'ON' : 'OFF'; } catch(e) {}
      try { if (elFb) elFb.textContent = (__firebaseOk && db) ? 'OK' : 'OFF'; } catch(e) {}

      try { if (elHttps) elHttps.textContent = (location.protocol === 'https:') ? 'YES' : 'NO'; } catch(e) {}
      try {
        if (elHost) {
          const h = location.host || '(file)';
          elHost.textContent = (h.length > 18) ? (h.slice(0,18) + '‚Ä¶') : h;
        }
      } catch(e) {}
      try {
        if (elKey) {
          const k = getEventKey();
          elKey.textContent = k ? 'SET' : '-';
        }
      } catch(e) {}


      const fetchAgo = diagLastFetchAt ? (now - diagLastFetchAt) : null;
      if (elFetch) elFetch.textContent = (diagLastFetchMs ? (diagLastFetchMs + 'ms') : '-') + ' ¬∑ hace ' + fmtAgo(fetchAgo);

      try { if (elInt) elInt.textContent = (typeof pollLastIntervalMs !== 'undefined' ? (pollLastIntervalMs + 'ms') : '-'); } catch(e) {}
      try { if (elErr) elErr.textContent = (typeof pollConsecutiveErrors !== 'undefined' ? String(pollConsecutiveErrors) : '-'); } catch(e) {}
      if (elHid) elHid.textContent = document.hidden ? 'YES' : 'NO';
      try { if (elWake) elWake.textContent = (wakeLockSentinel ? 'ON' : 'OFF'); } catch(e) {}

      const hasTTS = !!(window.speechSynthesis && typeof window.speechSynthesis.speak === 'function');
      if (elTTS) elTTS.textContent = hasTTS ? 'OK' : 'NO';

      try {
        const st = (typeof voiceMasterEnabled !== 'undefined' && voiceMasterEnabled) ? 'ON' : 'OFF';
        if (elVoice) elVoice.textContent = st;
      } catch(e) {}

      if (elTicks) elTicks.textContent = (diagTicksPerMin ? (diagTicksPerMin + '/min') : '-');

      const chgAgo = diagLastRaceChangeAt ? (now - diagLastRaceChangeAt) : null;
      if (elChg) elChg.textContent = diagLastRaceChangeAt ? ('hace ' + fmtAgo(chgAgo)) : '-';


      // --- DIAG: inspecci√≥n del feed (para validar watcher) ---
      try {
        const rr = window.__lastRawRace || null;
        const cd = rr && Array.isArray(rr.classification) ? rr.classification : [];
        const raceName = rr && rr.raceName ? String(rr.raceName) : '';
        const rn = raceName.toLowerCase();
        let sesType = 'OTRO';
        if (rn.includes('manga') || rn.includes('q') || rn.includes('qual') || rn.includes('clas')) sesType = 'MANGA/Q';
        else if (rn.includes('final')) sesType = 'FINAL';
        else if (rn.includes('entren') || rn.includes('practice') || rn.includes('training')) sesType = 'ENTRENO';

        let hasEst = false;
        for (const r of cd) {
          const el = Number(r && r.estLap || 0) || 0;
          const et = String(r && r.estTime || '').trim();
          if (el > 0) { hasEst = true; break; }
          if (et && et !== '00.000' && et !== '0' && et !== '0.000' && et !== '00:00.000') { hasEst = true; break; }
        }

        let hasV = false;
        for (const r of cd) {
          const g = String(r && r.gap || '');
          const d = String(r && r.diff || '');
          const s = (g + ' ' + d).toLowerCase();
          if (s.includes('+1 v') || s.includes('+2 v') || s.includes('+3 v') || s.includes('lap')) { hasV = true; break; }
        }

        if (elRaceX) elRaceX.textContent = raceName || '-';
        if (elSesType) elSesType.textContent = sesType;
        if (elPilX)  elPilX.textContent  = cd.length ? String(cd.length) : '-';
        if (elEstFX) elEstFX.textContent = hasEst ? 'SI' : 'NO';
        if (elGapVX) elGapVX.textContent = hasV ? 'SI' : 'NO';
      } catch(e) {}

      try {
        if (elSes) {
          const nm = (raceData && raceData.raceName) ? raceData.raceName : '';
          elSes.textContent = nm ? nm.slice(0, 24) : '-';
        }
      } catch(e) {}
      try {
        if (elRes) {
          if (typeof rescueMode !== 'undefined' && rescueMode) {
            const ago = rescueSince ? (now - rescueSince) : 0;
            elRes.textContent = 'ON ' + fmtAgo(ago);
          } else {
            elRes.textContent = 'OFF';
          }
        }
      } catch(e) {}

      try {
        if (elLErr) {
          if (typeof diagLastErrorStr !== 'undefined' && diagLastErrorStr) {
            const ago = diagLastErrorAt ? (now - diagLastErrorAt) : null;
            elLErr.textContent = diagLastErrorStr + (ago!=null ? (' (hace ' + fmtAgo(ago) + ')') : '');
          } else {
            elLErr.textContent = '-';
          }
        }
      } catch(e) {}

      try {
        if (elLog) {
          if (typeof diagLogRing !== 'undefined' && diagLogRing && diagLogRing.length) {
            const tail = diagLogRing.slice(-10);
            elLog.textContent = tail.join('\n');
          } else {
            elLog.textContent = '';
          }
        }
      } catch(e) {}

    }



    // Pintar versi√≥n en UI
    window.addEventListener("DOMContentLoaded", () => {
      const el = document.getElementById("appVersion");
      if (el) el.textContent = APP_LABEL;
      try { const rt = document.getElementById('raceTitleText'); if (rt && (!raceData || !raceData.raceName)) rt.textContent = APP_LABEL; } catch(e) {}
      // tambi√©n alinear title del documento
      try { document.title = APP_LABEL; } catch(e) {}
      
      // manual title
      try {
        const mt = document.querySelector('#manualBackdrop .manual-title');
        if (mt) mt.textContent = `Manual - ${APP_LABEL}`;
      } catch(e) {}
// DIAG toggle
      try {
        loadDiagPref();
        const diagBtn = document.getElementById('diagToggleBtn');
        if (diagBtn) diagBtn.addEventListener('click', () => setDiagEnabled(!diagEnabled));


      // MSGS toggle (categor√≠as)
      try{
        const msgsBtn = document.getElementById('msgsToggleBtn');
        const msgsState = document.getElementById('msgsStripState');
        function setMsgsOn(on){
          const v = !!on;
          document.body.classList.toggle('show-msgs', v);
          if (msgsBtn) msgsBtn.classList.toggle('active', v);
          if (msgsState) msgsState.textContent = v ? 'ON' : 'OFF';}
        // default: OFF (siempre)
        setMsgsOn(false);
        try{ localStorage.setItem('spotter_show_msgs','0'); }catch(e){}
        if (msgsBtn) msgsBtn.addEventListener('click', () => setMsgsOn(!document.body.classList.contains('show-msgs')));
      }catch(e){}
} catch(e) {}

      // Advanced UI toggle (limpieza)
      try {
        const advBtn = document.getElementById('advancedToggleBtn');
        const advKey = 'spotter_show_advanced';
        const applyAdv = (on) => {
          const v = !!on;
          document.body.classList.toggle('show-advanced', v);
          if (advBtn) {
            advBtn.classList.toggle('active', v);
            const st = document.getElementById('advStripState');
            if (st) st.textContent = v ? 'ON' : 'OFF';
          }};
        let advOn = false;
        // UI limpia: siempre inicia sin panel avanzado
        applyAdv(advOn);
        try { localStorage.setItem(advKey,'0'); } catch(e) {}
        if (advBtn) advBtn.addEventListener('click', () => applyAdv(!document.body.classList.contains('show-advanced')));
      } catch(e) {}

    });


    // =========================
    // Helpers globales (compat)
    // =========================
    // =========================
    // LocalStorage SAFE (Google Sites / iOS / privacy)
    // - Si falla, no revienta el spotter; solo no persiste config
    // =========================
    let __lsOk = true;
    function lsGet(key) {
      try { return localStorage.getItem(key); } catch (e) { __lsOk = false; return null; }
    }
    function lsSet(key, value) {
      try { localStorage.setItem(key, value); return true; } catch (e) { __lsOk = false; return false; }
    }
    function lsRemove(key) {
      try { localStorage.removeItem(key); } catch (e) { __lsOk = false; }
    }

    function groupOf(msgId) {
      const id = String(msgId || '').toLowerCase().trim();
      if (!id) return 'misc';
      // Esenciales
      if (['laps','blueflag','ritmo_up','ritmo_down','ritmo','streak','estlap','leader','podium','bestlap'].includes(id)) return 'ess';
      // Batalla
      if (['pos','gaps','attack','defense','fight'].includes(id)) return 'bat';
      // Resumen
      if (['total','box'].includes(id)) return 'sum';
      return 'misc';
    }

    // =========================
    // Auditor√≠a de narraciones (conteo por categor√≠a, esta sesi√≥n)
    // =========================
    const narrUsage = Object.create(null);
    function __esc(s){
      return String(s||'').replace(/[&<>"']/g, (c)=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
    }
    function bumpNarrUsage(cat){
      const k0 = String(cat||'').trim();
      if (!k0) return;
      narrUsage[k0] = (narrUsage[k0]||0) + 1;
      try { renderNarrUsage(); } catch(e) {}
    }
    function renderNarrUsage(){
      const panel = document.getElementById('usagePanel');
      const grid  = document.getElementById('usageGrid');
      if (!panel || !grid) return;
      // agrupar por bot√≥n (m√°s √∫til que ids internos)
      const grouped = Object.create(null);
      for (const k of Object.keys(narrUsage)) {
        const n = narrUsage[k] || 0;
        if (!n) continue;
        // AUTO
        if (k.startsWith('auto:')) {
          const kk = 'AUTO ' + k.slice(5);
          grouped[kk] = (grouped[kk]||0) + n;
          continue;
        }
        const g = groupOf(k);
        // Normalizaciones para que cuadre con los botones
        const kBtn = (k === 'leader') ? 'leadergap' : (k === 'fight') ? 'pelea' : (k === 'ritmo_up' || k === 'ritmo_down') ? 'ritmo' : k;
        const label = kBtn.toUpperCase();
        grouped[label] = (grouped[label]||0) + n;
      }
      const items = Object.entries(grouped).sort((a,b)=> (b[1]-a[1]) || a[0].localeCompare(b[0])).slice(0, 20);
      panel.style.display = 'block';
      grid.innerHTML = items.length
        ? items.map(([name, count]) => `<div class="usage-item"><span class="usage-k">${__esc(name)}</span><b class="usage-v">${count}</b></div>`).join('')
        : `<div class="usage-empty">A√∫n sin datos. Habla una vuelta y se llena.</div>`;
    }

    function say(text, opts = {}) {
      // Alias para compatibilidad (algunos m√≥dulos llaman "say")
      return enqueueSpeech(text, opts);
    }

    // =========================
    // Firebase SDK (dynamic import) - evita que un fallo de red/bloqueo truene TODO el spotter
    // =========================
    let initializeApp = null;
    let initializeFirestore = null;
    let doc = null;
    let getDoc = null;
    let __firebaseSdkReady = false;

    async function ensureFirebaseSdk() {
      if (__firebaseSdkReady) return true;
      try {
        const appMod = await import("https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js");
        const fsMod  = await import("https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js");
        initializeApp = appMod.initializeApp;
        initializeFirestore = fsMod.initializeFirestore;
        doc = fsMod.doc;
        getDoc = fsMod.getDoc;
        __firebaseSdkReady = true;
        return true;
      } catch (e) {
        __firebaseSdkReady = false;
        console.error("Firebase SDK no carg√≥ (red/bloqueador/CSP)", e);
        return false;
      }
    }


    const firebaseConfig = {
      apiKey: "AIzaSyBaySYvIxH8JsvXCETv3XwVdNecJY1ez2c",
      authDomain: "turbo-racing-zround.firebaseapp.com",
      projectId: "turbo-racing-zround",
      storageBucket: "turbo-racing-zround.firebasestorage.app",
      messagingSenderId: "628478462576",
      appId: "1:628478462576:web:c2dbc45c95bbe362ce42b5"
    };

    // Firebase runtime init (se hace en bootstrap, despu√©s de cargar SDK)
    let appFB = null;
    let db = null;
    let __firebaseOk = false;

    async function initFirebaseRuntime() {
      try {
        const ok = await ensureFirebaseSdk();
        if (!ok) throw new Error("Firebase SDK no disponible");
        if (!initializeApp || !initializeFirestore || !doc || !getDoc) {
          throw new Error("Firebase SDK incompleto");
        }
        appFB = initializeApp(firebaseConfig);
        db = initializeFirestore(appFB, {
          experimentalForceLongPolling: true,
          useFetchStreams: false
        });
        __firebaseOk = true;
        return true;
      } catch (e) {
        __firebaseOk = false;
        console.error("Firebase init fall√≥", e);
        return false;
      }
    }

    const raceTitleMain   = document.getElementById('raceTitleMain');
    const raceTitleText   = document.getElementById('raceTitleText');
    const raceModeBadge   = document.getElementById('raceModeBadge');
    const raceSubtitle    = document.getElementById('raceSubtitle');
    const raceInfo        = document.getElementById('raceInfo');
    const lastUpdateInfo  = document.getElementById('lastUpdateInfo');
    const liveIndicator   = document.getElementById('liveIndicator');

    const pilotSelect     = document.getElementById('pilotSelect');

    function applyPilotSelectPosTheme(pos){
      if (!pilotSelect) return;
      const classes = ['pos-none','pos-1','pos-2','pos-3','pos-top5','pos-other'];
      for (const c of classes) pilotSelect.classList.remove(c);

      const n = Number(pos);
      if (!pos || !isFinite(n) || n <= 0){
        pilotSelect.classList.add('pos-none');
        return;
      }
      if (n === 1) pilotSelect.classList.add('pos-1');
      else if (n === 2) pilotSelect.classList.add('pos-2');
      else if (n === 3) pilotSelect.classList.add('pos-3');
      else if (n <= 5) pilotSelect.classList.add('pos-top5');
      else pilotSelect.classList.add('pos-other');
    }

    const pilotNameEl     = document.getElementById('pilotName');
    const pilotMetaEl     = document.getElementById('pilotMeta');
    const posTextEl       = document.getElementById('posText');
    const gapInfoEl       = document.getElementById('gapInfo');
    const lastLapEl       = document.getElementById('lastLap');
    const bestLapEl       = document.getElementById('bestLap');
    const meanLapEl       = document.getElementById('meanLap');
    const estLapValEl      = document.getElementById('estLapVal');
    const consistencyValEl = document.getElementById('consistencyVal');
    const sigmaValEl       = document.getElementById('sigmaVal');
    const pace3ValEl      = document.getElementById('pace3Val');
    const streakValEl     = document.getElementById('streakVal');
    const lapChartEl      = document.getElementById('lapChart');
    const top3MiniGridEl  = document.getElementById('top3MiniGrid');
    const lapChartMetaEl  = document.getElementById('lapChartMeta');
    // Lap Chart - Top 3 simult√°neo en modo Auto Locutor (P1/P2/P3)
    let lapChartAutoKey = '';

    
        // === Preferencias persistentes (localStorage primero + cookie fallback + sessionStorage) ===
    // Nota iPhone/Safari: si abres el HTML como archivo (file://), iOS puede NO persistir cookies y a veces tampoco localStorage.
    // Lo m√°s estable en iPhone es abrirlo desde una URL https (hosting) para tener un "origen" fijo.

    function setCookie(name, value, days){
      try{
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        const expires = "expires=" + d.toUTCString();
        const secure = (location.protocol === 'https:') ? ';Secure' : '';
        document.cookie = name + "=" + encodeURIComponent(value) + ";" + expires + ";path=/;SameSite=Lax" + secure;
      }catch(e){}
    }
    function getCookie(name){
      try{
        const n = name + "=";
        const ca = document.cookie ? document.cookie.split(';') : [];
        for (let i=0;i<ca.length;i++){
          let c = ca[i].trim();
          if (c.indexOf(n) === 0) return decodeURIComponent(c.substring(n.length, c.length));
        }
      }catch(e){}
      return null;
    }

    function prefKey(k){ return "TRMX_SPOTTER_" + String(k||""); }

    function prefGet(k, fallback=null){
      const ck = prefKey(k);
      let v = null;

      // 1) localStorage (namespaced)
      try{ v = localStorage.getItem(ck); }catch(e){ v = null; }
      // 2) localStorage legacy (por compatibilidad de versiones anteriores)
      if (v == null){
        try{ v = localStorage.getItem(k); }catch(e){ v = null; }
      }
      // 3) cookie (fallback)
      if (v == null){
        try{ v = getCookie(ck); }catch(e){ v = null; }
      }
      // 4) sessionStorage (√∫ltimo recurso, por sesi√≥n)
      if (v == null){
        try{ v = sessionStorage.getItem(ck); }catch(e){ v = null; }
      }

      if (v == null) return fallback;
      return v;
    }

    function prefSet(k, value, days=365){
      const ck = prefKey(k);
      const v = (typeof value === 'string') ? value : JSON.stringify(value);

      // Guardar en todos los lugares posibles (no asumimos que alguno siempre funciona en iOS)
      try{ localStorage.setItem(ck, v); }catch(e){}
      try{ localStorage.setItem(k, v); }catch(e){} // legacy
      try{ sessionStorage.setItem(ck, v); }catch(e){}
      try{ setCookie(ck, v, days); }catch(e){}
    }

    // Diagn√≥stico silencioso (para iPhone)
    (function storageDiag(){
      try{
        const proto = location.protocol || '';
        // Si es file://, avisar en consola (sin molestar al usuario)
        if (proto === 'file:') {
          console.warn('[Spotter] iPhone/Safari: file:// puede NO guardar preferencias (cookies/localStorage). Recomendado: abrir desde URL https.');
        }
      }catch(e){}
    })();

function htmlEsc(s){
      return String(s == null ? '' : s)
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    function shortChipName(name){
      const n = (safeRacerName(name) || '').replace(/\s+/g,' ').trim();
      if (!n) return '-';
      return n.length > 12 ? (n.slice(0,12) + '...') : n;
    }

    function getTop3Rows(){
      try{
        const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const top = [];
        const seen = new Set();
        for (let i=0;i<rows.length && top.length<3;i++){
          const r = rows[i];
          if (!r) continue;
          const p = Number(r.pos);
          if (!isFinite(p) || p <= 0) continue;
          const k = getPilotKey(r);
          if (!k || seen.has(k)) continue;
          seen.add(k);
          top.push(r);
        }
        return top;
      }catch(e){ return []; }
    }


    function getTopRows(limit){
      try{
        const lim = Math.max(1, Math.min(50, Number(limit) || 3));
        const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const top = [];
        for (let i=0;i<rows.length && top.length<lim;i++){
          const r = rows[i];
          if (!r) continue;
          const k = getPilotKey(r);
          if (!k) continue;
          top.push(r);
        }
        return top;
      }catch(e){ return []; }
    }

    function getAutoLapChartKey(){
      const top = getTop3Rows();
      const leaderKey = top[0] ? getPilotKey(top[0]) : '';
      if (lapChartAutoKey && top.some(r => getPilotKey(r) === lapChartAutoKey)) return lapChartAutoKey;
      return leaderKey;
    }

    function renderAutoLapChartTop3(){
      if (!lapChartMetaEl) return;
      const top = getTop3Rows();
      if (!top.length){
        lapChartMetaEl.textContent = 'Sin datos';
        return;
      }
      const active = getAutoLapChartKey();
      lapChartMetaEl.innerHTML = top.map((r, i) => {
        const k = getPilotKey(r);
        const label = 'P' + (i+1);
        const nm = shortChipName(r.racerName);
        const posCls = (i===0?'pos1':(i===1?'pos2':'pos3'));
        const cls = (k === active) ? ('lap-pos-chip active ' + posCls) : ('lap-pos-chip ' + posCls);
        return '<span class="' + cls + '" data-key="' + htmlEsc(k) + '" title="' + htmlEsc(safeRacerName(r.racerName) || '') + '"><span class="lp">' + label + '</span><span class="nm">' + htmlEsc(nm) + '</span></span>';
      }).join('');
    }

    function renderAutoTop3MiniGrid(){
  if (!top3MiniGridEl) return;

  const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
  rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
  if (!rows.length){
    top3MiniGridEl.innerHTML = '';
    return;
  }

  const limit = Math.min(miniGridLimit || 3, rows.length);
  const top = rows.slice(0, limit);

  if (!window.__miniHist) window.__miniHist = new Map(); // key -> {front:[sec...], back:[sec...]}

  const parseInterval = (raw) => {
    const s0 = String(raw || '').trim();
    if (!s0 || s0 === '-' || s0 === 'LDR') return { sec:null, laps:null };
    const mV = s0.match(/([+-]?\s*\d+)\s*v/i);
    if (mV){
      const n = parseInt(String(mV[1]).replace(/\s+/g,''),10);
      if (isFinite(n)) return { sec:null, laps:Math.abs(n) };
    }
    const s = s0.toLowerCase();
    const mMas = s.match(/m[a√°]s\s+(\d+|una|un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s+vueltas?/i);
    if (mMas){
      const tok = mMas[1];
      const map = { 'una':1,'un':1,'uno':1,'dos':2,'tres':3,'cuatro':4,'cinco':5,'seis':6,'siete':7,'ocho':8,'nueve':9,'diez':10 };
      const n = /^\d+$/.test(tok) ? parseInt(tok,10) : (map[tok] || NaN);
      if (isFinite(n) && n > 0) return { sec:null, laps:n };
    }
    const f = parseFloat(s0.replace(/[^0-9.+-]/g,''));
    if (isFinite(f)) return { sec:Math.abs(f), laps:null };
    return { sec:null, laps:null };
  };

  const computeBattleTag = (hist, fSec, bSec) => {
    const isManga = (currentSessionInfo && currentSessionInfo.type === 'MANGA');
    const thr = isManga ? 0.55 : 0.60;

    const near2 = (arr) => {
      if (!arr || arr.length < 2) return false;
      const b = arr[arr.length - 2];
      const c = arr[arr.length - 1];
      return isFinite(b) && isFinite(c) && (b <= thr) && (c <= thr);
    };



    const atk = (fSec != null && isFinite(fSec) && fSec <= thr && (near2(hist.front) || (hist.front && hist.front.length>=1 && isFinite(hist.front[hist.front.length-1]) && hist.front[hist.front.length-1] <= thr)));
    const def = (bSec != null && isFinite(bSec) && bSec <= thr && (near2(hist.back) || (hist.back && hist.back.length>=1 && isFinite(hist.back[hist.back.length-1]) && hist.back[hist.back.length-1] <= thr)));

    if (atk && def) return 'DUEL';
    if (atk) return 'ATK';
    if (def) return 'DEF';
    return '-';
  };

  let html = '';
  html += '<table class="mini-timing" role="table" aria-label="Timing screen">';
  html += '<thead><tr>';
  html += '<th class="mt-pos">P</th>';
  html += '<th class="mt-name">Piloto</th>';
  html += '<th class="mt-laps">V</th>';
  html += '<th class="mt-last">UL</th>';
  html += '<th class="mt-gap">INT</th>';
  html += '<th class="mt-st">ST</th>';
  html += '</tr></thead><tbody>';

  for (let i=0;i<top.length;i++){
    const r = top[i];
    const posVal = Number(r.pos) || (i+1);
    const posCls = (posVal===1?'pos1':(posVal===2?'pos2':(posVal===3?'pos3':'posN')));

    const name = safeRacerName(r.racerName) || '-';
    const _nParts = String(name || '').trim().split(/\s+/).filter(Boolean);
    let name1 = name;
    let name2 = '';
    if (_nParts.length === 2){
      name1 = _nParts[0];
      name2 = _nParts[1];
    } else if (_nParts.length > 2){
      name1 = _nParts.slice(0,2).join(' ');
      name2 = _nParts.slice(2).join(' ');
    }
    const nameCell = '<span class="mt-driver"><span class="mt-line mt-line1">' + htmlEsc(name1) + '</span>' + (name2 ? ('<span class="mt-line mt-line2">' + htmlEsc(name2) + '</span>') : '') + '</span>';

    const laps = formatLaps3(r.lapcount);

    const lastMs = parseTimeToMs((typeof r.lastTime !== 'undefined' ? r.lastTime : (typeof r.lastLap !== 'undefined' ? r.lastLap : (typeof r.lastLapMs !== 'undefined' ? r.lastLapMs : 0))));
    const lastStr = (lastMs && lastMs > 0) ? msToMinSec(lastMs) : '-:--.---';

    // Intervalo al de adelante
    let intervalTxt = '‚Äî';
    if (posVal === 1) {
      intervalTxt = 'LDR';
    } else {
      const raw = (r.diff != null ? r.diff : (r.interval != null ? r.interval : ''));
      const vis = formatoGapVueltas(raw) || String(raw || '').trim();
      const info = parseInterval(vis);
      if (info.laps != null) intervalTxt = info.laps + 'V';
      else if (info.sec != null && isFinite(info.sec)) intervalTxt = toFixedFloor(info.sec, 2);
      else intervalTxt = vis || '‚Äî';
    }

    // Para estado ATK/DEF usamos front/back del top visible
    const key = getPilotKey(r) || r._id || (r.racerName || ('p'+posVal));
    const frontRaw = (posVal === 1) ? 'LDR' : (formatoGapVueltas(r.diff != null ? r.diff : (r.interval != null ? r.interval : '')) || (r.diff != null ? r.diff : (r.interval != null ? r.interval : '')));
    const frontInfo = (posVal === 1) ? {sec:null,laps:null} : parseInterval(frontRaw);

    const next = (i < top.length - 1) ? top[i+1] : null;
    const backVis = next ? (formatoGapVueltas(next.diff != null ? next.diff : (next.interval != null ? next.interval : '')) || String(next.diff != null ? next.diff : (next.interval != null ? next.interval : '')) ) : '';
    const backInfo = next ? parseInterval(backVis) : {sec:null,laps:null};

    const H = window.__miniHist;
    let hist = H.get(key);
    if (!hist) { hist = { front: [], back: [] }; H.set(key, hist); }

    const fSec = (frontInfo && frontInfo.laps == null && frontInfo.sec != null && isFinite(frontInfo.sec)) ? Number(frontInfo.sec) : null;
    const bSec = (backInfo  && backInfo.laps  == null && backInfo.sec  != null && isFinite(backInfo.sec))  ? Number(backInfo.sec)  : null;

    // Reset history if not comparable (lapped / missing), to avoid phantom ATK/DEF
    if (fSec == null) hist.front = [];
    else { hist.front.push(fSec); if (hist.front.length > 6) hist.front.splice(0, hist.front.length - 6); }

    if (bSec == null) hist.back = [];
    else { hist.back.push(bSec); if (hist.back.length > 6) hist.back.splice(0, hist.back.length - 6); }

    const state = computeBattleTag(hist, fSec, bSec);
let stateCell = state;
    if (state === 'ATK') stateCell = '<span class="st-atk">ATK</span>';
    else if (state === 'DEF') stateCell = '<span class="st-def">DEF</span>';
    else if (state === 'DUEL') stateCell = '<span class="st-duel">DUEL</span>';
    else stateCell = '<span class="st-na">-</span>';

    html += '<tr class="mt-row ' + posCls + '">';
    html +=   '<td class="mt-pos mt-mono">' + htmlEsc(String(posVal)) + '</td>';
    html +=   '<td class="mt-name">' + nameCell + '</td>';
    html +=   '<td class="mt-laps mt-mono">' + htmlEsc(laps) + '</td>';
    html +=   '<td class="mt-last mt-mono">' + htmlEsc(lastStr) + '</td>';
    html +=   '<td class="mt-gap mt-mono">' + htmlEsc(intervalTxt) + '</td>';
    html +=   '<td class="mt-st">' + stateCell + '</td>';
    html += '</tr>';
  }

  html += '</tbody></table>';
  top3MiniGridEl.innerHTML = html;
}


    try{
      lapChartMetaEl.addEventListener('click', (ev) => {
      if (selectedPilotKey) return;
        const chip = ev.target && ev.target.closest ? ev.target.closest('.lap-pos-chip') : null;
        if (!chip) return;
        const k = chip.getAttribute('data-key') || '';
        if (!k) return;
        lapChartAutoKey = k;
        // Redibuja el lap chart sin "seleccionar" piloto
        drawLapChartTop3Auto();
        renderAutoLapChartTop3();
        renderAutoTop3MiniGrid();
      });
    }catch(e){}


    const rateRange       = document.getElementById('rateRange');
    const rateDisplay     = document.getElementById('rateDisplay');
    const voiceToggleBtn  = document.getElementById('voiceToggleBtn');
    const voiceToggleBtnMini = document.getElementById('voiceToggleBtnMini');
    const voiceToggleBtns = [voiceToggleBtn, voiceToggleBtnMini].filter(Boolean);
    const speakBtn        = document.getElementById('speakBtn');
    const voiceSelect     = document.getElementById('voiceSelect');
    const ttsTestBtn     = document.getElementById('ttsTestBtn');
    const announcerSelect = document.getElementById('announcerSelect');

    const precisionSelect = document.getElementById('precisionSelect');
    const precisionBadges = document.querySelectorAll('.precision-badge');

    const wakeLockToggle  = document.getElementById('wakeLockToggle');
    const wakeLockStatus  = document.getElementById('wakeLockStatus');
    
    const backgroundToggle = document.getElementById('backgroundToggle');
    const backgroundStatus = document.getElementById('backgroundStatus');
    let backgroundModeEnabled = false;
const btnOpenGrid       = document.getElementById('btnOpenGrid');
let miniGridExpanded = false;
let miniGridLimit = 3;
try{
  miniGridExpanded = (prefGet('miniGridExpanded','0') === '1');
  miniGridLimit = miniGridExpanded ? 20 : 3;
}catch(e){}

function applyMiniGridExpandedUI(){
  try{
    if (!top3MiniGridEl) return;
    top3MiniGridEl.classList.toggle('expanded', !!miniGridExpanded);
    top3MiniGridEl.setAttribute('aria-label', miniGridExpanded ? 'Top 20 grid' : 'Top 3 grid');
  }catch(e){}
  try{
    const lab = miniGridExpanded ? 'TOP 20' : 'TOP 3';
    if (typeof top3ToggleBtn !== 'undefined' && top3ToggleBtn) top3ToggleBtn.textContent = lab;
    if (btnOpenGrid) btnOpenGrid.textContent = 'üìã ' + lab;
  }catch(e){}
}
applyMiniGridExpandedUI();

try{
  const _toggleMiniGrid = () => {
    miniGridExpanded = !miniGridExpanded;
    miniGridLimit = miniGridExpanded ? 20 : 3;
    try{ prefSet('miniGridExpanded', miniGridExpanded ? '1' : '0'); }catch(e){}
    applyMiniGridExpandedUI();
    try{ renderAutoTop3MiniGrid(); }catch(e){}
  };
  if (btnOpenGrid) btnOpenGrid.addEventListener('click', _toggleMiniGrid);
  if (typeof top3ToggleBtn !== 'undefined' && top3ToggleBtn) top3ToggleBtn.addEventListener('click', _toggleMiniGrid);
}catch(e){}

    const spotterButtons   = document.querySelectorAll('.spotter-btn');
    const basicToggleButtons = document.querySelectorAll('.basic-toggle[data-flag]');
    const uiModeBasicBtn = document.getElementById('uiModeBasicBtn');
    const uiModeProBtn   = document.getElementById('uiModeProBtn');

    const uiModeBtn      = document.getElementById('uiModeBtn');

    // ===== Narration Styles (UI simple) =====
    // TV: narrativa tipo transmisi√≥n
    // SILENT: solo lo esencial (cero ruido)
    const NARR_MODE_ORDER = ['TV','SILENT','SUPER'];

    let uiNarrationMode = (function(){
      try{
        const raw = String(lsGet('spotterNarrMode') || 'TV').toUpperCase();
        // Compat: MIN => SILENT | COACH/ENG => TV
        const v = (raw === 'MIN' || raw === 'SILENT') ? 'SILENT'
                : (raw === 'COACH' || raw === 'ENG' || raw === 'ENGINEER') ? 'TV'
                : raw;
        return NARR_MODE_ORDER.includes(v) ? v : 'TV';
      }catch(e){ return 'TV'; }
    })();

    function _setModeBtnLabel(){
      try{
        if (!uiModeBtn) return;
        uiModeBtn.textContent = (uiNarrationMode === 'SILENT' ? 'BASE' : uiNarrationMode);
        uiModeBtn.setAttribute('data-mode', uiNarrationMode);
      }catch(e){}
    }

    const MODE_ALLOWED_FLAGS = {
      // SUPER: solo laptime + posici√≥n
      SUPER:  new Set(['laps','pos']),
      // SILENT (BASE): esencial sin locutor global
      SILENT: new Set(['laps','blueflag','pos','courtesy','bestlap','leadergap','estlap']),
      // TV: transmisi√≥n
      TV:     new Set(['laps','blueflag','pos','gaps','pelea','bestlap','podium','leadergap','courtesy','ritmo','total','attack','defense'])
    };

    function applyNarrationModePreset(sessionInfo){
      const stRaw = String((sessionInfo && sessionInfo.type) ? sessionInfo.type : 'TRAIN').toUpperCase();
      // Normaliza: en este proyecto "MANGA" y "Q" son clasificaci√≥n (contra reloj)
      const st = (stRaw.includes('MANGA') || stRaw.includes('QUALI') || stRaw === 'Q') ? 'MANGA'
               : (stRaw.includes('FINAL') ? 'FINAL' : 'TRAIN');

      const allowed = MODE_ALLOWED_FLAGS[uiNarrationMode] || MODE_ALLOWED_FLAGS.TV;
      // En SUPER forzamos el set completo (no hereda toggles viejos)
      if (uiNarrationMode === 'SUPER'){
        try{
          Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k=>{ voiceSettings[k] = false; });
          voiceSettings.laps = true;
          voiceSettings.pos  = true;
          try{ applyVoiceSettingsToButtons(); }catch(e){}
          try{ saveVoiceSettings(); }catch(e){}
        }catch(e){}
        return;
      }


      // Base defaults por estilo (IMPORTANTE: no dejar todo en falso o se vuelve mudo)
      const base = {};
      Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k=>{ base[k]=false; });

      // Siempre activo
      base.laps = true;

      // Esenciales (en SUPER van OFF)
      if (uiNarrationMode !== 'SUPER'){
        base.blueflag = true;
        base.courtesy = true;
      }

      // --- Por modo / sesi√≥n ---
      if (uiNarrationMode === 'SUPER'){
        // SUPER = solo laptime + posici√≥n (sin bandera azul, sin courtesy, sin locutor)
        base.pos = true;
      } else if (uiNarrationMode === 'SILENT'){
        // SILENT = solo lo esencial, pero que SI hable en MANGA/FINAL
        base.pos = true;          // pole / posici√≥n confirmada
        base.bestlap = false;
        base.estlap  = false; // estimaci√≥n OFF por default
        base.leadergap = (st !== 'TRAIN');
      } else { // TV
        base.pos = true;                 // pole + anuncios estables
        base.bestlap = false;
        base.estlap  = false; // estimaci√≥n OFF por default
        base.leadergap = (st !== 'TRAIN');

        if (st === 'FINAL'){
          base.gaps = true;
          base.pelea = true;
          base.podium = true;
          base.ritmo = true;
        }
      }

      // Aplicar allowed (sin apagar laps)
      try{
        Object.keys(base).forEach(k=>{
          if (k === 'laps'){ voiceSettings.laps = true; return; }
          if (allowed && !allowed.has(k)) return;
          voiceSettings[k] = !!base[k];
        });
        voiceSettings.laps = true;
      }catch(e){}

      try{ applyVoiceSettingsToButtons(); }catch(e){}
      try{ saveVoiceSettings(); }catch(e){}
    }

    function setUIMode(mode, opts = {}) {
      // Siempre BASIC: interfaz simple
      basicModeEnabled = true;
      try { document.body.setAttribute('data-ui-mode', 'BASIC'); } catch(e) {}
      try { if (uiModeBasicBtn) uiModeBasicBtn.classList.add('mode-active'); } catch(e) {}
      try { if (uiModeProBtn)   uiModeProBtn.classList.remove('mode-active'); } catch(e) {}

      try { lsSet('spotterUIMode', 'BASIC'); } catch(e) {}

      try { loadVoiceSettings(); } catch(e) {}
      try { applyBasicMode(); } catch(e) {}

      try { applyVoiceSettingsToButtons(); } catch(e) {}
      try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      try { if (typeof updateConfigStatusUI === 'function') updateConfigStatusUI(); } catch(e) {}
    }

    function setNarrationMode(mode, opts = {}){
      const m = String(mode || 'TV').toUpperCase();
      uiNarrationMode = NARR_MODE_ORDER.includes(m) ? m : 'TV';
      try { document.body.setAttribute('data-narr-mode', uiNarrationMode); } catch(e) {}
      try{ if (!(opts && opts.temp)) lsSet('spotterNarrMode', uiNarrationMode); }catch(e){}
      _setModeBtnLabel();

      // Asegura UI clean
      try{ setUIMode('BASIC', {silent:true}); }catch(e){}

      // Alinear Auto Locutor + Race Director al estilo (sin recursion)
      try{
        if (!(opts && opts.fromAutoCommentator)) {
          setAutoCommentatorMode(uiNarrationMode === 'TV' ? 'tv' : 'pro', { fromNarration:true });
        }
      }catch(e){}
      try{ setRaceDirectorMode(uiNarrationMode === 'TV' ? 'coach' : 'minimal'); }catch(e){}

      // Preset por sesi√≥n + estilo
      try{
        autoSessionPresetsEnabled = true;
        applyNarrationModePreset(currentSessionInfo || {type:'TRAIN'});
      }catch(e){}
    }

    function cycleNarrationMode(){
      const i = NARR_MODE_ORDER.indexOf(uiNarrationMode);
      const next = NARR_MODE_ORDER[(i + 1) % NARR_MODE_ORDER.length];
      setNarrationMode(next);
    }
    if (uiModeBtn) uiModeBtn.addEventListener('click', cycleNarrationMode);

    // Init mode at startup
    try { _setModeBtnLabel(); } catch(e) {}
    try { setNarrationMode(uiNarrationMode, {silent:true}); } catch(e) {}


    // ===== Tema (BLOQUE 3.1) =====
    const THEME_LIST = [
      { id:'carbon-neon',        label:'Carbon Neon' },
      { id:'oled-black',         label:'OLED Black' },
      { id:'pitlane-red',        label:'Pitlane Red' },
      { id:'final-gold',         label:'Final A Gold' },
      { id:'toreo-blue',         label:'Toreo Blue' },
      { id:'cotorritos-crimson', label:'Cotorritos Crimson' },
      { id:'streamer-purple',    label:'Streamer Purple' },
      { id:'high-contrast',      label:'High Contrast' },
      { id:'retro-90s',          label:'Retro 90s' },
    ];
    const THEME_LABELS = (function(){
      const o = {};
      THEME_LIST.forEach(t=>{ o[t.id] = t.label; });
      return o;
    })();

    const themeSelect   = document.getElementById('themeSelect');
    const themeCycleBtn = document.getElementById('themeCycleBtn');
    let currentThemeChoice = 'pitlane-red';

    function computeAutoThemeFromSession(sess){
      // Auto tema pro: FINAL A = Gold, FINAL B/C = Red, MANGA = Blue, TRAIN = Carbon/OLED (noche)
      let type = 'TRAIN';
      let main = '';

      try{
        if (sess && typeof sess === 'object'){
          type = String(sess.type || 'TRAIN').toUpperCase();
          main = String(sess.main || '').toUpperCase();
        } else {
          const s = String(sess || 'TRAIN').toUpperCase();
          type = s;
        }
      }catch(e){}

      // Stream/OBS: fuerza tema streamer-purple si viene por URL o storage
      try{
        const qs = new URLSearchParams(location.search || '');
        const qStream = (qs.get('stream') === '1') || (qs.get('obs') === '1');
        let lsStream = false;
        try{ lsStream = (localStorage.getItem('tr_stream') === '1'); }catch(e){}
        if (qStream || lsStream) return 'streamer-purple';
      }catch(e){}

      const h = (new Date()).getHours();
      const isNight = (h >= 20 || h < 6);

      const t = String(type || 'TRAIN').toUpperCase();
      if (t.includes('FINAL')){
        if (main === 'A') return 'final-gold';
        return 'pitlane-red';
      }
      if (t.includes('MANGA') || t.includes('QUALI') || t === 'Q') return 'toreo-blue';
      // TRAIN / unknown
      return isNight ? 'oled-black' : 'carbon-neon';
    }

    function applyThemeChoice(choice, opts = {}){
      const ch = String(choice || 'pitlane-red');
      currentThemeChoice = ch;

      let actual = ch;
      if (ch === 'auto'){
        const autoInfo = (typeof currentSessionInfo !== 'undefined' && currentSessionInfo && currentSessionInfo.type) ? currentSessionInfo : ((typeof __lastAutoPresetType !== 'undefined' ? __lastAutoPresetType : 'TRAIN'));
        actual = computeAutoThemeFromSession(autoInfo);
      }

      try{
        const prev = document.body.getAttribute('data-theme') || '';
        if (prev !== actual) document.body.setAttribute('data-theme', actual);
      }catch(e){}

      try{
        if (themeSelect && themeSelect.value !== ch) themeSelect.value = ch;
      }catch(e){}

      try{
        const cfgTheme = document.getElementById('cfgTheme');
        if (cfgTheme){
          const actualLabel = THEME_LABELS[actual] || actual;
          cfgTheme.textContent = (ch === 'auto') ? (`Auto - ${actualLabel}`) : actualLabel;
        }
      }catch(e){}

      if (!opts.noPersist){
        try{ localStorage.setItem('tr_theme', ch); }catch(e){}
      }
    }

    (function initTheme(){
      let saved = '';
      try{ saved = localStorage.getItem('tr_theme') || ''; }catch(e){}
      const choice = saved || 'pitlane-red';
      applyThemeChoice(choice, { noPersist:true });

      if (themeSelect){
        try{ themeSelect.value = choice; }catch(e){}
        themeSelect.addEventListener('change', ()=> applyThemeChoice(themeSelect.value));
      }

      if (themeCycleBtn){
        themeCycleBtn.addEventListener('click', ()=>{
          // Si estas en Auto, cicla sobre el tema actual (no sobre Auto)
          const base = (currentThemeChoice === 'auto')
            ? computeAutoThemeFromSession((typeof currentSessionInfo !== 'undefined' && currentSessionInfo && currentSessionInfo.type) ? currentSessionInfo : ((typeof __lastAutoPresetType !== 'undefined' ? __lastAutoPresetType : 'TRAIN')))
            : (document.body.getAttribute('data-theme') || 'pitlane-red');

          const ids = THEME_LIST.map(t=>t.id);
          let i = ids.indexOf(base);
          if (i < 0) i = 0;
          const next = ids[(i + 1) % ids.length];
          applyThemeChoice(next);
        });
      }
    })();



    // BASIC toggles (solo Azul/Pos - Laps es lock)
    basicToggleButtons.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const flag = btn.getAttribute('data-flag');
        if (!flag) return;
        if (flag === 'laps') return; // lock
        voiceSettings[flag] = !voiceSettings[flag];
        try { applyVoiceSettingsToButtons(); } catch(e) {}
        saveVoiceSettings(); // guarda SOLO en BASIC key
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
        try { playBeep(voiceSettings[flag] ? 'up' : 'down'); } catch(e) {}
      });
    });


    let voiceMasterEnabled = false;
    try {
      const vme = prefGet('voiceMasterEnabled', null);
      if (vme !== null) voiceMasterEnabled = (vme === '1');
    } catch(e) {}

    const DEFAULT_VOICE_SETTINGS = {
      laps: true,       // siempre activo (no se apaga)

      // Esenciales (default)
      blueflag: true,
      courtesy: true,
      ritmo: true,
      streak: false,

      // Todo lo demas OFF por default (para no abrumar)
      pos: false,
      gaps: false,
      leadergap: false,
      podium: false,
      attack: false,
      defense: false,
      pelea: false,
      total: false,
      estlap: false,
      bestlap: false,
      box: false
    };

    // One-time: aplicar defaults de esta versi√≥n (sin pisar cada recarga)
    // - Evita que el usuario se quede con toggles viejos (todo prendido) cuando cambia de base.
    const DEFAULTS_APPLIED_KEY = 'TRM_DEFAULTS_APPLIED_' + SPOTTER_VERSION + '_BASIC';
    try{
      if (localStorage.getItem(DEFAULTS_APPLIED_KEY) === null && localStorage.getItem('spotterVoiceSettings') === null){
        localStorage.setItem('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        prefSet('spotterDecimalPrecision', '2');
        prefSet('raceDirectorEnabled', '1');
        prefSet('raceDirectorMode', 'minimal');
        prefSet('autoCommentatorMode', 'picante');
        localStorage.setItem(DEFAULTS_APPLIED_KEY, '1');
      }
    }catch(e){}


    // Defaults y migraci√≥n NO destructiva (por dispositivo)
    // - Antes reseteaba por "versi√≥n de esquema" y eso era gasolina en el fuego.
    // - Ahora: solo si no existe, se siembran defaults. Si existe, solo se rellenan faltantes.
    const SETTINGS_SCHEMA_VERSION = 'TRM_SPOTTER_SCHEMA_V1';
    try {
      const prevSchema = lsGet('spotterSettingsSchema');

      // Si es primera vez: seed defaults
      if (prevSchema === null) {
        if (lsGet('spotterVoiceSettings') === null) lsSet('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        if (lsGet('spotterDecimalPrecision') === null) lsSet('spotterDecimalPrecision', '2');
      } else {
        // Upgrade: NO sobreescribir preferencias existentes
        if (lsGet('spotterVoiceSettings') === null) lsSet('spotterVoiceSettings', JSON.stringify(DEFAULT_VOICE_SETTINGS));
        if (lsGet('spotterDecimalPrecision') === null) lsSet('spotterDecimalPrecision', '2');
      }

      // Actualizamos schema sin resetear
      lsSet('spotterSettingsSchema', SETTINGS_SCHEMA_VERSION);
    } catch (e) {}



    let voiceSettings = { ...DEFAULT_VOICE_SETTINGS };

    // ===== BASIC mode (modo simple para pilotos) =====
    // Objetivo: util y NO abrumador.
    // En BASIC: solo voz de LAPS + AZUL + POSICION (confirmada), todo lo demas en OFF.
    let basicModeEnabled = true; // Siempre inicia en BASIC (modo simple)

    function applyBasicMode() {
      if (!basicModeEnabled || (typeof uiNarrationMode !== "undefined" && uiNarrationMode !== "MIN")) return;

      // En BASIC solo apagamos ruido. Azul/Pos los puede prender/apagar el usuario.
      const keepBlue = (typeof voiceSettings.blueflag === 'boolean') ? voiceSettings.blueflag : true;
      const keepPos  = (typeof voiceSettings.pos === 'boolean') ? voiceSettings.pos : true;

            voiceSettings = { ...voiceSettings,
        laps: true,
        blueflag: keepBlue,
        pos: keepPos,

        // Todo lo demas OFF
        ritmo: false,
        streak: false,
        gaps: false,
        leadergap: false,
        podium: false,
        attack: false,
        defense: false,
        pelea: false,
        total: false,
        estlap: false,
        bestlap: false,
        box: false
      };

      // En BASIC el RD se recomienda ON y sin presets autom√°ticos, pero SIN pisar prefs del usuario
      try { raceDirectorEnabled = true; } catch(e) {}
      try { autoSessionPresetsEnabled = false; } catch(e) {}
    }
    let raceDirectorEnabled = true;
    try {
      const rdStored = prefGet('raceDirectorEnabled', null);
      if (rdStored !== null) raceDirectorEnabled = (rdStored === '1');
      else { raceDirectorEnabled = true; try { prefSet('raceDirectorEnabled','1'); } catch(e) {} }
    } catch(e) {}

        try { applyBasicMode(); } catch(e) {}

const rdToggleBtn = document.getElementById('rdToggleBtn');
    
    // Manual (ayuda)
const manualBtn       = document.getElementById('manualBtn');
const manualBackdrop  = document.getElementById('manualBackdrop');
const manualCloseBtn  = document.getElementById('manualCloseBtn');

function openManual(){
  if (!manualBackdrop) return;
  // Siempre arrancar en Pilotos (si existe)
  try { document.getElementById('manualTabPilot')?.classList?.add('active'); } catch(e) {}
  try { document.getElementById('manualTabTech')?.classList?.remove('active'); } catch(e) {}
  manualBackdrop.classList.add('open');
  manualBackdrop.setAttribute('aria-hidden','false');
}

function closeManual(){
  if (!manualBackdrop) return;
  manualBackdrop.classList.remove('open');
  manualBackdrop.setAttribute('aria-hidden','true');
}

if (manualBtn) manualBtn.addEventListener('click', openManual);
if (manualCloseBtn) manualCloseBtn.addEventListener('click', closeManual);
if (manualBackdrop) manualBackdrop.addEventListener('click', (e)=>{ if (e.target === manualBackdrop) closeManual(); });

// Copiar diagn√≥stico (JSON)
function __copyToClipboard(text){
  if (navigator.clipboard && navigator.clipboard.writeText){
    return navigator.clipboard.writeText(text);
  }
  return new Promise((resolve, reject)=>{
    try{
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.setAttribute('readonly','');
      ta.style.position = 'fixed';
      ta.style.top = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand('copy');
      document.body.removeChild(ta);
      ok ? resolve() : reject(new Error('execCommand copy failed'));
    }catch(e){ reject(e); }
  });
}

function collectDiagPayload(){
  const payload = {};
  try { payload.version = VERSION; } catch(e) {}
  try { payload.app = APP_NAME; } catch(e) {}
  try { payload.ua = navigator.userAgent; } catch(e) {}
  try { payload.lang = navigator.language; } catch(e) {}
  try { payload.time = new Date().toISOString(); } catch(e) {}

  // Pilot
  try { payload.pilot = (document.getElementById('pilotSelect')?.value || '').trim(); } catch(e) {}

  // Feed
  try{
    payload.feed = {
      connected: !!(window.__spotterConnected),
      lastUpdateMs: Number(window.__spotterLastUpdateMs||0),
      lastRaceName: String(window.__spotterLastRaceName||''),
    };
  }catch(e){}

  // RD/Locutor desde botones activos
  try{
    const rdActive = document.getElementById('rdToggleBtn')?.classList?.contains('active');
    payload.rdEnabled = rdActive ? 'ON' : 'OFF';
  }catch(e){}
  try{
    const rdModeBtn = document.querySelector('.rd-mode.btn-mode.mode-active');
    if (rdModeBtn) payload.rdModeButton = rdModeBtn.textContent.trim();
  }catch(e){}
  try{
    const autoBtn = document.querySelector('.rd-mode-row[aria-label="Modo del Auto Locutor"] .btn-mode.mode-active');
    if (autoBtn) payload.autoLocutorButton = autoBtn.textContent.trim();
  }catch(e){}

  return payload;
}

function bindCopyDiag(btn){
  if (!btn) return;
  btn.addEventListener('click', async ()=>{
    try{
      const payload = collectDiagPayload();
      const txt = JSON.stringify(payload, null, 2);
      await __copyToClipboard(txt);
      const old = btn.textContent;
      btn.textContent = '‚úÖ Copiado';
      setTimeout(()=>{ try{ btn.textContent = old; }catch(e){} }, 1200);
    }catch(e){
      const old = btn.textContent;
      btn.textContent = '‚ùå Error';
      setTimeout(()=>{ try{ btn.textContent = old; }catch(e){} }, 1200);
      try{ console.error('copy diag failed', e); }catch(_e){}
    }
  });
}

bindCopyDiag(document.getElementById('copyDiagBtn'));
bindCopyDiag(document.getElementById('copyDiagBtnManual'));

// Q TABLA (Clasificaci√≥n general del d√≠a)
    const qualiBtn       = document.getElementById('qualiBtn');
    const qualiBackdrop  = document.getElementById('qualiBackdrop');
    const qualiCloseBtn  = document.getElementById('qualiCloseBtn');
    const qualiMeta      = document.getElementById('qualiMeta');
    const qualiTable     = document.getElementById('qualiTable');
    const qualiSub       = document.getElementById('qualiSub');
    const qualiViewSel   = document.getElementById('qualiViewSel');
    const qualiSessionSel= document.getElementById('qualiSessionSel');
    const qualiSessionWrap = document.getElementById('qualiSessionWrap');


    function openQuali(){
      if (!qualiBackdrop) return;
      try { renderQualiTable(); } catch(e) {}
      qualiBackdrop.classList.add('open');
      qualiBackdrop.setAttribute('aria-hidden','false');
    }
    function closeQuali(){
      if (!qualiBackdrop) return;
      qualiBackdrop.classList.remove('open');
      qualiBackdrop.setAttribute('aria-hidden','true');
    }

    if (qualiBtn) qualiBtn.addEventListener('click', openQuali);
    if (qualiCloseBtn) qualiCloseBtn.addEventListener('click', closeQuali);
    if (qualiViewSel) qualiViewSel.addEventListener('change', ()=>{ try{ renderQualiTable(); }catch(e){} });
    if (qualiSessionSel) qualiSessionSel.addEventListener('change', ()=>{ try{ renderQualiTable(); }catch(e){} });

    if (qualiBackdrop) qualiBackdrop.addEventListener('click', (e)=>{ if (e.target === qualiBackdrop) closeQuali(); });

// HARD BIND Q TABLA: captura clicks aunque haya stopPropagation (y da feedback visual)
try{
  document.addEventListener('click', (ev)=>{
    const btn = (ev.target && ev.target.closest) ? ev.target.closest('#qualiBtn') : null;
    if (!btn) return;
    ev.preventDefault();
    ev.stopPropagation();
    try{
      const txtEl = btn.querySelector('.cbtn-txt') || btn;
      const old = txtEl.textContent;
      txtEl.textContent = 'Q...';
      setTimeout(()=>{ try{ txtEl.textContent = old; }catch(e){} }, 350);
    }catch(e){}
    try{ openQuali(); }catch(e){}
  }, true);
}catch(e){}

// Tecla r√°pida: Q abre/cierra Q TABLA (si no est√°s escribiendo)
try{
  window.addEventListener('keydown', (ev)=>{
    if ((ev.key || '').toLowerCase() !== 'q') return;
    const ae = document.activeElement;
    if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT')) return;
    try{
      if (qualiBackdrop && qualiBackdrop.classList.contains('open')) closeQuali();
      else openQuali();
    }catch(e){}
  });
}catch(e){}




window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') { closeManual(); closeQuali(); } });
// URL param: ?manual=1
    try{
      const qp = new URLSearchParams(location.search);
      if (qp.get('manual') === '1') setTimeout(openManual, 250);
    }catch(e){}
let raceDirectorMode = 'minimal';
    try {
      const m = prefGet('raceDirectorMode', null);
      if (m === 'minimal' || m === 'stratega' || m === 'coach' || m === 'sarca' || m === 'engineer' || m === 'hype') raceDirectorMode = m;
      else { raceDirectorMode = 'minimal'; try { prefSet('raceDirectorMode','minimal'); } catch(e) {} }
    } catch(e) {}

    const rdModeMinimal  = document.getElementById('rdModeMinimal');
    const rdModeStratega = document.getElementById('rdModeStratega');
    const rdModeCoach    = document.getElementById('rdModeCoach');
    const rdModeSarca    = document.getElementById('rdModeSarca');
    const rdModeEngineer = document.getElementById('rdModeEngineer');
    const rdModeHype     = document.getElementById('rdModeHype');

    // ===== Auto Locutor (sin piloto) - 3 estilos
    let autoCommentatorMode = 'tv';
    let autoLocutorActive = false; // true cuando est√° activo Auto Locutor (sin seguimiento)
    try {
      const m = prefGet('autoCommentatorMode', null);
      if (m === 'tv') autoCommentatorMode = 'tv';
      else if (m === 'narrativo') { autoCommentatorMode = 'tv'; try { prefSet('autoCommentatorMode','tv'); } catch(e) {} }
      else if (m === 'pro' || m === 'picante' || m === 'engineer') autoCommentatorMode = m;
      else { autoCommentatorMode = 'tv'; try { prefSet('autoCommentatorMode','tv'); } catch(e) {} }
    } catch(e) {}

    const autoLocutorPro      = document.getElementById('autoLocutorPro');
    const autoLocutorPicante  = document.getElementById('autoLocutorPicante');
    const autoLocutorEngineer = document.getElementById('autoLocutorEngineer');
    const autoLocutorNarrativo = document.getElementById('autoLocutorNarrativo');

    function updateAutoCommentatorButtons() {
      const setActive = (el, on) => {
        if (!el) return;
        el.classList.toggle('active', !!on);
        el.setAttribute('aria-pressed', on ? 'true' : 'false');
      };
      setActive(autoLocutorPro,      autoCommentatorMode === 'pro');
      setActive(autoLocutorPicante,  autoCommentatorMode === 'picante');
      setActive(autoLocutorEngineer, autoCommentatorMode === 'engineer');
      // Narrativo = TV
      setActive(autoLocutorNarrativo, (autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo'));
    }

    function setAutoCommentatorMode(mode, opts = {}) {
      if (!(mode === 'pro' || mode === 'picante' || mode === 'engineer' || mode === 'tv' || mode === 'narrativo')) return;
      if (mode === 'narrativo') mode = 'tv';
      const fromNarration = !!(opts && opts.fromNarration);

      autoCommentatorMode = mode;
      try { autoLocutorActive = true; } catch(e) {}

      // Si esto viene desde setNarrationMode, NO forzar TV ni tocar seguimiento (evita loops)
      if (!fromNarration) {
        // Auto Locutor requiere modo TV para pasar filtros de narraci√≥n
        try { setNarrationMode('TV', { silent:true, temp:true, fromAutoCommentator:true }); } catch(e) {}

        // Al activar Auto Locutor por click, salimos de seguimiento para que el locutor mande
        try {
          if (typeof selectPilotByKey === 'function') {
            selectPilotByKey('', { announce:false });
          } else {
            try { selectedPilotKey = ''; } catch(e) {}
            try { if (pilotSelect) pilotSelect.value = ''; } catch(e) {}
            try { prefSet('spotterSelectedPilotKey',''); } catch(e) {}
          }
        } catch(e) {}
      }

      try { prefSet('autoCommentatorMode', mode); } catch(e) {}
      updateAutoCommentatorButtons();

      // Confirmaci√≥n corta (siempre)
      try { enqueueSpeech('Auto locutor activado.', { key:'sys_autolocutor_on', cat:'system', prio: 90, ttlMs: 2500, cooldownMs: 2000, interrupt:false, dedupe:true }); } catch(e) {}
    }

    if (autoLocutorPro)      autoLocutorPro.addEventListener('click', () => setAutoCommentatorMode('pro'));
    if (autoLocutorPicante)  autoLocutorPicante.addEventListener('click', () => setAutoCommentatorMode('picante'));
    if (autoLocutorEngineer) autoLocutorEngineer.addEventListener('click', () => setAutoCommentatorMode('engineer'));
    if (autoLocutorNarrativo) autoLocutorNarrativo.addEventListener('click', () => setAutoCommentatorMode('tv'));


function updateRdModeButtons() {
      const setActive = (el, on) => {
        if (!el) return;
        el.classList.toggle('active', !!on);
        el.setAttribute('aria-pressed', on ? 'true' : 'false');
};
      setActive(rdModeMinimal,  raceDirectorMode === 'minimal');
      setActive(rdModeStratega, raceDirectorMode === 'stratega');
      setActive(rdModeCoach,    raceDirectorMode === 'coach');
      setActive(rdModeSarca,    raceDirectorMode === 'sarca');
      setActive(rdModeEngineer, raceDirectorMode === 'engineer');
      setActive(rdModeHype,     raceDirectorMode === 'hype');
    }
    function setRaceDirectorMode(mode) {
      if (!(mode === 'minimal' || mode === 'stratega' || mode === 'coach' || mode === 'sarca' || mode === 'engineer' || mode === 'hype')) return;
      raceDirectorMode = mode;
      try { prefSet('raceDirectorMode', mode); } catch(e) {}
      updateRdModeButtons();
    updateAutoCommentatorButtons();
      try { playBeep('tap'); } catch(e) {}
    }
    if (rdModeMinimal)  rdModeMinimal.addEventListener('click',  () => setRaceDirectorMode('minimal'));
    if (rdModeStratega) rdModeStratega.addEventListener('click', () => setRaceDirectorMode('stratega'));
    if (rdModeCoach)    rdModeCoach.addEventListener('click',    () => setRaceDirectorMode('coach'));
    if (rdModeSarca)    rdModeSarca.addEventListener('click',    () => setRaceDirectorMode('sarca'));
    if (rdModeEngineer) rdModeEngineer.addEventListener('click', () => setRaceDirectorMode('engineer'));
    if (rdModeHype)     rdModeHype.addEventListener('click',     () => setRaceDirectorMode('hype'));
updateRdModeButtons();
    updateAutoCommentatorButtons();

    
// Selecci√≥n "shuffle bag" anti repetici√≥n (m√°s variaci√≥n real)
const rdPhraseBag = new Map();

function rdShuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

function rdPick(variants, key) {
  if (!variants || !variants.length) return '';
  const k = key || 'rd';

  // Dedupe de textos id√©nticos (evita bancos con clones)
  const uniq = [];
  const seen = new Set();
  for (let i = 0; i < variants.length; i++) {
    const t = String(variants[i]);
    if (!seen.has(t)) { seen.add(t); uniq.push(t); }
  }
  if (!uniq.length) return '';

  let st = rdPhraseBag.get(k);
  if (!st || !Array.isArray(st.bag) || st.srcLen !== uniq.length) {
    st = { bag: [], recent: [], srcLen: uniq.length };
  }

  const RECENT_N = Math.min(6, Math.max(2, Math.floor(uniq.length / 4)));

  if (!st.bag.length) {
    const idxs = [];
    for (let i = 0; i < uniq.length; i++) idxs.push(i);
    rdShuffleInPlace(idxs);

    // Si hay suficiente variedad, empuja lo "reci√©n usado" al final del saco
    if (st.recent && st.recent.length && uniq.length > (st.recent.length + 2)) {
      const rec = new Set(st.recent);
      const a = idxs.filter(i => !rec.has(i));
      const b = idxs.filter(i =>  rec.has(i));
      st.bag = a.concat(b);
    } else {
      st.bag = idxs;
    }
  }

  const pickIdx = st.bag.shift();
  st.recent = st.recent || [];
  st.recent.push(pickIdx);
  while (st.recent.length > RECENT_N) st.recent.shift();

  rdPhraseBag.set(k, st);
  return uniq[pickIdx % uniq.length];
}

// ---- RD helpers (persuasivo + preciso, sin metralleta) ----
    function rdSafeName(name) {
      const n = safeRacerName(name);
      return n || 'el de adelante';
    }
    function rdSec(sec) {
      if (sec == null || !isFinite(sec)) return '';
      const v = Math.max(0, sec);
      return toFixedFloor(v, decimalPrecision);
    }
    function rdExtractPos(txt) {
      const m = String(txt || '').match(/P\s*(\d+)/i);
      if (m) return parseInt(m[1], 10) || 0;
      const n = parseInt(String(txt || '').replace(/\D+/g,''), 10) || 0;
      return n;
    }
    function rdTrimWords(text, maxWords) {
      const t = String(text || '').trim();
      if (!t) return '';
      const parts = t.split(/\s+/).filter(Boolean);
      if (parts.length <= maxWords) return t;
      const cut = parts.slice(0, maxWords).join(' ');
      return cut.replace(/[,:;\-]+$/,'') + '...';
    }
    function rdBuildCtx(baseCtx, p) {
      const ctx = baseCtx || {};
      const posNow = Number((p && (p.pos || p.position)) || 0) || 0;
      const frontName = ctx.frontName || '';
      const backName  = ctx.backName || '';
      const frontSec  = ctx.frontSec;
      const backSec   = ctx.backSec;
      return {
        ...ctx,
        posNow,
        frontName,
        backName,
        frontSec,
        backSec,
        frontNameSafe: rdSafeName(frontName),
        backNameSafe: rdSafeName(backName),
        frontSecStr: rdSec(frontSec),
        backSecStr: rdSec(backSec),
      };
    }
    // Banco de frases por modo (A/B/C) - m√°s humano y distinto
    
    // Banco de frases por modo - humano, persuasivo y con acci√≥n
    // Nota: las plantillas aceptan {frontNameSafe}, {backNameSafe}, {frontSecStr}, {backSecStr}, {posNow}
    const RD_PHRASES = {
      minimal: {
        manga: [
          'Manga, vuelta limpia y sin errores.',
          'Manga, vuelta limpia y sin errores. Mant√©n el plan.',
          'Manga, vuelta limpia y sin errores. Sin regalar nada.',
          'Manga, vuelta limpia y sin errores. Sin prisa, sin pausa.',
          'Manga, vuelta limpia y sin errores. Control total.',
          'Manga, suma vueltas y cuida la trazada.',
          'Manga, suma vueltas y cuida la trazada. Mant√©n el plan.',
          'Manga, suma vueltas y cuida la trazada. Sin regalar nada.',
          'Manga, suma vueltas y cuida la trazada. Sin prisa, sin pausa.',
          'Manga, suma vueltas y cuida la trazada. Control total.',
          'Manga, ritmo estable, no te salgas.',
          'Manga, ritmo estable, no te salgas. Mant√©n el plan.',
          'Manga, ritmo estable, no te salgas. Sin regalar nada.',
          'Manga, ritmo estable, no te salgas. Sin prisa, sin pausa.',
          'Manga, ritmo estable, no te salgas. Control total.',
          'Manga, evita tr√°fico y busca aire limpio.',
          'Manga, evita tr√°fico y busca aire limpio. Mant√©n el plan.',
          'Manga, evita tr√°fico y busca aire limpio. Sin regalar nada.',
          'Manga, evita tr√°fico y busca aire limpio. Sin prisa, sin pausa.',
          'Manga, evita tr√°fico y busca aire limpio. Control total.',
          'Manga, todo es consistencia.',
          'Manga, todo es consistencia. Mant√©n el plan.',
          'Manga, todo es consistencia. Sin regalar nada.',
          'Manga, todo es consistencia. Sin prisa, sin pausa.',
          'Manga, todo es consistencia. Control total.'
        ],
        attack: [
          'Traes a {frontNameSafe} a {frontSecStr}. Prepara el pase.',
          'Traes a {frontNameSafe} a {frontSecStr}. Ataque con calma.',
          'Traes a {frontNameSafe} a {frontSecStr}. Busca salida fuerte.',
          'Traes a {frontNameSafe} a {frontSecStr}. Sin arriesgar de m√°s.',
          'Traes a {frontNameSafe} a {frontSecStr}. Cuida la entrada y acelera.',
          'Traes a {frontNameSafe} a {frontSecStr}. Coloca el intento en zona segura.',
          'Traes a {frontNameSafe} a {frontSecStr}. Un giro m√°s y lo tienes.',
          'Traes a {frontNameSafe} a {frontSecStr}. Mant√©n presi√≥n y el pase cae.',
          'Traes a {frontNameSafe} a {frontSecStr}. Enf√≥cate en la salida.',
          'Traes a {frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Prepara el pase.',
          'A {frontSecStr} de {frontNameSafe}. Ataque con calma.',
          'A {frontSecStr} de {frontNameSafe}. Busca salida fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Sin arriesgar de m√°s.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada y acelera.',
          'A {frontSecStr} de {frontNameSafe}. Coloca el intento en zona segura.',
          'A {frontSecStr} de {frontNameSafe}. Un giro m√°s y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Mant√©n presi√≥n y el pase cae.',
          'A {frontSecStr} de {frontNameSafe}. Enf√≥cate en la salida.',
          'A {frontSecStr} de {frontNameSafe}. No te abras en la entrada.',
          '{frontNameSafe} est√° cerca. Prepara el pase.',
          '{frontNameSafe} est√° cerca. Ataque con calma.',
          '{frontNameSafe} est√° cerca. Busca salida fuerte.',
          '{frontNameSafe} est√° cerca. Sin arriesgar de m√°s.',
          '{frontNameSafe} est√° cerca. Cuida la entrada y acelera.'
        ],
        defense: [
          '{backNameSafe} a {backSecStr}. Cierra la puerta.',
          '{backNameSafe} a {backSecStr}. L√≠nea firme.',
          '{backNameSafe} a {backSecStr}. No regales la entrada.',
          '{backNameSafe} a {backSecStr}. Protege interior.',
          '{backNameSafe} a {backSecStr}. Salida fuerte y recto.',
          '{backNameSafe} a {backSecStr}. Sin volantazos.',
          '{backNameSafe} a {backSecStr}. No te abras.',
          '{backNameSafe} a {backSecStr}. Defiende con trazada.',
          '{backNameSafe} a {backSecStr}. Cubre lo b√°sico.',
          '{backNameSafe} a {backSecStr}. No te desconcentres.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Cierra la puerta.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. L√≠nea firme.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. No regales la entrada.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Protege interior.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Salida fuerte y recto.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Sin volantazos.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. No te abras.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Defiende con trazada.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Cubre lo b√°sico.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. No te desconcentres.',
          'Ojo atr√°s con {backNameSafe}. Cierra la puerta.',
          'Ojo atr√°s con {backNameSafe}. L√≠nea firme.',
          'Ojo atr√°s con {backNameSafe}. No regales la entrada.',
          'Ojo atr√°s con {backNameSafe}. Protege interior.',
          'Ojo atr√°s con {backNameSafe}. Salida fuerte y recto.'
        ],
        fight: [
          'Dos frentes, cabeza fr√≠a.',
          'Dos frentes, cabeza fr√≠a. Controla el volante.',
          'Dos frentes, cabeza fr√≠a. Sin regalos.',
          'Dos frentes, cabeza fr√≠a. Todo con calma.',
          'Dos frentes, cabeza fr√≠a. Limpio y r√°pido.',
          'Pelea cerrada, cero errores.',
          'Pelea cerrada, cero errores. Controla el volante.',
          'Pelea cerrada, cero errores. Sin regalos.',
          'Pelea cerrada, cero errores. Todo con calma.',
          'Pelea cerrada, cero errores. Limpio y r√°pido.',
          'Tr√°fico, no te enredes.',
          'Tr√°fico, no te enredes. Controla el volante.',
          'Tr√°fico, no te enredes. Sin regalos.',
          'Tr√°fico, no te enredes. Todo con calma.',
          'Tr√°fico, no te enredes. Limpio y r√°pido.',
          'Mucho movimiento, mant√©n la l√≠nea.',
          'Mucho movimiento, mant√©n la l√≠nea. Controla el volante.',
          'Mucho movimiento, mant√©n la l√≠nea. Sin regalos.',
          'Mucho movimiento, mant√©n la l√≠nea. Todo con calma.',
          'Mucho movimiento, mant√©n la l√≠nea. Limpio y r√°pido.',
          'Hay pelea, prioriza la salida.',
          'Hay pelea, prioriza la salida. Controla el volante.',
          'Hay pelea, prioriza la salida. Sin regalos.',
          'Hay pelea, prioriza la salida. Todo con calma.',
          'Hay pelea, prioriza la salida. Limpio y r√°pido.'
        ],
        blueflag: [
          'Bandera azul, mant√©n l√≠nea.',
          'Bandera azul, mant√©n l√≠nea. Sin drama.',
          'Bandera azul, mant√©n l√≠nea. Con seguridad.',
          'Bandera azul, mant√©n l√≠nea. Sin perder la l√≠nea.',
          'Bandera azul, mant√©n l√≠nea. Todo limpio.',
          'Bandera azul, deja pasar seguro.',
          'Bandera azul, deja pasar seguro. Sin drama.',
          'Bandera azul, deja pasar seguro. Con seguridad.',
          'Bandera azul, deja pasar seguro. Sin perder la l√≠nea.',
          'Bandera azul, deja pasar seguro. Todo limpio.',
          'Bandera azul, no pelees la posici√≥n.',
          'Bandera azul, no pelees la posici√≥n. Sin drama.',
          'Bandera azul, no pelees la posici√≥n. Con seguridad.',
          'Bandera azul, no pelees la posici√≥n. Sin perder la l√≠nea.',
          'Bandera azul, no pelees la posici√≥n. Todo limpio.',
          'Bandera azul, cede sin frenar de m√°s.',
          'Bandera azul, cede sin frenar de m√°s. Sin drama.',
          'Bandera azul, cede sin frenar de m√°s. Con seguridad.',
          'Bandera azul, cede sin frenar de m√°s. Sin perder la l√≠nea.',
          'Bandera azul, cede sin frenar de m√°s. Todo limpio.',
          'Bandera azul, facilita el pase.',
          'Bandera azul, facilita el pase. Sin drama.',
          'Bandera azul, facilita el pase. Con seguridad.',
          'Bandera azul, facilita el pase. Sin perder la l√≠nea.',
          'Bandera azul, facilita el pase. Todo limpio.'
        ],
        front06: [
          '{frontNameSafe} a {frontSecStr}. Es alcanzable.',
          '{frontNameSafe} a {frontSecStr}. Ventana de pase.',
          '{frontNameSafe} a {frontSecStr}. Mant√©n la presi√≥n.',
          '{frontNameSafe} a {frontSecStr}. Busca salida fuerte.',
          '{frontNameSafe} a {frontSecStr}. Sin desesperarte.',
          '{frontNameSafe} a {frontSecStr}. Cuida la entrada.',
          '{frontNameSafe} a {frontSecStr}. Una curva bien hecha y est√°s.',
          '{frontNameSafe} a {frontSecStr}. No te abras.',
          '{frontNameSafe} a {frontSecStr}. Pase posible en la siguiente.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Es alcanzable.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ventana de pase.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Mant√©n la presi√≥n.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Busca salida fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Sin desesperarte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Cuida la entrada.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una curva bien hecha y est√°s.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No te abras.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Pase posible en la siguiente.',
          'A {frontSecStr} de {frontNameSafe}. Es alcanzable.',
          'A {frontSecStr} de {frontNameSafe}. Ventana de pase.',
          'A {frontSecStr} de {frontNameSafe}. Mant√©n la presi√≥n.',
          'A {frontSecStr} de {frontNameSafe}. Busca salida fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Sin desesperarte.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Una curva bien hecha y est√°s.'
        ],
        back06: [
          '{backNameSafe} a {backSecStr}. Defiende.',
          '{backNameSafe} a {backSecStr}. Cubre interior.',
          '{backNameSafe} a {backSecStr}. L√≠nea firme.',
          '{backNameSafe} a {backSecStr}. No regales la salida.',
          '{backNameSafe} a {backSecStr}. Sin errores.',
          '{backNameSafe} a {backSecStr}. No te abras.',
          '{backNameSafe} a {backSecStr}. Protege la trazada.',
          '{backNameSafe} a {backSecStr}. Salida fuerte.',
          '{backNameSafe} a {backSecStr}. Calma y control.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. Defiende.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. Cubre interior.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. L√≠nea firme.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. No regales la salida.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. Sin errores.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. No te abras.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. Protege la trazada.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. Salida fuerte.',
          'Presi√≥n atr√°s: {backNameSafe} {backSecStr}. Calma y control.',
          '{backNameSafe} en rango: {backSecStr}. Defiende.',
          '{backNameSafe} en rango: {backSecStr}. Cubre interior.',
          '{backNameSafe} en rango: {backSecStr}. L√≠nea firme.',
          '{backNameSafe} en rango: {backSecStr}. No regales la salida.',
          '{backNameSafe} en rango: {backSecStr}. Sin errores.',
          '{backNameSafe} en rango: {backSecStr}. No te abras.',
          '{backNameSafe} en rango: {backSecStr}. Protege la trazada.'
        ],
        pos: [
          'Quedaste P{posNow}. Enf√≥cate.',
          'Quedaste P{posNow}. Calma y ritmo.',
          'Quedaste P{posNow}. A trabajar.',
          'Quedaste P{posNow}. No te desconcentres.',
          'Quedaste P{posNow}. Hazlo simple.',
          'Quedaste P{posNow}. Cuida la salida.',
          'Quedaste P{posNow}. Ritmo constante.',
          'Quedaste P{posNow}. Sin errores.',
          'Quedaste P{posNow}. Vuelve al plan.',
          'Ahora P{posNow}. Enf√≥cate.',
          'Ahora P{posNow}. Calma y ritmo.',
          'Ahora P{posNow}. A trabajar.',
          'Ahora P{posNow}. No te desconcentres.',
          'Ahora P{posNow}. Hazlo simple.',
          'Ahora P{posNow}. Cuida la salida.',
          'Ahora P{posNow}. Ritmo constante.',
          'Ahora P{posNow}. Sin errores.',
          'Ahora P{posNow}. Vuelve al plan.',
          'Vas P{posNow}. Enf√≥cate.',
          'Vas P{posNow}. Calma y ritmo.',
          'Vas P{posNow}. A trabajar.',
          'Vas P{posNow}. No te desconcentres.',
          'Vas P{posNow}. Hazlo simple.',
          'Vas P{posNow}. Cuida la salida.',
          'Vas P{posNow}. Ritmo constante.'
        ],
        leader: [
          'L√≠der al frente, controla tus marcas.',
          'L√≠der al frente, controla tus marcas. Sin errores.',
          'L√≠der al frente, controla tus marcas. Limpio.',
          'L√≠der al frente, controla tus marcas. Control total.',
          'L√≠der al frente, controla tus marcas. Paso a paso.',
          'Referencia del l√≠der, no te salgas.',
          'Referencia del l√≠der, no te salgas. Sin errores.',
          'Referencia del l√≠der, no te salgas. Limpio.',
          'Referencia del l√≠der, no te salgas. Control total.',
          'Referencia del l√≠der, no te salgas. Paso a paso.',
          'Mira al l√≠der y copia la l√≠nea.',
          'Mira al l√≠der y copia la l√≠nea. Sin errores.',
          'Mira al l√≠der y copia la l√≠nea. Limpio.',
          'Mira al l√≠der y copia la l√≠nea. Control total.',
          'Mira al l√≠der y copia la l√≠nea. Paso a paso.',
          'El l√≠der marca el ritmo, mant√©n precisi√≥n.',
          'El l√≠der marca el ritmo, mant√©n precisi√≥n. Sin errores.',
          'El l√≠der marca el ritmo, mant√©n precisi√≥n. Limpio.',
          'El l√≠der marca el ritmo, mant√©n precisi√≥n. Control total.',
          'El l√≠der marca el ritmo, mant√©n precisi√≥n. Paso a paso.',
          'Observa al l√≠der, trazada limpia.',
          'Observa al l√≠der, trazada limpia. Sin errores.',
          'Observa al l√≠der, trazada limpia. Limpio.',
          'Observa al l√≠der, trazada limpia. Control total.',
          'Observa al l√≠der, trazada limpia. Paso a paso.'
        ],
        podium: [
          'Huele a podio, no te compliques.',
          'Huele a podio, no te compliques. Controla.',
          'Huele a podio, no te compliques. Sin drama.',
          'Huele a podio, no te compliques. Cero regalos.',
          'Huele a podio, no te compliques. Bien hecho.',
          'Podio posible, manejo fino.',
          'Podio posible, manejo fino. Controla.',
          'Podio posible, manejo fino. Sin drama.',
          'Podio posible, manejo fino. Cero regalos.',
          'Podio posible, manejo fino. Bien hecho.',
          'Podio a la vista, sin errores.',
          'Podio a la vista, sin errores. Controla.',
          'Podio a la vista, sin errores. Sin drama.',
          'Podio a la vista, sin errores. Cero regalos.',
          'Podio a la vista, sin errores. Bien hecho.',
          'Podio cerca, no regales la salida.',
          'Podio cerca, no regales la salida. Controla.',
          'Podio cerca, no regales la salida. Sin drama.',
          'Podio cerca, no regales la salida. Cero regalos.',
          'Podio cerca, no regales la salida. Bien hecho.',
          'Est√°s en zona de podio, calma.',
          'Est√°s en zona de podio, calma. Controla.',
          'Est√°s en zona de podio, calma. Sin drama.',
          'Est√°s en zona de podio, calma. Cero regalos.',
          'Est√°s en zona de podio, calma. Bien hecho.'
        ],
        trend: [
          'Buen ritmo, repite.',
          'Buen ritmo, repite. Sin apuro.',
          'Buen ritmo, repite. Sin errores.',
          'Buen ritmo, repite. Limpio.',
          'Buen ritmo, repite. Control.',
          'Ritmo cay√≥, ajusta.',
          'Ritmo cay√≥, ajusta. Sin apuro.',
          'Ritmo cay√≥, ajusta. Sin errores.',
          'Ritmo cay√≥, ajusta. Limpio.',
          'Ritmo cay√≥, ajusta. Control.',
          'Consistente, sigue as√≠.',
          'Consistente, sigue as√≠. Sin apuro.',
          'Consistente, sigue as√≠. Sin errores.',
          'Consistente, sigue as√≠. Limpio.',
          'Consistente, sigue as√≠. Control.',
          'Mejorando ritmo, mant√©n.',
          'Mejorando ritmo, mant√©n. Sin apuro.',
          'Mejorando ritmo, mant√©n. Sin errores.',
          'Mejorando ritmo, mant√©n. Limpio.',
          'Mejorando ritmo, mant√©n. Control.',
          'Ritmo irregular, calma y l√≠nea.',
          'Ritmo irregular, calma y l√≠nea. Sin apuro.',
          'Ritmo irregular, calma y l√≠nea. Sin errores.',
          'Ritmo irregular, calma y l√≠nea. Limpio.',
          'Ritmo irregular, calma y l√≠nea. Control.'
        ],
        est: [
          'Estimaci√≥n lista, mant√©n el plan.',
          'Estimaci√≥n lista, mant√©n el plan. Todo limpio.',
          'Estimaci√≥n lista, mant√©n el plan. Sin drama.',
          'Estimaci√≥n lista, mant√©n el plan. A tu ritmo.',
          'Estimaci√≥n lista, mant√©n el plan. Control total.',
          'Ojo con la estimaci√≥n, no te duermas.',
          'Ojo con la estimaci√≥n, no te duermas. Todo limpio.',
          'Ojo con la estimaci√≥n, no te duermas. Sin drama.',
          'Ojo con la estimaci√≥n, no te duermas. A tu ritmo.',
          'Ojo con la estimaci√≥n, no te duermas. Control total.',
          'Estimaci√≥n estable, sigue empujando.',
          'Estimaci√≥n estable, sigue empujando. Todo limpio.',
          'Estimaci√≥n estable, sigue empujando. Sin drama.',
          'Estimaci√≥n estable, sigue empujando. A tu ritmo.',
          'Estimaci√≥n estable, sigue empujando. Control total.',
          'Estimaci√≥n en marcha, cuida el ritmo.',
          'Estimaci√≥n en marcha, cuida el ritmo. Todo limpio.',
          'Estimaci√≥n en marcha, cuida el ritmo. Sin drama.',
          'Estimaci√≥n en marcha, cuida el ritmo. A tu ritmo.',
          'Estimaci√≥n en marcha, cuida el ritmo. Control total.',
          'Estimaci√≥n cambia, ajusta salida.',
          'Estimaci√≥n cambia, ajusta salida. Todo limpio.',
          'Estimaci√≥n cambia, ajusta salida. Sin drama.',
          'Estimaci√≥n cambia, ajusta salida. A tu ritmo.',
          'Estimaci√≥n cambia, ajusta salida. Control total.'
        ],
        bestlap: [
          'Nueva best lap, bien ah√≠.',
          'Nueva best lap, bien ah√≠. Mant√©n l√≠nea.',
          'Nueva best lap, bien ah√≠. Sin emoci√≥n extra.',
          'Nueva best lap, bien ah√≠. Control.',
          'Nueva best lap, bien ah√≠. Perfecto.',
          'Best lap, eso es.',
          'Best lap, eso es. Mant√©n l√≠nea.',
          'Best lap, eso es. Sin emoci√≥n extra.',
          'Best lap, eso es. Control.',
          'Best lap, eso es. Perfecto.',
          'Best lap, rep√≠telo.',
          'Best lap, rep√≠telo. Mant√©n l√≠nea.',
          'Best lap, rep√≠telo. Sin emoci√≥n extra.',
          'Best lap, rep√≠telo. Control.',
          'Best lap, rep√≠telo. Perfecto.',
          'Mejoraste best lap, mant√©n.',
          'Mejoraste best lap, mant√©n. Mant√©n l√≠nea.',
          'Mejoraste best lap, mant√©n. Sin emoci√≥n extra.',
          'Mejoraste best lap, mant√©n. Control.',
          'Mejoraste best lap, mant√©n. Perfecto.',
          'Best lap confirmada, buen trabajo.',
          'Best lap confirmada, buen trabajo. Mant√©n l√≠nea.',
          'Best lap confirmada, buen trabajo. Sin emoci√≥n extra.',
          'Best lap confirmada, buen trabajo. Control.',
          'Best lap confirmada, buen trabajo. Perfecto.'
        ]
      },
      stratega: {
        manga: [
          'Manga, contra reloj. Busca vuelta limpia.',
          'Manga, contra reloj. Busca vuelta limpia. Mant√©n el plan.',
          'Manga, contra reloj. Busca vuelta limpia. Sin inventar.',
          'Manga, contra reloj. Busca vuelta limpia. Cero errores.',
          'Manga, contra reloj. Busca vuelta limpia. Vuelta a vuelta.',
          'Manga, suma vueltas y no te salgas.',
          'Manga, suma vueltas y no te salgas. Mant√©n el plan.',
          'Manga, suma vueltas y no te salgas. Sin inventar.',
          'Manga, suma vueltas y no te salgas. Cero errores.',
          'Manga, suma vueltas y no te salgas. Vuelta a vuelta.',
          'Manga, ritmo constante y sin tr√°fico.',
          'Manga, ritmo constante y sin tr√°fico. Mant√©n el plan.',
          'Manga, ritmo constante y sin tr√°fico. Sin inventar.',
          'Manga, ritmo constante y sin tr√°fico. Cero errores.',
          'Manga, ritmo constante y sin tr√°fico. Vuelta a vuelta.',
          'Manga, prioriza vuelta clara, no pelea.',
          'Manga, prioriza vuelta clara, no pelea. Mant√©n el plan.',
          'Manga, prioriza vuelta clara, no pelea. Sin inventar.',
          'Manga, prioriza vuelta clara, no pelea. Cero errores.',
          'Manga, prioriza vuelta clara, no pelea. Vuelta a vuelta.',
          'Manga, presi√≥n controlada, sin riesgos.',
          'Manga, presi√≥n controlada, sin riesgos. Mant√©n el plan.',
          'Manga, presi√≥n controlada, sin riesgos. Sin inventar.',
          'Manga, presi√≥n controlada, sin riesgos. Cero errores.',
          'Manga, presi√≥n controlada, sin riesgos. Vuelta a vuelta.'
        ],
        attack_front: [
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Ataque quir√∫rgico.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Entra fuerte y sal m√°s fuerte.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Busca la l√≠nea corta.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Una vuelta m√°s y lo ejecutas.',
          'Por la punta se gana: {frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Ataque quir√∫rgico.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Entra fuerte y sal m√°s fuerte.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Busca la l√≠nea corta.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Una vuelta m√°s y lo ejecutas.',
          'Top 3 en juego: {frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          'Arriba est√° {frontNameSafe} a {frontSecStr}. Pasa en la salida.',
          'Arriba est√° {frontNameSafe} a {frontSecStr}. Ataque quir√∫rgico.',
          'Arriba est√° {frontNameSafe} a {frontSecStr}. Coloca el pase sin tocar.',
          'Arriba est√° {frontNameSafe} a {frontSecStr}. Entra fuerte y sal m√°s fuerte.',
          'Arriba est√° {frontNameSafe} a {frontSecStr}. Busca la l√≠nea corta.',
          'Arriba est√° {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Arriba est√° {frontNameSafe} a {frontSecStr}. Hazlo en zona segura.'
        ],
        attack_mid: [
          '{frontNameSafe} a {frontSecStr}. Arma el pase con paciencia.',
          '{frontNameSafe} a {frontSecStr}. Intenta en recta.',
          '{frontNameSafe} a {frontSecStr}. Cuida la entrada y sal fuerte.',
          '{frontNameSafe} a {frontSecStr}. Si no se da, vuelve a intentarlo.',
          '{frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          '{frontNameSafe} a {frontSecStr}. P√°salo y respira.',
          '{frontNameSafe} a {frontSecStr}. Hazlo simple y limpio.',
          '{frontNameSafe} a {frontSecStr}. Busca error y capitaliza.',
          '{frontNameSafe} a {frontSecStr}. Coloca el coche y listo.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Arma el pase con paciencia.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Intenta en recta.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Cuida la entrada y sal fuerte.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Si no se da, vuelve a intentarlo.',
          'Cierre con {frontNameSafe} a {frontSecStr}. No te abras en la entrada.',
          'Cierre con {frontNameSafe} a {frontSecStr}. P√°salo y respira.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Hazlo simple y limpio.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Busca error y capitaliza.',
          'Cierre con {frontNameSafe} a {frontSecStr}. Coloca el coche y listo.',
          'A {frontSecStr} de {frontNameSafe}. Arma el pase con paciencia.',
          'A {frontSecStr} de {frontNameSafe}. Intenta en recta.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la entrada y sal fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Si no se da, vuelve a intentarlo.',
          'A {frontSecStr} de {frontNameSafe}. No te abras en la entrada.',
          'A {frontSecStr} de {frontNameSafe}. P√°salo y respira.',
          'A {frontSecStr} de {frontNameSafe}. Hazlo simple y limpio.'
        ],
        attack_back: [
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec√∫talo.',
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. Presiona y toma la puerta.',
          'Recupera posici√≥n: {frontNameSafe} a {frontSecStr}. Pase r√°pido, sin drama.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec√∫talo.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Presiona y toma la puerta.',
          'Oportunidad: {frontNameSafe} a {frontSecStr}. Pase r√°pido, sin drama.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Pega y suelta el pase.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Pasa y estabiliza.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. No pierdas tiempo, ejec√∫talo.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Asegura salida y listo.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Sin riesgo extra, pero firme.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Hazlo en la entrada.',
          'Tienes pase: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.'
        ],
        defense_front: [
          'Defiende el podio: {backNameSafe} a {backSecStr}. Cubre interior.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. L√≠nea dura, sin golpes.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Cierra la puerta y acelera limpio.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Defensa inteligente, sin error.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. No frenes de m√°s.',
          'Defiende el podio: {backNameSafe} a {backSecStr}. Hazlo predecible y firme.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Cubre interior.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. L√≠nea dura, sin golpes.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Cierra la puerta y acelera limpio.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Defensa inteligente, sin error.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. No frenes de m√°s.',
          'Arriba no se regala: {backNameSafe} a {backSecStr}. Hazlo predecible y firme.',
          'Presi√≥n por podio: {backNameSafe} {backSecStr}. Cubre interior.',
          'Presi√≥n por podio: {backNameSafe} {backSecStr}. L√≠nea dura, sin golpes.',
          'Presi√≥n por podio: {backNameSafe} {backSecStr}. Salida fuerte.',
          'Presi√≥n por podio: {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'Presi√≥n por podio: {backNameSafe} {backSecStr}. Cierra la puerta y acelera limpio.',
          'Presi√≥n por podio: {backNameSafe} {backSecStr}. Defensa inteligente, sin error.',
          'Presi√≥n por podio: {backNameSafe} {backSecStr}. No te abras en la entrada.'
        ],
        defense_mid: [
          '{backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          '{backNameSafe} a {backSecStr}. Defiende con l√≠nea, no con volantazo.',
          '{backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          '{backNameSafe} a {backSecStr}. No regales la curva.',
          '{backNameSafe} a {backSecStr}. Calma, trazada limpia.',
          '{backNameSafe} a {backSecStr}. No frenes tarde de m√°s.',
          '{backNameSafe} a {backSecStr}. Mant√©n la puerta cerrada.',
          '{backNameSafe} a {backSecStr}. Control total.',
          'Te cazan: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Te cazan: {backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          'Te cazan: {backNameSafe} a {backSecStr}. Defiende con l√≠nea, no con volantazo.',
          'Te cazan: {backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          'Te cazan: {backNameSafe} a {backSecStr}. No regales la curva.',
          'Te cazan: {backNameSafe} a {backSecStr}. Calma, trazada limpia.',
          'Te cazan: {backNameSafe} a {backSecStr}. No frenes tarde de m√°s.',
          'Te cazan: {backNameSafe} a {backSecStr}. Mant√©n la puerta cerrada.',
          'Te cazan: {backNameSafe} a {backSecStr}. Control total.',
          'Presi√≥n atr√°s con {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'Presi√≥n atr√°s con {backNameSafe} {backSecStr}. Salida fuerte, sin error.',
          'Presi√≥n atr√°s con {backNameSafe} {backSecStr}. Defiende con l√≠nea, no con volantazo.',
          'Presi√≥n atr√°s con {backNameSafe} {backSecStr}. Cubre interior y acelera.',
          'Presi√≥n atr√°s con {backNameSafe} {backSecStr}. No regales la curva.',
          'Presi√≥n atr√°s con {backNameSafe} {backSecStr}. Calma, trazada limpia.',
          'Presi√≥n atr√°s con {backNameSafe} {backSecStr}. No frenes tarde de m√°s.'
        ],
        defense_back: [
          'No regales: {backNameSafe} a {backSecStr}. Orden y manejo.',
          'No regales: {backNameSafe} a {backSecStr}. Sube ritmo sin error.',
          'No regales: {backNameSafe} a {backSecStr}. Cubre interior y listo.',
          'No regales: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'No regales: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'No regales: {backNameSafe} a {backSecStr}. No inventes, defiende.',
          'No regales: {backNameSafe} a {backSecStr}. L√≠nea firme.',
          'No regales: {backNameSafe} a {backSecStr}. Sin drama, pero firme.',
          'No regales: {backNameSafe} a {backSecStr}. Mant√©n la calma.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. Orden y manejo.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. Sube ritmo sin error.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. Cubre interior y listo.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. No te abras en la entrada.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. Salida fuerte.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. No inventes, defiende.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. L√≠nea firme.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. Sin drama, pero firme.',
          'Defiende lo b√°sico: {backNameSafe} {backSecStr}. Mant√©n la calma.',
          'Presi√≥n real: {backNameSafe} a {backSecStr}. Orden y manejo.',
          'Presi√≥n real: {backNameSafe} a {backSecStr}. Sube ritmo sin error.',
          'Presi√≥n real: {backNameSafe} a {backSecStr}. Cubre interior y listo.',
          'Presi√≥n real: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'Presi√≥n real: {backNameSafe} a {backSecStr}. Salida fuerte.',
          'Presi√≥n real: {backNameSafe} a {backSecStr}. No inventes, defiende.',
          'Presi√≥n real: {backNameSafe} a {backSecStr}. L√≠nea firme.'
        ],
        fight: [
          'Pelea viva: adelante y atr√°s. Prioriza salida.',
          'Pelea viva: adelante y atr√°s. Prioriza salida. Plan claro.',
          'Pelea viva: adelante y atr√°s. Prioriza salida. Sin riesgos tontos.',
          'Pelea viva: adelante y atr√°s. Prioriza salida. Salida fuerte.',
          'Pelea viva: adelante y atr√°s. Prioriza salida. Todo limpio.',
          'Doble presi√≥n, decide: o atacas o aseguras.',
          'Doble presi√≥n, decide: o atacas o aseguras. Plan claro.',
          'Doble presi√≥n, decide: o atacas o aseguras. Sin riesgos tontos.',
          'Doble presi√≥n, decide: o atacas o aseguras. Salida fuerte.',
          'Doble presi√≥n, decide: o atacas o aseguras. Todo limpio.',
          'Tr√°fico pesado. No pierdas tiempo en tonter√≠as.',
          'Tr√°fico pesado. No pierdas tiempo en tonter√≠as. Plan claro.',
          'Tr√°fico pesado. No pierdas tiempo en tonter√≠as. Sin riesgos tontos.',
          'Tr√°fico pesado. No pierdas tiempo en tonter√≠as. Salida fuerte.',
          'Tr√°fico pesado. No pierdas tiempo en tonter√≠as. Todo limpio.',
          'Dos frentes. Elige la batalla correcta.',
          'Dos frentes. Elige la batalla correcta. Plan claro.',
          'Dos frentes. Elige la batalla correcta. Sin riesgos tontos.',
          'Dos frentes. Elige la batalla correcta. Salida fuerte.',
          'Dos frentes. Elige la batalla correcta. Todo limpio.',
          'Cuidado con el tr√°fico, no regales segundos.',
          'Cuidado con el tr√°fico, no regales segundos. Plan claro.',
          'Cuidado con el tr√°fico, no regales segundos. Sin riesgos tontos.',
          'Cuidado con el tr√°fico, no regales segundos. Salida fuerte.',
          'Cuidado con el tr√°fico, no regales segundos. Todo limpio.'
        ],
        blueflag: [
          'Bandera azul. L√≠der encima. Mant√©n l√≠nea y deja pasar.',
          'Bandera azul. L√≠der encima. Mant√©n l√≠nea y deja pasar. Con seguridad.',
          'Bandera azul. L√≠der encima. Mant√©n l√≠nea y deja pasar. Sin perder tiempo.',
          'Bandera azul. L√≠der encima. Mant√©n l√≠nea y deja pasar. Todo limpio.',
          'Bandera azul. L√≠der encima. Mant√©n l√≠nea y deja pasar. Sin riesgos.',
          'Bandera azul. No te metas en broncas, cede seguro.',
          'Bandera azul. No te metas en broncas, cede seguro. Con seguridad.',
          'Bandera azul. No te metas en broncas, cede seguro. Sin perder tiempo.',
          'Bandera azul. No te metas en broncas, cede seguro. Todo limpio.',
          'Bandera azul. No te metas en broncas, cede seguro. Sin riesgos.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Con seguridad.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Sin perder tiempo.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Todo limpio.',
          'Bandera azul. Respeta, deja pasar y sigue tu carrera. Sin riesgos.',
          'Bandera azul. L√≠nea predecible, no frenes raro.',
          'Bandera azul. L√≠nea predecible, no frenes raro. Con seguridad.',
          'Bandera azul. L√≠nea predecible, no frenes raro. Sin perder tiempo.',
          'Bandera azul. L√≠nea predecible, no frenes raro. Todo limpio.',
          'Bandera azul. L√≠nea predecible, no frenes raro. Sin riesgos.',
          'Bandera azul. Abre espacio en la salida.',
          'Bandera azul. Abre espacio en la salida. Con seguridad.',
          'Bandera azul. Abre espacio en la salida. Sin perder tiempo.',
          'Bandera azul. Abre espacio en la salida. Todo limpio.',
          'Bandera azul. Abre espacio en la salida. Sin riesgos.'
        ],
        front06: [
          '{frontNameSafe} a {frontSecStr}. Ventana de ataque abierta.',
          '{frontNameSafe} a {frontSecStr}. Prepara maniobra.',
          '{frontNameSafe} a {frontSecStr}. Entra fuerte, sal m√°s fuerte.',
          '{frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          '{frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          '{frontNameSafe} a {frontSecStr}. Busca el error y capitaliza.',
          '{frontNameSafe} a {frontSecStr}. Ataque en zona segura.',
          '{frontNameSafe} a {frontSecStr}. Presiona sin regalar.',
          '{frontNameSafe} a {frontSecStr}. Una vuelta m√°s y lo ejecutas.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ventana de ataque abierta.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Prepara maniobra.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Entra fuerte, sal m√°s fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No dudes en la recta.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Corta la curva y acelera.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Busca el error y capitaliza.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Ataque en zona segura.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Presiona sin regalar.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una vuelta m√°s y lo ejecutas.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Ventana de ataque abierta.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Prepara maniobra.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Entra fuerte, sal m√°s fuerte.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. No dudes en la recta.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Corta la curva y acelera.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Busca el error y capitaliza.',
          'Ventana abierta: {frontNameSafe} a {frontSecStr}. Ataque en zona segura.'
        ],
        back06: [
          '{backNameSafe} a {backSecStr}. Defensa inteligente, sin errores.',
          '{backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          '{backNameSafe} a {backSecStr}. No abras la puerta.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          '{backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          '{backNameSafe} a {backSecStr}. Trazada firme, sin volantazo.',
          '{backNameSafe} a {backSecStr}. Defiende con cabeza.',
          '{backNameSafe} a {backSecStr}. No regales la curva.',
          '{backNameSafe} a {backSecStr}. Calma y control.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. Defensa inteligente, sin errores.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. Cubre interior y acelera.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. No abras la puerta.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. Salida fuerte, sin error.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. No dejes hueco en la entrada.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. Trazada firme, sin volantazo.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. Defiende con cabeza.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. No regales la curva.',
          'Gap chico atr√°s: {backNameSafe} {backSecStr}. Calma y control.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Defensa inteligente, sin errores.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Cubre interior y acelera.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. No abras la puerta.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Salida fuerte, sin error.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. No dejes hueco en la entrada.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Trazada firme, sin volantazo.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Defiende con cabeza.'
        ],
        pos: [
          'Ahora P{posNow}. Reacciona: l√≠nea limpia y salida fuerte.',
          'Ahora P{posNow}. Cero errores, recupera ritmo.',
          'Ahora P{posNow}. Acom√≥date y vuelve al ataque.',
          'Ahora P{posNow}. Plan claro: salida manda.',
          'Ahora P{posNow}. Busca aire limpio y aprieta.',
          'Ahora P{posNow}. Sin prisa tonta, pero firme.',
          'Ahora P{posNow}. Orden y gas.',
          'Ahora P{posNow}. No inventes, ejecuta.',
          'Ahora P{posNow}. A trabajar, vuelta a vuelta.',
          'P{posNow}. Reacciona: l√≠nea limpia y salida fuerte.',
          'P{posNow}. Cero errores, recupera ritmo.',
          'P{posNow}. Acom√≥date y vuelve al ataque.',
          'P{posNow}. Plan claro: salida manda.',
          'P{posNow}. Busca aire limpio y aprieta.',
          'P{posNow}. Sin prisa tonta, pero firme.',
          'P{posNow}. Orden y gas.',
          'P{posNow}. No inventes, ejecuta.',
          'P{posNow}. A trabajar, vuelta a vuelta.',
          'Vas P{posNow}. Reacciona: l√≠nea limpia y salida fuerte.',
          'Vas P{posNow}. Cero errores, recupera ritmo.',
          'Vas P{posNow}. Acom√≥date y vuelve al ataque.',
          'Vas P{posNow}. Plan claro: salida manda.',
          'Vas P{posNow}. Busca aire limpio y aprieta.',
          'Vas P{posNow}. Sin prisa tonta, pero firme.',
          'Vas P{posNow}. Orden y gas.'
        ],
        leader: [
          'L√≠der al frente. Usa referencia y no te desesperes.',
          'L√≠der al frente. Usa referencia y no te desesperes. Plan claro.',
          'L√≠der al frente. Usa referencia y no te desesperes. Vuelta a vuelta.',
          'L√≠der al frente. Usa referencia y no te desesperes. Control total.',
          'L√≠der al frente. Usa referencia y no te desesperes. Salida fuerte.',
          'El l√≠der marca la pauta. Copia frenada y salida.',
          'El l√≠der marca la pauta. Copia frenada y salida. Plan claro.',
          'El l√≠der marca la pauta. Copia frenada y salida. Vuelta a vuelta.',
          'El l√≠der marca la pauta. Copia frenada y salida. Control total.',
          'El l√≠der marca la pauta. Copia frenada y salida. Salida fuerte.',
          'Mide al l√≠der. Tu carrera es precisi√≥n.',
          'Mide al l√≠der. Tu carrera es precisi√≥n. Plan claro.',
          'Mide al l√≠der. Tu carrera es precisi√≥n. Vuelta a vuelta.',
          'Mide al l√≠der. Tu carrera es precisi√≥n. Control total.',
          'Mide al l√≠der. Tu carrera es precisi√≥n. Salida fuerte.',
          'L√≠der al frente. No persigas, ejecuta.',
          'L√≠der al frente. No persigas, ejecuta. Plan claro.',
          'L√≠der al frente. No persigas, ejecuta. Vuelta a vuelta.',
          'L√≠der al frente. No persigas, ejecuta. Control total.',
          'L√≠der al frente. No persigas, ejecuta. Salida fuerte.',
          'L√≠der adelante. Tu vuelta, tu plan.',
          'L√≠der adelante. Tu vuelta, tu plan. Plan claro.',
          'L√≠der adelante. Tu vuelta, tu plan. Vuelta a vuelta.',
          'L√≠der adelante. Tu vuelta, tu plan. Control total.',
          'L√≠der adelante. Tu vuelta, tu plan. Salida fuerte.'
        ],
        podium: [
          'Podio posible. Prioriza consistencia y no te enredes.',
          'Podio posible. Prioriza consistencia y no te enredes. Sin riesgos tontos.',
          'Podio posible. Prioriza consistencia y no te enredes. Control.',
          'Podio posible. Prioriza consistencia y no te enredes. Limpio.',
          'Podio posible. Prioriza consistencia y no te enredes. Firme.',
          'Est√°s peleando podio. Manejo fino, cero regalos.',
          'Est√°s peleando podio. Manejo fino, cero regalos. Sin riesgos tontos.',
          'Est√°s peleando podio. Manejo fino, cero regalos. Control.',
          'Est√°s peleando podio. Manejo fino, cero regalos. Limpio.',
          'Est√°s peleando podio. Manejo fino, cero regalos. Firme.',
          'Podio cerca. Paciencia en el tr√°fico.',
          'Podio cerca. Paciencia en el tr√°fico. Sin riesgos tontos.',
          'Podio cerca. Paciencia en el tr√°fico. Control.',
          'Podio cerca. Paciencia en el tr√°fico. Limpio.',
          'Podio cerca. Paciencia en el tr√°fico. Firme.',
          'Zona de podio. Salida manda.',
          'Zona de podio. Salida manda. Sin riesgos tontos.',
          'Zona de podio. Salida manda. Control.',
          'Zona de podio. Salida manda. Limpio.',
          'Zona de podio. Salida manda. Firme.',
          'Podio en juego. No inventes en la entrada.',
          'Podio en juego. No inventes en la entrada. Sin riesgos tontos.',
          'Podio en juego. No inventes en la entrada. Control.',
          'Podio en juego. No inventes en la entrada. Limpio.',
          'Podio en juego. No inventes en la entrada. Firme.'
        ],
        trend: [
          'Ritmo subiendo. Mant√©n la presi√≥n.',
          'Ritmo subiendo. Mant√©n la presi√≥n. Vuelta a vuelta.',
          'Ritmo subiendo. Mant√©n la presi√≥n. Control total.',
          'Ritmo subiendo. Mant√©n la presi√≥n. Sin errores.',
          'Ritmo subiendo. Mant√©n la presi√≥n. Plan claro.',
          'Ritmo baj√≥. Corrige trazada y salida.',
          'Ritmo baj√≥. Corrige trazada y salida. Vuelta a vuelta.',
          'Ritmo baj√≥. Corrige trazada y salida. Control total.',
          'Ritmo baj√≥. Corrige trazada y salida. Sin errores.',
          'Ritmo baj√≥. Corrige trazada y salida. Plan claro.',
          'Consistente. Repite la l√≠nea y aprieta.',
          'Consistente. Repite la l√≠nea y aprieta. Vuelta a vuelta.',
          'Consistente. Repite la l√≠nea y aprieta. Control total.',
          'Consistente. Repite la l√≠nea y aprieta. Sin errores.',
          'Consistente. Repite la l√≠nea y aprieta. Plan claro.',
          'Ritmo s√≥lido. No cambies nada.',
          'Ritmo s√≥lido. No cambies nada. Vuelta a vuelta.',
          'Ritmo s√≥lido. No cambies nada. Control total.',
          'Ritmo s√≥lido. No cambies nada. Sin errores.',
          'Ritmo s√≥lido. No cambies nada. Plan claro.',
          'Ritmo irregular. Vuelve al plan.',
          'Ritmo irregular. Vuelve al plan. Vuelta a vuelta.',
          'Ritmo irregular. Vuelve al plan. Control total.',
          'Ritmo irregular. Vuelve al plan. Sin errores.',
          'Ritmo irregular. Vuelve al plan. Plan claro.'
        ],
        est: [
          'Estimaci√≥n en marcha. No te desconcentres.',
          'Estimaci√≥n en marcha. No te desconcentres. Control.',
          'Estimaci√≥n en marcha. No te desconcentres. Sin drama.',
          'Estimaci√≥n en marcha. No te desconcentres. Limpio.',
          'Estimaci√≥n en marcha. No te desconcentres. Plan claro.',
          'La estimaci√≥n cambi√≥. Ajusta y sigue.',
          'La estimaci√≥n cambi√≥. Ajusta y sigue. Control.',
          'La estimaci√≥n cambi√≥. Ajusta y sigue. Sin drama.',
          'La estimaci√≥n cambi√≥. Ajusta y sigue. Limpio.',
          'La estimaci√≥n cambi√≥. Ajusta y sigue. Plan claro.',
          'Estimaci√≥n estable. Mant√©n ritmo limpio.',
          'Estimaci√≥n estable. Mant√©n ritmo limpio. Control.',
          'Estimaci√≥n estable. Mant√©n ritmo limpio. Sin drama.',
          'Estimaci√≥n estable. Mant√©n ritmo limpio. Limpio.',
          'Estimaci√≥n estable. Mant√©n ritmo limpio. Plan claro.',
          'Estimaci√≥n lista. No regales la salida.',
          'Estimaci√≥n lista. No regales la salida. Control.',
          'Estimaci√≥n lista. No regales la salida. Sin drama.',
          'Estimaci√≥n lista. No regales la salida. Limpio.',
          'Estimaci√≥n lista. No regales la salida. Plan claro.',
          'Estimaci√≥n marcada. Control de riesgo.',
          'Estimaci√≥n marcada. Control de riesgo. Control.',
          'Estimaci√≥n marcada. Control de riesgo. Sin drama.',
          'Estimaci√≥n marcada. Control de riesgo. Limpio.',
          'Estimaci√≥n marcada. Control de riesgo. Plan claro.'
        ],
        bestlap: [
          'Best lap confirmada. Ahora rep√≠tela sin riesgo.',
          'Best lap confirmada. Ahora rep√≠tela sin riesgo. Sin riesgos.',
          'Best lap confirmada. Ahora rep√≠tela sin riesgo. Limpio.',
          'Best lap confirmada. Ahora rep√≠tela sin riesgo. Plan claro.',
          'Best lap confirmada. Ahora rep√≠tela sin riesgo. Vuelta a vuelta.',
          'Mejoraste best lap. Sost√©n el ritmo.',
          'Mejoraste best lap. Sost√©n el ritmo. Sin riesgos.',
          'Mejoraste best lap. Sost√©n el ritmo. Limpio.',
          'Mejoraste best lap. Sost√©n el ritmo. Plan claro.',
          'Mejoraste best lap. Sost√©n el ritmo. Vuelta a vuelta.',
          'Best lap. No te emociones, repite.',
          'Best lap. No te emociones, repite. Sin riesgos.',
          'Best lap. No te emociones, repite. Limpio.',
          'Best lap. No te emociones, repite. Plan claro.',
          'Best lap. No te emociones, repite. Vuelta a vuelta.',
          'Best lap. Buen trabajo, ahora consistencia.',
          'Best lap. Buen trabajo, ahora consistencia. Sin riesgos.',
          'Best lap. Buen trabajo, ahora consistencia. Limpio.',
          'Best lap. Buen trabajo, ahora consistencia. Plan claro.',
          'Best lap. Buen trabajo, ahora consistencia. Vuelta a vuelta.',
          'Nueva best lap. Mant√©n la l√≠nea.',
          'Nueva best lap. Mant√©n la l√≠nea. Sin riesgos.',
          'Nueva best lap. Mant√©n la l√≠nea. Limpio.',
          'Nueva best lap. Mant√©n la l√≠nea. Plan claro.',
          'Nueva best lap. Mant√©n la l√≠nea. Vuelta a vuelta.'
        ]
      },
      coach: {
        manga: [
          'Manga: vuelta limpia. Respira y aprieta.',
          'Manga: vuelta limpia. Respira y aprieta. T√∫ puedes.',
          'Manga: vuelta limpia. Respira y aprieta. Mant√©n el plan.',
          'Manga: vuelta limpia. Respira y aprieta. Sin presionarte.',
          'Manga: vuelta limpia. Respira y aprieta. Paso a paso.',
          'Manga: sin errores. Cada meta cuenta.',
          'Manga: sin errores. Cada meta cuenta. T√∫ puedes.',
          'Manga: sin errores. Cada meta cuenta. Mant√©n el plan.',
          'Manga: sin errores. Cada meta cuenta. Sin presionarte.',
          'Manga: sin errores. Cada meta cuenta. Paso a paso.',
          'Manga: constancia. No persigas fantasmas.',
          'Manga: constancia. No persigas fantasmas. T√∫ puedes.',
          'Manga: constancia. No persigas fantasmas. Mant√©n el plan.',
          'Manga: constancia. No persigas fantasmas. Sin presionarte.',
          'Manga: constancia. No persigas fantasmas. Paso a paso.',
          'Manga: manos suaves, l√≠nea firme.',
          'Manga: manos suaves, l√≠nea firme. T√∫ puedes.',
          'Manga: manos suaves, l√≠nea firme. Mant√©n el plan.',
          'Manga: manos suaves, l√≠nea firme. Sin presionarte.',
          'Manga: manos suaves, l√≠nea firme. Paso a paso.',
          'Manga: aire limpio y ritmo estable.',
          'Manga: aire limpio y ritmo estable. T√∫ puedes.',
          'Manga: aire limpio y ritmo estable. Mant√©n el plan.',
          'Manga: aire limpio y ritmo estable. Sin presionarte.',
          'Manga: aire limpio y ritmo estable. Paso a paso.'
        ],
        attack: [
          'Vas alcanzando a {frontNameSafe}. Entra suave, sal fuerte.',
          'Vas alcanzando a {frontNameSafe}. Prepara el pase seguro.',
          'Vas alcanzando a {frontNameSafe}. Hazlo limpio, sin tocar.',
          'Vas alcanzando a {frontNameSafe}. Cuida la salida y lo tienes.',
          'Vas alcanzando a {frontNameSafe}. Paciencia, el pase llega.',
          'Vas alcanzando a {frontNameSafe}. No fuerces la entrada.',
          'Vas alcanzando a {frontNameSafe}. Busca aire limpio y ejecuta.',
          'Vas alcanzando a {frontNameSafe}. Un giro m√°s y cae.',
          'Vas alcanzando a {frontNameSafe}. Con calma y precisi√≥n.',
          'Vas alcanzando a {frontNameSafe}. Sin prisa tonta.',
          'A {frontSecStr} de {frontNameSafe}. Entra suave, sal fuerte.',
          'A {frontSecStr} de {frontNameSafe}. Prepara el pase seguro.',
          'A {frontSecStr} de {frontNameSafe}. Hazlo limpio, sin tocar.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la salida y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Paciencia, el pase llega.',
          'A {frontSecStr} de {frontNameSafe}. No fuerces la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Busca aire limpio y ejecuta.',
          'A {frontSecStr} de {frontNameSafe}. Un giro m√°s y cae.',
          'A {frontSecStr} de {frontNameSafe}. Con calma y precisi√≥n.',
          'A {frontSecStr} de {frontNameSafe}. Sin prisa tonta.',
          '{frontNameSafe} est√° cerca. Entra suave, sal fuerte.',
          '{frontNameSafe} est√° cerca. Prepara el pase seguro.',
          '{frontNameSafe} est√° cerca. Hazlo limpio, sin tocar.',
          '{frontNameSafe} est√° cerca. Cuida la salida y lo tienes.',
          '{frontNameSafe} est√° cerca. Paciencia, el pase llega.'
        ],
        defense: [
          'Te viene {backNameSafe}. Mant√©n tu l√≠nea y acelera limpio.',
          'Te viene {backNameSafe}. Puerta cerrada, sin frenar de m√°s.',
          'Te viene {backNameSafe}. Protege interior.',
          'Te viene {backNameSafe}. Defiende con trazada, no con golpes.',
          'Te viene {backNameSafe}. Salida fuerte, manos suaves.',
          'Te viene {backNameSafe}. No te abras en la entrada.',
          'Te viene {backNameSafe}. Respira y controla.',
          'Te viene {backNameSafe}. Todo limpio.',
          'Te viene {backNameSafe}. Sin errores.',
          'Te viene {backNameSafe}. Calma, lo tienes.',
          '{backNameSafe} a {backSecStr}. Mant√©n tu l√≠nea y acelera limpio.',
          '{backNameSafe} a {backSecStr}. Puerta cerrada, sin frenar de m√°s.',
          '{backNameSafe} a {backSecStr}. Protege interior.',
          '{backNameSafe} a {backSecStr}. Defiende con trazada, no con golpes.',
          '{backNameSafe} a {backSecStr}. Salida fuerte, manos suaves.',
          '{backNameSafe} a {backSecStr}. No te abras en la entrada.',
          '{backNameSafe} a {backSecStr}. Respira y controla.',
          '{backNameSafe} a {backSecStr}. Todo limpio.',
          '{backNameSafe} a {backSecStr}. Sin errores.',
          '{backNameSafe} a {backSecStr}. Calma, lo tienes.',
          'Ojo atr√°s con {backNameSafe}. Mant√©n tu l√≠nea y acelera limpio.',
          'Ojo atr√°s con {backNameSafe}. Puerta cerrada, sin frenar de m√°s.',
          'Ojo atr√°s con {backNameSafe}. Protege interior.',
          'Ojo atr√°s con {backNameSafe}. Defiende con trazada, no con golpes.',
          'Ojo atr√°s con {backNameSafe}. Salida fuerte, manos suaves.'
        ],
        fight: [
          'Hay pelea. Prioriza salida y cero errores.',
          'Hay pelea. Prioriza salida y cero errores. T√∫ puedes.',
          'Hay pelea. Prioriza salida y cero errores. Paso a paso.',
          'Hay pelea. Prioriza salida y cero errores. Sin drama.',
          'Hay pelea. Prioriza salida y cero errores. Limpio y r√°pido.',
          'Dos frentes. Cabeza fr√≠a, trazada limpia.',
          'Dos frentes. Cabeza fr√≠a, trazada limpia. T√∫ puedes.',
          'Dos frentes. Cabeza fr√≠a, trazada limpia. Paso a paso.',
          'Dos frentes. Cabeza fr√≠a, trazada limpia. Sin drama.',
          'Dos frentes. Cabeza fr√≠a, trazada limpia. Limpio y r√°pido.',
          'Tr√°fico. No te enganches, s√© inteligente.',
          'Tr√°fico. No te enganches, s√© inteligente. T√∫ puedes.',
          'Tr√°fico. No te enganches, s√© inteligente. Paso a paso.',
          'Tr√°fico. No te enganches, s√© inteligente. Sin drama.',
          'Tr√°fico. No te enganches, s√© inteligente. Limpio y r√°pido.',
          'Mant√©n la calma, el pase llega.',
          'Mant√©n la calma, el pase llega. T√∫ puedes.',
          'Mant√©n la calma, el pase llega. Paso a paso.',
          'Mant√©n la calma, el pase llega. Sin drama.',
          'Mant√©n la calma, el pase llega. Limpio y r√°pido.',
          'No todo es ahora, cuida el coche.',
          'No todo es ahora, cuida el coche. T√∫ puedes.',
          'No todo es ahora, cuida el coche. Paso a paso.',
          'No todo es ahora, cuida el coche. Sin drama.',
          'No todo es ahora, cuida el coche. Limpio y r√°pido.'
        ],
        blueflag: [
          'Bandera azul. Deja pasar sin perder la l√≠nea.',
          'Bandera azul. Deja pasar sin perder la l√≠nea. Con seguridad.',
          'Bandera azul. Deja pasar sin perder la l√≠nea. Sin drama.',
          'Bandera azul. Deja pasar sin perder la l√≠nea. Todo limpio.',
          'Bandera azul. Deja pasar sin perder la l√≠nea. Sin riesgos.',
          'Bandera azul. Cede seguro y sigue tu ritmo.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Con seguridad.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Sin drama.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Todo limpio.',
          'Bandera azul. Cede seguro y sigue tu ritmo. Sin riesgos.',
          'Bandera azul. Respeta, no arriesgues.',
          'Bandera azul. Respeta, no arriesgues. Con seguridad.',
          'Bandera azul. Respeta, no arriesgues. Sin drama.',
          'Bandera azul. Respeta, no arriesgues. Todo limpio.',
          'Bandera azul. Respeta, no arriesgues. Sin riesgos.',
          'Bandera azul. L√≠nea predecible.',
          'Bandera azul. L√≠nea predecible. Con seguridad.',
          'Bandera azul. L√≠nea predecible. Sin drama.',
          'Bandera azul. L√≠nea predecible. Todo limpio.',
          'Bandera azul. L√≠nea predecible. Sin riesgos.',
          'Bandera azul. Abre espacio en salida.',
          'Bandera azul. Abre espacio en salida. Con seguridad.',
          'Bandera azul. Abre espacio en salida. Sin drama.',
          'Bandera azul. Abre espacio en salida. Todo limpio.',
          'Bandera azul. Abre espacio en salida. Sin riesgos.'
        ],
        front06: [
          'Buen cierre con {frontNameSafe}. Si te abre, vas.',
          'Buen cierre con {frontNameSafe}. Mant√©n presi√≥n.',
          'Buen cierre con {frontNameSafe}. Una vuelta m√°s y lo tienes.',
          'Buen cierre con {frontNameSafe}. Cuida la salida.',
          'Buen cierre con {frontNameSafe}. No fuerces la entrada.',
          'Buen cierre con {frontNameSafe}. Con calma, el pase llega.',
          'Buen cierre con {frontNameSafe}. Todo limpio.',
          'Buen cierre con {frontNameSafe}. Salida fuerte.',
          'Buen cierre con {frontNameSafe}. Aprovecha el error.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Si te abre, vas.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Mant√©n presi√≥n.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Una vuelta m√°s y lo tienes.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Cuida la salida.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. No fuerces la entrada.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Con calma, el pase llega.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Todo limpio.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Salida fuerte.',
          'Gap corto con {frontNameSafe}: {frontSecStr}. Aprovecha el error.',
          'A {frontSecStr} de {frontNameSafe}. Si te abre, vas.',
          'A {frontSecStr} de {frontNameSafe}. Mant√©n presi√≥n.',
          'A {frontSecStr} de {frontNameSafe}. Una vuelta m√°s y lo tienes.',
          'A {frontSecStr} de {frontNameSafe}. Cuida la salida.',
          'A {frontSecStr} de {frontNameSafe}. No fuerces la entrada.',
          'A {frontSecStr} de {frontNameSafe}. Con calma, el pase llega.',
          'A {frontSecStr} de {frontNameSafe}. Todo limpio.'
        ],
        back06: [
          '{backNameSafe} est√° encima. Defiende con trazada, no con golpes.',
          '{backNameSafe} est√° encima. L√≠nea firme y salida fuerte.',
          '{backNameSafe} est√° encima. Sin errores, lo aguantas.',
          '{backNameSafe} est√° encima. Calma y control.',
          '{backNameSafe} est√° encima. No te abras en la entrada.',
          '{backNameSafe} est√° encima. Puerta cerrada.',
          '{backNameSafe} est√° encima. Respira y acelera limpio.',
          '{backNameSafe} est√° encima. Cubre interior.',
          '{backNameSafe} est√° encima. Todo limpio.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Defiende con trazada, no con golpes.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. L√≠nea firme y salida fuerte.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Sin errores, lo aguantas.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Calma y control.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. No te abras en la entrada.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Puerta cerrada.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Respira y acelera limpio.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Cubre interior.',
          'Presi√≥n atr√°s: {backNameSafe} a {backSecStr}. Todo limpio.',
          '{backNameSafe} en rango: {backSecStr}. Defiende con trazada, no con golpes.',
          '{backNameSafe} en rango: {backSecStr}. L√≠nea firme y salida fuerte.',
          '{backNameSafe} en rango: {backSecStr}. Sin errores, lo aguantas.',
          '{backNameSafe} en rango: {backSecStr}. Calma y control.',
          '{backNameSafe} en rango: {backSecStr}. No te abras en la entrada.',
          '{backNameSafe} en rango: {backSecStr}. Puerta cerrada.',
          '{backNameSafe} en rango: {backSecStr}. Respira y acelera limpio.'
        ],
        pos: [
          'Ahora P{posNow}. Respira, vuelve al plan.',
          'Ahora P{posNow}. Calma y ritmo.',
          'Ahora P{posNow}. Trazada limpia.',
          'Ahora P{posNow}. A trabajar, vuelta a vuelta.',
          'Ahora P{posNow}. No te desconcentres.',
          'Ahora P{posNow}. T√∫ puedes, sigue.',
          'Ahora P{posNow}. Sin errores.',
          'Ahora P{posNow}. Busca aire limpio.',
          'Ahora P{posNow}. Salida fuerte.',
          'Vas P{posNow}. Respira, vuelve al plan.',
          'Vas P{posNow}. Calma y ritmo.',
          'Vas P{posNow}. Trazada limpia.',
          'Vas P{posNow}. A trabajar, vuelta a vuelta.',
          'Vas P{posNow}. No te desconcentres.',
          'Vas P{posNow}. T√∫ puedes, sigue.',
          'Vas P{posNow}. Sin errores.',
          'Vas P{posNow}. Busca aire limpio.',
          'Vas P{posNow}. Salida fuerte.',
          'Posici√≥n P{posNow}. Respira, vuelve al plan.',
          'Posici√≥n P{posNow}. Calma y ritmo.',
          'Posici√≥n P{posNow}. Trazada limpia.',
          'Posici√≥n P{posNow}. A trabajar, vuelta a vuelta.',
          'Posici√≥n P{posNow}. No te desconcentres.',
          'Posici√≥n P{posNow}. T√∫ puedes, sigue.',
          'Posici√≥n P{posNow}. Sin errores.'
        ],
        leader: [
          'El l√≠der marca el ritmo. T√∫ marca tu l√≠nea.',
          'El l√≠der marca el ritmo. T√∫ marca tu l√≠nea. T√∫ puedes.',
          'El l√≠der marca el ritmo. T√∫ marca tu l√≠nea. Paso a paso.',
          'El l√≠der marca el ritmo. T√∫ marca tu l√≠nea. Sin errores.',
          'El l√≠der marca el ritmo. T√∫ marca tu l√≠nea. Control.',
          'Referencia del l√≠der, sin obsesionarte.',
          'Referencia del l√≠der, sin obsesionarte. T√∫ puedes.',
          'Referencia del l√≠der, sin obsesionarte. Paso a paso.',
          'Referencia del l√≠der, sin obsesionarte. Sin errores.',
          'Referencia del l√≠der, sin obsesionarte. Control.',
          'L√≠der al frente. Enf√≥cate en tus marcas.',
          'L√≠der al frente. Enf√≥cate en tus marcas. T√∫ puedes.',
          'L√≠der al frente. Enf√≥cate en tus marcas. Paso a paso.',
          'L√≠der al frente. Enf√≥cate en tus marcas. Sin errores.',
          'L√≠der al frente. Enf√≥cate en tus marcas. Control.',
          'Observa al l√≠der y aprende la trazada.',
          'Observa al l√≠der y aprende la trazada. T√∫ puedes.',
          'Observa al l√≠der y aprende la trazada. Paso a paso.',
          'Observa al l√≠der y aprende la trazada. Sin errores.',
          'Observa al l√≠der y aprende la trazada. Control.',
          'L√≠der adelante. Paciencia y consistencia.',
          'L√≠der adelante. Paciencia y consistencia. T√∫ puedes.',
          'L√≠der adelante. Paciencia y consistencia. Paso a paso.',
          'L√≠der adelante. Paciencia y consistencia. Sin errores.',
          'L√≠der adelante. Paciencia y consistencia. Control.'
        ],
        podium: [
          'Podio posible. Mant√©n cabeza fr√≠a.',
          'Podio posible. Mant√©n cabeza fr√≠a. Paso a paso.',
          'Podio posible. Mant√©n cabeza fr√≠a. Sin drama.',
          'Podio posible. Mant√©n cabeza fr√≠a. Control.',
          'Podio posible. Mant√©n cabeza fr√≠a. Limpio y r√°pido.',
          'Zona de podio. Todo limpio.',
          'Zona de podio. Todo limpio. Paso a paso.',
          'Zona de podio. Todo limpio. Sin drama.',
          'Zona de podio. Todo limpio. Control.',
          'Zona de podio. Todo limpio. Limpio y r√°pido.',
          'Podio en juego. No fuerces.',
          'Podio en juego. No fuerces. Paso a paso.',
          'Podio en juego. No fuerces. Sin drama.',
          'Podio en juego. No fuerces. Control.',
          'Podio en juego. No fuerces. Limpio y r√°pido.',
          'Por el trofeo. Trazada firme.',
          'Por el trofeo. Trazada firme. Paso a paso.',
          'Por el trofeo. Trazada firme. Sin drama.',
          'Por el trofeo. Trazada firme. Control.',
          'Por el trofeo. Trazada firme. Limpio y r√°pido.',
          'Podio cerca. Cuida la salida.',
          'Podio cerca. Cuida la salida. Paso a paso.',
          'Podio cerca. Cuida la salida. Sin drama.',
          'Podio cerca. Cuida la salida. Control.',
          'Podio cerca. Cuida la salida. Limpio y r√°pido.'
        ],
        trend: [
          'Ritmo mejorando. Mant√©n.',
          'Ritmo mejorando. Mant√©n. T√∫ puedes.',
          'Ritmo mejorando. Mant√©n. Paso a paso.',
          'Ritmo mejorando. Mant√©n. Sin errores.',
          'Ritmo mejorando. Mant√©n. Control.',
          'Ritmo baj√≥. Ajusta y sigue.',
          'Ritmo baj√≥. Ajusta y sigue. T√∫ puedes.',
          'Ritmo baj√≥. Ajusta y sigue. Paso a paso.',
          'Ritmo baj√≥. Ajusta y sigue. Sin errores.',
          'Ritmo baj√≥. Ajusta y sigue. Control.',
          'Consistente. Buen trabajo.',
          'Consistente. Buen trabajo. T√∫ puedes.',
          'Consistente. Buen trabajo. Paso a paso.',
          'Consistente. Buen trabajo. Sin errores.',
          'Consistente. Buen trabajo. Control.',
          'Ritmo s√≥lido. No cambies.',
          'Ritmo s√≥lido. No cambies. T√∫ puedes.',
          'Ritmo s√≥lido. No cambies. Paso a paso.',
          'Ritmo s√≥lido. No cambies. Sin errores.',
          'Ritmo s√≥lido. No cambies. Control.',
          'Ritmo irregular. Respira y repite.',
          'Ritmo irregular. Respira y repite. T√∫ puedes.',
          'Ritmo irregular. Respira y repite. Paso a paso.',
          'Ritmo irregular. Respira y repite. Sin errores.',
          'Ritmo irregular. Respira y repite. Control.'
        ],
        est: [
          'Estimaci√≥n lista. Mant√©n el plan.',
          'Estimaci√≥n lista. Mant√©n el plan. T√∫ puedes.',
          'Estimaci√≥n lista. Mant√©n el plan. Sin drama.',
          'Estimaci√≥n lista. Mant√©n el plan. Limpio.',
          'Estimaci√≥n lista. Mant√©n el plan. Control.',
          'Estimaci√≥n cambi√≥. Ajusta y sigue.',
          'Estimaci√≥n cambi√≥. Ajusta y sigue. T√∫ puedes.',
          'Estimaci√≥n cambi√≥. Ajusta y sigue. Sin drama.',
          'Estimaci√≥n cambi√≥. Ajusta y sigue. Limpio.',
          'Estimaci√≥n cambi√≥. Ajusta y sigue. Control.',
          'Estimaci√≥n estable. No te desconcentres.',
          'Estimaci√≥n estable. No te desconcentres. T√∫ puedes.',
          'Estimaci√≥n estable. No te desconcentres. Sin drama.',
          'Estimaci√≥n estable. No te desconcentres. Limpio.',
          'Estimaci√≥n estable. No te desconcentres. Control.',
          'Estimaci√≥n marcada. Todo limpio.',
          'Estimaci√≥n marcada. Todo limpio. T√∫ puedes.',
          'Estimaci√≥n marcada. Todo limpio. Sin drama.',
          'Estimaci√≥n marcada. Todo limpio. Limpio.',
          'Estimaci√≥n marcada. Todo limpio. Control.',
          'Estimaci√≥n ok. Paso a paso.',
          'Estimaci√≥n ok. Paso a paso. T√∫ puedes.',
          'Estimaci√≥n ok. Paso a paso. Sin drama.',
          'Estimaci√≥n ok. Paso a paso. Limpio.',
          'Estimaci√≥n ok. Paso a paso. Control.'
        ],
        bestlap: [
          'Best lap. Bien ah√≠, repite con calma.',
          'Best lap. Bien ah√≠, repite con calma. Paso a paso.',
          'Best lap. Bien ah√≠, repite con calma. Control.',
          'Best lap. Bien ah√≠, repite con calma. Sin errores.',
          'Best lap. Bien ah√≠, repite con calma. Limpio.',
          'Nueva best lap. Buen trabajo.',
          'Nueva best lap. Buen trabajo. Paso a paso.',
          'Nueva best lap. Buen trabajo. Control.',
          'Nueva best lap. Buen trabajo. Sin errores.',
          'Nueva best lap. Buen trabajo. Limpio.',
          'Best lap confirmada. Mant√©n.',
          'Best lap confirmada. Mant√©n. Paso a paso.',
          'Best lap confirmada. Mant√©n. Control.',
          'Best lap confirmada. Mant√©n. Sin errores.',
          'Best lap confirmada. Mant√©n. Limpio.',
          'Mejoraste best lap. Control total.',
          'Mejoraste best lap. Control total. Paso a paso.',
          'Mejoraste best lap. Control total. Control.',
          'Mejoraste best lap. Control total. Sin errores.',
          'Mejoraste best lap. Control total. Limpio.',
          'Best lap. Ahora consistencia.',
          'Best lap. Ahora consistencia. Paso a paso.',
          'Best lap. Ahora consistencia. Control.',
          'Best lap. Ahora consistencia. Sin errores.',
          'Best lap. Ahora consistencia. Limpio.'
        ]
      }
    };

    
    function rdMakeText(id, baseText, ctx) {
      const mode = (raceDirectorMode === 'minimal' || raceDirectorMode === 'stratega' || raceDirectorMode === 'coach')
        ? raceDirectorMode : 'stratega';

      const c = (ctx || {});
      const isManga = !!c.isManga;
      const tier = c.tier || 'mid';
      const posNow = c.posNow || rdExtractPos(baseText) || 0;

      // Rellena placeholders
      const fill = (tpl) => {
        let s = String(tpl || '');
        s = s.replace(/\{frontNameSafe\}/g, c.frontNameSafe || 'el de adelante');
        s = s.replace(/\{backNameSafe\}/g, c.backNameSafe || 'el de atr√°s');
        s = s.replace(/\{frontSecStr\}/g, c.frontSecStr || '');
        s = s.replace(/\{backSecStr\}/g, c.backSecStr || '');
        s = s.replace(/\{posNow\}/g, String(posNow || 0));
        return s.replace(/\s+/g, ' ').trim();
      };


function rdMakeMangaBattleText(kind, c, mode) {
  const front = (c && c.frontNameSafe) ? c.frontNameSafe : 'el de adelante';
  const back  = (c && c.backNameSafe)  ? c.backNameSafe  : 'el de atr√°s';
  const fs = (c && c.frontSecStr) ? c.frontSecStr : '';
  const bs = (c && c.backSecStr)  ? c.backSecStr  : '';

  // Plantillas cortas, √∫tiles y con nombres. (MANGA = suave, pero con datos)
  const attack = [
    'Manga. {frontNameSafe} a {frontSecStr}. Limpio y lo cazas.',
    'Manga. {frontNameSafe} a {frontSecStr}. Sal bien y cae el pase.',
    'Manga. {frontNameSafe} a {frontSecStr}. L√≠nea fina, sin drama.',
    'Manga. {frontNameSafe} a {frontSecStr}. Cero errores, aprieta.',
    'Manga. {frontNameSafe} a {frontSecStr}. Dos vueltas as√≠ y lo tienes.',
    'Manga. Vas por {frontNameSafe}. Gap {frontSecStr}.',
    'Manga. {frontNameSafe} est√° a tiro. {frontSecStr}.',
    'Manga. Se ve el rebufo. {frontNameSafe} {frontSecStr}.',
    'Manga. Ojo con {frontNameSafe}. {frontSecStr}.',
    'Manga. Paciencia y tracci√≥n. {frontNameSafe} {frontSecStr}.',
    'Manga. Si la salida es limpia, {frontNameSafe} cae. {frontSecStr}.',
    'Manga. Ataque inteligente. {frontNameSafe} {frontSecStr}.',
    'Manga. No lo forces, prov√≥calo. {frontNameSafe} {frontSecStr}.',
    'Manga. Gap rico para cazar. {frontNameSafe} {frontSecStr}.',
    'Manga. Est√° en ventana. {frontNameSafe} {frontSecStr}.'
  ];

  const defense = [
    'Manga. {backNameSafe} a {backSecStr}. Cierra puertas, suave.',
    'Manga. {backNameSafe} a {backSecStr}. Sin espejo, pero sin regalo.',
    'Manga. {backNameSafe} a {backSecStr}. Marca el apex y listo.',
    'Manga. {backNameSafe} a {backSecStr}. Control, no ansiedad.',
    'Manga. {backNameSafe} a {backSecStr}. Si te equivocas, te muerde.',
    'Manga. Te vienen oliendo. {backNameSafe} {backSecStr}.',
    'Manga. Defensa fina. {backNameSafe} {backSecStr}.',
    'Manga. No des espacio gratis. {backNameSafe} {backSecStr}.',
    'Manga. Mant√©n tu l√≠nea. {backNameSafe} {backSecStr}.',
    'Manga. Respira. {backNameSafe} est√° encima. {backSecStr}.',
    'Manga. Sal de curva bien, y se apaga. {backNameSafe} {backSecStr}.',
    'Manga. No te enredes. {backNameSafe} {backSecStr}.',
    'Manga. Si te presiona, tu respuesta es limpieza. {backNameSafe} {backSecStr}.',
    'Manga. Cero contactos. {backNameSafe} {backSecStr}.',
    'Manga. Aguanta el ritmo. {backNameSafe} {backSecStr}.'
  ];

  const fight = [
    'Manga. Duelo doble: adelante {frontSecStr}, atr√°s {backSecStr}.',
    'Manga. Est√°s en s√°ndwich. Adelante {frontSecStr}, atr√°s {backSecStr}.',
    'Manga. Se viene pelea: {frontNameSafe} {frontSecStr}, {backNameSafe} {backSecStr}.',
    'Manga. Tres autos en un respiro. Mant√©n calma.',
    'Manga. Esto es ajedrez en miniatura. No regales.',
    'Manga. L√≠nea limpia, manos suaves. Duelo real.',
    'Manga. Cada error cuesta dos posiciones. Ojo.',
    'Manga. Juega con la salida, no con el choque.',
    'Manga. Batalla cerrada. Decide con cabeza fr√≠a.',
    'Manga. Si te pones nervioso, ya perdiste. Respira.'
  ];

  let bank = null;
  if (kind === 'attack') bank = attack;
  else if (kind === 'defense') bank = defense;
  else if (kind === 'fight') bank = fight;

  if (!bank || !bank.length) return '';
  return fill(rdPick(bank, 'mb_' + String(mode || 'x') + '_' + kind));
}

    
// Manga: NO aplastar todo a frases gen√©ricas.
// - Si hay batalla, habla con nombres y gaps (suave, pero √∫til).
if (isManga && (id === 'attack' || id === 'defense' || id === 'fight')) {
  const out = rdMakeMangaBattleText(id, c, mode);
  if (out) return out;

  const arr = RD_PHRASES[mode] && RD_PHRASES[mode].manga;
  if (arr && arr.length) return fill(rdPick(arr, mode[0] + '_manga'));
}
// Selecci√≥n por modo
      if (mode === 'minimal') {
        const arr = RD_PHRASES.minimal[id] || null;
        if (arr && arr.length) return fill(rdPick(arr, 'm_' + id));
        if (id === 'pos' && posNow) return `P${posNow}.`;
        return String(baseText || '').trim();
      }

      if (mode === 'coach') {
        const arr = RD_PHRASES.coach[id] || null;
        if (arr && arr.length) return fill(rdPick(arr, 'c_' + id));
        return String(baseText || '').trim();
      }

      // stratega
      if (id === 'attack') {
        const arr = RD_PHRASES.stratega['attack_' + tier] || RD_PHRASES.stratega.attack_mid;
        return fill(rdPick(arr, 's_attack_' + tier));
      }
      if (id === 'defense') {
        const arr = RD_PHRASES.stratega['defense_' + tier] || RD_PHRASES.stratega.defense_mid;
        return fill(rdPick(arr, 's_def_' + tier));
      }
      const arr = RD_PHRASES.stratega[id] || null;
      if (arr && arr.length) return fill(rdPick(arr, 's_' + id));
      return String(baseText || '').trim();
    }

      

    function updateRdButton() {
      if (!rdToggleBtn) return;
      rdToggleBtn.textContent = raceDirectorEnabled ? 'ü§ñ RD ON' : 'ü§ñ RD OFF';
      rdToggleBtn.classList.toggle('active', !!raceDirectorEnabled);
      rdToggleBtn.classList.toggle('off', !raceDirectorEnabled);
      rdToggleBtn.setAttribute('aria-pressed', raceDirectorEnabled ? 'true' : 'false');
    }

    if (rdToggleBtn) {
      updateRdButton();
      rdToggleBtn.addEventListener('click', () => {
        raceDirectorEnabled = !raceDirectorEnabled;
      try { rdToggleBtn.classList.toggle('active', raceDirectorEnabled); } catch(e) {}
        try { prefSet('raceDirectorEnabled', raceDirectorEnabled ? '1' : '0'); } catch(e) {}
        updateRdButton();
        try { playBeep(raceDirectorEnabled ? 'up' : 'down'); } catch(e) {}
      });
    }
    let posImmediateLastSpokenAt = 0;
    let posImmediateLastSpokenPos = 0;
    let posDropDebounceTimer = null;
    let posDropDebounceLatest = null;

    // MANGA (clasificaci√≥n) - estabilidad de posici√≥n para evitar "flip-flop" por salida escalonada
    const mangaPosStability = { lastSeenPos: null, stablePos: null, stableCount: 0, lastAnnouncedStablePos: null, lastAnnounceAt: 0, lastChangeAt: 0 };
    let mangaLastLapCrossPos = null;
    let mangaLastLapCrossLap = 0;


    function announcePositionBrief(pos) {
      const p = Math.max(1, Math.min(99, Math.floor(Number(pos) || 0)));
      const now = Date.now();

      // No repitas el mismo P# seguido
      if (p === posImmediateLastSpokenPos && (now - posImmediateLastSpokenAt) < 2000) return;

      // Nombre del de adelante (si existe) para que sea √∫til, no solo "P6"
      let aheadName = '';
      try {
        const idx = findPilotIndexByKey(selectedPilotKey);
        const ctx = (idx >= 0) ? getFrontBackContext(idx) : null;
        aheadName = (ctx && ctx.frontName) ? safeRacerName(ctx.frontName) : '';
      } catch(e) {}

      const tail = aheadName ? ('. Adelante ' + aheadName) : '';
      say('P' + p + tail, { key: 'pos_brief_' + p, priority: 85, cooldownMs: 800, dedupe: true });

      posImmediateLastSpokenAt = now;
      posImmediateLastSpokenPos = p;
    }

    function handlePositionChangeNoLap(fromPos, toPos, delta) {
      const from = Math.floor(Number(fromPos) || 0);
      const to = Math.floor(Number(toPos) || 0);
      if (!to) return;

      // + = cae (peor), - = sube (mejor)
      const drop = (from && to) ? (to - from) : (delta || 0);

      // Si cae 2+ lugares, debounce 1.5s y anuncia solo la posici√≥n final (evita metralleta)
      if (drop >= 2) {
        posDropDebounceLatest = to;
        if (!posDropDebounceTimer) {
          posDropDebounceTimer = setTimeout(() => {
            announcePositionBrief(posDropDebounceLatest);
            posDropDebounceTimer = null;
            posDropDebounceLatest = null;
          }, 1500);
        }
        return;
      }

      // Si est√° en debounce, actualiza y no hables a√∫n
      if (posDropDebounceTimer) {
        posDropDebounceLatest = to;
        return;
      }

      const now = Date.now();
      if (now - posImmediateLastSpokenAt < 650) return;
      announcePositionBrief(to);
    }

    
function getVoiceStoreKey(){
      // Separamos preferencias para no romper PRO cuando el usuario usa BASIC
      return basicModeEnabled ? 'spotterVoiceSettings_BASIC' : 'spotterVoiceSettings_PRO';
    }

function saveVoiceSettings() {
      try {
        const toSave = { ...voiceSettings, laps: true };
        const key = getVoiceStoreKey();
        prefSet(key, JSON.stringify(toSave));
        // Compat: PRO sigue escribiendo legacy (versiones viejas)
        if (!basicModeEnabled) {
          try { prefSet('spotterVoiceSettings', JSON.stringify(toSave)); } catch(e) {}
        }
      } catch (e) {}
    }

    
function loadVoiceSettings() {
      try {
        const key = getVoiceStoreKey();
        let raw = prefGet(key, null);

        // Fallback: legacy
        if (!raw) raw = prefGet('spotterVoiceSettings', null);

        if (raw) {
          const parsed = JSON.parse(raw);
          voiceSettings = { ...DEFAULT_VOICE_SETTINGS, ...parsed, laps: true };
          if (basicModeEnabled) {
            // Si no existia la preferencia en el JSON, en BASIC lo prendemos por default
            if (!( 'pos' in parsed )) voiceSettings.pos = true;
            if (!( 'blueflag' in parsed )) voiceSettings.blueflag = true;
          }
          // Si venimos de legacy y el key no existia, lo copiamos para este modo
          try { if (!prefGet(key, null)) prefSet(key, raw); } catch(e) {}
        } else {
          if (basicModeEnabled) {
            voiceSettings = { ...DEFAULT_VOICE_SETTINGS, laps: true, blueflag: true, pos: true };
          } else {
            voiceSettings = { ...DEFAULT_VOICE_SETTINGS, laps: true };
          }
        }
      } catch (e) {
        voiceSettings = { ...DEFAULT_VOICE_SETTINGS, laps: true };
      }

            // Enforce: Laps siempre activo
      voiceSettings.laps = true;
      // Limpieza: toggles retirados (5.0.95)
      try {
        ['saylaps','pacedown','front06','back06','netgain','cons10'].forEach(k=>{
          if (k in voiceSettings) delete voiceSettings[k];
        });
      } catch(e) {}

      // Refresca UI si ya existe la funci√≥n (hoisting en function decl)
      try {
        if (typeof applyVoiceSettingsToButtons === 'function') applyVoiceSettingsToButtons();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      } catch (e) {}
    }



    loadVoiceSettings();

    // UI mode boot (sin depender de DEFAULT_VOICE_SETTINGS antes de tiempo)
    try { document.body.setAttribute('data-ui-mode', basicModeEnabled ? 'BASIC' : 'PRO'); } catch(e) {}
    try { if (uiModeBasicBtn) uiModeBasicBtn.classList.toggle('active', !!basicModeEnabled); } catch(e) {}
    try { if (uiModeProBtn)   uiModeProBtn.classList.toggle('active', !basicModeEnabled); } catch(e) {}
    try { if (basicModeEnabled) applyBasicMode(); } catch(e) {}


    // Gesto de usuario (Chrome bloquea AudioContext si no hay interacci√≥n)
    let __userGestureUnlocked = false;
    try{
      const _unlock = () => { __userGestureUnlocked = true; };
      ['pointerdown','touchstart','keydown','click'].forEach(ev=>{
        window.addEventListener(ev, _unlock, { once:true, passive:true });
      });
    }catch(e){}

    // WebAudio beeps (sin archivos)
    let audioCtx = null;
    function ensureAudioCtx() {
      try {
        if (!__userGestureUnlocked) return;
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(()=>{});
        }
      } catch (e) {}
    }

    function playBeep(kind = 'up') {
      try {
        try { if (typeof autoLocutorActive !== 'undefined' && autoLocutorActive) return; } catch(e) {}
        const __t = Date.now();
        if (typeof window.__lastBeepAt === 'undefined') window.__lastBeepAt = 0;
        if (__t - window.__lastBeepAt < 180) return;
        window.__lastBeepAt = __t;

        ensureAudioCtx();
        if (!audioCtx) return;

        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        const f = (kind === 'soft') ? 620 : ((kind === 'up') ? 880 : 440);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(f, now);

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime((kind === 'soft') ? 0.06 : 0.18, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.10);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(now);
        osc.stop(now + ((kind === 'soft') ? 0.07 : 0.12));
      } catch (e) {}
    }

    // TTS
    let chosenVoiceURI = '';

    // ===== Auto presets por sesi√≥n (TRAIN/MANGA/FINAL) =====
    let autoSessionPresetsEnabled = true;   // ON por default
    var __lastAutoPresetType = '';
    
    function applyDecimalPrecision(val){
      const v = Math.max(1, Math.min(3, parseInt(val,10) || 2));
      decimalPrecision = v;
      try { prefSet('spotterDecimalPrecision', String(v)); } catch(e) {}
      try { if (precisionSelect) precisionSelect.value = String(v); } catch(e) {}
      try { if (typeof syncPrecisionBadges === 'function') syncPrecisionBadges(); } catch(e) {}
    }
    
    function applySessionPreset(type){
      const t = String(type || 'TRAIN').toUpperCase();
      applySessionPresetFull(t, 'auto');
    }

    function maybeAutoApplySessionPreset(sessionInfo){
      if (!autoSessionPresetsEnabled) return;
      const t = String((sessionInfo && sessionInfo.type) ? sessionInfo.type : 'TRAIN').toUpperCase();
      if (!t || t === __lastAutoPresetType) return;
      __lastAutoPresetType = t;
      applySessionPresetFull(t, 'auto');
    }
    
    
    // ===== UI: Mostrar modo actual + Presets por sesi√≥n =====
    const SESSION_PRESET_PROFILES = {
      TRAIN: {
        label: 'Entrenamiento',
        rdMode: 'engineer',
        autoMode: 'engineer',
        precision: 2,
        voice: {
          pos:false, gaps:false, leadergap:false, podium:false,
        }
      },
      MANGA: {
        label: 'Manga',
        rdMode: 'minimal',
        autoMode: 'tv',
        precision: 2,
        voice: {
          // MANGA = contra reloj: hablar SOLO en cruce, sin ruido por jitter
          pos:true,
          bestlap:true,
          estlap:true,
          ritmo:true,
          streak:false,

          // seguridad / cortes√≠a
          blueflag: true,
          courtesy:true,

          // gaps/podium/batallas OFF (en MANGA confunde)
          gaps:false,
          leadergap:false,
          podium:false,
          attack:false,
          defense:false,
          pelea:false,
          total:false,
          box:false
        }
      },
      FINAL: {
        label: 'Final',
        rdMode: 'coach',
        autoMode: 'tv',
        precision: 2,
        voice: {
          // FINAL = carrera: m√°s info √∫til, pero sin spam
          pos:true,
          leadergap:true,
          bestlap:true,
          ritmo:true,
          courtesy:true,
          podium:true,
          box:true,

          // Mantener moderado
          gaps:false,
          attack:false,
          defense:false,
          pelea:false,
          total:false,
          estlap:false,
          streak:false,

          // aunque la dejemos "en pausa" mentalmente, queda habilitada
          blueflag:true
        }
      }
    };

    function _pillHtml(name, on){
      const cls = on ? 'toggle-pill on' : 'toggle-pill off';
      const safe = String(name||'').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      return `<span class="${cls}">${safe}</span>`;
    }

    function _getVoiceToggleMap(){
      // voiceSettings es la fuente de verdad
      const out = {};
      try{
        Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => out[k] = !!voiceSettings[k]);
        // asegurar llaves nuevas si faltan
        ['leadergap','podium','pelea','bestlap','estlap','box','total','gaps','pos','attack','defense','blueflag','ritmo','streak'].forEach(k=>{
          if (typeof out[k] === 'undefined') out[k] = !!voiceSettings[k];
        });
        out.laps = true;
      }catch(e){}
      return out;
    }

    function renderPresetCards(){
      // Meta de cada preset + texto ON/OFF sin pills (m√°s compacto y legible)
      const cards = [
        {id:'presetCardTrain', key:'TRAIN', metaId:'presetTrainMeta'},
        {id:'presetCardManga', key:'MANGA', metaId:'presetMangaMeta'},
        {id:'presetCardFinal', key:'FINAL', metaId:'presetFinalMeta'}
      ];

      // Nombres cortos para la lista (UI)
      const ORDER = ['laps','blueflag','ritmo','streak','estlap','leadergap','podium','pos','gaps','attack','defense','pelea','bestlap','total','box'];
      const NICE = {
        laps:'LAPS', blueflag:'AZUL', ritmo:'RITMO', streak:'RACHA', estlap:'EST', leadergap:'L√çDER', podium:'PODIO',
        pos:'POS', gaps:'GAP', attack:'ATK', defense:'DEF', pelea:'PELEA',
        bestlap:'BEST', total:'TOTAL', box:'BOX'
      };

      function buildOnOffText(map){
        const on = [], off = [];
        ORDER.forEach(k=>{
          const isOn = (k==='laps') ? true : !!map[k];
          const label = NICE[k] || k;
          (isOn ? on : off).push(label);
        });
        return { on: on.join(', '), off: off.join(', ') };
      }

      // Escribe meta en cada bot√≥n
      cards.forEach(c=>{
        const prof = SESSION_PRESET_PROFILES[c.key];
        const metaEl = document.getElementById(c.metaId);
        if (metaEl && prof){
          metaEl.textContent = `RD ${String(prof.rdMode||'').toUpperCase()} - Auto ${String(prof.autoMode||'').toUpperCase()} - ${prof.precision} d√©c.`;
        }
      });

      // Preset activo: lo que detect√≥ el sistema (o el √∫ltimo aplicado)
              const sess = String((typeof __lastAutoPresetType !== 'undefined' ? __lastAutoPresetType : 'TRAIN')).toUpperCase();
        try{
          if (typeof applyThemeChoice === 'function' && String(currentThemeChoice) === 'auto'){
            applyThemeChoice('auto', { noPersist:true });
          }
        }catch(e){}

      const prof = SESSION_PRESET_PROFILES[sess] || SESSION_PRESET_PROFILES.TRAIN;

      // Texto del preset (ON/OFF)
      const presetOnEl  = document.getElementById('presetOnText');
      const presetOffEl = document.getElementById('presetOffText');
      if (presetOnEl && presetOffEl){
        const t = buildOnOffText(prof.voice || {});
        presetOnEl.textContent  = t.on || '-';
        presetOffEl.textContent = t.off || '-';
      }

      // Texto "Ahora" seg√∫n settings actuales del usuario
      const nowOnEl  = document.getElementById('nowOnText');
      const nowOffEl = document.getElementById('nowOffText');
      if (nowOnEl && nowOffEl){
        const mapNow = _getVoiceToggleMap();
        const t2 = buildOnOffText(mapNow);
        nowOnEl.textContent  = t2.on || '-';
        nowOffEl.textContent = t2.off || '-';
      }
    }

    function updateConfigStatusUI(){
      try{
        const sess = String((typeof __lastAutoPresetType !== 'undefined' ? __lastAutoPresetType : 'TRAIN')).toUpperCase();
        const prof = SESSION_PRESET_PROFILES[sess] || SESSION_PRESET_PROFILES.TRAIN;

        const sessionPill = document.getElementById('cfgSessionPill');
        const presetPill  = document.getElementById('cfgPresetPill');
        const rdEl        = document.getElementById('cfgRdMode');
        const autoEl      = document.getElementById('cfgAutoMode');
        const precEl      = document.getElementById('cfgPrec');
        const voicesEl    = document.getElementById('cfgVoices');
        const noteEl      = document.getElementById('sessionPresetNote');

        if (sessionPill) sessionPill.textContent = `UI: ${(basicModeEnabled ? 'BASIC' : 'PRO')} - Sesi√≥n: ${sess}`;
        if (presetPill)  presetPill.textContent  = `Preset: ${(prof && prof.label) ? prof.label : '-'}`;

        // RD actual
        const rdRaw = (typeof raceDirectorMode === 'string' ? raceDirectorMode : prof.rdMode);
        const amRaw = (typeof autoCommentatorMode === 'string' ? autoCommentatorMode : prof.autoMode);
        const rd = rdRaw ? String(rdRaw) : 'minimal';
        const am = amRaw ? String(amRaw) : 'pro';
        const pr = (typeof decimalPrecision !== 'undefined' && decimalPrecision) ? decimalPrecision : prof.precision;

        if (rdEl) rdEl.textContent = (raceDirectorEnabled ? rd.toUpperCase() : 'OFF');
        if (autoEl) autoEl.textContent = am.toUpperCase();
        if (precEl) precEl.textContent = `${pr} d√©cimas`;
        if (voicesEl) voicesEl.textContent = (autoVoiceRotateEnabled ? 'ES + rotaci√≥n' : 'ES');

        if (noteEl) noteEl.textContent = `Auto: ${autoSessionPresetsEnabled ? 'ON' : 'OFF'}`;

        // active card highlight
        ['TRAIN','MANGA','FINAL'].forEach(k=>{
          const el = document.querySelector(`.session-preset-card[data-session="${k}"]`);
          if (el) el.classList.toggle('active', k===sess);
        });

        renderPresetCards();
      }catch(e){}
    }

    function applySessionPresetFull(type, source){
      const t = String(type || 'TRAIN').toUpperCase();
      const prof = SESSION_PRESET_PROFILES[t] || SESSION_PRESET_PROFILES.TRAIN;

      // Ajustes core
      raceDirectorEnabled = true;
      try { prefSet('raceDirectorEnabled', '1'); } catch(e) {}
      try { if (typeof updateRdButton === 'function') updateRdButton(); } catch(e) {}

      try { setRaceDirectorMode(prof.rdMode); } catch(e) {}
      try { setAutoCommentatorMode(prof.autoMode); } catch(e) {}
      applyDecimalPrecision(prof.precision);

      // Ajustes de mensajes por sesi√≥n: dejar claro ON/OFF
      try{
        if (!basicModeEnabled) {
          Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => {
            if (k === 'laps'){ voiceSettings.laps = true; return; }
            voiceSettings[k] = !!prof.voice[k];
          });
          voiceSettings.laps = true;
          applyVoiceSettingsToButtons();
          saveVoiceSettings();
        } else {
          // BASIC:
          // - SILENT: mantiene el BASIC cl√°sico (cero ruido)
          // - TV: permite presets por sesi√≥n, pero LIMITADOS al modo (UI simple)
          try {
            if (typeof uiNarrationMode !== 'undefined' && uiNarrationMode === 'SILENT') {
              applyBasicMode();
            } else {
              const allowed = (typeof MODE_ALLOWED_FLAGS !== 'undefined') ? MODE_ALLOWED_FLAGS[uiNarrationMode] : null;
              Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => {
                if (k === 'laps'){ voiceSettings.laps = true; return; }
                if (allowed && !allowed.has(k)) return;
                if (typeof prof.voice[k] === 'undefined') return;
                voiceSettings[k] = !!prof.voice[k];
              });
              voiceSettings.laps = true;
              applyVoiceSettingsToButtons();
              saveVoiceSettings();
            }
          } catch(e) {
            try { applyBasicMode(); } catch(e2) {}
          }
        }
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      }catch(e){}

      __lastAutoPresetType = t;
      updateConfigStatusUI();
      try { if (source) console.log('[PresetSesion]', t, 'source=', source); } catch(e){}
    }

    // Click handlers para aplicar preset manual
    function bindSessionPresetCards(){
      document.querySelectorAll('.session-preset-card').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const t = btn.getAttribute('data-session') || 'TRAIN';
          applySessionPresetFull(t, 'manual');
          playBeep('up');
        });
      });
    }


// ===== Voces (solo espa√±ol) + rotaci√≥n Auto Locutor =====
    let autoVoiceRotateEnabled = true; // ON por default
    let __autoVoicePool = [];
    let __autoVoiceIdx = 0;
    
    function nextAutoVoiceURI(){
      if (!autoVoiceRotateEnabled) return '';
      if (!__autoVoicePool || !__autoVoicePool.length) return '';
      const uri = __autoVoicePool[__autoVoiceIdx % __autoVoicePool.length];
      __autoVoiceIdx = (__autoVoiceIdx + 1) % __autoVoicePool.length;
      return uri || '';
    }

    
    // Defaults por plataforma: iPhone 1.2, Android 1.7, Web 2.0
    function _isIOSWebKitRate() {
      const ua = navigator.userAgent || '';
      return /iPad|iPhone|iPod/i.test(ua);
    }
    function _isAndroidRate() {
      const ua = navigator.userAgent || '';
      return /Android/i.test(ua);
    }
    function detectDefaultTtsRate() {
      if (_isIOSWebKitRate()) return 1.2;
      if (_isAndroidRate()) return 1.7;
      return 2.0;
    }

let ttsRate = detectDefaultTtsRate();

    try {
      const storedRate = prefGet('spotterTtsRate', null);
      if (storedRate) {
        const r = Number(storedRate);
        if (isFinite(r) && r >= 1.0 && r <= 2.5) ttsRate = r;
      }
      else {
        // Si no hay setting guardado, usamos el default por plataforma
        try { prefSet('spotterTtsRate', String(ttsRate)); } catch (e) {}
      }
} catch (e) {}

    if (rateRange) {
      rateRange.value = String(ttsRate);
      rateDisplay.textContent = `${Number(rateRange.value).toFixed(1)}x`;
      rateRange.addEventListener('input', () => {
        ttsRate = Number(rateRange.value) || 1.5;
        rateDisplay.textContent = `${Number(rateRange.value).toFixed(1)}x`;
        try { prefSet('spotterTtsRate', String(ttsRate)); } catch (e) {}
      });
    }

    function pickDefaultVoice(voices) {
      // Prioridad: es-MX, luego es (cualquier), luego lo que haya.
      const vMx = voices.find(v => (v.lang || '').toLowerCase().startsWith('es-mx'));
      if (vMx) return vMx;
      const vEs = voices.find(v => (v.lang || '').toLowerCase().startsWith('es'));
      if (vEs) return vEs;
      return voices[0] || null;
    }

    function refreshVoiceList() {
      if (!voiceSelect) return;

      const raw = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
      if (!raw || !raw.length) return;

      // Cargar seleccionado previo una sola vez
      if (!chosenVoiceURI) {
        try {
          const storedURI = prefGet('spotterVoiceURI', null);
          if (storedURI) chosenVoiceURI = storedURI;
        } catch (e) {}
      }

      // Deduplicar y ordenar (es-MX arriba)
      const seen = new Set();
      const voicesAll = raw.filter(v => {
        const k = `${v.voiceURI || v.name || ''}|${v.lang || ''}`;
        if (!k.trim()) return false;
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
      }).sort((a,b) => {
        const al = (a.lang || '').toLowerCase();
        const bl = (b.lang || '').toLowerCase();
        const aMx = al.startsWith('es-mx') ? 0 : 1;
        const bMx = bl.startsWith('es-mx') ? 0 : 1;
        if (aMx !== bMx) return aMx - bMx;
        return (a.name || '').localeCompare(b.name || '');
      });

      // Solo espa√±ol (fallback a todo si no hay voces ES)
      const voicesES = voicesAll.filter(v => ((v.lang || '').toLowerCase().startsWith('es')));
      const voices = voicesES.length ? voicesES : voicesAll;

      // Pool para rotaci√≥n de Auto Locutor (solo voces visibles)
      try {
        __autoVoicePool = voices.map(v => v.voiceURI).filter(Boolean);
        if (!__autoVoicePool.length) __autoVoicePool = voicesAll.map(v => v.voiceURI).filter(Boolean);
      } catch(e) {}


      voiceSelect.innerHTML = '';
      voices.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI || v.name || '';
        const nm = (v && v.name != null && String(v.name).trim() && String(v.name) !== 'undefined') ? String(v.name) : 'Voz';
        const lg = (v && v.lang != null && String(v.lang).trim() && String(v.lang) !== 'undefined') ? String(v.lang) : 'es';
        opt.textContent = `${nm} (${lg})`;
        voiceSelect.appendChild(opt);
      });

      let toUse = chosenVoiceURI ? voices.find(v => (v.voiceURI || v.name) === chosenVoiceURI) : null;
      if (!toUse) {
        toUse = pickDefaultVoice(voices);
        chosenVoiceURI = toUse ? (toUse.voiceURI || toUse.name) : '';
      }

      if (chosenVoiceURI) voiceSelect.value = chosenVoiceURI;

      if (!voiceSelect.__bound) {
        voiceSelect.__bound = true;
        voiceSelect.addEventListener('change', () => {
          chosenVoiceURI = voiceSelect.value || '';
          try { prefSet('spotterVoiceURI', chosenVoiceURI); } catch (e) {}
        });
      }
    }

    if (window.speechSynthesis) {
      refreshVoiceList();
    try { bindSessionPresetCards(); } catch(e) {}
    try { updateConfigStatusUI(); } catch(e) {}

      // Reintentos por si getVoices() llega vac√≠o al inicio (com√∫n en iOS/Android)
      let __vtries = 0;
      const __vtimer = setInterval(() => {
        __vtries++;
        refreshVoiceList();
        const v = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
        if ((v && v.length) || __vtries >= 10) clearInterval(__vtimer);
      }, 250);

      window.speechSynthesis.onvoiceschanged = () => refreshVoiceList();
    }

    // Bot√≥n de prueba de voz (genera gesto de usuario y ayuda a iOS)
    if (ttsTestBtn) {
      ttsTestBtn.addEventListener('click', () => {
        try { setVoiceMaster(true, { silent:true }); } catch(e) {}
        try { ensureAudioCtx(); } catch(e) {}
        try { playBeep('soft'); } catch(e) {}
        try {
          enqueueSpeech('Spotter listo. Probando voz.', { key:'tts_test', cat:'system', priority: 99, cooldownMs: 0, interrupt:true, dedupe: false });
        } catch(e) {}
      });
    }


    // Speech queue manager: evita que se trunque cuando entra otro mensaje.
    const speechQueue = [];
    let lastAnySpeechAt = 0;

    let speechSpeaking = false;
    let speechWatchdog = 0;
    const lastSpokenKeyAt = new Map();

    
    // =========================
    // TTS normalizaci√≥n de tiempos (evita que diga d√≠gito por d√≠gito)
    // =========================
    function normalizeTtsText(raw) {
      try {
        let s = String(raw || '');

        // Limpieza extra (por si algo se col√≥ fuera del safety net)
        s = s.replace(/\b(undefin\w*|undefined|null|nan)\b/ig,'').replace(/\s{2,}/g,' ').trim();

        // "+1 V" / "+2 V" -> "m√°s una vuelta" / "m√°s dos vueltas"
        s = s.replace(/\+(\d+)\s*V\b/ig, (m0, n0) => {
          const n = Math.max(0, parseInt(n0, 10) || 0);
          if (!n) return '';
          const txt = numeroATexto0a999(n);
          const word = (n === 1) ? 'vuelta' : 'vueltas';
          return 'm√°s ' + txt + ' ' + word;
        });

        // P1 / P 2 / "Rank P3" -> lectura m√°s clara en espa√±ol
        s = s.replace(/\bRank\s+P\s?(\d{1,2})\b/ig, (m0, n0) => {
          const n = Math.max(0, parseInt(n0, 10) || 0);
          if (!n) return m0;
          return 'Rank, P ' + numeroATexto0a999(n);
        });
        s = s.replace(/\bP\s?(\d{1,2})\b/g, (m0, n0) => {
          const n = Math.max(0, parseInt(n0, 10) || 0);
          if (!n) return m0;
          return 'P ' + numeroATexto0a999(n);
        });

        // mm:ss.mmm
        s = s.replace(/\b(\d{1,2}):(\d{2})\.(\d{3})\b/g, (m0) => {
          const ms = parseTimeToMs(m0);
          return ms ? tiempoATexto(ms) : m0;
        });

        // ss.xxx (evitar tocar versiones tipo 4.0.7: usa lookaround para no estar pegado a otro punto)
        s = s.replace(/(^|[^\d.])(\d{1,2}\.\d{1,3})(?![\d.])/g, (m0, pre, tok) => {
          const v = parseFloat(tok);
          if (!isFinite(v) || v <= 0 || v >= 180) return pre + tok;
          const ms = parseTimeToMs(v);
          return pre + (ms ? tiempoATexto(ms) : tok);
        });

        return s;
      } catch(e) {
        return String(raw || '');
      }
    }

    // =========================
    // MANGA: reloj de 3:00 POR PILOTO (arranca en su 1er cruce por meta)
    // - La sesi√≥n dura 3:00, pero cada piloto trae su propio cron√≥metro (salida escalonada).
    // - Guardamos el inicio por piloto (pilotKey) para que NO se reinicie al cambiar de piloto seguido.
    // =========================
    let mangaClockTimer = 0;
    const MANGA_SESSION_MS = 180000;

    // pilotKey -> epoch ms (inicio aproximado del cron√≥metro de ese piloto)
    let mangaPilotStartAt = new Map();
    // pilotKey -> laps vistos en el tick anterior (para detectar primer cruce)
    let mangaPrevLapsByPilot = new Map();
    // pilotKey -> ya anunciamos "Inicio cronometro" (evita repetir al volver a seleccionar)
    let mangaStartAnnouncedByPilot = new Set();

    // First-detect beep (suave) por piloto (no repetir cuando re-seleccionas)
    let firstDetectBeepedByPilot = new Map();

    function setMangaClockVisible(on) {
      const it = document.getElementById('mangaClockItem');
      if (!it) return;
      if (on) it.classList.remove('timer-only');
      else it.classList.add('timer-only');
    }

    function formatClockMs(ms) {
      const v = Math.max(0, Math.floor(ms));
      const mm = Math.floor(v / 60000);
      const ss = Math.floor((v % 60000) / 1000);
      const mmm = v % 1000;
      return String(mm) + ':' + String(ss).padStart(2,'0') + '.' + String(mmm).padStart(3,'0');
    }

// Formato unificado para mostrar el "time" del feed en HH:MM:SS.mmm
// Acepta:
// - string "m:ss.mmm" o "h:mm:ss.mmm"
// - number / string num√©rica en ms (>=1000)
// - number / string num√©rica en segundos (<1000)
function formatFeedTimeHMSms(v) {
  if (v == null) return '';
  const s0 = String(v).trim();
  if (!s0) return '';

  // Caso 1: ya viene con ":" (m:ss.mmm o h:mm:ss.mmm)
  if (s0.includes(':')) {
    const parts = s0.split(':').map(p => p.trim());
    let h = 0, m = 0, secPart = '';
    if (parts.length >= 3) {
      h = parseInt(parts[0], 10) || 0;
      m = parseInt(parts[1], 10) || 0;
      secPart = parts.slice(2).join(':');
    } else {
      m = parseInt(parts[0], 10) || 0;
      secPart = parts[1] || '0';
    }
    let ss = 0, ms = 0;
    if (secPart.includes('.')) {
      const sp = secPart.split('.');
      ss = parseInt(sp[0], 10) || 0;
      const msStr = (sp[1] || '').padEnd(3, '0').slice(0, 3);
      ms = parseInt(msStr, 10) || 0;
    } else {
      ss = parseInt(secPart, 10) || 0;
    }
    const totalMs = (((h * 60) + m) * 60 + ss) * 1000 + ms;
    return formatMsToHMSms(totalMs);
  }

  // Caso 2: num√©rico (ms o segundos)
  if (/^[0-9]+(?:\.[0-9]+)?$/.test(s0)) {
    const n = Number(s0);
    if (!isFinite(n)) return '';
    // Heur√≠stica: si es >=1000 asumimos ms, si no segundos
    const ms = (n >= 1000) ? Math.round(n) : Math.round(n * 1000);
    return formatMsToHMSms(ms);
  }

  // Caso 3: cualquier otra cosa, lo dejamos igual
  return s0;
}

function formatMsToHMSms(ms) {
  const v = Math.max(0, Math.floor(ms));
  const hh = Math.floor(v / 3600000);
  const mm = Math.floor((v % 3600000) / 60000);
  const ss = Math.floor((v % 60000) / 1000);
  const mmm = v % 1000;
  return String(hh).padStart(2,'0') + ':' + String(mm).padStart(2,'0') + ':' + String(ss).padStart(2,'0') + '.' + String(mmm).padStart(3,'0');
}

    function setMangaClockColorByRemaining(remMs) {
      const el = document.getElementById('mangaClock');
      if (!el) return;
      const r = Math.max(0, Math.min(1, remMs / MANGA_SESSION_MS));
      const hue = 120 * r; // 120=verde, 60=amarillo, 0=rojo
      el.style.setProperty('--clock-hue', hue.toFixed(1));
    }

    function flashMangaClock() {
      const el = document.getElementById('mangaClock');
      if (!el) return;
      el.classList.add('flash');
      setTimeout(() => el.classList.remove('flash'), 750);
    }

    function updateMangaClockDisplay() {
      const el = document.getElementById('mangaClock');
      if (!el) return;

      // Mostramos el campo "time" del feed (ms o string), no cron√≥metro local.
      if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) {
        el.textContent = '--:--:--.---';
        el.style.setProperty('--clock-hue', '120');
        return;
      }

      let row = null;

      // 1) Si sigues piloto, ese manda
      if (selectedPilotKey) {
        row = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey) || null;
      }

      // 2) Si est√°s en Auto Locutor, usa el foco (o l√≠der)
      if (!row) {
        let k = '';
        try { k = autoLocutorFocusKey || ''; } catch(e) { k = ''; }
        if (k) row = raceData.classification.find(r => getPilotKey(r) === k) || null;
        if (!row) {
          const top = getTopRowsUnique(1);
          row = top && top[0] ? top[0] : (raceData.classification[0] || null);
        }
      }

      const tRaw = (row && row.time != null) ? row.time : '';
      const t = formatFeedTimeHMSms(tRaw);
      el.textContent = t ? t : '--:--:--.---';
      // Siempre alto contraste
      el.style.setProperty('--clock-hue', '120');
    }

    // MANGA: TIME
    // MANGA: TIME del feed (sin ticker local)
function stopMangaClock() {
  try {
    if (mangaClockTimer) { clearInterval(mangaClockTimer); mangaClockTimer = 0; }
  } catch(e) {}
  try { setMangaClockVisible(false); } catch(e) {}
}

// MANGA: actualizar reloj por piloto en cada tick (arranca al 1er cruce REAL por meta: 0 -> 1)
function updateMangaPilotStartsFromClassification(classification) {
  try {
    const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
    if (!isManga) return;

    // Solo UI: mostrar el TIME del feed para el piloto seguido.
    setMangaClockVisible(true);
    updateMangaClockDisplay();
  } catch(e) {}
}


function flashPilotCardGreen() {
      const card = document.querySelector('.pilot-card');
      if (!card) return;
      card.classList.add('flash-green');
      setTimeout(() => card.classList.remove('flash-green'), 650);
    }

    // =========================
    // Record de carrera: avisar cuando lo mejora CUALQUIERA
    // =========================
    let lastGlobalBestSpokenMs = 0;
    let lastGlobalBestSpokenHolderKey = null;
    let lastGlobalBestSpokenAt = 0;


function clampNum(v, lo, hi){
      const n = Number(v);
      if (!isFinite(n)) return lo;
      return Math.max(lo, Math.min(hi, n));
    }

    function prosodyFromMood(mood){
      const m = String(mood||'').toLowerCase();
      // Nota: Web Speech API no tiene "emociones" reales. Esto solo ajusta rate/pitch/volume.
      if (m === 'hype' || m === 'excited') return { rateMul: 1.06, pitch: 1.12, volume: 1.0 };
      if (m === 'urgent') return { rateMul: 1.10, pitch: 1.18, volume: 1.0 };
      if (m === 'calm') return { rateMul: 0.98, pitch: 0.96, volume: 0.95 };
      if (m === 'serious') return { rateMul: 0.99, pitch: 0.92, volume: 1.0 };
      return { rateMul: 1.0, pitch: 1.0, volume: 1.0 };
    }

    // =========================
    // Anti-spam por inactividad: si no hay "movimiento" 20s, silenciar voz hasta nuevo movimiento
    // Movimiento = cambio de lapcount/pos/tiempos (detectado en normalizeRaceData)
    // =========================
    const IDLE_SILENCE_MS = 20000;
    let lastMovementAt = Date.now();
    let idleSilenceActive = false;

    function markMovement(reason) {
      lastMovementAt = Date.now();
      try { diagLastRaceChangeAt = lastMovementAt; } catch(e) {}
      if (idleSilenceActive) {
        idleSilenceActive = false;
      }
    }

    function applyIdleSilenceIfNeeded() {
      const now = Date.now();
      // Inactividad = sin cambios reales de carrera (vueltas/pos/tiempos). Si solo llegan refresh repetidos, calla.
      if (typeof sessionFinishAnnounced !== 'undefined' && sessionFinishAnnounced) return true;

      const lastActAt = (typeof lastMovementAt !== 'undefined' && lastMovementAt) ? Number(lastMovementAt) : 0;
      const lastActivityAt = lastActAt || 0;

      const idle = (now - lastActivityAt) > IDLE_SILENCE_MS;
      if (idle && !idleSilenceActive) {
        idleSilenceActive = true;
        try { speechQueue.length = 0; } catch(e) {}
        try { if (window.speechSynthesis) window.speechSynthesis.cancel(); } catch(e) {}
      }
      if (!idle && idleSilenceActive) {
        idleSilenceActive = false;
      }
      return idleSilenceActive;
    }



function enqueueSpeech(text, opts = {}) {
      try {
        if (!voiceMasterEnabled) return;

        let clean = String(text || '').trim();
        // Safety net: evita que TTS diga literalmente 'undefined'/'null'
        clean = clean.replace(/\b(undefined|null|nan)\b/ig,'').replace(/\s{2,}/g,' ').trim();
        if (!clean) return;
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;
        if (typeof sessionFinishAnnounced !== 'undefined' && sessionFinishAnnounced) {
          const k = String((opts && opts.key) || '');
          if (!k.startsWith('session_finish_')) return;
        }
        if (applyIdleSilenceIfNeeded()) return;

        const now = Date.now();
        const cat = String(opts.cat || opts.type || '').trim();

        

        // key: dedupe/cooldown. si no viene, usa texto
        // (Debe declararse ANTES de cualquier guard que lo use para evitar TDZ)
        const key = String(((opts && (opts.key || opts.k)) || '')).trim() || clean;
        // System/bypass keys: siempre permitidos (no dependen de modo ni toggles)
        const __bypassKey = (key.startsWith('tts_') || key.startsWith('pilot_') || key.startsWith('sys_') || key.startsWith('auto_') || key.startsWith('sys_auto_'));

        // ===== Guard: modo + flags (evita que SUPER light hable de m√°s y reduce spam) =====
        // Nota: si el caller no manda cat, inferimos por key/texto y si no, cae en 'misc' (se filtra).
        let catNorm = cat;
        if (!__bypassKey) {
          if (!catNorm) {
            const k2 = String((opts && (opts.key || opts.k)) || '').toLowerCase();
            const t2 = clean.toLowerCase();
            if (k2.startsWith('session_finish_')) catNorm = 'total';
            else if (k2.startsWith('courtesy_') || k2.includes('courtesy')) catNorm = 'courtesy';
            else if (k2.includes('blueflag') || k2.includes('blue_flag') || k2.includes('blue-flag')) catNorm = 'blueflag';
            else if (k2.includes('top3') || k2.includes('podium')) catNorm = 'podium';
            else if (k2.includes('battle') || k2.includes('pelea') || k2.includes('duel')) catNorm = 'pelea';
            else if (k2.includes('leadergap') || k2.includes('leader_gap') || (k2.startsWith('leader_'))) catNorm = 'leadergap';
            else if (k2.includes('gap')) catNorm = 'gaps';
            else if (k2.includes('ritmo') || k2.includes('pace')) catNorm = 'ritmo';
            else if (k2.includes('attack')) catNorm = 'attack';
            else if (k2.includes('defense')) catNorm = 'defense';

            else if (k2.includes('bestlap') || t2.includes('best lap')) catNorm = 'bestlap';
            else if (k2.includes('blue') || t2.includes('bandera azul')) catNorm = 'blueflag';
            else if (k2.includes('pos') || t2.includes('posicion') || t2.includes('posici√≥n')) catNorm = 'pos';
            else if (k2.includes('lap')) catNorm = 'laps';
            else catNorm = 'misc';
          }
        } else {
          catNorm = 'system';
        }

        const flag = (catNorm === 'leader' ? 'leadergap' : catNorm);
        const allowedSet = (typeof MODE_ALLOWED_FLAGS !== 'undefined' && MODE_ALLOWED_FLAGS)
          ? (MODE_ALLOWED_FLAGS[uiNarrationMode] || MODE_ALLOWED_FLAGS.TV)
          : null;

        if (!__bypassKey) {
          // SUPER light: solo laps + pos
          if (uiNarrationMode === 'SUPER') {
            if (!(flag === 'laps' || flag === 'pos' || String(key||'').startsWith('session_finish_'))) return true;
          } else {
            // Otros modos: respeta allowed set
            if (allowedSet && flag !== 'laps' && !allowedSet.has(flag) && !String(key||'').startsWith('session_finish_')) return true;
            // 'misc' solo se permite en TV (y aun as√≠, se filtra por voiceSettings si existe)
            if (flag === 'misc' && uiNarrationMode !== 'TV') return true;
          }

          // Respeta toggles (voiceSettings)
          try {
            if (typeof voiceSettings !== 'undefined' && voiceSettings && flag && flag !== 'laps') {
              if (Object.prototype.hasOwnProperty.call(voiceSettings, flag) && !voiceSettings[flag]) return true;
            }
          } catch(e){}
        }

        // Defaults por capa (TV): evita hablar del pasado y mantiene consistencia
        const sessType = (typeof currentSessionInfo !== 'undefined' && currentSessionInfo && currentSessionInfo.type) ? String(currentSessionInfo.type) : '';
        const isManga = (sessType === 'MANGA');
        const isFinal = (sessType === 'FINAL');

        // ttlMs: si el mensaje caduca, se descarta antes de hablar (anti "dato viejo")
        let ttlMs = (opts.ttlMs != null) ? Number(opts.ttlMs) : NaN;
        if (!isFinite(ttlMs)) {
          if (cat === 'pos') ttlMs = isManga ? 6000 : 2800;
          else if (cat === 'gaps') ttlMs = isManga ? 3800 : 2200;
          else if (cat === 'leader' || cat === 'leadergap') ttlMs = 5000;
          else if (cat === 'podium') ttlMs = 6500;
          else if (cat === 'bestlap') ttlMs = 9000;
          else if (cat === 'blueflag') ttlMs = 4500;
          else if (cat === 'ritmo' || cat === 'ritmo_up' || cat === 'ritmo_down') ttlMs = 6000;
          else if (cat === 'total') ttlMs = 16000;
          else ttlMs = 12000;
        }
        ttlMs = Math.max(800, Math.min(30000, ttlMs));
        const expiresAt = (opts.expiresAt != null) ? Number(opts.expiresAt) : (now + ttlMs);

        // priority por capa si no viene expl√≠cito (0 es v√°lido, pero aqu√≠ usamos "no definido" = null)
        let priority = (Number.isFinite(opts.priority) ? opts.priority : null);
        if (priority == null) {
          if (cat === 'bestlap') priority = 80;
          else if (cat === 'laps') priority = 90;
          else if (cat === 'blueflag') priority = 75;
          else if (cat === 'pos') priority = isManga ? 55 : 65;
          else if (cat === 'leader' || cat === 'leadergap') priority = 60;
          else if (cat === 'podium') priority = 55;
          else if (cat === 'fight') priority = 50;
          else if (cat === 'gaps') priority = 35;
          else if (cat === 'ritmo' || cat === 'ritmo_up' || cat === 'ritmo_down') priority = 25;
          else if (cat === 'total') priority = 10;
          else priority = 20;
        }

        
        // cooldown: caller puede pedir, pero aqu√≠ imponemos m√≠nimos para evitar spam
        let cooldownMs = Number(opts.cooldownMs || 0) || 0;
        try {
          // m√≠nimos por categor√≠a (especialmente en MANGA donde hay jitter)
          const minCd =
            (flag === 'pos')     ? (isManga ? 6500 : 3200) :
            (flag === 'bestlap') ? 14000 :
            (flag === 'leadergap') ? 7000 :
            (flag === 'pelea')   ? 7500 :
            (flag === 'blueflag')? 9000 :
            (flag === 'podium')  ? 12000 :
            (flag === 'total')   ? 600000 :
            0;
          cooldownMs = Math.max(cooldownMs, minCd);
        } catch(e) {}

        if (cooldownMs > 0) {
          const last = lastSpokenKeyAt.get(key) || 0;
          if (now - last < cooldownMs) return;
        }

        const interrupt = !!opts.interrupt;
        const dedupe = (opts.dedupe !== false);

        // replaceKey: mantiene la cola limpia (ej. gaps/podio/l√≠der actualiza, no apila)
        const replaceKey = (opts.replaceKey !== false) && (!!cat) && (['pos','gaps','leader','leadergap','podium','total'].includes(cat));
        if (replaceKey) {
          try {
            for (let i = speechQueue.length - 1; i >= 0; i--) {
              if (speechQueue[i] && speechQueue[i].key === key) speechQueue.splice(i, 1);
            }
          } catch(e) {}
        }

        if (dedupe) {
          if (speechQueue.some(it => it.text === clean)) return;
        }

        if (interrupt) {
          try { speechQueue.length = 0; } catch(e) {}
          speechSpeaking = false;
          try { window.speechSynthesis.cancel(); } catch (e) {}
        }

        const baseRate = (Number.isFinite(ttsRate) ? ttsRate : 1.5);
        const mood = opts.mood;
        const pr = prosodyFromMood(mood);
        const rate = clampNum((opts.rate != null ? opts.rate : (baseRate * (pr.rateMul || 1.0))), 0.6, 2.2);
        const pitch = clampNum((opts.pitch != null ? opts.pitch : (pr.pitch != null ? pr.pitch : 1.0)), 0.5, 2.0);
        const volume = clampNum((opts.volume != null ? opts.volume : (pr.volume != null ? pr.volume : 1.0)), 0.0, 1.0);

        speechQueue.push({
          text: clean,
          key,
          priority,
          ts: now,
          expiresAt,
          rate,
          pitch,
          volume,
          cat,
          validatePos: (opts && opts.validatePos) ? opts.validatePos : null,
          validateLap: (opts && opts.validateLap) ? opts.validateLap : null
        });

        // Prioridad desc, FIFO por tiempo
        speechQueue.sort((a,b) => (b.priority - a.priority) || (a.ts - b.ts));

        // Tope de cola (evita mon√≥logos si el feed se vuelve loco)
        const MAX_Q = 10;
        if (speechQueue.length > MAX_Q) {
          speechQueue.splice(MAX_Q); // recorta sin reasignar (speechQueue es const)
        }

        pumpSpeechQueue();
      } catch (e) {
        console.error('enqueueSpeech', e);
      }
    }

    function pumpSpeechQueue() {
      try {
        if (!voiceMasterEnabled) return;
        if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) return;

        if (speechSpeaking || window.speechSynthesis.speaking) return;
        if (applyIdleSilenceIfNeeded()) return;

        let next = null;
        while (true) {
          next = speechQueue.shift();
          if (!next) return;

          // Expiry: evita hablar del pasado (capas TV)
          try {
            if (next.expiresAt && Date.now() > next.expiresAt) continue;
          } catch(e) {}

          // Stale-guard: si la condici√≥n ya no se cumple (ej. POS cambi√≥), descarta este mensaje
          if (next.validatePos) {
            try {
              const pk = next.validatePos.pilotKey || selectedPilotKey;
              const wanted = Math.floor(Number(next.validatePos.pos) || 0);
              if (pk && wanted > 0 && raceData && Array.isArray(raceData.classification)) {
                const i = findPilotIndexByKey(pk);
                if (i >= 0) {
                  const cp = Math.floor(Number((raceData.classification[i] && raceData.classification[i].pos) || 0));
                  if (cp && cp !== wanted) continue; // descarta mensaje viejo
                }
              }
            } catch (e) {}
          }

          // Stale-guard adicional: si la vuelta ya cambi√≥, descarta este mensaje (evita datos viejos)
          if (next.validateLap) {
            try {
              const pk = next.validateLap.pilotKey || selectedPilotKey;
              const wantedLap = Math.floor(Number(next.validateLap.lapcount) || 0);
              if (pk && wantedLap > 0 && raceData && Array.isArray(raceData.classification)) {
                const i = findPilotIndexByKey(pk);
                if (i >= 0) {
                  const cl = Math.floor(Number((raceData.classification[i] && raceData.classification[i].lapcount) || 0));
                  if (cl && cl !== wantedLap) continue;
                }
              }
            } catch (e) {}
          }

          break;
        }
        if (!next) return;

        const u = new SpeechSynthesisUtterance(normalizeTtsText(next.text));
        u.lang = 'es-MX';
        u.rate = (next.rate != null ? next.rate : (isFinite(ttsRate) ? ttsRate : 1.5));
        u.pitch = (next.pitch != null ? next.pitch : 1.0);
        u.volume = (next.volume != null ? next.volume : 1.0);

        const voices = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
        if (voices && voices.length) {
          let v = null;
          if (chosenVoiceURI) v = voices.find(x => (x.voiceURI || x.name) === chosenVoiceURI);
          if (!v) v = pickDefaultVoice(voices);
          if (v) {
            u.voice = v;
            if (v.lang) u.lang = v.lang;
          }
        }

        speechSpeaking = true;

        const clearWd = () => {
          if (speechWatchdog) { clearTimeout(speechWatchdog); speechWatchdog = 0; }
        };
        clearWd();
        speechWatchdog = setTimeout(() => {
          // watchdog anti-freeze (iOS/Chrome a veces se queda "hablando")
          try { window.speechSynthesis.cancel(); } catch (e) {}
          speechSpeaking = false;
          pumpSpeechQueue();
        }, 15000);

        u.onend = () => {
          clearWd();
          speechSpeaking = false;
          lastAnySpeechAt = Date.now();
          lastSpokenKeyAt.set(next.key, Date.now());
          try { if (next.cat) bumpNarrUsage(next.cat); } catch(e) {}
          pumpSpeechQueue();
        };
        u.onerror = () => {
          clearWd();
          speechSpeaking = false;
          lastAnySpeechAt = Date.now();
          lastSpokenKeyAt.set(next.key, Date.now());
          try { if (next.cat) bumpNarrUsage(next.cat); } catch(e) {}
          pumpSpeechQueue();
        };

        window.speechSynthesis.speak(u);
      } catch (e) {
        console.error('pumpSpeechQueue', e);
        speechSpeaking = false;
      }
    }

    function speakText(text, opts) {
      enqueueSpeech(text, opts || {});
    }

    // LAPS prefix latch: evita repetir "X vueltas" dos veces en la misma vuelta
    let __lastLapsPrefixLap = null;
    let __lastLapsPrefixAt = 0;

function speakWithLaps(_laps, message, opts) {
      // Prefijo de LAPS (opcional): si "Vueltas" est√° apagado, no digas "10 vueltas..."
      const msg = String(message || '').trim();
      const allowPrefix = false;

      if (!allowPrefix) {
        if (msg) speakText(msg, opts || {});
        return;
      }

      // Regla: no decir "Vuelta X" ni el n√∫mero de vuelta.
      // Aqu√≠ s√≠ leemos LAPS primero (como siempre), y metemos coma para pausar antes del mensaje.
      let prefix = '';
      const laps = (_laps == null) ? null : Number(_laps);
      const __now = Date.now();
      const __sameLapRecently = (Number.isFinite(laps) && (__lastLapsPrefixLap === Math.floor(laps)) && ((__now - __lastLapsPrefixAt) < 1800));
      if (Number.isFinite(laps) && laps >= 0) {
        if (!__sameLapRecently) {
          if (laps === 1) prefix = 'Una vuelta';
          else prefix = String(Math.floor(laps)) + ' vueltas';
          __lastLapsPrefixLap = Math.floor(laps);
          __lastLapsPrefixAt = __now;
        }
      }

      const finalText = prefix ? (msg ? (prefix + ', ' + msg) : (prefix + '.')) : msg;
      if (finalText) speakText(finalText, opts || {});
    }

    function formatAnnouncer(msg) {
      // PRO: directo y claro
      return String(msg || '').trim();
    }

    // Bot√≥n maestro de voz (iOS requiere gesto del usuario)

function isIOSWebKit() {
      const ua = navigator.userAgent || '';
      return /iPad|iPhone|iPod/i.test(ua);
    }
    function scheduleOneTapUnlock() {
      // iOS/Chrome (WebKit) a veces no suelta TTS hasta un tap extra.
      const handler = () => {
        if (!pendingAutoVoiceUnlock) return;
        pendingAutoVoiceUnlock = false;
        try { voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
        // aqu√≠ s√≠ hacemos unlock completo
        try { setVoiceMaster(true); } catch(e) {}
      };
      try { window.addEventListener('touchstart', handler, { once:true, passive:true, capture:true }); } catch(e) {}
      try { window.addEventListener('pointerdown', handler, { once:true, passive:true, capture:true }); } catch(e) {}
    }

function setVoiceMaster(on, opts = {}) {

      // cualquier unlock pendiente se resuelve aqu√≠
      // IMPORTANT: estamos dentro de un click/tap del usuario, desbloquea audio aqu√≠ mismo (iOS/WebKit)
      try { __userGestureUnlocked = true; } catch(e) {}
      try { ensureAudioCtx(); } catch(e) {}
      try { if (window.speechSynthesis && window.speechSynthesis.resume) window.speechSynthesis.resume(); } catch(e) {}
      try { if (window.speechSynthesis && window.speechSynthesis.getVoices) window.speechSynthesis.getVoices(); } catch(e) {}
      pendingAutoVoiceUnlock = false;
      try { voiceToggleBtns.forEach(b => b.classList.remove('needs-unlock')); } catch(e) {}
voiceMasterEnabled = !!on;
      try { prefSet('voiceMasterEnabled', voiceMasterEnabled ? '1' : '0'); } catch(e) {}
      try { voiceToggleBtns.forEach(b => b.classList.toggle('voice-on', voiceMasterEnabled)); } catch(e) {}
      try {
        voiceToggleBtns.forEach(b => {
          const sub = b.querySelector('.cbtn-sub');
          if (sub) {
            try { b.setAttribute('data-voice', voiceMasterEnabled ? 'on' : 'off'); } catch(e) {}
            sub.textContent = '';
            try { sub.style.display = 'none'; } catch(e) {}
          } else {
            b.textContent = voiceMasterEnabled ? 'üîä VOZ ACTIVA' : 'üîä ACTIVAR VOZ';
          }
        });
      } catch(e) {}
      // unlock audio (seleccionar piloto cuenta como gesto)
      try { ensureAudioCtx(); } catch(e) {}
      if (voiceMasterEnabled && !opts.silent) {
        try { playBeep('up'); } catch(e) {}

        // iOS/WebKit: hablar en el MISMO gesto del usuario (sin depender de cola)
        try {
          if (window.speechSynthesis && window.SpeechSynthesisUtterance) {
            try { if (window.speechSynthesis.resume) window.speechSynthesis.resume(); } catch(e) {}
            let u0 = new SpeechSynthesisUtterance(normalizeTtsText('Audio listo'));
            u0.lang = 'es-MX';
            u0.rate = (isFinite(ttsRate) ? ttsRate : 1.5);
            u0.pitch = 1.0;
            u0.volume = 1.0;

            const voices0 = window.speechSynthesis.getVoices ? window.speechSynthesis.getVoices() : [];
            if (voices0 && voices0.length) {
              let v0 = null;
              if (chosenVoiceURI) v0 = voices0.find(x => (x.voiceURI || x.name) === chosenVoiceURI);
              if (!v0) v0 = pickDefaultVoice(voices0);
              if (v0) { u0.voice = v0; if (v0.lang) u0.lang = v0.lang; }
            }

            // Si el motor quedo "speaking" pegado, cancela SOLO si realmente esta hablando
            try { if (window.speechSynthesis.speaking || window.speechSynthesis.pending) window.speechSynthesis.cancel(); } catch(e) {}
            window.speechSynthesis.speak(u0);
          }
        } catch(e) {}

        // Backup: cola normal (por si algun navegador ignora el utterance inmediato)
        try { speakText('Audio listo', {priority: 99, interrupt: true, dedupe: false}); } catch(e) {}
        try { setTimeout(pumpSpeechQueue, 0); setTimeout(pumpSpeechQueue, 180); } catch(e) {}
      }
      if (!voiceMasterEnabled) {
        try { window.speechSynthesis.cancel(); } catch(e) {}
      }
    }

          if (voiceToggleBtns && voiceToggleBtns.length) {
      voiceToggleBtns.forEach(btn => {
        try {
          btn.addEventListener('click', () => {
            // iOS/WebKit: desbloquea audio en el MISMO click (si no, a veces requiere 2 taps)
            try { __userGestureUnlocked = true; } catch(e) {}
            try { ensureAudioCtx(); } catch(e) {}
            try { if (window.speechSynthesis && window.speechSynthesis.resume) window.speechSynthesis.resume(); } catch(e) {}
            setVoiceMaster(!voiceMasterEnabled);
          });
        } catch(e) {}
      });
    }

    // Toggle UI de mensajes
    function applyVoiceSettingsToButtons() {
      spotterButtons.forEach(btn => {
        const flag = btn.getAttribute('data-flag');
        if (!flag) return;
        const on = (flag === 'laps') ? true : !!voiceSettings[flag];
        btn.classList.toggle('active', on);
      
        // LAPS siempre activo y bloqueado visual
        if (flag === 'laps') { btn.classList.add('locked'); } else { btn.classList.remove('locked'); }
});

      // Sync BASIC toggles (si existen)
      try{
        basicToggleButtons.forEach(b=>{
          const flag = b.getAttribute('data-flag');
          if (!flag) return;
          const on = (flag === 'laps') ? true : !!voiceSettings[flag];
          b.classList.toggle('active', on);
          if (flag === 'laps') b.classList.add('lock');
        });
      }catch(e){}

      try { if (typeof updateConfigStatusUI === 'function') updateConfigStatusUI(); } catch(e) {}
}

    applyVoiceSettingsToButtons();

    spotterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const flag = btn.getAttribute('data-flag');
        if (!flag) return;

        if (flag === 'laps') {
          // no se apaga
          voiceSettings.laps = true;
          applyVoiceSettingsToButtons();
          saveVoiceSettings();
          try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
          return;
        }

        voiceSettings[flag] = !voiceSettings[flag];
        applyVoiceSettingsToButtons();
        saveVoiceSettings();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
        playBeep(voiceSettings[flag] ? 'up' : 'down');
      });
    });

    

    // =========================
    // Master: prender/apagar todos los mensajes (excepto Laps)
    // =========================
    const toggleAllMsgsBtn = document.getElementById('toggleAllMsgsBtn');

    // =========================
    // Presets r√°pidos (RD PRO limpio / RD SHOW)
    // - Ajusta los mismos toggles del spotter (lo que el RD usa para decidir que narrar).
    // =========================
    const presetRdProBtn  = document.getElementById('presetRdProBtn');
    const presetRdShowBtn = document.getElementById('presetRdShowBtn');
    const SPOTTER_PRESET_KEY = 'spotterMasterPreset';

    function setPresetBtnActive(name){
      try{
        if (presetRdProBtn)  presetRdProBtn.classList.toggle('active', name === 'pro');
        if (presetRdShowBtn) presetRdShowBtn.classList.toggle('active', name === 'show');
        localStorage.setItem(SPOTTER_PRESET_KEY, name || '');
      }catch(e){}
    }

    function applyPresetVoiceSettings(preset){
      // PRO limpio: directo, sin ruido
      const base = {
        laps: true,
        pos: true,
        gaps: true,
        leadergap: true,
        podium: true,
        blueflag: true,
      courtesy: true,
        front06: true,
        back06: true,
        attack: true,
        defense: true,

        // OFF por defecto
        ritmo: false,
        estlap: false,
        total: false,
        cons10: false,
        bestlap: false,
        box: false,
        pelea: false,
        netgain: false
      };

      // SHOW: mas emocion
      if (preset === 'show'){
        base.bestlap = true;
        base.pelea = true;
        base.ritmo = true;
      }

      try{
        Object.keys(DEFAULT_VOICE_SETTINGS).forEach(k => {
          if (k === 'laps'){ voiceSettings.laps = true; return; }
          if (k === 'saylaps'){ return; }
          voiceSettings[k] = !!base[k];
        });
        voiceSettings.laps = true;
        applyVoiceSettingsToButtons();
        saveVoiceSettings();
        try { if (typeof updateToggleAllMsgsBtn === 'function') updateToggleAllMsgsBtn(); } catch(e) {}
      }catch(e){}
    }

    if (presetRdProBtn){
      presetRdProBtn.addEventListener('click', () => {
        applyPresetVoiceSettings('pro');
        setPresetBtnActive('pro');
        playBeep('up');
      });
    }
    if (presetRdShowBtn){
      presetRdShowBtn.addEventListener('click', () => {
        applyPresetVoiceSettings('show');
        setPresetBtnActive('show');
        playBeep('up');
      });
    }

    // Solo restaura highlight (no pisa tus settings)
    try{
      const savedPreset = localStorage.getItem(SPOTTER_PRESET_KEY);
      if (savedPreset === 'pro' || savedPreset === 'show') setPresetBtnActive(savedPreset);
    }catch(e){}


    function isAllMsgsOn(){
      let allOn = true;
      try{
        spotterButtons.forEach(btn => {
          const flag = btn.getAttribute('data-flag');
          if (!flag || flag === 'laps' || flag === 'saylaps') return;
          if (!voiceSettings[flag]) allOn = false;
        });
      }catch(e){}
      return allOn;
    }

    function updateToggleAllMsgsBtn(){
      if (!toggleAllMsgsBtn) return;
      const allOn = isAllMsgsOn();
      toggleAllMsgsBtn.textContent = allOn ? 'TODO OFF' : 'TODO ON';
      toggleAllMsgsBtn.classList.toggle('active', allOn);
    }

    if (toggleAllMsgsBtn){
      updateToggleAllMsgsBtn();
      toggleAllMsgsBtn.addEventListener('click', () => {
        const allOn = isAllMsgsOn();
        try{
          spotterButtons.forEach(btn => {
            const flag = btn.getAttribute('data-flag');
            if (!flag || flag === 'laps' || flag === 'saylaps') return;
            voiceSettings[flag] = !allOn;
          });
          voiceSettings.laps = true;
          applyVoiceSettingsToButtons();
          saveVoiceSettings();
          updateToggleAllMsgsBtn();
          playBeep(!allOn ? 'up' : 'down');
        }catch(e){}
      });
    }

    // =========================
    // Categor√≠as desplegables (Esenciales / Batalla / Resumen)
    // =========================


// =========================
    
    const DEFAULT_MESSAGE_TOGGLES = {
      laps: true,              // siempre ON (bloqueado)
      blueflag: true,
      courtesy: true,
      ritmo_up: true,
      ritmo_down: true,
      estlap: true,
      leader: true,
      podium: true,
      bestlap: true,

      pos: true,
      gaps: true,
      front06: true,
      back06: true,
      attack: true,
      defense: true,
      fight: true,

      total: true,
      cons10: true,
      box: true,
      netgain: true
    };
    let toggles = {};
    try {
      const storedMsgToggles = prefGet('spotterMessageToggles', null);
      if (storedMsgToggles) {
        toggles = JSON.parse(storedMsgToggles) || {};
      } else {
        toggles = { ...DEFAULT_MESSAGE_TOGGLES };
        prefSet('spotterMessageToggles', JSON.stringify(toggles));
      }
    } catch(e) {
      toggles = { ...DEFAULT_MESSAGE_TOGGLES };
    }


// Voice message toggles (18 botones)
    // - laps: siempre activo (no se puede apagar)
    // - blueflag: por defecto activo al abrir (si no hay config guardada)
    // =========================

    // Estado global (debe existir SIEMPRE en m√≥dulos ES)
    let raceData = null;
    let selectedPilotKey = '';
    let selectedPilotFirstDetectBeeped = false;// hotfix: init without undefined k

    
    let pendingAutoVoiceUnlock = false;
let isLoading = false;
    let loadingSince = 0;

    let isSelectingPilot = false;
    let lastPilotOptionsSignature = '';
    let lastRaceName = '';

    let pilotOptionsAutoRefreshTimer = null; // auto-refresh dropdown

    let previousClassification = null;

    let decimalPrecision = 2;
    try {
      const storedDec = prefGet('spotterDecimalPrecision', null);
      if (storedDec != null) {
        const parsed = parseInt(storedDec, 10);
        if (parsed >= 1 && parsed <= 3) {
          decimalPrecision = parsed;
        }
      }
    } catch (e) {}

    if (precisionSelect) precisionSelect.value = String(decimalPrecision);
// =========================
// Truncado (sin redondeo) para lecturas/c√°lculos mostrados o hablados
// - Requisito: no redondear, usar floor.
// =========================
function floorTo(value, decimals = 0) {
  const p = Math.pow(10, decimals);
  if (!isFinite(value)) return 0;
  return Math.floor(value * p) / p;
}

function toFixedFloor(value, decimals = 0) {
  const v = floorTo(Number(value), decimals);
  return v.toFixed(decimals);
}

    if (precisionSelect) {
      precisionSelect.addEventListener('change', () => {
        const val = parseInt(precisionSelect.value, 10);
        if (!isNaN(val) && val >= 1 && val <= 3) {
          decimalPrecision = val;
          try {
            prefSet('spotterDecimalPrecision', String(decimalPrecision));
          } catch (e) {}
        }
      });
    }

    function syncPrecisionBadges() {
      precisionBadges.forEach(badge => {
        const val = parseInt(badge.getAttribute('data-precision'), 10);
        badge.classList.toggle('active', val === decimalPrecision);
      });
    }

    precisionBadges.forEach(badge => {
      badge.addEventListener('click', () => {
        const val = parseInt(badge.getAttribute('data-precision'), 10);
        if (!isNaN(val) && val >= 1 && val <= 3) {
          decimalPrecision = val;
          if (precisionSelect) {
            precisionSelect.value = String(val);
            precisionSelect.dispatchEvent(new Event('change'));
          }
          syncPrecisionBadges();
        }
      });
    });

    syncPrecisionBadges();

    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator && navigator.wakeLock.request) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLockStatus.textContent = 'Pantalla activa';
          wakeLock.addEventListener('release', () => {
            // Chrome puede liberar wake lock al cambiar de app / apagar pantalla.
            // Este Spotter lo mantiene SIEMPRE encendido.
            wakeLock = null;
            wakeLockStatus.textContent = 'Pantalla liberada';
            try { if (wakeLockToggle) wakeLockToggle.classList.add('active'); } catch(e) {}
            try {
              if (document.visibilityState === 'visible') {
                requestWakeLock().catch(()=>{});
              }
            } catch(e) {}
          });
        } else {
          wakeLockStatus.textContent = 'Tu navegador no soporta wake lock';
        }
      } catch (e) {
        console.error('Error wake lock', e);
        wakeLockStatus.textContent = 'Toca pantalla para mantener despierta';
      }
    }

    async function releaseWakeLock() {
      try {
        if (wakeLock) {
          await wakeLock.release();
          wakeLock = null;
        }
        wakeLockStatus.textContent = '';
      } catch (e) {
        console.error('Error liberando wake lock', e);
      }
    }

    // Wake Lock SIEMPRE ON (locked)
    try { if (wakeLockToggle) wakeLockToggle.classList.add('active'); } catch(e) {}
    try { prefSet('spotterWakeLock','1'); } catch(e) {}

    if (wakeLockToggle) {
      wakeLockToggle.addEventListener('click', async () => {
        // Bloqueado en ON
        try { wakeLockToggle.classList.add('active'); } catch(e) {}
        try { prefSet('spotterWakeLock','1'); } catch(e) {}
        await requestWakeLock();
      });
    }

    // Intento inmediato (si el navegador lo permite)
    try { requestWakeLock(); } catch(e) {}

    // Reintento en el primer gesto del usuario (por pol√≠ticas del navegador)
    (function(){
      let __wlGestureDone = false;
      async function __wlTry() {
        if (__wlGestureDone) return;
        __wlGestureDone = true;
        try {
          if (wakeLockToggle && wakeLockToggle.classList.contains('active')) {
            await requestWakeLock();
          }
        } catch(e) {}
      }
      window.addEventListener('pointerdown', __wlTry, { once:true, passive:true });
      window.addEventListener('keydown', __wlTry, { once:true, passive:true });
    })();
// =========================
    // MODO BACKGROUND
    // =========================
    function setBackgroundStatus() {
      if (!backgroundStatus) return;
      backgroundStatus.textContent = backgroundModeEnabled ? 'Background ON' : '';
    }

    try {
      const savedBg = prefGet('spotterBackgroundMode', null);
      // For this build: Background is ALWAYS ON
      backgroundModeEnabled = true;
      try { prefSet('spotterBackgroundMode','1'); } catch(e){}
      if (backgroundToggle) {
        backgroundToggle.classList.toggle('active', backgroundModeEnabled);
      }
      setBackgroundStatus();
    } catch(e) {}

    if (backgroundToggle) {
      backgroundToggle.addEventListener('click', () => {
        // Background always ON (locked)
        backgroundModeEnabled = true;
        backgroundToggle.classList.add('active');
        try { prefSet('spotterBackgroundMode','1'); } catch(e) {}
        setBackgroundStatus();
      });
    }

    // Reenganche al volver al tab (Chrome puede soltar wake lock)
    document.addEventListener('visibilitychange', async () => {
      try {
        if (document.visibilityState === 'visible') {
          // forzar refresh inmediato al regresar
          try { loadRaceFromFirebase(); } catch(e) {}
          // reintentar wake lock si estaba ON
          if (wakeLockToggle && wakeLockToggle.classList.contains('active')) {
            await requestWakeLock();
          }
        }
      } catch(e) {}
    });
function setLiveStatus(isOnline) {
      if (!liveIndicator) return;
      liveIndicator.classList.toggle('live-off', !isOnline);
      liveIndicator.querySelector('span:last-child').textContent = isOnline ? 'Live' : 'Offline';
    }

    function getPilotKey(row) {
      if (!row) return '';
      const numRaw = row.racerNumber != null ? String(row.racerNumber).trim() : '';
      const nameRaw = row.racerName != null ? String(row.racerName).trim() : '';
      const num = (numRaw && numRaw !== '-' && numRaw !== '0') ? numRaw : '';
      const name = nameRaw;
      if (name && !num) return name.toLowerCase();
      return (num + '||' + name).toLowerCase();
    }

    function safeRacerName(name) {
      if (name == null) return '';
      let s = String(name).trim();
      if (!s) return '';
      const low = s.toLowerCase();
      // Evitar que se lea o se muestre literalmente "undefined"/"null"
      if (low === 'undefined' || low === 'null' || low === 'nan' || low === '-' || low === 'n/a') return '';
      // Quitar prefijos num√©ricos tipo "26 Victor" o "#26 Victor"
      s = s.replace(/^#?\d+\s+/, '');
      // Normalizar espacios
      s = s.replace(/\s{2,}/g, ' ').trim();
      const low2 = s.toLowerCase();
      if (!s || low2 === 'undefined' || low2 === 'null') return '';
      return s;
    }

    function parseTimeToMs(input) {
      if (input == null) return 0;

      // Heur√≠stica clave:
      // - Si viene como n√∫mero y es "chico" (ej. 9.881, 14.564), normalmente est√° en segundos.
      // - Si viene grande (ej. 9881, 14564), normalmente ya est√° en milisegundos.
      if (typeof input === 'number') {
        const n = input;
        if (!isFinite(n) || n <= 0) return 0;
        if (n < 300) return n * 1000; // tratar como segundos
        return n;                     // tratar como ms
      }

      // Strings: a veces llegan con prefijos tipo "27L 04:05.107" o texto extra.
      let str = String(input).trim();
      if (!str) return 0;

      // 1) Si hay un patr√≥n de tiempo, tomamos el √öLTIMO (lo m√°s probable es el tiempo real).
      //    Soporta: "m:ss.mmm", "mm:ss", "h:mm:ss.mmm"
      try {
        const matches = str.match(/(?:\d{1,2}:)?\d{1,2}:\d{2}(?:\.\d{1,3})?/g);
        if (matches && matches.length) {
          str = matches[matches.length - 1];
        }
      } catch(e) {}

      // 2) Si es entero puro, asumimos ms (ej. "14564")
      if (/^\d+$/.test(str)) return parseInt(str, 10);

      // 3) Parse con ":" (m:ss o h:mm:ss)
      const parts = str.split(':');
      if (parts.length === 2) {
        const m = parseInt(parts[0], 10);
        const s = parseFloat(parts[1]);
        if (!isNaN(m) && !isNaN(s)) return (m * 60 * 1000) + (s * 1000);
      }
      if (parts.length === 3) {
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        const s = parseFloat(parts[2]);
        if (!isNaN(h) && !isNaN(m) && !isNaN(s)) return (h * 3600 * 1000) + (m * 60 * 1000) + (s * 1000);
      }

      // 4) N√∫mero en string sin ":" -> puede venir en segundos ("14.564") o en ms ("3000")
      // Regla:
      // - Si es entero y >= 300, lo tratamos como milisegundos.
      // - Si es decimal o < 300, lo tratamos como segundos.
      if (/^\d+$/.test(str)) {
        const n = parseInt(str, 10);
        if (!isNaN(n)) return (n < 300) ? (n * 1000) : n;
      }
      const s = parseFloat(str);
      if (!isNaN(s)) return (s < 300) ? (s * 1000) : s;

      return 0;
    }

    function msToMinSec(ms) {
      if (!ms || isNaN(ms) || ms <= 0) return '-:--.---';
      const totalSeconds = ms / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds - minutes * 60;
      const secInt = Math.floor(seconds);
      let msRemainder = Math.floor((seconds - secInt) * 1000);
      if (!isFinite(msRemainder) || msRemainder < 0) msRemainder = 0;
      if (msRemainder > 999) msRemainder = 999;
      const secStr = String(secInt).padStart(2, '0');
      const msStr = String(msRemainder).padStart(3, '0');
      return `${minutes}:${secStr}.${msStr}`;
    }

    function formatLaps3(v){
      const n = Math.floor(Number(v));
      if (!isFinite(n) || n < 0) return '-';
      if (n > 999) return '999';
      const s = String(n);
      // M√°ximo 3 caracteres
      return (s.length <= 3) ? s : s.slice(-3);
    }


    // Rangos plausibles de una vuelta Turbo Racing 1/76 (evita basura tipo 0:00.010)
    const LAP_MS_MIN = 2500;   // 2.5 s (hay feeds que reportan medias vueltas)
    const LAP_MS_MAX = 90000;  // 90.0 s  // 60.0 s

    
    // Normaliza valores que a veces llegan en segundos (ej 9.339) en lugar de ms (9339)
    function normalizeIncomingLapValue(v) {
      // Acepta number o string (ej. 9.339, "9.339", "0:09.339", "9339")
      const ms = parseTimeToMs(v);
      if (!ms || !isFinite(ms) || ms <= 0) return 0;
      return Math.round(ms);
    }

function isLapPlausible(ms) {
      // Validaci√≥n para guardar historial (NO depende del rango din√°mico del chart).
      // As√≠, si alguien hace una vuelta lenta (ej. >30s por choque/reincorporaci√≥n), se registra.
      return typeof ms === 'number' && isFinite(ms) && ms >= LAP_MS_MIN && ms <= LAP_MS_MAX;
    }

    function normalizeLapMs(ms) {
      return isLapPlausible(ms) ? ms : 0;
    }

    
    // Rango din√°mico (se ajusta con el historial para no "matar" la gr√°fica con umbrales fijos)
    let lapRange = { min: LAP_MS_MIN, max: LAP_MS_MAX };

    function updateLapRangeFromHistory(timesAll) {
      if (!timesAll || timesAll.length < 6) return;
      const arr = timesAll.slice(-40).filter(v => typeof v === 'number' && isFinite(v) && v > 0).sort((a,b)=>a-b);
      if (arr.length < 6) return;
      const p90 = arr[Math.floor(arr.length * 0.90)];
      if (!p90) return;

      // IMPORTANTE:
      // No subimos el m√≠nimo con el hist√≥rico, porque al arranque o en re-incorporaciones
      // pueden llegar "vueltas parciales" (ej. 3.0s) y se deben registrar.
      const min = LAP_MS_MIN;
      const max = Math.min(150000, p90 + 2500);

      lapRange = { min, max };
    }

// Consistencia en porcentaje: % de vueltas dentro de +/- tolMs del promedio
// Ej: tolMs=200 -> +/-0.200 s
function consistencyPercent(arr, tolMs = 200) {
  // Consistencia % = 100 - (variabilidad %)
  // Variabilidad % = (sigma / media) * 100  (coeficiente de variaci√≥n)
  // Nota: arr viene en ms.
  if (!arr || arr.length < 2) return 0;
  const clean = arr.filter(v => typeof v === 'number' && isFinite(v) && v > 0);
  if (clean.length < 2) return 0;
  const mean = clean.reduce((a,b)=>a+b,0) / clean.length;
  if (!isFinite(mean) || mean <= 0) return 0;
  // sigma (ms)
  let s2 = 0;
  for (const v of clean) { const d = v - mean; s2 += d*d; }
  const sigma = Math.sqrt(s2 / clean.length);
  const variabilityPct = (sigma / mean) * 100;
  let cons = 100 - variabilityPct;
  if (!isFinite(cons)) cons = 0;
  if (cons < 0) cons = 0;
  if (cons > 100) cons = 100;
  return Math.floor(cons);
}

// Consistencia desde Firebase (ya viene calculada)
function getConsistencyFromFirebase(p) {
  if (!p) return 0;
  const candidates = [
    p.consistency,
    p.consistencyPercent,
    p.consPct,
    p.cons,
    p.consistencia,
    p.consistenciaPct,
    p.consistency_pct,
    p.consistency10,
    p.cons10,
    p.CONSISTENCY
  ];
  for (const v of candidates) {
    if (v == null) continue;
    if (typeof v === 'string') {
      const m = v.match(/(\d+(?:\.\d+)?)/);
      if (m) {
        const n = Number(m[1]);
        if (isFinite(n) && n > 0) return Math.max(0, Math.min(100, Math.floor(n)));
      }
      continue;
    }
    const n = Number(v);
    if (isFinite(n) && n > 0) return Math.max(0, Math.min(100, Math.floor(n)));
  }
  return 0;
}

function statsFromTimes(arr) {
      if (!arr || !arr.length) return { n: 0, best: 0, mean: 0, sigma: 0, last: 0 };
      const n = arr.length;
      const last = arr[n - 1] || 0;
      let best = Infinity;
      let sum = 0;
      for (const v of arr) {
        if (!isLapPlausible(v)) continue;
        if (v < best) best = v;
        sum += v;
      }

      const mean = sum / n;
      let varSum = 0;
      for (const v of arr) {
        varSum += (v - mean) * (v - mean);
      }
      const sigma = Math.sqrt(varSum / n);
      return { n, best: isFinite(best) ? best : 0, mean, sigma, last };
    }

// Cache de m√©tricas por piloto (BLOQUE 2.1)
// Evita recalcular stats (best/mean/sigma/last) en cada tick.
// Se recalcula solo cuando cambian las vueltas registradas del piloto.
function ensureHistComputed(hist) {
  try {
    if (!hist) return { n: 0, best: 0, mean: 0, sigma: 0, last: 0 };
    if (!Array.isArray(hist.times)) hist.times = [];

    const len = hist.times.length || 0;
    const lapc = Number(hist.lastLapcount) || 0;

    // Firma simple: (len + lapcount). Si no cambia, reutiliza.
    if (hist._computed && hist._computedLen === len && hist._computedLapcount === lapc) {
      return hist._computed;
    }

    // Nota: hist.times ya viene normalizado y plausible en updateLapHistoryAll (pushLap).
    const computed = statsFromTimes(hist.times);
    hist._computed = computed;
    hist._computedLen = len;
    hist._computedLapcount = lapc;
    return computed;
  } catch (e) {
    return { n: 0, best: 0, mean: 0, sigma: 0, last: 0 };
  }
}


// Devuelve el mejor "stint" consecutivo de tama√±o window (por promedio), y la peor vuelta.
// times debe venir en ms, ya filtrado a vueltas plausibles.
function findFastestStint(times, window=5) {
  try {
    if (!Array.isArray(times) || times.length < window) return null;
    let bestSum = Infinity;
    let bestStart = 0;
    let sum = 0;
    for (let i = 0; i < times.length; i++) {
      sum += times[i];
      if (i >= window) sum -= times[i - window];
      if (i >= window - 1) {
        if (sum < bestSum) {
          bestSum = sum;
          bestStart = i - window + 1;
        }
      }
    }
    return { start: bestStart, end: bestStart + window - 1, sum: bestSum, avg: bestSum / window };
  } catch (e) { return null; }
}

function findWorstLap(times) {
  try {
    if (!Array.isArray(times) || !times.length) return null;
    let worst = -Infinity;
    let idx = -1;
    for (let i = 0; i < times.length; i++) {
      const v = times[i];
      if (!isLapPlausible(v)) continue;
      if (v > worst) { worst = v; idx = i; }
    }
    if (idx < 0) return null;
    return { idx, ms: worst };
  } catch (e) { return null; }
}


// Promedio de las ultimas N vueltas (ms). times debe venir ya filtrado a plausibles.
function rollingAvgLast(times, n=3){
  try{
    if (!Array.isArray(times) || times.length < n) return 0;
    const last = times.slice(-n);
    if (last.length < n) return 0;
    const sum = last.reduce((a,b)=>a + (Number(b)||0), 0);
    const avg = sum / n;
    return (avg && isFinite(avg)) ? avg : 0;
  }catch(e){ return 0; }
}

// Cuenta cuantas vueltas consecutivas (desde la ultima hacia atras) estan por debajo de un umbral (ms).
function countConsecutiveWithin(times, thresholdMs){
  try{
    if (!Array.isArray(times) || !times.length || !thresholdMs) return 0;
    let c = 0;
    for (let i = times.length - 1; i >= 0; i--){
      const v = Number(times[i]) || 0;
      if (!isLapPlausible(v)) continue;
      if (v <= thresholdMs) c++;
      else break;
    }
    return c;
  }catch(e){ return 0; }
}

// Devuelve el milestone actual para racha (se anuncia solo cuando sube).
function streakMilestone(n){
  const ms = [3,5,8,10,12,15,20];
  let out = 0;
  for (const v of ms){
    if (n >= v) out = v;
  }
  return out;
}

    function ensureCanvasHiDpi(canvas) {
      if (!canvas) return;
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }

    
    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }


// Lap Chart - cache de render (2.2) para no redibujar si no cambi√≥ la data
const lapChartRenderSigByKey = new Map();
let lastLapChartRenderedKey = null;

// Cache para Lap Chart Top3 Auto (2.2)
let lapChartAutoRenderCache = { sig: '', w: 0, h: 0 };

function buildLapChartSig(pilotKey, hist, timesAllRaw, marksAll, pNow){
  try {
    const len = (timesAllRaw && timesAllRaw.length) ? timesAllRaw.length : 0;
    const last = len ? (Number(timesAllRaw[len - 1]) || 0) : 0;
    const best = (hist && hist.bestMs) ? normalizeLapMs(hist.bestMs) : 0;
    const mlen = (marksAll && marksAll.length) ? marksAll.length : 0;
    const mlast = mlen ? String(marksAll[mlen - 1] || '') : '';
    const lapsNow = pNow ? (Number(pNow.lapcount) || 0) : 0;
    return `${pilotKey}|${lapsNow}|${len}|${last}|${best}|${mlen}|${mlast}`;
  } catch(e) {
    return `${pilotKey}|0|0|0|0|0|`;
  }
}
function drawLapChartForKey(pilotKey, force) {
      force = !!force;
      if (!lapChartEl || !lapChartMetaEl) return;
      if (!pilotKey) {
        lastLapChartRenderedKey = null;
        lapChartMetaEl.textContent = 'Sin datos';
        if (pilotKey) lapChartRenderSigByKey.delete(pilotKey);
        if (lastLapChartRenderedKey === pilotKey) lastLapChartRenderedKey = null;
        const ctx = lapChartEl.getContext('2d');
        if (ctx) ctx.clearRect(0, 0, lapChartEl.width, lapChartEl.height);
        return;
      }
      const hist = lapHistory.get(pilotKey) || { lastLapcount: 0, times: [] };
      const timesAllRaw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
      updateLapRangeFromHistory(timesAllRaw);
      const timesAll = timesAllRaw.filter(isLapPlausible);
      if (!timesAll.length) {
        lapChartMetaEl.textContent = 'Sin datos';
        if (pilotKey) lapChartRenderSigByKey.delete(pilotKey);
        if (lastLapChartRenderedKey === pilotKey) lastLapChartRenderedKey = null;
        const ctx = lapChartEl.getContext('2d');
        if (ctx) ctx.clearRect(0, 0, lapChartEl.width, lapChartEl.height);
        return;
      }

      const N = 40;
      const times = timesAll.slice(-N);
      const marksAll = (hist.marks || []).filter(v => (typeof v === 'string' || v == null));
      const marks = marksAll.slice(-N);
      const st = statsFromTimes(times);
      const best = st.best || 0;
      const last = st.last || 0;
      const mean = st.mean || 0;

      // Best/Worst globales (historial completo) + Fast5 (mejor bloque consecutivo)
      const bestAll = timesAll.length ? Math.min(...timesAll) : 0;
      const idxBestAll = bestAll ? timesAll.indexOf(bestAll) : -1;
      const worstInfo = findWorstLap(timesAll);
      const worstAll = worstInfo ? worstInfo.ms : 0;
      const idxWorstAll = worstInfo ? worstInfo.idx : -1;
      const fast5 = findFastestStint(timesAll, 5);

      const pNow = (raceData && Array.isArray(raceData.classification))
        ? raceData.classification.find(r => getPilotKey(r) === pilotKey)
        : null;
      const lapsNow = pNow ? (Number(pNow.lapcount) || 0) : 0;
      const consFb = getConsistencyFromFirebase(pNow);

      const lapsLabel = lapsNow ? lapsNow : timesAll.length;

      const bestTxt = (bestAll && idxBestAll >= 0) ? `${msToMinSec(bestAll)} (L${idxBestAll + 1})` : '-:--.---';
      const fastTxt = (fast5 && fast5.avg) ? `${msToMinSec(fast5.avg)} (L${fast5.start + 1}-${fast5.end + 1})` : '-:--.---';
      const worstTxt = (worstAll && idxWorstAll >= 0) ? `${msToMinSec(worstAll)} (L${idxWorstAll + 1})` : '-:--.---';

      lapChartMetaEl.textContent =
        `${lapsLabel} vueltas ¬∑ Hist ${timesAll.length} ¬∑ Best ${bestTxt} ¬∑ Fast5 ${fastTxt} ¬∑ Worst ${worstTxt} ¬∑ Last ${last ? msToMinSec(last) : '-:--.---'} ¬∑ Cons ${consFb ? (consFb + '%') : '-'}`;

      const sig = buildLapChartSig(pilotKey, hist, timesAllRaw, marksAll, pNow);

ensureCanvasHiDpi(lapChartEl);
      const ctx = lapChartEl.getContext('2d');
      if (!ctx) return;

      const w = lapChartEl.width;
      const h = lapChartEl.height;

      const prev = lapChartRenderSigByKey.get(pilotKey);
      if (!force && lastLapChartRenderedKey === pilotKey && prev && prev.sig === sig && prev.w === w && prev.h === h) {
        return;
      }
      lapChartRenderSigByKey.set(pilotKey, { sig, w, h });
      lastLapChartRenderedKey = pilotKey;

      ctx.clearRect(0, 0, w, h);

      // fondo suave
      ctx.fillStyle = 'rgba(2,6,23,0.45)';
      ctx.fillRect(0, 0, w, h);

      // escala
      let minV = Math.min(...times);
      let maxV = Math.max(...times);
      minV = Math.min(minV, best);
      maxV = Math.max(maxV, best);

      const pad = Math.max(400, (maxV - minV) * 0.18);
      minV = Math.max((lapRange && lapRange.min) ? lapRange.min : LAP_MS_MIN, minV - pad);
      maxV = Math.min((lapRange && lapRange.max) ? lapRange.max : LAP_MS_MAX, maxV + pad);

      const left = Math.floor(w * 0.06);
      const right = Math.floor(w * 0.03);
      const top = Math.floor(h * 0.12);
      const bottom = Math.floor(h * 0.18);
      const gw = w - left - right;
      const gh = h - top - bottom;

      const baseIdx = timesAll.length - times.length; // √≠ndice global del primer punto mostrado

      // grid horizontal (4)
      ctx.strokeStyle = 'rgba(148,163,184,0.18)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = top + (gh * i / 4);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(left + gw, y);
        ctx.stroke();
      }

      // l√≠nea promedio
      if (isLapPlausible(mean)) {
        const yMean = top + (1 - (Math.min(Math.max(mean, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.strokeStyle = 'rgba(34,211,238,0.35)';
        ctx.beginPath();
        ctx.moveTo(left, yMean);
        ctx.lineTo(left + gw, yMean);
        ctx.stroke();
      }

// Highlight Fast5 (mejor bloque consecutivo de 5 vueltas) si cae dentro del rango mostrado
try {
  if (fast5 && maxV > minV && times.length > 1) {
    const startDisp = fast5.start - baseIdx;
    const endDisp = fast5.end - baseIdx;
    if (endDisp >= 0 && startDisp <= (times.length - 1)) {
      const s = Math.max(0, startDisp);
      const e = Math.min(times.length - 1, endDisp);
      const x1 = left + (gw * s / (times.length - 1));
      const x2 = left + (gw * e / (times.length - 1));
      ctx.save();
      ctx.fillStyle = 'rgba(34,197,94,0.08)';
      ctx.fillRect(Math.min(x1, x2), top, Math.abs(x2 - x1), gh);
      ctx.restore();
    }
  }
} catch(e) {}

      // l√≠nea tiempos
      ctx.strokeStyle = 'rgba(251,146,60,0.95)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      times.forEach((v, i) => {
        const x = left + (times.length === 1 ? 0 : (gw * i / (times.length - 1)));
        const y = top + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // puntos/medias/markers (Preset A)
      // banda de ritmo (extra #2): media +- 0.20s
      const BAND_MS = 200;
      if (mean && maxV > minV) {
        const lo = Math.max(minV, mean - BAND_MS);
        const hi = Math.min(maxV, mean + BAND_MS);
        const yHi = top + (1 - (Math.min(Math.max(hi, minV), maxV) - minV) / (maxV - minV)) * gh;
        const yLo = top + (1 - (Math.min(Math.max(lo, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.save();
        ctx.fillStyle = 'rgba(226,232,240,0.06)';
        ctx.fillRect(left, yHi, gw, Math.max(0, yLo - yHi));
        ctx.restore();
      }

      // l√≠nea de media (pace)
      if (mean && maxV > minV) {
        const yM = top + (1 - (Math.min(Math.max(mean, minV), maxV) - minV) / (maxV - minV)) * gh;
        ctx.save();
        ctx.strokeStyle = 'rgba(226,232,240,0.28)';
        ctx.setLineDash([Math.max(4, Math.floor(w*0.01)), Math.max(3, Math.floor(w*0.008))]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(left, yM);
        ctx.lineTo(left + gw, yM);
        ctx.stroke();
        ctx.restore();
      }

      // puntos (Preset A): best personal (verde) / best sesi√≥n (morado) / error grande (rojo) + last por estado
      const drawDot = (x, y, fill, rMul=1.0) => {
        const r = Math.max(2, Math.floor(w * 0.005)) * rMul;
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      };

      // best sesi√≥n (Opci√≥n B: desde clasificaci√≥n visible)
      const sessionBestMs = computeSessionBestMs ? computeSessionBestMs() : 0;

      // errores grandes (rojo): +0.8s vs media o +0.9s vs best (lo que aplique)
      const ERR_A_MS = 800;
      const ERR_B_MS = 900;

      for (let i = 0; i < times.length; i++) {
        const v = times[i];
        const x = left + (times.length === 1 ? 0 : (gw * i / (times.length - 1)));
        const y = top + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;

        const bigErr = (mean && v > (mean + ERR_A_MS)) || (best && v > (best + ERR_B_MS));
        if (bigErr) drawDot(x, y, 'rgba(239,68,68,0.92)', 1.15);
      }

      // last (color por mejora)
      const iLast = times.length - 1;
      const xLast = left + (times.length === 1 ? 0 : (gw * iLast / (times.length - 1)));
      const yLast = top + (1 - (Math.min(Math.max(times[iLast], minV), maxV) - minV) / (maxV - minV)) * gh;
      const prevBest = (times.length > 1) ? Math.min(...times.slice(0, -1)) : 0;
      const lastClass = classifyLapColor ? classifyLapColor(times[iLast], prevBest || best || 0, sessionBestMs) : 'lap-neutral';
      const lastFill =
        lastClass === 'lap-purple' ? 'rgba(167,139,250,0.95)' :
        lastClass === 'lap-green'  ? 'rgba(34,197,94,0.95)'  :
        lastClass === 'lap-yellow' ? 'rgba(251,191,36,0.92)' :
                                     'rgba(226,232,240,0.85)';
      drawDot(xLast, yLast, lastFill, 1.18);

      // best (√≠ndice) - verde, pero si es best sesi√≥n -> morado
      const idxBest = times.findIndex(v => v === best);
      if (idxBest >= 0) {
        const xB = left + (times.length === 1 ? 0 : (gw * idxBest / (times.length - 1)));
        const yB = top + (1 - (Math.min(Math.max(best, minV), maxV) - minV) / (maxV - minV)) * gh;
        const bestFill = 'rgba(167,139,250,0.98)';
        drawDot(xB, yB, bestFill, 1.28);
      }

      // Tags de batalla (ATK/DEF/DUEL) por vuelta
      try {
        const fontPx = Math.max(9, Math.floor(w * 0.028));
        ctx.font = `600 ${fontPx}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';

        for (let i = 0; i < marks.length && i < times.length; i++) {
          const tag = marks[i];
          if (!tag) continue;
          const x = left + (times.length === 1 ? 0 : (gw * i / (times.length - 1)));
          const y = top + (1 - (Math.min(Math.max(times[i], minV), maxV) - minV) / (maxV - minV)) * gh;

          let bg = 'rgba(255,255,255,0.10)';
          let fg = 'rgba(226,232,240,0.95)';
          if (tag === 'ATK') { bg = 'rgba(255,140,0,0.22)'; fg = 'rgba(255,230,200,0.95)'; }
          if (tag === 'DEF') { bg = 'rgba(59,130,246,0.22)'; fg = 'rgba(220,235,255,0.95)'; }
          if (tag === 'DUEL'){ bg = 'rgba(255,40,40,0.22)'; fg = 'rgba(255,230,230,0.95)'; }

                    // marcador visible en la gr√°fica
          try {
            let stroke = 'rgba(226,232,240,0.35)';
            let fill = 'rgba(226,232,240,0.70)';
            if (tag === 'ATK') { stroke = 'rgba(255,140,0,0.85)'; fill = 'rgba(255,140,0,0.70)'; }
            if (tag === 'DEF') { stroke = 'rgba(59,130,246,0.85)'; fill = 'rgba(59,130,246,0.70)'; }
            if (tag === 'DUEL'){ stroke = 'rgba(239,68,68,0.85)'; fill = 'rgba(239,68,68,0.70)'; }
            ctx.save();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, top + 2);
            ctx.stroke();
            // dot ring
            const rr = Math.max(2, Math.floor(w * 0.004));
            ctx.fillStyle = 'rgba(2,6,23,0.45)';
            ctx.beginPath();
            ctx.arc(x, y, rr + 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, rr, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          } catch(e) {}

          let stroke = 'rgba(226,232,240,0.35)';
          let fill = 'rgba(226,232,240,0.70)';
          if (tag === 'ATK') { stroke = 'rgba(255,140,0,0.85)'; fill = 'rgba(255,140,0,0.70)'; }
          if (tag === 'DEF') { stroke = 'rgba(59,130,246,0.85)'; fill = 'rgba(59,130,246,0.70)'; }
          if (tag === 'DUEL'){ stroke = 'rgba(239,68,68,0.85)'; fill = 'rgba(239,68,68,0.70)'; }

          const iconS = Math.max(6, Math.floor(fontPx * 0.72));
          const iy = y - Math.max(10, iconS); // arriba del punto
          ctx.save();
          ctx.translate(x, iy);

          ctx.fillStyle = fill;
          ctx.strokeStyle = stroke;
          ctx.lineWidth = 2;

          ctx.beginPath();
          if (tag === 'ATK') {
            // tri√°ngulo arriba (zona de ataque)
            ctx.moveTo(0, -iconS * 0.65);
            ctx.lineTo(iconS * 0.65, iconS * 0.65);
            ctx.lineTo(-iconS * 0.65, iconS * 0.65);
          } else if (tag === 'DEF') {
            // tri√°ngulo abajo (zona de defensa)
            ctx.moveTo(0, iconS * 0.65);
            ctx.lineTo(iconS * 0.65, -iconS * 0.65);
            ctx.lineTo(-iconS * 0.65, -iconS * 0.65);
          } else {
            // DUEL: rombo
            ctx.moveTo(0, -iconS * 0.8);
            ctx.lineTo(iconS * 0.8, 0);
            ctx.lineTo(0, iconS * 0.8);
            ctx.lineTo(-iconS * 0.8, 0);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          ctx.restore();}
      } catch(e) {}

// Labels BEST / WORST y FAST5 (solo si est√°n dentro del rango mostrado)
try {
  const labelFont = Math.max(9, Math.floor(w * 0.024));
  const drawLabel = (txt, x, y, bg, fg) => {
    ctx.save();
    ctx.font = `700 ${labelFont}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    const padX = Math.max(5, Math.floor(labelFont * 0.55));
    const padY = Math.max(3, Math.floor(labelFont * 0.35));
    const tw = ctx.measureText(txt).width;
    const bw = tw + padX * 2;
    const bh = labelFont + padY * 2;
    const bx = x - bw / 2;
    const by = y - 6;
    ctx.fillStyle = bg;
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 1;
    roundRect(ctx, bx, by - bh, bw, bh, Math.max(6, Math.floor(labelFont*0.6)));
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = fg;
    ctx.fillText(txt, x, by - padY);
    ctx.restore();
  };

  // BEST global
  if (idxBestAll >= 0) {
    const iB = idxBestAll - baseIdx;
    if (iB >= 0 && iB < times.length) {
      const x = left + (gw * iB / (times.length - 1));
      const y = top + (1 - (Math.min(Math.max(times[iB], minV), maxV) - minV) / (maxV - minV)) * gh;
      drawLabel('BEST', x, y, 'rgba(167,139,250,0.22)', 'rgba(245,240,255,0.98)');
    }
  }

  // WORST global (dentro del rango mostrado)
  if (idxWorstAll >= 0) {
    const iW = idxWorstAll - baseIdx;
    if (iW >= 0 && iW < times.length) {
      const x = left + (gw * iW / (times.length - 1));
      const y = top + (1 - (Math.min(Math.max(times[iW], minV), maxV) - minV) / (maxV - minV)) * gh;
      // dot extra para que se vea
      drawDot(x, y, 'rgba(239,68,68,0.92)', 1.25);
      drawLabel('WORST', x, y, 'rgba(239,68,68,0.18)', 'rgba(255,235,235,0.95)');
    }
  }

  // FAST5 label (centro del bloque)
  if (fast5 && times.length > 1) {
    const s = fast5.start - baseIdx;
    const e = fast5.end - baseIdx;
    if (e >= 0 && s <= (times.length - 1)) {
      const ss = Math.max(0, s);
      const ee = Math.min(times.length - 1, e);
      const xc = left + (gw * ((ss + ee) / 2) / (times.length - 1));
      const yTop = top + 2;
      drawLabel('FAST5', xc, yTop + labelFont + 10, 'rgba(34,197,94,0.16)', 'rgba(220,255,235,0.95)');
    }
  }
} catch(e) {}

      }




function drawLapChartTopNAuto(force){
      force = !!force;
      if (!lapChartEl || !lapChartMetaEl) return;

      const limit = (typeof miniGridLimit === 'number' && miniGridLimit > 3) ? miniGridLimit : 3;
      const top = getTopRowsUnique(Math.max(3, Math.min(20, limit)));
      const keys = top.map(r => getPilotKey(r)).filter(Boolean);

      // Si no hay datos, limpia
      if (!keys.length){
        lapChartMetaEl.textContent = 'Sin datos';
        if (top3MiniGridEl) top3MiniGridEl.innerHTML = '';
        const ctx0 = lapChartEl.getContext('2d');
        if (ctx0) ctx0.clearRect(0,0,lapChartEl.width,lapChartEl.height);
        return;
      }

      // UI (chips Top3 + mini grid Top3/Top20)
      try { renderAutoLapChartTop3(); } catch(e) {}
      try { renderAutoTop3MiniGrid(); } catch(e) {}

      const N = 50;

      function colorForIdx(i){
        if (i === 0) return { stroke:'rgba(251,191,36,0.95)', dot:'rgba(251,191,36,0.98)' }; // P1
        if (i === 1) return { stroke:'rgba(255,255,255,0.86)', dot:'rgba(255,255,255,0.94)' }; // P2
        if (i === 2) return { stroke:'rgba(249,115,22,0.95)', dot:'rgba(249,115,22,0.98)' }; // P3
        const hue = (i * 43) % 360;
        return {
          stroke: `hsla(${hue}, 92%, 60%, 0.55)`,
          dot:    `hsla(${hue}, 95%, 62%, 0.72)`
        };
      }

      // Series por piloto (muestra su progreso desde la izquierda)
      const series = [];
      let allVals = [];

      for (let i=0;i<keys.length;i++){
        const k = keys[i];
        const hist = lapHistory.get(k) || { times: [] };
        const raw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
        let valsAll = raw.filter(isLapPlausible);

        // Fallback: si todav√≠a no hay historial, pinta al menos 1 punto con lastTime/best
        if (!valsAll.length) {
          const row = top[i] || null;
          const last = row ? normalizeLapMs(normalizeIncomingLapValue(row.lastTime)) : 0;
          const best = row ? normalizeLapMs(normalizeIncomingLapValue(row.best)) : 0;
          const candidate = isLapPlausible(last) ? last : (isLapPlausible(best) ? best : 0);
          if (candidate) valsAll = [candidate];
        }

        if (!valsAll.length) continue;

        const vals = valsAll.slice(-N);
        series.push({ key: k, vals, color: colorForIdx(i), idx: i });
        allVals = allVals.concat(vals);
      }

      if (!series.length){
        lapChartMetaEl.textContent = 'Sin datos';
        if (top3MiniGridEl) top3MiniGridEl.innerHTML = '';
        const ctx0 = lapChartEl.getContext('2d');
        if (ctx0) ctx0.clearRect(0,0,lapChartEl.width,lapChartEl.height);
        return;
      }

      updateLapRangeFromHistory(allVals);

      // Firma para evitar redibujar si no cambi√≥ la data
      const focusKey = (autoLocutorFocusKey && keys.includes(autoLocutorFocusKey)) ? autoLocutorFocusKey : keys[0];
      const sig = `${keys.join(',')}|${focusKey}|${N}|` + series.map(s => {
        const v = (s.vals && s.vals.length) ? s.vals[s.vals.length - 1] : 0;
        const l = (s.vals && s.vals.length) ? s.vals.length : 0;
        return `${s.key}:${l}:${v}`;
      }).join('|');

      ensureCanvasHiDpi(lapChartEl);
      const ctx = lapChartEl.getContext('2d');
      if (!ctx) return;

      const w = lapChartEl.width;
      const h = lapChartEl.height;

      if (!force && lapChartAutoRenderCache && lapChartAutoRenderCache.sig === sig && lapChartAutoRenderCache.w === w && lapChartAutoRenderCache.h === h) {
        return;
      }
      lapChartAutoRenderCache = { sig, w, h };

      ctx.clearRect(0,0,w,h);

      // fondo
      ctx.fillStyle = 'rgba(2,6,23,0.45)';
      ctx.fillRect(0,0,w,h);

      // escala combinada
      let minV = Math.min(...allVals);
      let maxV = Math.max(...allVals);
      const pad = Math.max(400, (maxV - minV) * 0.18);
      minV = Math.max((lapRange && lapRange.min) ? lapRange.min : LAP_MS_MIN, minV - pad);
      maxV = Math.min((lapRange && lapRange.max) ? lapRange.max : LAP_MS_MAX, maxV + pad);

      const left = Math.floor(w * 0.06);
      const right = Math.floor(w * 0.03);
      const topPad = Math.floor(h * 0.12);
      const bottom = Math.floor(h * 0.18);
      const gw = w - left - right;
      const gh = h - topPad - bottom;

      // grid
      ctx.strokeStyle = 'rgba(148,163,184,0.18)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = topPad + (gh * i / 4);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(left + gw, y);
        ctx.stroke();
      }

      // ancho de ventana en X: del primer punto (izq) al √∫ltimo (der)
      const windowLen = Math.max(2, ...series.map(s => (s.vals ? s.vals.length : 0)));

      // dibuja series
      for (const s of series){
        const vals = s.vals;
        const len = vals.length;
        if (!len) continue;

        const isFocus = (s.key === focusKey);
        ctx.save();
        ctx.globalAlpha = isFocus ? 1.0 : (s.idx < 3 ? 0.70 : 0.28);
        ctx.strokeStyle = s.color.stroke;
        ctx.lineWidth = isFocus ? 2.8 : (s.idx < 3 ? 1.9 : 1.1);
        ctx.beginPath();

        for (let j=0;j<len;j++){
          const x = left + (windowLen === 1 ? 0 : (gw * j / (windowLen - 1)));
          const v = vals[j];
          const y = topPad + (1 - (Math.min(Math.max(v, minV), maxV) - minV) / (maxV - minV)) * gh;
          if (j===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();

        // dot √∫ltima vuelta (solo top3 + foco)
        if (isFocus || s.idx < 3){
          const jLast = len - 1;
          const xL = left + (windowLen === 1 ? 0 : (gw * jLast / (windowLen - 1)));
          const vL = vals[jLast];
          const yL = topPad + (1 - (Math.min(Math.max(vL, minV), maxV) - minV) / (maxV - minV)) * gh;
          const r = Math.max(2, Math.floor(w * 0.005)) * (isFocus ? 1.25 : 1.05);
          ctx.fillStyle = s.color.dot;
          ctx.beginPath();
          ctx.arc(xL, yL, r, 0, Math.PI*2);
          ctx.fill();
        }

        ctx.restore();
      }

      // Meta
      try{
        const leader = top[0];
        const lapsLabel = leader && leader.lapcount != null ? leader.lapcount : '-';
        lapChartMetaEl.textContent = (limit > 3 ? 'Top 20' : 'Top 3') + ' ¬∑ laps l√≠der ' + lapsLabel;
      }catch(e){
        lapChartMetaEl.textContent = (limit > 3 ? 'Top 20' : 'Top 3');
      }
    }

    // Compat: nombre viejo
    function drawLapChartTop3Auto(force){
      return drawLapChartTopNAuto(force);
    }
window.addEventListener('resize', () => {
      if (selectedPilotKey) drawLapChartForKey(selectedPilotKey, true);
      else { try { drawLapChartTop3Auto(true); } catch(e) {} }
    });


    function numeroATexto0a999(n) {
      n = Math.floor(n);
      if (Number.isNaN(n) || n < 0 || n > 999) return String(n);
      const unidades = ['cero','uno','dos','tres','cuatro','cinco','seis','siete','ocho','nueve'];
      const especiales = ['diez','once','doce','trece','catorce','quince','dieciseis','diecisiete','dieciocho','diecinueve'];
      const decenas = ['','','veinte','treinta','cuarenta','cincuenta','sesenta','setenta','ochenta','noventa'];
      const centenas = ['','cien','doscientos','trescientos','cuatrocientos','quinientos','seiscientos','setecientos','ochocientos','novecientos'];

      if (n < 10) return unidades[n];
      if (n < 20) return especiales[n - 10];
      if (n < 100) {
        const d = Math.floor(n / 10);
        const u = n % 10;
        if (n === 20) return 'veinte';
        if (n < 30) return 'veinti' + unidades[u];
        if (u === 0) return decenas[d];
        return decenas[d] + ' y ' + unidades[u];
      }
      const c = Math.floor(n / 100);
      const resto = n % 100;
      if (n === 100) return 'cien';
      let resultado = centenas[c];
      if (resto > 0) {
        resultado += ' ' + numeroATexto0a999(resto);
      }
      return resultado;
    }

    function tiempoATexto(ms) {
      if (ms == null || isNaN(ms) || ms <= 0) return '';
      const totalSeconds = ms / 1000;

      // Para anuncios largos (ej: "Total X minutos..."), mantenemos texto tradicional.
      if (totalSeconds >= 60) {
        const minutes = Math.floor(totalSeconds / 60);
        const secondsFloat = totalSeconds - minutes * 60;

        const minutesTxt = numeroATexto0a999(minutes);
        const secondsStr = toFixedFloor(secondsFloat, decimalPrecision);
        const secParts = secondsStr.split('.');
        const secIntPart = parseInt(secParts[0], 10);
        const secDecStr = (secParts[1] || '').padEnd(3, '0');
        const d1 = secDecStr[0] || '0';
        const d2 = secDecStr[1] || '0';
        const d3 = secDecStr[2] || '0';

        let secondsTxt = '';
        if (!isNaN(secIntPart)) secondsTxt += numeroATexto0a999(secIntPart);
        if (secDecStr !== '000') {
          // Aqu√≠ usamos d√≠gitos separados para que no se coma ceros.
          secondsTxt = secondsTxt ? `${secondsTxt} punto ${d1} ${d2} ${d3}` : `cero punto ${d1} ${d2} ${d3}`;
        }
        if (!secondsTxt) secondsTxt = 'cero';

        const palabraMin = minutes === 1 ? 'minuto' : 'minutos';
        return `${minutesTxt} ${palabraMin} con ${secondsTxt} segundos`;
      }

      // ---- Lap time (lo que el piloto escucha todo el rato)
      // Regla: si la d√©cima es 0 (X.0xx) -> "X flat"
      // Si no, el decimal (0-999) se lee como n√∫mero completo:
      // 9.103 -> "nueve punto ciento tres"
      // 5.546 -> "cinco punto quinientos cuarenta y seis"
      const secInt = Math.floor(ms / 1000);
      const rem = Math.max(0, ms - secInt * 1000); // 0..999
      const d1 = Math.floor(rem / 100); // d√©cima (0..9)

      // "flat" SOLO cuando la d√©cima es 0 (X.0xx), sin importar la precisi√≥n seleccionada.
      if (d1 === 0) {
        return `${secInt} flat`;
      }

      // Regla especial (precisi√≥n 3): si la cent√©sima es 0 (X.x0y) -> "X punto x flat"
      // Ej: 9.103 -> "9 punto 1 flat"
      const d2 = Math.floor((rem % 100) / 10); // cent√©sima (0..9)
      if (decimalPrecision === 3 && d2 === 0) {
        return `${secInt} punto ${d1} flat`;
      }

      // Aplicar precisi√≥n seleccionada (1, 2 o 3 decimales) a la lectura:
      // 1 decimal  -> floor(rem/100)  (0..9)
      // 2 decimales -> floor(rem/10)   (0..99)
      // 3 decimales -> rem            (0..999)
      let decN = 0;
      if (decimalPrecision === 1) decN = Math.floor(rem / 100);
      else if (decimalPrecision === 2) decN = Math.floor(rem / 10);
      else decN = rem;

      // Gaps sub-1s (t√≠pico en Final): 0.60 -> "cero punto seis" (no "cero punto sesenta")
      if (secInt === 0 && decimalPrecision === 2 && (decN % 10) === 0) {
        return `cero punto ${numeroATexto0a999(Math.floor(decN / 10))}`;
      }

      return `${secInt} punto ${numeroATexto0a999(decN)}`;
          }

    // Wrapper: formato de tiempo corto para TTS (mismo criterio que tiempoATexto para vueltas)
    // Nota: esta funci√≥n exist√≠a en versiones anteriores; aqu√≠ la restauramos para evitar "msToVoiceTime is not defined".
    function msToVoiceTime(ms) {
      try { return tiempoATexto(ms); } catch(e) {}
      try {
        if (!isFinite(ms) || ms <= 0) return '';
        const s = ms / 1000;
        return String(toFixedFloor(s, (isFinite(decimalPrecision) ? decimalPrecision : 2)));
      } catch(e) {
        return '';
      }
    }


    function formatoGapVueltas(raw) {
      if (!raw) return '';
      const trimmed = raw.toString().trim();
      if (!trimmed || trimmed === '-') return '';
      if (/^\+?\d+\s*V$/i.test(trimmed)) {
        const numStr = trimmed.replace(/[^\d]/g, '');
        const n = parseInt(numStr, 10);
        if (!isNaN(n)) {
          if (n === 1) return 'm√°s una vuelta';
          return `m√°s ${n} vueltas`;
        }
      }
      return trimmed;
    }

    function normalizeRaceData(rawRace) {
      const result = {
        raceName: rawRace.raceName || '',
        lapCount: rawRace.lapCount || 0,
        bestLapTime: parseTimeToMs(rawRace.bestLapTime),
        classification: []
      };

      const passEvents = [];
      let movementDetected = false;
      const prevByKey = new Map();
      if (previousClassification && Array.isArray(previousClassification)) {
        previousClassification.forEach(p => {
          prevByKey.set(getPilotKey(p), p);
        });
      }

      const nextPrev = [];

      (rawRace.classification || []).forEach(row => {
        const key = getPilotKey(row);
        const lap = Number(row.lapcount) || 0;

        let totalMs = 0;
        const timeStr = row.time != null ? String(row.time) : '';
        if (typeof row.timeMs === 'number') {
          totalMs = row.timeMs;
        } else if (timeStr) {
          totalMs = parseTimeToMs(timeStr);
        }

        // bestLap suele ser NUMERO DE VUELTA (indice), no tiempo. Usar "best"/"bestLapTime" para el tiempo.
const bestTimeRaw =
  (row.best != null ? row.best :
   (row.bestMs != null ? row.bestMs :
    (row.bestLapTime != null ? row.bestLapTime :
     (row.bestLapTimeMs != null ? row.bestLapTimeMs :
      (row.bestTime != null ? row.bestTime : 0)))));
let bestMs = parseTimeToMs(bestTimeRaw);
        // meanLap a veces se usa para otra cosa; prioriza campos de tiempo.
const meanTimeRaw =
  (row.mean != null ? row.mean :
   (row.meanMs != null ? row.meanMs :
    (row.meanLapTime != null ? row.meanLapTime :
     (row.meanLapTimeMs != null ? row.meanLapTimeMs : 0))));
let meanMs = parseTimeToMs(meanTimeRaw);
        const estMs  = parseTimeToMs(row.estTime);

        let lastMs = 0;
        const prev = prevByKey.get(key);
        try {
          if (!prev) {
            if (lap > 0) movementDetected = true;
          } else {
            const prevLap = Number(prev.lapcount) || 0;
            const prevPos = Number(prev.pos) || 0;
            const curPos = Number(row.pos) || 0;
            if (lap !== prevLap) movementDetected = true;
            if (curPos && prevPos && curPos !== prevPos) movementDetected = true;
            const prevLast = Number(prev.lastTime) || 0;
            if (lastMs > 0 && prevLast > 0 && lastMs !== prevLast) movementDetected = true;
          }
        } catch(e) {}
        if (prev) {
          const prevLaps = Number(prev.lapcount) || 0;
          if (lap > prevLaps) {
            if (totalMs > prev.time) {
              lastMs = totalMs - prev.time;
            } else if (prev.lastTime && prev.lastTime > 0) {
              lastMs = prev.lastTime;
            } else {
              lastMs = 0;
            }
            // registrar evento de paso por meta para l√≥gica de bandera azul (√∫ltimo paso por piloto)
            // NOTA: usamos timestamp local (Date.now) para poder medir "cercania" aunque los tiempos del feed sean por-piloto.
            if (!lastPassEvents || typeof lastPassEvents.set !== 'function') {
              lastPassEvents = new Map();
            }
            lastPassEvents.set(key, {
              key,
              pos: row.pos,
              name: safeRacerName(row.racerName),
              lap,
              time: totalMs,
              abs: Date.now()
            });
          } else if (lap === prevLaps && prev.lastTime && prev.lastTime > 0) {
            lastMs = prev.lastTime;
          } else if (lap === 0) {
            lastMs = 0;
          }
        }

        lastMs = normalizeLapMs(lastMs);
        bestMs = normalizeLapMs(bestMs);
        meanMs = normalizeLapMs(meanMs);

        // Correcci√≥n de best/mean cuando vienen como n√∫mero de vuelta u otro formato raro
        const MIN_VALID_LAP_MS = LAP_MS_MIN;
        const MAX_VALID_LAP_MS = LAP_MS_MAX;
        if (!bestMs || isNaN(bestMs) || bestMs < MIN_VALID_LAP_MS || bestMs > MAX_VALID_LAP_MS) {
          if (prev && prev.best && !isNaN(prev.best) && prev.best > 0) {
            bestMs = prev.best;
          }
          if (lastMs && lastMs > 0 && (!bestMs || lastMs < bestMs)) {
            bestMs = lastMs;
          }
        }

        if ((!meanMs || isNaN(meanMs) || meanMs < MIN_VALID_LAP_MS || meanMs > MAX_VALID_LAP_MS) && lap > 0 && totalMs > 0) {
          meanMs = totalMs / lap;
        } else if ((!meanMs || isNaN(meanMs) || meanMs <= 0) && prev && prev.mean && !isNaN(prev.mean) && prev.mean > 0) {
          meanMs = prev.mean;
        }

        const normalized = {
          pos:         row.pos,
          racerNumber: row.racerNumber,
          racerName:   safeRacerName(row.racerName),
          lapcount:    lap,
          time:        totalMs,
          timeStr:     timeStr,
          lastTime:    lastMs,
          gap:         row.gap || "",
          diff:        row.diff || "",
          best:        bestMs,
          bestLap:     row.bestLap,
          mean:        meanMs,
          estLap:      row.estLap || 0,
          estTime:     estMs,
          consistency: row.consistency
        };

        result.classification.push(normalized);
        nextPrev.push({ ...normalized });
      });

      previousClassification = nextPrev;
      try { if (movementDetected) markMovement('movement'); } catch(e) {}
      return result;
    }

    let lastSpokenLastTime = null;
    let lastAnnouncedLapcount = 0;
    let lastKnownPos = null;
    let lastTotalTimeAnnouncedSeconds = 0;
    let lastGapInfoLap = 0;
    let lastBehindAlertMs = 0;

    let lastBestAnnouncedMs = null;
    let lastBestAnnouncedLap = 0;
    let lastTrendSpokenLap = 0;
    let lastAheadAlertMs = 0;
    
    // Latches para alertas <0.6 (decir solo una vez hasta que se libere)
    let behind06Latch = { active:false, otherKey:'', lap:-1 };
    let ahead06Latch  = { active:false, otherKey:'', lap:-1 };

    // Latches y estado para estrategia
    let attackLatch  = { active:false, otherKey:'', lap:-1 };
    let defenseLatch = { active:false, otherKey:'', lap:-1 };
    let fightLatch   = { active:false, lap:-1 };
    let startPosForSelected = null;
    let lastNetGainValue = null;
    let lastNetGainSpokenLap = 0;
    let lastLeaderGapSpokenLap = 0;
    let lastPodiumSpokenLap = 0;
let lastAutoSummaryAnnouncedSeconds = 0;

    // =========================
    // Modo LOCUTOR (AUTO cuando NO hay piloto seleccionado)
    // =========================
    let commentatorTop3LastLeaderLap = 0;
    let commentatorTop3LastSpokenMs = 0;
    let commentatorBattleLatch = new Map(); // pairKey -> { active, lastLeadLap }
    let commentatorGapHistory = new Map();  // pairKey -> { lastGapMs, lastTrailLap, lastSpokenTrailLap }

// Narraci√≥n con contexto (Auto Locutor) - seguimiento de una pelea para que suene hilado
let autoNarratorState = {
  focusPairKey: '',
  focusPos: 0,
  focusDefender: '',
  focusAttacker: '',
  focusSinceMs: 0,
  focusLastSec: null,
  focusStage: '',
  focusLastSpeakMs: 0,
  focusStickyUntilMs: 0,
  lastSpokenType: '',
  lastSpokenMs: 0
};

// pairKey -> { lastSec, lastSec2, lastMs, lastLap, lastMentionMs }
let autoPairState = new Map();

// MANGA (clasificaci√≥n): seguimiento de pole/best lap sin saturar
let autoQualiState = {
  bestOverallMs: null,
  bestOverallKey: '',
  lastBestSpeakMs: 0,
  lastPoleFightSpeakMs: 0
};

function resetAutoNarratorState() {
  try {
    autoNarratorState = {
      focusPairKey: '',
      focusPos: 0,
      focusDefender: '',
      focusAttacker: '',
      focusSinceMs: 0,
      focusLastSec: null,
      focusStage: '',
      focusLastSpeakMs: 0,
      focusStickyUntilMs: 0,
      lastSpokenType: '',
      lastSpokenMs: 0
    };
    if (autoPairState && typeof autoPairState.clear === 'function') autoPairState.clear();
    autoQualiState = { bestOverallMs: null, bestOverallKey: '', lastBestSpeakMs: 0, lastPoleFightSpeakMs: 0 };
  } catch(e) {}
}


    function resetAutoCommentatorState() {
      try {
        commentatorTop3LastLeaderLap = 0;
        commentatorTop3LastSpokenMs = 0;
        if (commentatorBattleLatch && typeof commentatorBattleLatch.clear === 'function') commentatorBattleLatch.clear();
        if (commentatorGapHistory && typeof commentatorGapHistory.clear === 'function') commentatorGapHistory.clear();
        if (commentatorAutoState) {
          commentatorAutoState.lastSpeakMs = -999999999;
          commentatorAutoState.window = [];
          if (commentatorAutoState.recentSig && typeof commentatorAutoState.recentSig.clear === 'function') commentatorAutoState.recentSig.clear();
          if (commentatorAutoState.prevPosByKey && typeof commentatorAutoState.prevPosByKey.clear === 'function') commentatorAutoState.prevPosByKey.clear();
          commentatorAutoState.prevKeyByPos = [];
          commentatorAutoState.lastLeaderKey = '';
          commentatorAutoState.lastLeaderLap = 0;
          commentatorAutoState.lastQuietMs = 0;
          commentatorAutoState.lastTop3Ms = -999999999;
          commentatorAutoState.lastTop3Sig = '';
          commentatorAutoState.lastMilestone = 0;
        }
        try { resetAutoNarratorState(); } catch(e) {}
      } catch(e) {}
    }



    // Historial de vueltas para consistencia
    let lapHistory = new Map();
    
    // Lap Chart marks: tags por vuelta (ATK/DEF/DUEL)
    function setLastLapMark(pilotKey, tag) {
      try {
        if (!pilotKey || !tag) return;
        const hist = lapHistory.get(pilotKey);
        if (!hist) return;
        if (!Array.isArray(hist.times)) hist.times = [];
        if (!Array.isArray(hist.marks)) hist.marks = [];
        const tlen = hist.times.length;
        if (!tlen) return;
        while (hist.marks.length < tlen) hist.marks.push(null);

        const i = tlen - 1;
        const cur = hist.marks[i];
        const pr = { DUEL: 3, ATK: 2, DEF: 2, PB: 1, ERR: 1 };
        if (!cur || (pr[tag] || 0) >= (pr[cur] || 0)) {
          hist.marks[i] = tag;
        }
        lapHistory.set(pilotKey, hist);
      } catch (e) {}
    }

// Best lap previo por piloto (para detectar mejora aunque Firebase ya actualice el best)
    let prevBestByKey = new Map();
    let lastSessionSigForBest = '';

    // Race Director: memoria anti repetici√≥n (por laps)
    let rdLastIdLap = new Map();
    let rdLastTextLap = new Map();

    let lastConsistencySpokenLap = 0;
    let lastSpokenEstLap = null;
    let lastEstLapSpokenLap = 0;
    let lastPoleSpokenKey = '';
    let lastPoleSpokenAt = 0;

    // Pendientes para AI Director (se anuncian post-Laps)
    let pendingPosChange = null;
    let pendingNetGain   = null;
    let pendingBestLap   = null;
    let pendingEstLap    = null;
    let pendingPole      = null;

    // Posicion estable (anti-jitter): anuncios SOLO en cruce por meta
    const posStability = {
      stablePos: null,
      pendingPos: null,
      pendingCount: 0,
      pendingSince: 0,
      lastAnnounceAt: 0
    };

    // eventos de paso por meta y estado de bandera azul
    let lastPassEvents = new Map();
    let pendingBlueFlagForPilotKey = '';
    let pendingBlueFlagMessage = '';
    let lastBlueFlagPilotLap = 0;
    let lastBlueWarnPilotLap = 0;
    let pendingBlueFlagExpiresLap = 0;
    let blueFlagState = Object.create(null);
    let courtesyState = null;


    // Auto Locutor: rotaci√≥n de m√©tricas (P1 -> P2 -> P3 -> AVG Top3)
    var autoLocutorCycleIdx = 0;
    var autoLocutorFocusKey = '';
    var autoLocutorCycleTimer = 0;

    function getTopRowsUnique(limit){
      try{
        const lim = Math.max(1, Math.min(50, Number(limit) || 3));
        const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.slice() : [];
        rows.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));
        const out = [];
        const seen = new Set();
        for (let i=0;i<rows.length && out.length<lim;i++){
          const r = rows[i];
          if (!r) continue;
          const k = getPilotKey(r);
          if (!k || seen.has(k)) continue;
          seen.add(k);
          out.push(r);
        }
        return out;
      }catch(e){ return []; }
    }

    function avgMsFrom(rows, getter){
      let sum = 0, cnt = 0;
      for (const r of rows){
        const v = getter(r);
        if (isLapPlausible(v)) { sum += v; cnt++; }
      }
      return cnt ? (sum / cnt) : 0;
    }

    function computeAvgTop3Row(rows){
      try{
        const top = rows && rows.length ? rows.slice(0,3) : [];
        if (!top.length) return null;
        const lastAvg = avgMsFrom(top, r => normalizeIncomingLapValue(r.lastTime));
        const bestAvg = avgMsFrom(top, r => normalizeIncomingLapValue(r.best));
        const meanAvg = avgMsFrom(top, r => normalizeIncomingLapValue(r.mean));
        const estAvg = (() => {
          let sum = 0, cnt = 0;
          for (const r of top){
            const n = Number(r.estLap);
            if (isFinite(n) && n > 0) { sum += n; cnt++; }
          }
          return cnt ? Math.round(sum / cnt) : 0;
        })();
        const consAvg = (() => {
          let sum = 0, cnt = 0;
          for (const r of top){
            const c = getConsistencyFromFirebase(r);
            const n = Number(c);
            if (isFinite(n) && n > 0) { sum += n; cnt++; }
          }
          return cnt ? (sum / cnt) : 0;
        })();

        const leader = top[0];
        return {
          pos: 'AVG',
          racerNumber: '-',
          racerName: 'Promedio Top 3',
          lapcount: leader ? leader.lapcount : 0,
          time: leader ? leader.time : 0,
          lastTime: lastAvg,
          best: bestAvg,
          mean: meanAvg,
          estLap: estAvg,
          consistency: consAvg,
          gap: '',
          diff: ''
        };
      }catch(e){ return null; }
    }

    function startAutoLocutorCycle(){
      try{
        if (autoLocutorCycleTimer) return;
        autoLocutorCycleTimer = setInterval(() => {
          if (selectedPilotKey) return;
          if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) return;
          autoLocutorCycleIdx = (autoLocutorCycleIdx + 1) % 4;
          try { renderPilotCard(null); } catch(e) {}
          try { drawLapChartTopNAuto(true); } catch(e) {}
          try { updateMangaClockDisplay(); } catch(e) {}
        }, 3500);
      }catch(e){}
    }
    function renderPilotCard(p) {
      if (!p) {
        // Arranca la rotaci√≥n de m√©tricas (suave, sin ruido)
        startAutoLocutorCycle();

        const top = getTopRowsUnique(3);
        const avgRow = computeAvgTop3Row(top);

        const mode = autoLocutorCycleIdx % 4;
        let focus = top[0] || null;
        let label = 'L√≠der';

        if (mode === 1) { focus = top[1] || top[0] || null; label = 'P2'; }
        else if (mode === 2) { focus = top[2] || top[0] || null; label = 'P3'; }
        else if (mode === 3 && avgRow) { focus = avgRow; label = 'AVG'; }

        // FocusKey para resaltar en gr√°fica (si es AVG, resalta l√≠der)
        try {
          if (focus && focus !== avgRow) autoLocutorFocusKey = getPilotKey(focus);
          else autoLocutorFocusKey = top[0] ? getPilotKey(top[0]) : '';
        } catch(e) { autoLocutorFocusKey = ''; }

        pilotNameEl.textContent = 'Auto Locutor';
        if (focus) {
          const nm = safeRacerName(focus.racerName) || '-';
          pilotMetaEl.textContent = (label === 'AVG')
            ? 'En foco: Promedio Top 3'
            : ('En foco: ' + label + ' - ' + nm);
        } else {
          pilotMetaEl.textContent = 'Auto Locutor ¬∑ Narraci√≥n global';
        }

        
// Pos pill (tama√±o fijo - no cambia entre P1 y P10)
if (label === 'AVG') {
  posTextEl.classList.add('is-avg');
  posTextEl.innerHTML = `<span class="pos-num">AVG</span>`;
} else {
  const posVal = (focus && focus.pos) ? focus.pos : null;
  posTextEl.classList.remove('is-avg');
  posTextEl.innerHTML = posVal
    ? `<span class="pos-letter">P</span><span class="pos-num">${posVal}</span>`
    : `<span class="pos-letter">P</span><span class="pos-num">-</span>`;
}
// Info corta
        try{
          const parts = [];
          if (focus && label !== 'AVG') {
            const gapText = formatoGapVueltas(focus.gap);
            if (gapText) parts.push(`Diferencia ${gapText}`);
          }
          const laps = focus && focus.lapcount != null ? focus.lapcount : null;
          if (laps != null) parts.push(`${laps} vueltas`);
          const total = (focus && focus.time) ? formatFeedTimeHMSms(focus.time) : '';
          if (total) parts.push(`Time ${total}`);
          gapInfoEl.textContent = parts.join(' ¬∑ ') || 'Diferencia l√≠der ¬∑ vueltas ¬∑ estado';
        }catch(e){
          gapInfoEl.textContent = 'Diferencia l√≠der ¬∑ vueltas ¬∑ estado';
        }

        // M√©tricas (l√≠der / P2 / P3 / AVG Top 3)
        const lastMs = focus ? normalizeLapMs(normalizeIncomingLapValue(focus.lastTime)) : 0;
        const bestMs = focus ? normalizeLapMs(normalizeIncomingLapValue(focus.best)) : 0;
        const meanMs = focus ? normalizeLapMs(normalizeIncomingLapValue(focus.mean)) : 0;

        lastLapEl.textContent = lastMs ? msToMinSec(lastMs) : '-:--.---';
        bestLapEl.textContent = bestMs ? msToMinSec(bestMs) : '-:--.---';
        meanLapEl.textContent = meanMs ? msToMinSec(meanMs) : '-:--.---';

        // Sin colorear agresivo en Auto (evita parpadeo)
        try { setLapClass(lastLapEl, 'lap-neutral'); } catch(e) {}
        try { setLapClass(bestLapEl, 'lap-neutral'); } catch(e) {}
        try { setLapClass(meanLapEl, 'lap-neutral'); } catch(e) {}

        // EstLap y Consistency
        try {
          const estRaw = (focus && focus.estLap != null) ? Number(focus.estLap) : NaN;
          if (estLapValEl) estLapValEl.textContent = (isFinite(estRaw) && estRaw > 0) ? String(estRaw) : '--';
        } catch(e) { if (estLapValEl) estLapValEl.textContent = '--'; }

        try {
          const cons = focus ? getConsistencyFromFirebase(focus) : 0;
          if (consistencyValEl) consistencyValEl.textContent = cons ? (cons + '%') : '--%';
        } catch(e) { if (consistencyValEl) consistencyValEl.textContent = '--%'; }

        // PRO-only en Auto: limpio
        try { if (pace3ValEl) pace3ValEl.textContent = '-:--.---'; } catch(e){}
        try { if (streakValEl) streakValEl.textContent = '--'; } catch(e){}

        // UI Top3 + Lap Chart multi-piloto (Top3/Top20 seg√∫n toggle)
        try { renderAutoLapChartTop3(); } catch(e) {}
        try { drawLapChartTopNAuto(); } catch(e) {}
        try { applyPilotSelectPosTheme(null); } catch(e) {}
        try { renderAutoTop3MiniGrid(); } catch(e) {}

        // TIME del feed (l√≠der o foco)
        try { updateMangaClockDisplay(); } catch(e) {}

        return;
      }

      pilotNameEl.textContent = safeRacerName(p.racerName) || 'Sin nombre';
      pilotMetaEl.textContent = `Auto #${p.racerNumber || '-'} ¬∑ Vueltas ${p.lapcount != null ? p.lapcount : '-'}`;

      posTextEl.classList.remove('is-avg');

      posTextEl.innerHTML = p.pos

        ? `<span class="pos-letter">P</span><span class="pos-num">${p.pos}</span>`

        : `<span class="pos-letter">P</span><span class="pos-num">-</span>`;
      try { applyPilotSelectPosTheme(p.pos); } catch(e) {}

      const gapText = formatoGapVueltas(p.gap);
      const meanStr = p.mean ? msToMinSec(p.mean) : '-:--.---';
      const totalStr = p.time ? msToMinSec(p.time) : '-:--.---';

      const partes = [];
      if (gapText) partes.push(`Diferencia ${gapText}`);
      if (p.lapcount != null) partes.push(`${p.lapcount} vueltas`);
      if (totalStr && totalStr !== '-:--.---') partes.push(`Total ${totalStr}`);
      gapInfoEl.textContent = partes.join(' ¬∑ ') || 'Diferencia l√≠der ¬∑ vueltas ¬∑ estado';

      const key = getPilotKey(p);
      let hist = lapHistory.get(key);
      if (!hist) {
        hist = { lastLapcount: Number(p.lapcount) || 0, lastTotalLapMs: 0, times: [], marks: [], bestMs: 0 };
        lapHistory.set(key, hist);
      }
      const timesRaw = (hist.times || []).filter(v => typeof v === 'number' && isFinite(v) && v > 0);
      updateLapRangeFromHistory(timesRaw);

      const computed = ensureHistComputed(hist);

      const consPct = getConsistencyFromFirebase(p);

      // EstLap desde Firebase (predicci√≥n/estimado)
      try {
        const estRaw = (p.estLap != null) ? Number(p.estLap) : NaN;
        if (estLapValEl) estLapValEl.textContent = (isFinite(estRaw) && estRaw > 0) ? String(estRaw) : '--';
      } catch(e) { if (estLapValEl) estLapValEl.textContent = '--'; }

      // Mostrar consistencia (feed) y œÉ (historial lap chart)
      try {
        if (consistencyValEl) consistencyValEl.textContent = consPct ? (consPct + '%') : '--%';
      } catch(e) {}
      try {
        const sig = (computed && computed.sigma && isFinite(computed.sigma)) ? (computed.sigma / 1000) : NaN;
        if (sigmaValEl) sigmaValEl.textContent = (isFinite(sig) && sig > 0) ? sig.toFixed(3) : '-.---';
      } catch(e) {}

      const computedBest = computed.best || 0;
      const computedLast = computed.last || 0;
      const computedMean = computed.mean || 0;

      const pLast = normalizeIncomingLapValue(p.lastTime);
      const pBest = normalizeIncomingLapValue(p.best);
      const pMean = normalizeIncomingLapValue(p.mean);

      const lastMsFinal = isLapPlausible(pLast) ? pLast : computedLast;
      let bestMsFinal = isLapPlausible(pBest) ? pBest : computedBest;
      // Si ya tenemos historia confiable (pasos por meta), √∫sala para corregir "best" raro del feed
      if (computedBest && computedBest > 0) {
        if (!bestMsFinal || bestMsFinal <= 0) {
          bestMsFinal = computedBest;
        } else {
          const lapsSeen = (hist.times && hist.times.length) ? hist.times.length : 0;
          // Si el best del feed es demasiado mas rapido que lo visto, es casi seguro basura
          if (lapsSeen >= 3 && bestMsFinal < (computedBest * 0.80)) {
            bestMsFinal = computedBest;
          } else if (computedBest < bestMsFinal) {
            bestMsFinal = computedBest;
          }
        }
      }
const meanMsFinal = isLapPlausible(pMean) ? pMean : computedMean;

      const lastStr = lastMsFinal ? msToMinSec(lastMsFinal) : '-:--.---';
      const bestStr = bestMsFinal ? msToMinSec(bestMsFinal) : '-:--.---';
      const meanStrFinal = meanMsFinal ? msToMinSec(meanMsFinal) : meanStr;


      // Pace 3 (promedio ultimas 3) y racha de consistencia (PRO)
      try{
        if (pace3ValEl){
          const pace3 = rollingAvgLast(timesRaw, 3);
          pace3ValEl.textContent = pace3 ? msToMinSec(pace3) : '-:--.---';
        }
      }catch(e){}
      try{
        if (streakValEl){
          const bestRef = (bestMsFinal && bestMsFinal > 0) ? bestMsFinal : (computedBest || 0);
          if (bestRef){
            const s02 = countConsecutiveWithin(timesRaw, bestRef + 200);
            const s05 = countConsecutiveWithin(timesRaw, bestRef + 500);
            streakValEl.textContent = `0.2:${s02} 0.5:${s05}`;
          } else {
            streakValEl.textContent = '--';
          }
        }
      }catch(e){}
      lastLapEl.textContent = lastStr;
      bestLapEl.textContent = bestStr;
      meanLapEl.textContent = meanStrFinal;
      // Colores estilo cronometraje (F1)
      const sessionBestMs = computeSessionBestMs();

      // √öLTIMA: morado (mejor absoluto) / verde (mejor personal) / amarillo (no mejora) / neutral
      const prevBest = prevBestByKey.get(key) || 0;
      const personalRef = prevBest > 0 ? prevBest : (bestMsFinal || 0);
      const lastClass = classifyLapColor(lastMsFinal, personalRef, sessionBestMs);
      // Actualiza referencia para pr√≥xima vuelta
      if (bestMsFinal && bestMsFinal > 0) prevBestByKey.set(key, bestMsFinal);
      setLapClass(lastLapEl, lastClass);

      // MEJOR: siempre morado (y si adem√°s es el mejor absoluto, se queda morado igual)
      if (bestMsFinal && bestMsFinal > 0) setLapClass(bestLapEl, 'lap-purple');
      else setLapClass(bestLapEl, 'lap-neutral');

      // MEDIA: color distinto (suave) cuando existe
      if (meanMsFinal && meanMsFinal > 0) setLapClass(meanLapEl, 'lap-avg');
      else setLapClass(meanLapEl, 'lap-neutral');

      // gr√°fica vuelta por vuelta
      if (selectedPilotKey && key === selectedPilotKey) {
        drawLapChartForKey(selectedPilotKey);
      }
    }

    
    
// Cache del record de carrera (best lap global) en ms
let sessionBestCache = { ms: 0, holder: '-', key: null };

function refreshSessionBestCache() {
  try {
    const rows = (raceData && Array.isArray(raceData.classification)) ? raceData.classification : [];
    const now = Date.now();
    let best = 0;
    let holder = '-';
    let holderKey = null;

    // 1) Fuente confiable: lo que nosotros vimos pasar por meta (delta de tiempos)
    for (const r of rows) {
      const key = getPilotKey(r);
      if (!key) continue;
      const hist = lapHistory ? lapHistory.get(key) : null;
      const ms = hist && hist.bestMs ? normalizeLapMs(hist.bestMs) : 0;
      if (!ms) continue;
      if (!best || ms < best) {
        best = ms;
        holder = safeRacerName(r.racerName) || '-';
        holderKey = key;
      }
    }

    // 2) Fallback: el "best" que manda el feed (por si abriste ya avanzada la carrera)
    if (!best) {
      for (const r of rows) {
        const raw =
          (typeof r.best !== 'undefined' ? r.best :
           (typeof r.bestMs !== 'undefined' ? r.bestMs :
            (typeof r.bestLapTime !== 'undefined' ? r.bestLapTime :
             (typeof r.bestLapTimeMs !== 'undefined' ? r.bestLapTimeMs : 0))));
        const ms = normalizeLapMs(normalizeIncomingLapValue(raw));
        if (!ms) continue;
        if (!best || ms < best) {
          best = ms;
          holder = safeRacerName(r.racerName) || '-';
          holderKey = getPilotKey(r);
        }
      }
    }

    // 3) √öltimo recurso: raceData.bestLapTime (sin due√±o seguro)
    if ((!best || best <= 0) && raceData && typeof raceData.bestLapTime !== 'undefined') {
      const fb = normalizeLapMs(normalizeIncomingLapValue(raceData.bestLapTime));
      if (fb) {
        best = fb;
        holder = (holder && holder !== '-') ? holder : '-';
      }
    }

    sessionBestCache = { ms: best || 0, holder: holder || '-', holderKey: holderKey || null };
    // Aviso de record de carrera (cualquiera)
    try {
      const now = Date.now();
      const cur = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
      const hKey = (sessionBestCache && sessionBestCache.holderKey) ? sessionBestCache.holderKey : null;
      const hName = (sessionBestCache && sessionBestCache.holder) ? sessionBestCache.holder : '-';
      const improved = cur && ((lastGlobalBestSpokenMs === 0) || (cur < (lastGlobalBestSpokenMs - 25)));
      const newHolder = hKey && (hKey !== lastGlobalBestSpokenHolderKey);
      if (improved && (newHolder || cur < (lastGlobalBestSpokenMs - 60)) && (now - lastGlobalBestSpokenAt > 2500)) {
        lastGlobalBestSpokenMs = cur;
        lastGlobalBestSpokenHolderKey = hKey;
        lastGlobalBestSpokenAt = now;
        // Beep + voz (no interrumpe si ya va hablando)
        const __allowRecord = !!(voiceSettings && voiceSettings.bestlap);
        if (__allowRecord){
          playBeep('up');
          enqueueSpeech(`Record de carrera. ${hName}. Best lap ${tiempoATexto(cur)}.`, { key: 'global_best_' + cur, priority: 88, cooldownMs: 2000, dedupe: true });
        }
        flashPilotCardGreen();
        flashMangaClock();
      }
    } catch(e) {}

  } catch (e) {
    console.error('refreshSessionBestCache', e);
    sessionBestCache = { ms: 0, holder: '-', holderKey: null };
  }
}


function updateRecordCarreraUI() {
  const lapEl = document.getElementById('bestOverallLap');
  const holderEl = document.getElementById('bestLapHolder');
  if (!lapEl || !holderEl) return;

  const best = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
  if (!best) {
    lapEl.textContent = '-:--.---';
    holderEl.textContent = '-';
    return;
  }

  lapEl.textContent = msToMinSec(best);
  holderEl.textContent = (sessionBestCache && sessionBestCache.holder) ? sessionBestCache.holder : '-';
}

function computeSessionBestMs() {
      // Usar cache (se refresca en cada tick)
      const best = (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
      if (best && isFinite(best)) return best;

      // fallback: recalcula si todav√≠a no hay cache por alguna raz√≥n
      refreshSessionBestCache();
      return (sessionBestCache && sessionBestCache.ms) ? sessionBestCache.ms : 0;
    }

    function classifyLapColor(lastMs, personalBestMs, sessionBestMs) {
      if (!lastMs || lastMs <= 0 || !isFinite(lastMs)) return 'lap-neutral';
      // Morado: mejor absoluto (tolerancia m√≠nima)
      if (sessionBestMs && sessionBestMs > 0 && lastMs <= (sessionBestMs + 1)) return 'lap-purple';
      // Verde: mejor√≥ su propio
      if (personalBestMs && personalBestMs > 0 && lastMs <= (personalBestMs + 1)) return 'lap-green';
      // Amarillo: no mejor√≥
      if (personalBestMs && personalBestMs > 0) return 'lap-yellow';
      return 'lap-neutral';
    }

    function setLapClass(el, cls) {
      if (!el) return;
      el.classList.remove('lap-purple','lap-green','lap-yellow','lap-neutral','lap-avg');
      if (cls) el.classList.add(cls);
    }

    function flashLastLap() {
      lastLapEl.classList.add('flash');
      setTimeout(() => {
        lastLapEl.classList.remove('flash');
      }, 300);
    }

    

    

    // =========================
    // Lista de pilotos (dropdown)
    // - Se refresca en cada tick (si no est√°s interactuando)
    // - Incluye raceName en firma para forzar refresh al cambiar de carrera
    // - iOS fix: focus/blur a veces se quedan pegados, usamos timeout de seguridad
    // =========================
    let pilotSelectBusyTimer = null;
    function setSelectingPilot(on, holdMs=3200){
      isSelectingPilot = !!on;
      try { if (pilotSelectBusyTimer) clearTimeout(pilotSelectBusyTimer); } catch(e) {}
      if (on) {
        pilotSelectBusyTimer = setTimeout(() => { isSelectingPilot = false; }, Math.max(600, Number(holdMs)||3200));
      }
    }

    function updatePilotOptions(force=false, reason='') {
      if (!pilotSelect) return;
      if (!raceData || !Array.isArray(raceData.classification)) return;
      const currentKey = selectedPilotKey;

      const raceSig = String((raceData && raceData.raceName) ? raceData.raceName : (lastRaceName || '')).trim();
      const signature = raceSig + '|' + raceData.classification
        .map(r => (getPilotKey(r) || '') + '::' + safeRacerName(r.racerName) + '::' + String((r && r.racerNumber!=null)?r.racerNumber:'').trim())
        .sort()
        .join('|');

      if (!force && signature === lastPilotOptionsSignature) {
        // mantener selecci√≥n
        if (currentKey) {
          const exists = raceData.classification.some(r => getPilotKey(r) === currentKey);
          if (!exists) {
            // Mantener selecci√≥n guardada aunque todav√≠a no aparezca en el feed.
            // Creamos una opci√≥n placeholder para que el select conserve el value.
            try{
              const opt = document.createElement('option');
              opt.value = currentKey;
              opt.textContent = 'Piloto guardado (esperando datos)';
              opt.dataset && (opt.dataset.placeholder = '1');
              pilotSelect.appendChild(opt);
            }catch(e){}
            pilotSelect.value = currentKey;
            selectedPilotKey = currentKey;
          } else {
            pilotSelect.value = currentKey;
          }
        } else {
          pilotSelect.value = '';
        }
        return;
}

      lastPilotOptionsSignature = signature;

      // Orden estable: por pos y luego nombre
      const rows = raceData.classification.slice().sort((a,b)=>{
        const pa = Number(a && a.pos) || 999;
        const pb = Number(b && b.pos) || 999;
        if (pa !== pb) return pa - pb;
        const na = (safeRacerName(a && a.racerName) || '').toLowerCase();
        const nb = (safeRacerName(b && b.racerName) || '').toLowerCase();
        if (na < nb) return -1;
        if (na > nb) return 1;
        return 0;
      });

      const options = [];
      options.push({ value: '', label: 'Sin piloto seleccionado' });

      const seen = new Set();
      for (const row of rows) {
        const key = getPilotKey(row);
        if (!key || seen.has(key)) continue;
        seen.add(key);
        const name = safeRacerName(row.racerName) || '(sin nombre)';
        const numRaw = (row.racerNumber != null) ? String(row.racerNumber).trim() : '';
        const num = (numRaw && numRaw !== '-' && numRaw !== '0') ? numRaw : '';
        const label = (num ? ('#' + num + ' - ') : '') + name;
        options.push({ value: key, label });
      }

      // Re-render options
      pilotSelect.innerHTML = '';
      for (const optData of options) {
        const opt = document.createElement('option');
        opt.value = optData.value;
        opt.textContent = optData.label;
        pilotSelect.appendChild(opt);
      }

      // restaurar selecci√≥n actual si existe
      if (currentKey) {
        const exists = rows.some(r => getPilotKey(r) === currentKey);
        if (exists) {
          pilotSelect.value = currentKey;
          selectedPilotKey = currentKey;
        } else {
          pilotSelect.value = '';
          selectedPilotKey = '';
        }
      } else {
        pilotSelect.value = '';
      }

      // Auto-selecci√≥n desde storage (si todav√≠a no hay selecci√≥n)
      try {
        if (!selectedPilotKey && !(typeof autoLocutorActive !== 'undefined' && autoLocutorActive)) {
          const storedKey = String(prefGet('spotterSelectedPilotKey', '') || '').toLowerCase().trim();
          if (storedKey) {
            const existsStored = rows.some(r => getPilotKey(r) === storedKey);
            if (existsStored) {
              selectPilotByKey(storedKey, { source:'cookie', announce:false });
            }
          }
        }
      } catch(e) {}

      // Diag opcional
      try {
        if (force && reason) diagLogPush('PILOTOS refresh: ' + reason);
      } catch(e) {}
    }

    // iOS/Safari: focus/blur puede quedarse pegado. Estas se√±ales + timeout lo corrigen.
    if (pilotSelect) {
      pilotSelect.addEventListener('pointerdown', () => setSelectingPilot(true, 3500));
      pilotSelect.addEventListener('touchstart', () => setSelectingPilot(true, 3500), { passive:true });
      pilotSelect.addEventListener('mousedown', () => setSelectingPilot(true, 3500));
      pilotSelect.addEventListener('focus', () => setSelectingPilot(true, 3500));
      pilotSelect.addEventListener('change', () => setSelectingPilot(false));
      pilotSelect.addEventListener('blur', () => setSelectingPilot(false));
    }

    // Auto-refresh lista de pilotos: √∫til cuando cambia la carrera o se actualizan n√∫meros/nombres
    try {
      if (pilotSelect) {
        if (pilotOptionsAutoRefreshTimer) clearInterval(pilotOptionsAutoRefreshTimer);
        pilotOptionsAutoRefreshTimer = setInterval(() => {
          try {
            if (!isSelectingPilot && raceData && Array.isArray(raceData.classification)) {
              updatePilotOptions(false, 'timer');
            }
          } catch(e) {}
        }, 2500);
      }
    } catch(e) {}


function resetSelectedPilotTrackingState() {
      // NO detener el reloj de MANGA aqu√≠: el cron√≥metro es por piloto y debe persistir al cambiar selecci√≥n.
      lastSpokenLastTime = null;
          lastAnnouncedLapcount = 0;
          lastKnownPos = null;
          lastTotalTimeAnnouncedSeconds = 0;
          lastBestAnnouncedMs = null;
          lastBestAnnouncedLap = 0;
          lastTrendSpokenLap = 0;
          lastAheadAlertMs = 0;
          lastAutoSummaryAnnouncedSeconds = 0;

          attackLatch  = { active:false, otherKey:'', lap:-1 };
          defenseLatch = { active:false, otherKey:'', lap:-1 };
          fightLatch   = { active:false, lap:-1 };
          startPosForSelected = null;
          lastNetGainValue = null;
          lastNetGainSpokenLap = 0;
          lastLeaderGapSpokenLap = 0;
          lastPodiumSpokenLap = 0;
        }

        function ensurePilotOptionExists(key) {
          if (!pilotSelect || !key) return;
          for (let i = 0; i < pilotSelect.options.length; i++) {
            if (pilotSelect.options[i].value === key) return;
          }
          let label = key;
          try {
            if (raceData && Array.isArray(raceData.classification)) {
              const p = raceData.classification.find(r => getPilotKey(r) === key);
              if (p) {
                const name = safeRacerName(p.racerName) || '(sin nombre)';
                const numRaw = (p.racerNumber != null) ? String(p.racerNumber).trim() : '';
                const num = (numRaw && numRaw !== '-' && numRaw !== '0') ? numRaw : '';
                label = (num ? ('#' + num + ' - ') : '') + name;
              }
            }
          } catch(e) {}
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = label;
          pilotSelect.appendChild(opt);
        }

        function selectPilotByKey(key, opts = {}) {
      try { document.body.classList.add('no-anim'); setTimeout(()=>document.body.classList.remove('no-anim'), 700); } catch(e) {}

          const k = (key || '').toLowerCase().trim();
          const announce = (opts.announce !== false);

          selectedPilotKey = k;

          try { if (k) autoLocutorActive = false; } catch(e) {}


      // Auto: si hay piloto seleccionado, arrancamos en SUPER (solo laps + pos). Si sales de seguimiento, volvemos al modo previo.
      try{
        if (!window.__autoNarrCtx) window.__autoNarrCtx = { active:false, prevMode: uiNarrationMode || 'TV' };
        const ctx = window.__autoNarrCtx;
        if (k) {
          if (!ctx.active) { ctx.prevMode = ((uiNarrationMode === 'SUPER') ? 'TV' : (uiNarrationMode || ctx.prevMode || 'TV')); ctx.active = true; }
          if (uiNarrationMode !== 'SUPER') {
            try { setNarrationMode('SUPER', { silent:true, temp:true }); } catch(e) {}
          }
        } else {
          // Auto locutor: nunca quedarse en SUPER (si no hay piloto, es TV)
          if (!ctx.active && uiNarrationMode === 'SUPER') {
            try { setNarrationMode('TV', { silent:true, temp:true }); } catch(e) {}
          }
          if (ctx.active) {
            let back = ctx.prevMode || 'TV';
            if (back === 'SUPER') back = 'TV';
            ctx.active = false;
            if (uiNarrationMode !== back) {
              try { setNarrationMode(back, { silent:true, temp:true }); } catch(e) {}
            }
          }
        }
      }catch(e){}
          try { prefSet('spotterSelectedPilotKey', k || ''); } catch(e) {}
          selectedPilotFirstDetectBeeped = !!firstDetectBeepedByPilot.get(k);
          pendingAutoVoiceUnlock = !!k;

          if (pilotSelect) {
            if (k) ensurePilotOptionExists(k);
            pilotSelect.value = k || '';
          }

          resetSelectedPilotTrackingState();

          if (k) {
            // Auto-activar voz al elegir piloto (siempre visible)
            try { setVoiceMaster(true, { silent:true }); } catch(e) {}

            // MANGA: NO inicia reloj al seleccionar (solo muestra UI)
            try { onPilotSelectedManga(k); } catch(e) {}

            // iOS/Chrome a veces requiere gesto extra para TTS
            try {
              if (isIOSWebKit()) {
                try { voiceToggleBtns.forEach(b => b.classList.add('needs-unlock')); } catch(e) {}
                scheduleOneTapUnlock();
              }
            } catch(e) {}
          } else {
            // Modo locutor: sin piloto seleccionado
            try { resetAutoCommentatorState(); } catch(e) {}
          }

          if (!raceData || !k) {
            renderPilotCard(null);
        try { renderAutoTop3MiniGrid(); } catch(e) {}
            return;
          }
          const p = raceData.classification.find(r => getPilotKey(r) === k);
          renderPilotCard(p || null);
          try { renderAutoTop3MiniGrid(); } catch(e) {}
          if (p && p.pos && p.pos > 0) { startPosForSelected = p.pos; lastNetGainValue = 0; }
          if (announce && p && voiceMasterEnabled) {
            enqueueSpeech('Siguiendo a ' + safeRacerName(p.racerName), { key: 'pilot_select_' + (k||''), cat: 'system', priority: 98, cooldownMs: 0, interrupt: true, dedupe: false });
          }
        }

        

// MANGA: NO inicia el reloj al seleccionar.
// El reloj por piloto inicia en su 1er cruce por meta (lapcount pasa de 0 -> 1).
// MANGA: al seleccionar piloto, solo mostramos el TIME del feed (no cron√≥metro local).
function onPilotSelectedManga(pilotKey) {
  try {
    const pk = (pilotKey || '').toLowerCase().trim();
    if (!pk) return;

    // Asegura session info actual
    try {
      if (raceData && raceData.raceName) currentSessionInfo = parseSessionFromRaceName(raceData.raceName);
    } catch(e) {}

    const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
    if (!isManga) return;

    setMangaClockVisible(true);
    updateMangaClockDisplay();
  } catch(e) {}
}

pilotSelect.addEventListener('change', () => {
          selectPilotByKey(pilotSelect.value || '', { source:'select', announce:true });
        });

        pilotSelect.addEventListener('input', () => {
          // iOS a veces dispara input antes de change
          selectPilotByKey(pilotSelect.value || '', { source:'select', announce:false });
        });

    function findPilotIndexByKey(key) {
      if (!raceData || !Array.isArray(raceData.classification)) return -1;
      return raceData.classification.findIndex(r => getPilotKey(r) === key);
    }


    // =========================
    // GAP lapDiff guard (anti "1 vuelta" fantasma)
    // - Solo hablamos de diferencia de vueltas si se repite estable en 2 lecturas
    // =========================
    const lapDiffSpeakGuard = new Map();
    function lapDiffGuardAllow(pairKey, lapDiff) {
      try {
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const st = lapDiffSpeakGuard.get(pairKey) || { last: null, count: 0, firstMs: 0 };
        if (st.last !== lapDiff) {
          st.last = lapDiff;
          st.count = 1;
          st.firstMs = now;
          lapDiffSpeakGuard.set(pairKey, st);
          return false;
        }
        st.count = (st.count || 0) + 1;
        lapDiffSpeakGuard.set(pairKey, st);
        if (st.count >= 2) return true;
        if ((now - (st.firstMs || 0)) >= 600) return true;
        return false;
      } catch(e) {
        return false;
      }
    }

    function buildGapSummaryForPilotIndex(idx) {
      if (!raceData || !Array.isArray(raceData.classification)) return null;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length) return null;

      const me = arr[idx];
      const ahead = idx > 0 ? arr[idx - 1] : null;
      const behind = idx < arr.length - 1 ? arr[idx + 1] : null;

      function diffTexto(me, other, direction) {
        if (!me || !other || me.time == null || other.time == null) return null;

        const meLaps = (me.lapcount != null) ? me.lapcount : 0;
        const otherLaps = (other.lapcount != null) ? other.lapcount : 0;
        const lapDiff = meLaps - otherLaps;

        // Si hay diferencia de vueltas, dilo como "m√°s una vuelta" (sin nombres).
        if (lapDiff !== 0) {


          // Guard: evitar glitches de lapcount en lecturas pegadas


          const expectedOk = (direction === 'ahead') ? (lapDiff <= 0) : (lapDiff >= 0);


          if (!expectedOk) {


            // Inconsistente: tratamos como mismo giro y seguimos con segundos


          } else {


            const meKey = getPilotKey(me) || (me.racerName || 'me');


            const otherKey = getPilotKey(other) || (other.racerName || 'other');


            const pairKey = meKey + '|' + otherKey + '|' + direction;


            if (!lapDiffGuardAllow(pairKey, lapDiff)) return null;


            const v = Math.abs(lapDiff);


            const palabra = (v === 1) ? 'una vuelta' : (v + ' vueltas');


            if (direction === 'ahead') return 'Gap con ' + (safeRacerName(other.racerName) || 'adelante') + ' m√°s ' + palabra;


            return 'Gap con ' + (safeRacerName(other.racerName) || 'atr√°s') + ' m√°s ' + palabra;


          }
        }
        const diffMs = Math.abs(me.time - other.time);
        if (!diffMs || diffMs <= 0) {
          if (direction === 'ahead') return 'Diferencia adelante pegados';
          return 'Diferencia atr√°s pegados';
        }

        const secStr = toFixedFloor((diffMs / 1000), decimalPrecision);
        if (direction === 'ahead') return 'Gap con ' + (safeRacerName(other.racerName) || 'adelante') + ' ' + secStr;
        return 'Gap con ' + (safeRacerName(other.racerName) || 'atr√°s') + ' ' + secStr;
      }

      const parts = [];
      if (ahead) {
        const t = diffTexto(me, ahead, 'ahead');
        if (t) parts.push(t);
      }
      if (behind) {
        const t = diffTexto(me, behind, 'behind');
        if (t) parts.push(t);
      }
      if (!parts.length) return null;
      return parts.join('. ');
    }

    function getFrontBackContext(idx) {
      if (!raceData || !Array.isArray(raceData.classification)) return null;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length) return null;

      const me = arr[idx];
      const ahead = idx > 0 ? arr[idx - 1] : null;
      const behind = idx < arr.length - 1 ? arr[idx + 1] : null;

      const meLaps = (me && me.lapcount != null) ? Number(me.lapcount) || 0 : 0;

      const wordToNum = (w) => {
        const map = { 'una':1,'un':1,'uno':1,'dos':2,'tres':3,'cuatro':4,'cinco':5,'seis':6,'siete':7,'ocho':8,'nueve':9,'diez':10 };
        return map[w] || NaN;
      };

      const parseDiff = (raw) => {
        try{
          const s0 = String(raw || '').trim();
          if (!s0 || s0 === '-' || s0 === '‚Äî') return { sec: null, laps: null };
          const mV = s0.match(/([+-]?\s*\d+)\s*v/i);
          if (mV){
            const n = parseInt(String(mV[1]).replace(/\s+/g,''),10);
            if (isFinite(n)) return { sec: null, laps: Math.abs(n) };
          }
          const s = s0.toLowerCase();
          const mMas = s.match(/m[a√°]s\s+(\d+|una|un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s+vueltas?/i);
          if (mMas){
            const tok = mMas[1];
            const n = /^\d+$/.test(tok) ? parseInt(tok,10) : wordToNum(tok);
            if (isFinite(n) && n > 0) return { sec: null, laps: n };
          }
          if (s0.includes(':')){
            const parts = s0.split(':');
            if (parts.length >= 2){
              const mm = parseFloat(parts[0].replace(/[^0-9.]/g,''));
              const sec = parseFloat(parts.slice(1).join(':').replace(/[^0-9.]/g,''));
              if (isFinite(mm) && isFinite(sec)) return { sec: Math.abs((mm*60)+sec), laps: null };
            }
          }
          const f = parseFloat(s0.replace(/[^0-9.+-]/g,''));
          if (isFinite(f)) return { sec: Math.abs(f), laps: null };
          return { sec: null, laps: null };
        }catch(e){
          return { sec: null, laps: null };
        }
      };

      let frontSec = null, backSec = null;
      let frontKey = '', backKey = '';
      let frontName = '', backName = '';
      let sameFrontLap = false, sameBackLap = false;

      if (ahead && me) {
        const meDiff = (me.diff != null ? me.diff : (me.interval != null ? me.interval : ''));
        const info = parseDiff(formatoGapVueltas(meDiff) || meDiff);
        const aLaps = (ahead.lapcount != null) ? Number(ahead.lapcount) || 0 : 0;

        if (info.laps != null) {
          sameFrontLap = false;
          frontSec = null;
        } else if (info.sec != null && isFinite(info.sec)) {
          sameFrontLap = true;
          frontSec = info.sec;
        } else {
          sameFrontLap = (aLaps === meLaps && meLaps > 0);
          if (sameFrontLap && me.time != null && ahead.time != null) {
            const diffMs = Number(me.time) - Number(ahead.time);
            if (diffMs && diffMs > 0) frontSec = diffMs / 1000;
          }
        }
        frontKey = getPilotKey(ahead) || ahead._id || ahead.racerName || String(idx - 1);
        frontName = safeRacerName(ahead.racerName) || '';
      }

      if (behind && me) {
        const bDiff = (behind.diff != null ? behind.diff : (behind.interval != null ? behind.interval : ''));
        const infoB = parseDiff(formatoGapVueltas(bDiff) || bDiff);
        const bLaps = (behind.lapcount != null) ? Number(behind.lapcount) || 0 : 0;

        if (infoB.laps != null) {
          sameBackLap = false;
          backSec = null;
        } else if (infoB.sec != null && isFinite(infoB.sec)) {
          sameBackLap = true;
          backSec = infoB.sec;
        } else {
          sameBackLap = (bLaps === meLaps && meLaps > 0);
          if (sameBackLap && me.time != null && behind.time != null) {
            const diffMs = Number(behind.time) - Number(me.time);
            if (diffMs && diffMs > 0) backSec = diffMs / 1000;
          }
        }
        backKey = getPilotKey(behind) || behind._id || behind.racerName || String(idx + 1);
        backName = safeRacerName(behind.racerName) || '';
      }

      return {
        me, ahead, behind,
        meLaps,
        frontSec, backSec,
        frontKey, backKey,
        frontName, backName,
        sameFrontLap, sameBackLap
      };
    }

    function checkBehindAlertForPilotIndex(idx) {

      if (!raceData || !Array.isArray(raceData.classification)) return;
      const arr = raceData.classification;
      if (idx < 0 || idx >= arr.length - 1) return;

      const me = arr[idx];
      const behind = arr[idx + 1];
      if (!me || !behind || !me.time || !behind.time) return;

      const meLaps = me.lapcount != null ? me.lapcount : 0;
      const behindLaps = behind.lapcount != null ? behind.lapcount : 0;

      // Si est√°n en distinta vuelta, liberamos latch (y no avisamos)
      if (meLaps !== behindLaps) {
        behind06Latch.active = false;
        return;
      }

      const diffMs = behind.time - me.time;
      if (!diffMs || diffMs <= 0) return;

      const sec = diffMs / 1000;

      // Histeresis: solo rearmamos cuando se libera bien el gap
      const otherKey = behind._id || behind.racerName || String(idx + 1);

      if (behind06Latch.active) {
        // Si cambia el rival o cambia la vuelta o ya se liber√≥ el gap, se rearma
        if (behind06Latch.otherKey !== otherKey || sec >= 0.80) {
          behind06Latch.active = false;
        } else {
          return; // sigue activo: NO repetir
        }
      }

      if (sec >= 0.6) return;

      const secStr = gapPhraseFromSec(sec);
      const nombreDetras = safeRacerName(behind.racerName || '');
      if (nombreDetras) {
        speakWithLaps(meLaps, 'Cuidado, ' + nombreDetras + ' viene atr√°s a ' + secStr + ' segundos', { key: 'back06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      } else {
        speakWithLaps(meLaps, 'Cuidado, traes un piloto atr√°s a ' + secStr + ' segundos', { key: 'back06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      }

      behind06Latch.active = true;
      behind06Latch.otherKey = otherKey;
      behind06Latch.lap = meLaps;

      const ahora = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      lastBehindAlertMs = ahora;
    }
    function checkAheadAlertForPilotIndex(idx) {

      if (!raceData || !Array.isArray(raceData.classification)) return;
      const arr = raceData.classification;
      if (idx <= 0 || idx >= arr.length) return;

      const me = arr[idx];
      const ahead = arr[idx - 1];
      if (!me || !ahead || !me.time || !ahead.time) return;

      const meLaps = me.lapcount != null ? me.lapcount : 0;
      const aheadLaps = ahead.lapcount != null ? ahead.lapcount : 0;

      if (meLaps !== aheadLaps) {
        ahead06Latch.active = false;
        return;
      }

      const diffMs = me.time - ahead.time;
      if (!diffMs || diffMs <= 0) return;

      const sec = diffMs / 1000;
      const otherKey = ahead._id || ahead.racerName || String(idx - 1);

      if (ahead06Latch.active) {
        if (ahead06Latch.otherKey !== otherKey || sec >= 0.80) {
          ahead06Latch.active = false;
        } else {
          return;
        }
      }

      if (sec >= 0.6) return;

      const secStr = gapPhraseFromSec(sec);
      const nombreAdelante = safeRacerName(ahead.racerName || '');
      if (nombreAdelante) {
        speakWithLaps(meLaps, 'Lo traes a tiro. ' + nombreAdelante + ' adelante a ' + secStr + ' segundos', { key: 'front06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      } else {
        speakWithLaps(meLaps, 'Lo traes a tiro. Adelante a ' + secStr + ' segundos', { key: 'front06_' + otherKey, priority: 7, cooldownMs: 2500, dedupe: true });
      }

      ahead06Latch.active = true;
      ahead06Latch.otherKey = otherKey;
      ahead06Latch.lap = meLaps;

      const ahora = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      lastAheadAlertMs = ahora;
      }

function updateBlueFlagFromPassEvents() {
  try {
    // Implementaci√≥n simple y confiable basada en cruces de meta (pasos)
    // - Prioriza timestamps locales (abs) cuando existan, porque en MANGA los tiempos del feed pueden ser por-piloto.
    // - Solo aplica al piloto seleccionado.
    if (!raceData || !Array.isArray(raceData.classification) || !selectedPilotKey) return;
    if (!voiceSettings || !voiceSettings.blueflag) return;
    if (!lastPassEvents || typeof lastPassEvents.get !== 'function') return;

    const cls = raceData.classification;
    if (!cls.length) return;

    const leader = cls.find(r => Math.floor(Number(r.pos) || 0) === 1) || cls[0];
    if (!leader) return;

    const leaderKey = getPilotKey(leader);
    if (!leaderKey || leaderKey === selectedPilotKey) return;

    const selEvent = lastPassEvents.get(selectedPilotKey);
    const leaderEvent = lastPassEvents.get(leaderKey);
    if (!selEvent || !leaderEvent) return;

    const tSel  = (selEvent.abs != null) ? Number(selEvent.abs) : Number(selEvent.time || 0);
    const tLead = (leaderEvent.abs != null) ? Number(leaderEvent.abs) : Number(leaderEvent.time || 0);
    if (!tSel || !tLead) return;

    // Queremos el caso donde el piloto seleccionado pas√≥ primero y despu√©s cruza el l√≠der.
    if (tLead < tSel) return;

    const delta = tLead - tSel;

    // Ventana de "viene detr√°s pegado" (en ms). Si es m√°s grande, no est√° cerca realmente.
    if (delta < 0 || delta > 2500) return;

    const lapDiff = (Number(leaderEvent.lap) || 0) - (Number(selEvent.lap) || 0);
    if (lapDiff < 0) return;

    const leaderName = safeRacerName(leader.racerName || '') || (leader.racerName || 'el l√≠der');

    if (lapDiff >= 1) {
      // Bandera azul real: el l√≠der ya va al menos una vuelta adelante y te viene a doblar/ya te dobl√≥.
      if (selEvent.lap && selEvent.lap <= lastBlueFlagPilotLap) return;

      const vueltasTxt = (lapDiff === 1) ? 'm√°s una vuelta' : ('m√°s ' + lapDiff + ' vueltas');
      pendingBlueFlagForPilotKey = selectedPilotKey;
      pendingBlueFlagMessage =
        'Bandera azul. El l√≠der ' + leaderName + ' viene detr√°s, ' + vueltasTxt + '. Mant√©n tu l√≠nea y d√©jalo pasar';
      lastBlueFlagPilotLap = selEvent.lap || lastBlueFlagPilotLap;
    } else {
      // lapDiff === 0 -> el l√≠der todav√≠a no lo ha lapeado pero viene pegado.
      if (selEvent.lap && selEvent.lap <= lastBlueWarnPilotLap) return;

      pendingBlueFlagForPilotKey = selectedPilotKey;
      pendingBlueFlagMessage =
        'El l√≠der ' + leaderName + ' viene muy cerca detr√°s. Aprieta el paso, precauci√≥n con el manejo y mant√©n tu l√≠nea';
      lastBlueWarnPilotLap = selEvent.lap || lastBlueWarnPilotLap;
    }
  } catch (e) {
    console.error('Error en updateBlueFlagFromPassEvents', e);
  }
}


// =========================
// Bandera azul - Auto Locutor (global)
// =========================
let autoBlueFlagLastLapByKey = new Map();
let autoBlueWarnLastLapByKey = new Map();
let autoBlueFlagLastAbsMs = 0;

function autoBlueFlagCandidate(sortedArr, leaderRow) {
  try {
    if (!sortedArr || !sortedArr.length || !leaderRow) return null;
    if (!voiceSettings || !voiceSettings.blueflag) return null;
    if (!lastPassEvents || typeof lastPassEvents.get !== 'function') return null;

    const leaderKey = getPilotKey(leaderRow);
    if (!leaderKey) return null;

    const leaderEvent = lastPassEvents.get(leaderKey);
    if (!leaderEvent) return null;

    const tLead = (leaderEvent.abs != null) ? Number(leaderEvent.abs) : Number(leaderEvent.time || 0);
    if (!tLead) return null;

    const leaderName = safeRacerName(leaderRow.racerName || '') || 'el l√≠der';

    const maxPos = 12; // TV: no infinito
    let best = null;

    for (const row of sortedArr) {
      if (!row) continue;
      const pos = Number(row.pos) || 999;
      if (pos <= 1 || pos > maxPos) continue;

      const k = getPilotKey(row);
      if (!k || k === leaderKey) continue;

      const ev = lastPassEvents.get(k);
      if (!ev) continue;

      const tSel = (ev.abs != null) ? Number(ev.abs) : Number(ev.time || 0);
      if (!tSel) continue;

      // queremos: el piloto cruza y luego el l√≠der cruza muy cerca detr√°s
      if (tLead < tSel) continue;

      const delta = tLead - tSel;
      if (delta < 0 || delta > 2500) continue;

      const lapDiff = (Number(leaderEvent.lap) || 0) - (Number(ev.lap) || 0);
      if (lapDiff < 0) continue;

      const lapNow = Number(ev.lap) || 0;

      const name = safeRacerName(row.racerName || '') || ('P' + pos);
      const deltaSec = Math.max(0, delta / 1000);
      const closeTxt = gapPhraseFromSec(deltaSec);

      let msg = '';
      let score = 0;
      let sig = '';
      let cd = 0;
      let priority = 0;

      if (lapDiff >= 1) {
        const lastLap = (autoBlueFlagLastLapByKey && autoBlueFlagLastLapByKey.get) ? (autoBlueFlagLastLapByKey.get(k) || 0) : 0;
        if (lapNow && lapNow <= lastLap) continue;

        const vueltasTxt = (lapDiff === 1) ? 'm√°s una vuelta' : ('m√°s ' + lapDiff + ' vueltas');
        msg = 'Bandera azul para ' + name + '. El l√≠der ' + leaderName + ' viene detr√°s, ' + vueltasTxt + '. Mant√©n tu l√≠nea y d√©jalo pasar';
        score = 9.6;
        priority = 10;
        sig = 'auto:blueflag:' + k + ':' + lapNow;
        cd = 5000;
      } else {
        const lastLap = (autoBlueWarnLastLapByKey && autoBlueWarnLastLapByKey.get) ? (autoBlueWarnLastLapByKey.get(k) || 0) : 0;
        if (lapNow && lapNow <= lastLap) continue;

        msg = 'Tr√°fico. El l√≠der ' + leaderName + ' viene muy cerca detr√°s de ' + name + ', a ' + closeTxt + ' segundos. Mant√©n tu l√≠nea';
        score = 7.8;
        priority = 8;
        sig = 'auto:bluewarn:' + k + ':' + lapNow;
        cd = 6500;
      }

      const cand = {
        type: 'blueflag',
        score: score + Math.max(0, (2.6 - deltaSec)), // m√°s cerca, m√°s score
        text: msg,
        key: 'auto_blue_' + k,
        sig,
        sigCooldownMs: cd,
        priority,
        onCommit: () => {
          try {
            if (lapDiff >= 1) autoBlueFlagLastLapByKey.set(k, lapNow);
            else autoBlueWarnLastLapByKey.set(k, lapNow);
            autoBlueFlagLastAbsMs = Date.now();
          } catch(e) {}
        }
      };

      if (!best || (Number(cand.score) > Number(best.score))) best = cand;
    }

    // anti spam: si acabamos de hablar azul, no encimes
    if (best) {
      const since = Date.now() - (autoBlueFlagLastAbsMs || 0);
      if (since < 3800) return null;
    }
    return best;
  } catch (e) {
    console.error('autoBlueFlagCandidate', e);
    return null;
  }
}


function updateCourtesyFromPassEvents() {
  try {
    if (!raceData || !Array.isArray(raceData.classification) || raceData.classification.length < 2) return;
    if (!voiceSettings || !voiceSettings.courtesy) return;

    const cls = raceData.classification.slice();
    cls.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));

    const clamp = (min, max, v) => Math.max(min, Math.min(max, v));
    const toDecimasRange = (sec) => {
      // devuelve 1..9 para <1s
      const s = Math.max(0, sec);
      const d = Math.floor(s * 10 + 1e-6);
      return clamp(1, 9, d || 1);
    };

    // Arma pares (adelante, atras)
    const pairs = [];
    if (selectedPilotKey) {
      const ahead = cls.find(r => getPilotKey(r) === selectedPilotKey);
      if (!ahead) return;
      const aheadPos = Number(ahead.pos)||0;
      const behind = cls.find(r => (Number(r.pos)||0) === (aheadPos + 1));
      if (behind) pairs.push({ ahead, behind, tv:false });
    } else if (uiNarrationMode !== 'SILENT') {
      for (let i = 0; i < cls.length - 1; i++) {
        const ahead = cls[i];
        const behind = cls[i+1];
        const behindPos = Number(behind.pos)||999;
        if (behindPos > 8) continue; // TV: top 8 max
        pairs.push({ ahead, behind, tv:true });
      }
    } else {
      return;
    }

    const state = courtesyState || (courtesyState = Object.create(null));

    for (const pair of pairs) {
      const ahead = pair.ahead;
      const behind = pair.behind;

      if (!ahead || !behind) continue;

      const keyAhead = getPilotKey(ahead);
      const keyBehind = getPilotKey(behind);
      if (!keyAhead || !keyBehind) continue;

      // Solo misma vuelta (si no, no es cortes√≠a, es lapeo/azul)
      const lapAhead = Number(ahead.lapcount)||0;
      const lapBehind = Number(behind.lapcount)||0;
      if (lapAhead !== lapBehind) continue;

      const tAhead = Number(ahead.time)||0;
      const tBehind = Number(behind.time)||0;
      if (!(tBehind > tAhead) || tAhead <= 0) continue;

      const gapMs = tBehind - tAhead;
      const lapMsBehind = rowLapMs(behind) || 9500;

      // Umbral de cercania: ~0.08 lap, clamp 0.4-1.1s
      const closeMs = clamp(400, 1100, 0.08 * lapMsBehind);
      if (gapMs > closeMs) continue;

      // Debe venir mas rapido (mean) con margen
      const meanAhead = Number(ahead.mean)||0;
      const meanBehind = Number(behind.mean)||0;
      if (!(meanAhead > 0 && meanBehind > 0)) continue;
      if ((meanAhead - meanBehind) < 90) continue; // minimo 0.09s mas rapido

      // Anti-spam: requiere 2 vueltas consecutivas dentro del rango
      const stKey = keyAhead + '::' + keyBehind;
      const st = state[stKey] || (state[stKey] = { lastLap: 0, streak: 0 });
      if (lapBehind === st.lastLap) continue;
      st.lastLap = lapBehind;

      st.streak = (st.streak || 0) + 1;
      if (st.streak < 2) continue;
      st.streak = 0;

      const nameAhead = safeRacerName(ahead.racerName) || 'Piloto';
      const nameBehind = safeRacerName(behind.racerName) || 'Piloto';

      const gapSec = gapMs / 1000;
      let phrase = '';
      if (gapSec < 1.0) {
        const d = toDecimasRange(gapSec);
        const variants = [
          `viene a menos de ${d} decimas`,
          `lo traes a menos de ${d} decimas`,
          `menos de ${d} decimas`
        ];
        phrase = variants[Math.floor(Math.random()*variants.length)];
      } else {
        // redondea a 0.5s y usa menos de / mas de
        const half = Math.round(gapSec * 2) / 2;
        const eps = 0.12;
        let label = `${half}`.replace('.5',' y medio').replace('.0','');
        if (Math.abs(gapSec - half) <= eps) phrase = `a ${label} segundos`;
        else if (gapSec < half) phrase = `a menos de ${label} segundos`;
        else phrase = `a mas de ${label} segundos`;
      }

      // Estilo AUTO: TV mas neutro, seleccionado mas agresivo
      const aggressive = (!pair.tv) || (gapSec < 0.35 && Math.random() < 0.6) || (Math.random() < 0.2);
      const msg = aggressive
        ? `Cortesia para ${nameAhead}. ${nameBehind} ya viene mas rapido, ${phrase}.`
        : `Cortesia para ${nameAhead}. ${nameBehind} ${phrase}.`;

      enqueueSpeech(msg, { prio: pair.tv ? 45 : 55, key: 'courtesy_' + stKey + '_' + lapBehind, dedupe: true });
    }
  } catch(e) {
    // silencio
  }
}


function updateLapHistoryAll() {
      try {
        if (!raceData || !Array.isArray(raceData.classification)) return;

        for (const p of raceData.classification) {
          const key = getPilotKey(p);
          if (!key) continue;

          const lapsNow = Number(p.lapcount) || 0;

          // Tiempo total del piloto (string "02:01.964" o ms/seg)
          const totalNowMs = parseTimeToMs(
            (typeof p.time !== 'undefined' ? p.time :
             (typeof p.totalTime !== 'undefined' ? p.totalTime :
              (typeof p.totalMs !== 'undefined' ? p.totalMs :
               (typeof p.totalTimeMs !== 'undefined' ? p.totalTimeMs :
                (typeof p.estTime !== 'undefined' ? p.estTime : 0)))))
          );

          let hist = lapHistory.get(key);
          if (!hist) hist = { lastLapcount: 0, lastTotalLapMs: 0, times: [], marks: [], bestMs: 0 };

          let didChange = false;

          // Reset por re-arranque / cambio de heat sin cambiar raceName (o data rara)
          if (lapsNow < (hist.lastLapcount || 0)) {
            hist.lastLapcount = lapsNow;
            hist.lastTotalLapMs = (totalNowMs && isFinite(totalNowMs) && totalNowMs > 0) ? totalNowMs : 0;
            hist.times = [];
            hist.marks = [];
            hist.bestMs = 0;
            hist._computed = null;
            hist._computedLen = 0;
            hist._computedLapcount = lapsNow;
            didChange = true;
            lapHistory.set(key, hist);
            continue;
          }

          // Nueva(s) vuelta(s)
          if (lapsNow > (hist.lastLapcount || 0)) {
            const diffLaps = lapsNow - (hist.lastLapcount || 0);

            const lastTimeMs = normalizeLapMs(parseTimeToMs(
              (typeof p.lastTime !== 'undefined' ? p.lastTime :
               (typeof p.lastLap !== 'undefined' ? p.lastLap :
                (typeof p.lastLapMs !== 'undefined' ? p.lastLapMs : 0)))
            ));

            const pushLap = (ms) => {
              if (!ms) return;
              hist.times.push(ms);
              if (!hist.marks) hist.marks = [];
              hist.marks.push(null);
              while (hist.times.length > 180) hist.times.shift();
              while (hist.marks.length > 180) hist.marks.shift();
              if (!hist.bestMs || ms < hist.bestMs) hist.bestMs = ms;
            };

            let didPush = false;

            // 1) Prioridad: lastTime del feed (mejor para Lap Chart y marcas)
            if (lastTimeMs && isFinite(lastTimeMs) && lastTimeMs > 0) {
              const pushN = Math.min(Math.max(1, diffLaps), 6);
              for (let i = 0; i < pushN; i++) pushLap(lastTimeMs);
              didPush = true;
            }

            // 2) Fallback: delta de tiempo total distribuido (si el feed brinc√≥ y no trae lastTime confiable)
            if (!didPush && hist.lastTotalLapMs && totalNowMs && isFinite(totalNowMs) && totalNowMs > hist.lastTotalLapMs) {
              const deltaMs = totalNowMs - hist.lastTotalLapMs;
              const nLaps = Math.max(1, diffLaps);
              const avgLapMs = normalizeLapMs(Math.round(deltaMs / nLaps));
              if (avgLapMs) {
                const pushN = Math.min(nLaps, 6);
                for (let i = 0; i < pushN; i++) pushLap(avgLapMs);
              }
            }

            hist.lastLapcount = lapsNow;
            didChange = true;
            // invalidar cache de m√©tricas para este piloto
            hist._computed = null;
            hist._computedLen = (hist.times && hist.times.length) ? hist.times.length : 0;
            hist._computedLapcount = lapsNow;
          }
          // Recalcular m√©tricas SOLO si cambi√≥ algo (BLOQUE 2.1)
          if (didChange || !hist._computed) {
            try { ensureHistComputed(hist); } catch(e) {}
          }


          // Siempre actualiza el total para el siguiente delta (aunque no haya nueva vuelta)
          if (typeof totalNowMs === 'number' && isFinite(totalNowMs) && totalNowMs > 0) {
            hist.lastTotalLapMs = totalNowMs;
          }

          lapHistory.set(key, hist);
        }
      } catch (e) {
        console.error('updateLapHistoryAll', e);
      }
    }

    // =========================
    // LOCUTOR AUTO (cuando NO hay piloto seleccionado)
    // Objetivo:
    // - Decidir QUE vale la pena decir (scoring)
    // - Decirlo con variedad (frases)
    // - No saturar (rate limit + dedupe)
    // =========================

        const commentatorAutoCfg = {
      // Anti metralleta: m√°s aire entre mensajes, menos repetici√≥n (pero sin quedarse mudo)
      minIntervalMs: 11500,
      windowMs: 30000,
      maxMsgsInWindow: 2,
      sigDefaultCooldownMs: 24000,
      top3CooldownMs: 65000,
      allowUrgentOverLimitScore: 10.0,
      baseThresholdScore: 4.0,

      // Story mode (narrativo): m√°s consistente, con updates √∫tiles
      focusHoldMs: 32000,
      focusMaxGapSec: 0.80,
      focusMinDeltaSpeakSec: 0.10,
      focusMinSpeakMs: 13000,
      focusCrossLevels: [0.50, 0.32, 0.25, 0.18],
      top3ChapterCooldownMs: 52000
    };

    // Ajuste din√°mico por estilo (m√°s control en narrativo/engineer)
    function autoDynCfgForStyle(style){
      try{
        const s = String(style || 'pro');
        const base = { ...commentatorAutoCfg };
        // no contaminar el spread con __dyn
        if ('__dyn' in base) delete base.__dyn;

                if (s === 'narrativo'){
          // TV (legacy): consistente, con ritmo, sin metralleta
          base.minIntervalMs = 9200;
          base.windowMs = 60000;
          base.maxMsgsInWindow = 5;
          base.sigDefaultCooldownMs = 17500;
          base.baseThresholdScore = 2.95;
          base.top3CooldownMs = 46000;
          base.top3ChapterCooldownMs = 52000;
          base.focusMinSpeakMs = 11500;
          base.focusMinDeltaSpeakSec = 0.080;

        } else if (s === 'tv'){
          // TV MID (default): m√°s conversaci√≥n, sin metralleta
          // - MANGA: un poco m√°s activo (tabla viva)
          // - FINAL: activo, pero cuidando jitter
          const stype = (typeof currentSessionInfo !== 'undefined' && currentSessionInfo && currentSessionInfo.type) ? String(currentSessionInfo.type) : '';
          if (stype === 'MANGA') {
            base.minIntervalMs = 11000;
            base.windowMs = 30000;
            base.maxMsgsInWindow = 2;
          } else if (stype === 'FINAL') {
            base.minIntervalMs = 12000;
            base.windowMs = 32000;
            base.maxMsgsInWindow = 2;
          } else {
            base.minIntervalMs = 13000;
            base.windowMs = 36000;
            base.maxMsgsInWindow = 2;
          }
          base.sigDefaultCooldownMs = 18000;
          base.top3CooldownMs = 28000;
          base.top3ChapterCooldownMs = 32000;
          base.allowUrgentOverLimitScore = 9.1;
          base.baseThresholdScore = 2.8;
          base.focusMinSpeakMs = 12000;
          base.focusHoldMs = 26000;
} else if (s === 'engineer'){
          base.minIntervalMs = 9000;
          base.windowMs = 30000;
          base.maxMsgsInWindow = 2;
          base.sigDefaultCooldownMs = 24000;
          base.baseThresholdScore = 4.0;
        } else if (s === 'picante'){
          base.minIntervalMs = 8500;
        }
        return base;
      } catch(e){
        return commentatorAutoCfg;
      }
    }


    let commentatorAutoState = {
      lastSpeakMs: 0,
      window: [],
      recentSig: new Map(),
      recentTexts: [],
      prevPosByKey: new Map(),
      prevKeyByPos: [],
      lastLeaderKey: '',
      lastLeaderLap: 0,
      lastQuietMs: 0,
      lastTop3Ms: 0,
      lastTop3Sig: '',
      lastTop3Chapter: -1,
      lastMilestone: 0
    };

    function autoGapTextFromLapDiff(lapDiff) {
      if (!lapDiff || lapDiff <= 0) return '';
      if (lapDiff === 1) return 'a m√°s una vuelta';
      return 'a m√°s ' + lapDiff + ' vueltas';
    }

    function autoPairKey(aKey, bKey) {
      return String(aKey || '') + '::' + String(bKey || '');
    }

    function clamp01(x) {
      if (!isFinite(x)) return 0;
      if (x < 0) return 0;
      if (x > 1) return 1;
      return x;
    }

    
// Auto Locutor: shuffle bag anti repetici√≥n (evita "me dijo eso hace 2 segundos")
const autoPhraseBag = new Map();

function autoShuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
  }
  return arr;
}

function autoRandPick(list, key) {
  try {
    if (!Array.isArray(list) || !list.length) return null;
    const k = String(key || 'auto');
    let st = autoPhraseBag.get(k);
    if (!st || !Array.isArray(st.bag) || st.srcLen !== list.length) {
      st = { bag: [], recent: [], srcLen: list.length };
    }

    const RECENT_N = Math.min(5, Math.max(2, Math.floor(list.length / 4)));

    if (!st.bag.length) {
      const idxs = [];
      for (let i = 0; i < list.length; i++) idxs.push(i);
      autoShuffleInPlace(idxs);

      if (st.recent && st.recent.length && list.length > (st.recent.length + 2)) {
        const rec = new Set(st.recent);
        const a = idxs.filter(i => !rec.has(i));
        const b = idxs.filter(i =>  rec.has(i));
        st.bag = a.concat(b);
      } else {
        st.bag = idxs;
      }
    }

    const pickIdx = st.bag.shift();
    st.recent = st.recent || [];
    st.recent.push(pickIdx);
    while (st.recent.length > RECENT_N) st.recent.shift();
    autoPhraseBag.set(k, st);

    return list[pickIdx % list.length];
  } catch(e) { return null; }
}


    function autoFmtSec(sec) {
      const s = Number(sec);
      if (!isFinite(s) || s <= 0) return '';
      return String(toFixedFloor(s, decimalPrecision));
    }

// =========================
// GAP a voz - frases condicionales (anti "0.478")
// Reglas:
// - < 1s: rangos por d√©cimas ("menos de 3 d√©cimas")
// - >= 1s: escalones de 0.5s con comparadores ("menos de / a / m√°s de un segundo y medio")
// =========================
function _numWord(n){
  const k = Math.floor(Number(n)||0);
  if (k === 1) return 'un';
  if (k === 2) return 'dos';
  if (k === 3) return 'tres';
  if (k === 4) return 'cuatro';
  if (k === 5) return 'cinco';
  if (k === 6) return 'seis';
  if (k === 7) return 'siete';
  if (k === 8) return 'ocho';
  if (k === 9) return 'nueve';
  if (k === 10) return 'diez';
  return String(k);
}

function _secToHumanHalf(step){
  const v = Math.max(0, Number(step)||0);
  const base = Math.floor(v);
  const half = Math.abs(v - base - 0.5) < 0.01;
  if (base <= 0 && half) return 'medio segundo';
  if (base <= 0) return 'un segundo'; // fallback
  const w = _numWord(base);
  const unit = (base === 1) ? 'segundo' : 'segundos';
  return half ? (w + ' ' + unit + ' y medio') : (w + ' ' + unit);
}

function gapPhraseFromSec(sec){
  const s = Math.max(0, Number(sec)||0);
  if (!isFinite(s)) return 'nada';

  // Muy pegados
  if (s < 0.06) return 'nada';
  if (s < 0.12) return 'menos de una d√©cima';

  // < 1s: rangos por d√©cimas
  if (s < 1.0) {
    if (s < 0.22) return 'menos de 2 d√©cimas';
    if (s < 0.32) return 'menos de 3 d√©cimas';
    if (s < 0.42) return 'menos de 4 d√©cimas';
    if (s < 0.52) return 'menos de 5 d√©cimas';
    if (s < 0.62) return 'menos de 6 d√©cimas';
    if (s < 0.72) return 'menos de 7 d√©cimas';
    if (s < 0.82) return 'menos de 8 d√©cimas';
    if (s < 0.92) return 'menos de 9 d√©cimas';
    return 'menos de un segundo';
  }

  // >= 1s: escalones 0.5s con comparadores
  const step = Math.round(s * 2) / 2;  // 0.5s
  const delta = s - step;
  let cmp = '';
  if (Math.abs(delta) <= 0.08) cmp = '';     // "a"
  else if (delta < 0) cmp = 'menos de ';
  else cmp = 'm√°s de ';

  return cmp + _secToHumanHalf(step);
}

    function autoRaceProgress(leaderLap) {
      const total = Number(raceData && raceData.lapCount);
      if (!isFinite(total) || total <= 0) return 0;
      const lap = Number(leaderLap) || 0;
      return clamp01(lap / total);
    }

    function autoPruneWindow(now) {
      const cfg = (commentatorAutoCfg && commentatorAutoCfg.__dyn) ? commentatorAutoCfg.__dyn : commentatorAutoCfg;
      const w = commentatorAutoState.window || [];
      const keep = [];
      for (const t of w) {
        if (now - t <= cfg.windowMs) keep.push(t);
      }
      commentatorAutoState.window = keep;
      return keep.length;
    }

    function autoSigOk(sig, cooldownMs, now) {
      try {
        const cfg = (commentatorAutoCfg && commentatorAutoCfg.__dyn) ? commentatorAutoCfg.__dyn : commentatorAutoCfg;
        if (!sig) return true;
        const cd = Number(cooldownMs || 0) || cfg.sigDefaultCooldownMs;
        const last = commentatorAutoState.recentSig.get(sig) || 0;
        return (now - last) >= cd;
      } catch(e) { return true; }
    }

    function autoMarkSig(sig, now) {
      try {
        if (!sig) return;
        commentatorAutoState.recentSig.set(sig, now);
      } catch(e) {}
    }

    // Dedupe de texto (adem√°s de la firma). Evita que el locutor repita la MISMA idea.
    function autoNormTextForDedupe(s) {
      try {
        return String(s || '')
          .toLowerCase()
          .replace(/\d+/g, '#')
          .replace(/[¬°\!¬ø\?\.,;:\(\)\[\]\{\}]/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      } catch(e) { return ''; }
    }

    function autoTextOk(text, now) {
      try {
        const t = autoNormTextForDedupe(text);
        if (!t) return false;
        const ring = Array.isArray(commentatorAutoState.recentTexts) ? commentatorAutoState.recentTexts : [];
        const keep = [];
        for (const it of ring) {
          if (!it || !it.t || !isFinite(it.at)) continue;
          if (now - it.at < 90000) keep.push(it);
        }
        for (const it of keep) {
          if (it.t === t) {
            commentatorAutoState.recentTexts = keep;
            return false;
          }
        }
        keep.push({ t, at: now });
        while (keep.length > 18) keep.shift();
        commentatorAutoState.recentTexts = keep;
        return true;
      } catch(e) { return true; }
    }

    function autoCanSpeak(score, sig, sigCooldownMs, now) {
      try {
        const cfg = (commentatorAutoCfg && commentatorAutoCfg.__dyn) ? commentatorAutoCfg.__dyn : commentatorAutoCfg;

        const winCount = autoPruneWindow(now);
        const since = now - (commentatorAutoState.lastSpeakMs || 0);

        // dedupe por firma
        if (!autoSigOk(sig, sigCooldownMs, now)) return false;

        // anti metralleta
        if (since < cfg.minIntervalMs && score < cfg.allowUrgentOverLimitScore) return false;

        // ventana
        if (winCount >= cfg.maxMsgsInWindow && score < cfg.allowUrgentOverLimitScore) return false;

        // umbral din√°mico (si ya hablaste mucho, sube la barra)
        let threshold = cfg.baseThresholdScore;
        threshold += Math.max(0, winCount - 1) * 0.8;
        if (since < (cfg.minIntervalMs + 1500)) threshold += 0.6;

        return score >= threshold;
      } catch(e) {
        return false;
      }
    }



// =========================
// Auto Locutor - Narraci√≥n con contexto (focus battle)
// =========================

function autoStageFromSec(sec) {
  const s = Number(sec);
  if (!isFinite(s) || s <= 0) return '';
  if (s <= 0.32) return 'strike';
  if (s <= 0.50) return 'attack';
  if (s <= 0.80) return 'pressure';
  if (s <= 1.25) return 'closing';
  return 'loose';
}


function autoCrossedLevels(prevSec, sec, levels){
  try{
    const p = Number(prevSec);
    const c = Number(sec);
    if (!isFinite(p) || !isFinite(c)) return false;
    const lv = Array.isArray(levels) ? levels : [];
    for (const L of lv){
      const l = Number(L);
      if (!isFinite(l) || l <= 0) continue;
      if ((p > l && c <= l) || (p <= l && c > l)) return true;
    }
    return false;
  } catch(e){
    return false;
  }
}
function autoRememberPair(pairKey, sec, leaderLap, now) {
  try {
    if (!pairKey) return { prevSec:null, deltaSec:0, rate:0, lastMentionMs:0 };
    const st = autoPairState.get(pairKey) || { lastSec:null, lastSec2:null, lastMs:0, lastLap:0, lastMentionMs:0 };
    const prev = (st.lastSec != null) ? Number(st.lastSec) : null;
    const prev2 = (st.lastSec2 != null) ? Number(st.lastSec2) : null;
    st.lastSec2 = prev;
    st.lastSec = Number(sec);
    st.lastMs = now;
    st.lastLap = Number(leaderLap) || st.lastLap || 0;

    const deltaSec = (prev != null && isFinite(prev)) ? (Number(sec) - prev) : 0;
    // rate aprox: cambio por tick (negativo = cerrando)
    const rate = (prev2 != null && isFinite(prev2)) ? (Number(sec) - prev2) : deltaSec;

    autoPairState.set(pairKey, st);
    return { prevSec: prev, deltaSec, rate, lastMentionMs: st.lastMentionMs || 0 };
  } catch(e) {
    return { prevSec:null, deltaSec:0, rate:0, lastMentionMs:0 };
  }
}

function autoMarkPairMention(pairKey, now) {
  try {
    if (!pairKey) return;
    const st = autoPairState.get(pairKey) || { lastSec:null, lastSec2:null, lastMs:0, lastLap:0, lastMentionMs:0 };
    st.lastMentionMs = now;
    autoPairState.set(pairKey, st);
  } catch(e) {}
}

function autoFocusMsg(stage, c, style) {
  const st = String(stage || '');
  const pos = c.pos;
  const a = c.attacker;
  const d = c.defender;
  const sec = c.sec;
  const delta = c.deltaStr || '';
  const fromSec = c.fromSec || '';
  const toSec = c.toSec || '';
  const ctx = { pos, attacker: a, defender: d, sec, delta, fromSec, toSec };

  // Conectores para hilar (menos robot, mas TV)
  const connectors = {
    pro: [
      'Ojo con esto.',
      'Atencion aqui.',
      'Se calienta la cosa.',
      'Dato clave.',
      'Esto se mueve.',
      'Importante.',
      'Tenemos tema.'
    ],
    picante: [
      'Se prendio.',
      'Uy.',
      'Ahi viene.',
      'Huele a pase.',
      'Ahora si.',
      'Aguas.',
      'Esto va a tronar.'
    ],
    engineer: [
      'Telemetria rapida.',
      'Lectura de ritmo.',
      'Numero mata chisme.',
      'Datos en corto.',
      'Aqui hay delta.',
      'Lo que importa.'
    ],
    narrativo: [
      'Seguimos con la historia.',
      'Mientras tanto...',
      'En el radar...',
      'Y ojo, porque...',
      'La pelea sigue viva.',
      'Sin soltar el volante...',
      'Atencion, que esto cambia.',
      'Del otro lado...'
    ]
  };

  const s = (style === 'picante' || style === 'engineer' || style === 'narrativo' || style === 'tv') ? (style === 'tv' ? 'narrativo' : style) : 'pro';
  const c0 = autoRandPick(connectors[s] || connectors.pro, 'auto:conn:' + s);

  const BANK = {
    keep: [
      (x) => `${c0} ${x.defender} aguanta en P${x.pos}. ${x.attacker} sigue pegado a ${x.sec}.`,
      (x) => `${c0} La pelea por P${x.pos} no se suelta: ${x.attacker} a ${x.sec} de ${x.defender}.`,
      (x) => `${c0} P${x.pos}: ${x.defender} adelante, ${x.attacker} atras. Gap ${x.sec}.`,
      (x) => `${c0} P${x.pos} esta en modo espejo: ${x.attacker} no lo suelta a ${x.defender}.`
    ],
    closing: [
      (x) => `${c0} Se esta cerrando P${x.pos}: ${x.attacker} recorta ${x.delta} y ya esta a ${x.toSec || x.sec} de ${x.defender}.`,
      (x) => `${c0} P${x.pos} se aprieta: de ${x.fromSec} baja a ${x.toSec}. ${x.attacker} viene encima.`,
      (x) => `${c0} P${x.pos}: ${x.attacker} acorta el gap. ${x.defender} ya lo trae en el espejo a ${x.toSec || x.sec}.`,
      (x) => `${c0} P${x.pos} se esta cocinando. ${x.attacker} viene recortando y ya esta a ${x.toSec || x.sec}.`
    ],
    opening: [
      (x) => `${c0} Se abre un poco la pelea en P${x.pos}. ${x.defender} estira a ${x.sec}.`,
      (x) => `${c0} Respiro para ${x.defender}: P${x.pos} se va a ${x.sec}.`,
      (x) => `${c0} P${x.pos} afloja tantito. ${x.attacker} pierde el contacto, gap ${x.sec}.`
    ],
    pass: [
      (x) => `${c0} Cambio de mando en P${x.pos}. ${x.attacker} le quita la posicion a ${x.defender}.`,
      (x) => `${c0} Pase hecho en P${x.pos}. ${x.attacker} se mete por delante de ${x.defender}.`,
      (x) => `${c0} P${x.pos} ya cambio. ${x.attacker} adelante, ${x.defender} a perseguir.`
    ]
  };

  const pool = BANK[st] || BANK.keep;
  return autoRandPick(pool, 'auto:focus:' + st + ':' + s)(ctx);
}

function autoBuildStoryCandidate(args) {
  try {
    const { battles, now, leaderLap, progress, isMangaSess } = args;
    const cfg = (commentatorAutoCfg && commentatorAutoCfg.__dyn) ? commentatorAutoCfg.__dyn : commentatorAutoCfg;
    if (!battles || !battles.length) return null;

    // 1) si hay foco vigente, intentamos seguirlo
    const stickyOk = (autoNarratorState.focusPairKey && now < (autoNarratorState.focusStickyUntilMs || 0));
    const focusPair = autoNarratorState.focusPairKey || '';
    let focus = null;

    if (focusPair) {
      focus = battles.find(b => b && b.pairKey === focusPair) || null;
      // si ya no existe o se abri√≥ demasiado, lo soltamos
      if (!focus || !isFinite(focus.secNum) || focus.secNum > 1.60) {
        autoNarratorState.focusPairKey = '';
        autoNarratorState.focusStage = '';
        focus = null;
      }
    }

    // 2) si no hay foco, elegimos uno (podio y cierres pesan m√°s)
    if (!focus) {
      let best = null;
      let bestScore = -1e9;
      for (const b of battles) {
        if (!b || !isFinite(b.score)) continue;
        const mentionedMs = (b.lastMentionMs || 0);
        const penalty = (now - mentionedMs < 14000) ? 1.2 : 0;
        const s = b.score - penalty;
        if (s > bestScore) { bestScore = s; best = b; }
      }
      if (!best) return null;

      autoNarratorState.focusPairKey = best.pairKey;
      autoNarratorState.focusPos = best.pos;
      autoNarratorState.focusDefender = best.defender;
      autoNarratorState.focusAttacker = best.attacker;
      autoNarratorState.focusSinceMs = now;
      autoNarratorState.focusLastSec = best.secNum;
      autoNarratorState.focusStage = 'intro';
      autoNarratorState.focusStickyUntilMs = now + (Number(cfg.focusHoldMs)||38000); // hilo antes de cambiar (si sigue viva)
      focus = best;
    }

    if (!focus) return null;

    // 3) construir update seg√∫n tendencia
    const sec = Number(focus.secNum);
    const prev = (autoNarratorState.focusLastSec != null) ? Number(autoNarratorState.focusLastSec) : null;
    const stageNow = autoStageFromSec(sec);
    const stagePrev = String(autoNarratorState.focusStage || '');

    const delta = (prev != null && isFinite(prev)) ? (sec - prev) : 0;
    const absDelta = Math.abs(delta);

    // decidir si hablar: cambio real o etapa nueva o pas√≥ mucho
    const sinceSpeak = now - (autoNarratorState.focusLastSpeakMs || 0);
    const stageChanged = (stageNow && stageNow !== stagePrev && stagePrev !== 'intro');

    const crossed = autoCrossedLevels(prev, sec, cfg.focusCrossLevels);
    const minStoryMs = ((autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo'))
      ? Math.max(Number(cfg.focusMinSpeakMs)||16000, Number(cfg.minIntervalMs)||12000)
      : Math.max(17000, Number(cfg.minIntervalMs)||9500);

    const deltaGate = ((autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo')) ? (Number(cfg.focusMinDeltaSpeakSec)||0.12) : 0.14;

    if (sinceSpeak < minStoryMs) return null;

    // Si ya se abri√≥ de m√°s, no insistimos (a menos que cambie de etapa o cruce niveles)
    const maxGap = Number(cfg.focusMaxGapSec)||0.80;
    if (sec > maxGap && !stageChanged && !crossed) return null;

    // Si no cambi√≥ etapa ni cruz√≥ niveles, pedimos cambio real para hablar
    if (!stageChanged && !crossed && absDelta < deltaGate && sec > 0.35) return null;


    let stage = stageNow || 'closing';
    if (stagePrev === 'intro') stage = 'closing';

    // si se abri√≥, usar "opening"
    if (prev != null && isFinite(prev) && delta > 0.09) stage = 'opening';

    const secStr = autoFmtSec(sec);
    const deltaStr = (prev != null && isFinite(prev)) ? autoFmtSec(Math.abs(delta)) : '';
    const style = (autoCommentatorMode === 'tv' || autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || (autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo')) ? autoCommentatorMode : 'pro';

    const fromSec = (prev != null && isFinite(prev)) ? autoFmtSec(prev) : '';
    const toSec = secStr;

    const text = autoFocusMsg((stagePrev === '' ? 'intro' : stage), {
      pos: focus.pos,
      attacker: focus.attacker,
      defender: focus.defender,
      sec: secStr,
      secNum: sec,
      deltaStr,
      fromSec,
      toSec
    }, style);

    // score: focus manda pero no todo el tiempo
    let score = 7.6;
    score += clamp01((1.20 - sec) / 1.20) * 2.2;
    if (focus.pos <= 3) score += 1.4;
    if (focus.pos === 1) score += 0.8;
    if (progress > 0.80 && focus.pos <= 5) score += 0.6;

    // manga: menos frecuencia
    if (isMangaSess) score -= 0.7;

    const sig = 'auto:story:' + focus.pairKey + ':' + stage;
    const key = 'auto_story_' + focus.pairKey;

    return {
      type: 'story',
      score,
      text,
      key,
      sig,
      sigCooldownMs: isMangaSess ? 22000 : 18000,
      priority: 8,
      onCommit: () => {
        autoNarratorState.focusLastSpeakMs = now;
        autoNarratorState.focusLastSec = sec;
        autoNarratorState.focusStage = stage;
        autoNarratorState.lastSpokenType = 'story';
        autoNarratorState.lastSpokenMs = now;
        autoMarkPairMention(focus.pairKey, now);
      }
    };
  } catch(e) {
    return null;
  }
}

    const AUTO_PHRASES_PRO = {
      leaderChange: [
        (c) => 'Cambio de l√≠der. ' + c.winner + ' toma P1, ' + c.loser + ' queda P2.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' al frente, ' + c.loser + ' ahora persigue.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' manda, ' + c.loser + ' queda segundo.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' lidera, ' + c.loser + ' se queda a la caza.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Cambio de l√≠der. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' se va adelante. ' + c.loser + ' a perseguir.',
        (c) => 'Nuevo l√≠der. ' + c.winner + ' toma P1, ' + c.loser + ' queda P2.',
        (c) => 'Nuevo l√≠der. ' + c.winner + ' al frente, ' + c.loser + ' ahora persigue.',
        (c) => 'Nuevo l√≠der. ' + c.winner + ' manda, ' + c.loser + ' queda segundo.',
        (c) => 'Nuevo l√≠der. ' + c.winner + ' lidera, ' + c.loser + ' se queda a la caza.',
        (c) => 'Nuevo l√≠der. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Nuevo l√≠der. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Nuevo l√≠der. ' + c.winner + ' se va adelante. ' + c.loser + ' a perseguir.',
        (c) => 'Se mueve la punta. ' + c.winner + ' toma P1, ' + c.loser + ' queda P2.',
        (c) => 'Se mueve la punta. ' + c.winner + ' al frente, ' + c.loser + ' ahora persigue.',
        (c) => 'Se mueve la punta. ' + c.winner + ' manda, ' + c.loser + ' queda segundo.',
        (c) => 'Se mueve la punta. ' + c.winner + ' lidera, ' + c.loser + ' se queda a la caza.',
        (c) => 'Se mueve la punta. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Se mueve la punta. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Se mueve la punta. ' + c.winner + ' se va adelante. ' + c.loser + ' a perseguir.',
        (c) => 'Intercambio en la cima. ' + c.winner + ' toma P1, ' + c.loser + ' queda P2.',
        (c) => 'Intercambio en la cima. ' + c.winner + ' al frente, ' + c.loser + ' ahora persigue.',
        (c) => 'Intercambio en la cima. ' + c.winner + ' manda, ' + c.loser + ' queda segundo.',
        (c) => 'Intercambio en la cima. ' + c.winner + ' lidera, ' + c.loser + ' se queda a la caza.'
      ],
      pass: [
        (c) => 'Adelantamiento. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' baja a P' + c.oldPos + '.',
        (c) => 'Adelantamiento. ' + c.winner + ' gana P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Adelantamiento. ' + c.winner + ' se queda con P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Adelantamiento. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' se acomoda en P' + c.oldPos + '.',
        (c) => 'Adelantamiento. ' + c.winner + ' pasa y asegura P' + c.newPos + '.',
        (c) => 'Adelantamiento. ' + c.winner + ' ejecuta el pase. P' + c.newPos + '.',
        (c) => 'Adelantamiento. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Rebase. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' baja a P' + c.oldPos + '.',
        (c) => 'Rebase. ' + c.winner + ' gana P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Rebase. ' + c.winner + ' se queda con P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Rebase. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' se acomoda en P' + c.oldPos + '.',
        (c) => 'Rebase. ' + c.winner + ' pasa y asegura P' + c.newPos + '.',
        (c) => 'Rebase. ' + c.winner + ' ejecuta el pase. P' + c.newPos + '.',
        (c) => 'Rebase. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Cambio de posici√≥n. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' baja a P' + c.oldPos + '.',
        (c) => 'Cambio de posici√≥n. ' + c.winner + ' gana P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Cambio de posici√≥n. ' + c.winner + ' se queda con P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de posici√≥n. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' se acomoda en P' + c.oldPos + '.',
        (c) => 'Cambio de posici√≥n. ' + c.winner + ' pasa y asegura P' + c.newPos + '.',
        (c) => 'Cambio de posici√≥n. ' + c.winner + ' ejecuta el pase. P' + c.newPos + '.',
        (c) => 'Cambio de posici√≥n. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Posici√≥n ganada. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' baja a P' + c.oldPos + '.',
        (c) => 'Posici√≥n ganada. ' + c.winner + ' gana P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Posici√≥n ganada. ' + c.winner + ' se queda con P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Posici√≥n ganada. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' se acomoda en P' + c.oldPos + '.'
      ],
      battle: [
        (c) => 'Duelo en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Duelo en P' + c.pos + '. ' + c.attacker + ' presiona a ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Duelo en P' + c.pos + '. ' + c.attacker + ' ya est√° encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Duelo en P' + c.pos + '. ' + c.attacker + ' buscando el hueco con ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Duelo en P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Duelo en P' + c.pos + '. ' + c.attacker + ' no se despega. ' + c.sec + '.',
        (c) => 'Batalla en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Batalla en P' + c.pos + '. ' + c.attacker + ' presiona a ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Batalla en P' + c.pos + '. ' + c.attacker + ' ya est√° encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Batalla en P' + c.pos + '. ' + c.attacker + ' buscando el hueco con ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Batalla en P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Batalla en P' + c.pos + '. ' + c.attacker + ' no se despega. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° apretado. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° apretado. ' + c.attacker + ' presiona a ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° apretado. ' + c.attacker + ' ya est√° encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° apretado. ' + c.attacker + ' buscando el hueco con ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° apretado. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° apretado. ' + c.attacker + ' no se despega. ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.attacker + ' presiona a ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.attacker + ' ya est√° encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.attacker + ' buscando el hueco con ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.attacker + ' no se despega. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en pelea directa. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.'
      ],
      battlePodium: [
        (c) => 'P' + c.pos + ' por podio. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por podio. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por podio. Gap ' + c.sec + '. ' + c.defender + ' defendiendo de ' + c.attacker + '.',
        (c) => 'P' + c.pos + ' por podio. ' + c.attacker + ' buscando pase sobre ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' por podio. ' + c.defender + ' resiste, ' + c.attacker + ' insiste. ' + c.sec + '.',
        (c) => 'Esto es podio en P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Esto es podio en P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Esto es podio en P' + c.pos + '. Gap ' + c.sec + '. ' + c.defender + ' defendiendo de ' + c.attacker + '.',
        (c) => 'Esto es podio en P' + c.pos + '. ' + c.attacker + ' buscando pase sobre ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Esto es podio en P' + c.pos + '. ' + c.defender + ' resiste, ' + c.attacker + ' insiste. ' + c.sec + '.',
        (c) => 'Pelea de trofeo en P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Pelea de trofeo en P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Pelea de trofeo en P' + c.pos + '. Gap ' + c.sec + '. ' + c.defender + ' defendiendo de ' + c.attacker + '.',
        (c) => 'Pelea de trofeo en P' + c.pos + '. ' + c.attacker + ' buscando pase sobre ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Pelea de trofeo en P' + c.pos + '. ' + c.defender + ' resiste, ' + c.attacker + ' insiste. ' + c.sec + '.',
        (c) => 'Zona de podio, P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Zona de podio, P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Zona de podio, P' + c.pos + '. Gap ' + c.sec + '. ' + c.defender + ' defendiendo de ' + c.attacker + '.',
        (c) => 'Zona de podio, P' + c.pos + '. ' + c.attacker + ' buscando pase sobre ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Zona de podio, P' + c.pos + '. ' + c.defender + ' resiste, ' + c.attacker + ' insiste. ' + c.sec + '.',
        (c) => 'Podio caliente, P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Podio caliente, P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Podio caliente, P' + c.pos + '. Gap ' + c.sec + '. ' + c.defender + ' defendiendo de ' + c.attacker + '.',
        (c) => 'Podio caliente, P' + c.pos + '. ' + c.attacker + ' buscando pase sobre ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Podio caliente, P' + c.pos + '. ' + c.defender + ' resiste, ' + c.attacker + ' insiste. ' + c.sec + '.'
      ],
      closing: [
        (c) => 'Se cierra P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Se cierra P' + c.pos + '. ' + c.attacker + ' reduce de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se cierra P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. ' + c.attacker + ' viene recortando.',
        (c) => 'Se cierra P' + c.pos + '. ' + c.attacker + ' ya est√° en ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Se cierra P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se cierra P' + c.pos + '. ' + c.attacker + ' recorta y se pone a ' + c.toSec + '.',
        (c) => 'Atenci√≥n P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Atenci√≥n P' + c.pos + '. ' + c.attacker + ' reduce de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Atenci√≥n P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. ' + c.attacker + ' viene recortando.',
        (c) => 'Atenci√≥n P' + c.pos + '. ' + c.attacker + ' ya est√° en ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Atenci√≥n P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Atenci√≥n P' + c.pos + '. ' + c.attacker + ' recorta y se pone a ' + c.toSec + '.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' reduce de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre en P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. ' + c.attacker + ' viene recortando.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' ya est√° en ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Cierre en P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' recorta y se pone a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se est√° cerrando. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' se est√° cerrando. ' + c.attacker + ' reduce de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se est√° cerrando. De ' + c.fromSec + ' a ' + c.toSec + '. ' + c.attacker + ' viene recortando.',
        (c) => 'P' + c.pos + ' se est√° cerrando. ' + c.attacker + ' ya est√° en ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' se est√° cerrando. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se est√° cerrando. ' + c.attacker + ' recorta y se pone a ' + c.toSec + '.',
        (c) => 'Tendencia clara en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + ' sobre ' + c.defender + '.'
      ],
      
      gap: [
        (c) => 'Gap P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Gap P' + c.pos + '. ' + c.defender + ' adelante, ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' gap ' + c.sec + 's. ' + c.attacker + ' viene detr√°s.',
        (c) => 'P' + c.pos + '. Separaci√≥n ' + c.sec + 's entre ' + c.defender + ' y ' + c.attacker + '.',
        (c) => 'P' + c.pos + '. ' + c.attacker + ' marca ' + c.sec + 's al de adelante.'
      ],
      pressure: [
        (c) => 'Presi√≥n en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' bajo presi√≥n. ' + c.attacker + ' a ' + c.sec + 's. Ojo defensa.',
        (c) => 'Defensa en P' + c.pos + '. ' + c.defender + ' se sostiene con ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en modo defensa. ' + c.attacker + ' est√° encima, ' + c.sec + 's.'
      ],
      top3: [
        (c) => 'Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Top 3: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Top 3: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.',
        (c) => 'Estado del podio: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Estado del podio: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Estado del podio: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Estado del podio: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.',
        (c) => 'Arriba van: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Arriba van: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Arriba van: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Arriba van: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Arriba van: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.',
        (c) => 'En la punta: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'En la punta: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'En la punta: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'En la punta: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'En la punta: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.',
        (c) => 'As√≠ va el frente: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'As√≠ va el frente: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'As√≠ va el frente: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'As√≠ va el frente: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'As√≠ va el frente: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.'
      ],
      train: [
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Nadie parpadee.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Cualquier error cambia todo.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Aqu√≠ se gana con precisi√≥n.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'No hay espacio para fallar.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Se viene el swap en cualquier curva.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto por P2 a P4. ') + 'Nadie parpadee.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto por P2 a P4. ') + 'Cualquier error cambia todo.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto por P2 a P4. ') + 'Aqu√≠ se gana con precisi√≥n.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto por P2 a P4. ') + 'No hay espacio para fallar.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto por P2 a P4. ') + 'Se viene el swap en cualquier curva.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4. ') + 'Nadie parpadee.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4. ') + 'Cualquier error cambia todo.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4. ') + 'Aqu√≠ se gana con precisi√≥n.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4. ') + 'No hay espacio para fallar.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4. ') + 'Se viene el swap en cualquier curva.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo compacto P2 a P4. ') + 'Nadie parpadee.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo compacto P2 a P4. ') + 'Cualquier error cambia todo.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo compacto P2 a P4. ') + 'Aqu√≠ se gana con precisi√≥n.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo compacto P2 a P4. ') + 'No hay espacio para fallar.',
        (c) => 'Trenecito por el podio. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo compacto P2 a P4. ') + 'Se viene el swap en cualquier curva.',
        (c) => 'Paquete compacto. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Nadie parpadee.',
        (c) => 'Paquete compacto. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Cualquier error cambia todo.',
        (c) => 'Paquete compacto. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Aqu√≠ se gana con precisi√≥n.',
        (c) => 'Paquete compacto. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'No hay espacio para fallar.',
        (c) => 'Paquete compacto. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Se viene el swap en cualquier curva.'
      ]
    };


    const AUTO_PHRASES_PICANTE = {
      leaderChange: [
        (c) => 'Cambio de l√≠der. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Cambio de l√≠der. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Cambio de l√≠der. ' + c.winner + ' al frente. ' + c.loser + ' con presi√≥n encima.',
        (c) => 'Cambio de l√≠der. ' + c.loser + ' pierde la punta. ' + c.winner + ' l√≠der.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Nuevo jefe en pista. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Nuevo jefe en pista. ' + c.winner + ' al frente. ' + c.loser + ' con presi√≥n encima.',
        (c) => 'Nuevo jefe en pista. ' + c.loser + ' pierde la punta. ' + c.winner + ' l√≠der.',
        (c) => 'Se volte√≥ la tortilla. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Se volte√≥ la tortilla. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Se volte√≥ la tortilla. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Se volte√≥ la tortilla. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Se volte√≥ la tortilla. ' + c.winner + ' se pone primero, ' + c.loser + ' baja a segundo.',
        (c) => 'Se volte√≥ la tortilla. ' + c.winner + ' al frente. ' + c.loser + ' con presi√≥n encima.',
        (c) => 'Se volte√≥ la tortilla. ' + c.loser + ' pierde la punta. ' + c.winner + ' l√≠der.',
        (c) => 'Golpe en la punta. ' + c.winner + ' se roba P1. ' + c.loser + ' a perseguir.',
        (c) => 'Golpe en la punta. ' + c.winner + ' toma la punta. ' + c.loser + ' no lo suelta.',
        (c) => 'Golpe en la punta. ' + c.winner + ' manda. ' + c.loser + ' queda segundo.',
        (c) => 'Golpe en la punta. P1 ' + c.winner + '. P2 ' + c.loser + '.'
      ],
      pass: [
        (c) => 'Rebase con colmillo. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Rebase con colmillo. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Rebase con colmillo. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Se la cobra. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Se la cobra. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.loser + ' pierde el lugar. ' + c.winner + ' se queda P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Cambio de puesto. ' + c.winner + ' se queda con el puesto. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' sube a P' + c.newPos + '. ' + c.loser + ' cae a P' + c.oldPos + '.',
        (c) => 'Puesto robado. P' + c.newPos + ' para ' + c.winner + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' le mete el coche y gana P' + c.newPos + '.',
        (c) => 'Puesto robado. ' + c.winner + ' dice con permiso y toma P' + c.newPos + '.'
      ],
      battle: [
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' en modo cuchillo. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'Duelazo en P' + c.pos + '. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° que arde. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° que arde. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° que arde. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° que arde. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° que arde. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' est√° que arde. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presi√≥n brava. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presi√≥n brava. ' + c.attacker + ' pegado a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presi√≥n brava. ' + c.defender + ' defendiendo, ' + c.attacker + ' insistiendo. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presi√≥n brava. ' + c.attacker + ' ya trae el pase en la mira. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presi√≥n brava. ' + c.attacker + ' presiona fuerte. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con presi√≥n brava. ' + c.defender + ' no se puede equivocar. ' + c.sec + '.',
        (c) => 'Ojo con P' + c.pos + '. ' + c.attacker + ' respirando en la nuca de ' + c.defender + '. ' + c.sec + '.'
      ],
      battlePodium: [
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. Gap ' + c.sec + '. Aqu√≠ se gana con cabeza fr√≠a.',
        (c) => 'Podio al rojo vivo, P' + c.pos + '. ' + c.attacker + ' ya se asom√≥. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' vale trofeo. Gap ' + c.sec + '. Aqu√≠ se gana con cabeza fr√≠a.',
        (c) => 'P' + c.pos + ' vale trofeo. ' + c.attacker + ' ya se asom√≥. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' de podio. Gap ' + c.sec + '. Aqu√≠ se gana con cabeza fr√≠a.',
        (c) => 'P' + c.pos + ' de podio. ' + c.attacker + ' ya se asom√≥. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'Pelea de podio en P' + c.pos + '. Gap ' + c.sec + '. Aqu√≠ se gana con cabeza fr√≠a.',
        (c) => 'Pelea de podio en P' + c.pos + '. ' + c.attacker + ' ya se asom√≥. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' encima de ' + c.defender + '. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' presionando a ' + c.defender + '. Gap ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.defender + ' aguanta, ' + c.attacker + ' empuja. ' + c.sec + '.',
        (c) => 'P' + c.pos + ' con olor a podio. Gap ' + c.sec + '. Aqu√≠ se gana con cabeza fr√≠a.',
        (c) => 'P' + c.pos + ' con olor a podio. ' + c.attacker + ' ya se asom√≥. ' + c.sec + '.'
      ],
      closing: [
        (c) => 'Se est√° cerrando P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se est√° cerrando P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est√° encima.',
        (c) => 'Se est√° cerrando P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Se est√° cerrando P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Se est√° cerrando P' + c.pos + '. ' + c.attacker + ' ya est√° a ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Se est√° cerrando P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est√° encima.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' se cocina. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.attacker + ' ya est√° a ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' se cocina. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'Atenci√≥n en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Atenci√≥n en P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est√° encima.',
        (c) => 'Atenci√≥n en P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Atenci√≥n en P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Atenci√≥n en P' + c.pos + '. ' + c.attacker + ' ya est√° a ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Atenci√≥n en P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. De ' + c.fromSec + ' a ' + c.toSec + '. Ya est√° encima.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' recorta a ' + c.toSec + ' sobre ' + c.defender + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. Gap cae de ' + c.fromSec + ' a ' + c.toSec + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.attacker + ' ya est√° a ' + c.toSec + ' de ' + c.defender + '.',
        (c) => 'Cierre fuerte en P' + c.pos + '. ' + c.defender + ' ya lo trae en el espejo. ' + c.toSec + '.',
        (c) => 'P' + c.pos + ' en recorte serio. ' + c.attacker + ' baja de ' + c.fromSec + ' a ' + c.toSec + '.'
      ],
      top3: [
        (c) => 'Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Top 3: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Top 3: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Arriba va as√≠: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Arriba va as√≠: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Arriba va as√≠: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Arriba va as√≠: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Arriba va as√≠: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Los de la punta: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Los de la punta: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Los de la punta: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Los de la punta: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Los de la punta: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'Podio provisional: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Podio provisional: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Podio provisional: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Podio provisional: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'Podio provisional: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.',
        (c) => 'As√≠ est√° el frente: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'As√≠ est√° el frente: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'As√≠ est√° el frente: ' + c.p1 + ' manda. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'As√≠ est√° el frente: ' + c.p1 + ' primero, ' + c.p2 + ' segundo, ' + c.p3 + ' tercero.',
        (c) => 'As√≠ est√° el frente: ' + c.p1 + ' al frente con ' + c.p2 + ' y ' + c.p3 + ' pegados.'
      ],
      train: [
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Aqu√≠ nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Aqu√≠ nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Paquete: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete cerrado por podio. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Aqu√≠ nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Tren: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Tren de P2 a P4, pegados. ') + 'Pista chica, orgullo grande.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Aqu√≠ nadie respira.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Esto se decide en una curva.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Tren de trofeo. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos juntos por el trofeo. ') + 'Pista chica, orgullo grande.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Aqu√≠ nadie respira.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Si uno falla, se invierte todo.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Esto se decide en una curva.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Huele a rebase en cualquier momento.',
        (c) => 'Paquete al rojo vivo. ' + (c.p2 ? ('P2 a P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'P2 a P4 en paquete. ') + 'Pista chica, orgullo grande.'
      ]
    };


    const AUTO_PHRASES_ENGINEER = {
      leaderChange: [
        (c) => 'Update punta. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Update punta. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Update punta. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Update punta. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecuci√≥n.',
        (c) => 'Update punta. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Update punta. P1 para ' + c.winner + '. ' + c.loser + ' queda detr√°s.',
        (c) => 'Update punta. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Cambio en P1. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Cambio en P1. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Cambio en P1. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Cambio en P1. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecuci√≥n.',
        (c) => 'Cambio en P1. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Cambio en P1. P1 para ' + c.winner + '. ' + c.loser + ' queda detr√°s.',
        (c) => 'Cambio en P1. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Telemetr√≠a: nuevo l√≠der. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Telemetr√≠a: nuevo l√≠der. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Telemetr√≠a: nuevo l√≠der. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Telemetr√≠a: nuevo l√≠der. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecuci√≥n.',
        (c) => 'Telemetr√≠a: nuevo l√≠der. Swap de liderato: ' + c.winner + ' adelante.',
        (c) => 'Telemetr√≠a: nuevo l√≠der. P1 para ' + c.winner + '. ' + c.loser + ' queda detr√°s.',
        (c) => 'Telemetr√≠a: nuevo l√≠der. ' + c.winner + ' al frente, ' + c.loser + ' a cazar.',
        (c) => 'Estado de carrera. P1 ' + c.winner + '. P2 ' + c.loser + '.',
        (c) => 'Estado de carrera. ' + c.winner + ' pasa a P1, ' + c.loser + ' cae a P2.',
        (c) => 'Estado de carrera. ' + c.winner + ' lidera, ' + c.loser + ' queda segundo.',
        (c) => 'Estado de carrera. ' + c.winner + ' toma el mando. ' + c.loser + ' en persecuci√≥n.'
      ],
      pass: [
        (c) => 'Overtake confirmado. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Overtake confirmado. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Overtake confirmado. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Overtake confirmado. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Overtake confirmado. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Overtake confirmado. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Overtake confirmado. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Cambio de posici√≥n. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Cambio de posici√≥n. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Cambio de posici√≥n. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Cambio de posici√≥n. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Cambio de posici√≥n. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Cambio de posici√≥n. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Cambio de posici√≥n. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Swap de posici√≥n. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Swap de posici√≥n. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Swap de posici√≥n. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Swap de posici√≥n. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.',
        (c) => 'Swap de posici√≥n. ' + c.loser + ' pierde el lugar. ' + c.winner + ' toma P' + c.newPos + '.',
        (c) => 'Swap de posici√≥n. Swap completado: ' + c.winner + ' por delante.',
        (c) => 'Swap de posici√≥n. ' + c.winner + ' completa el pase. P' + c.newPos + '.',
        (c) => 'Movimiento de ranking. ' + c.winner + ' a P' + c.newPos + '. ' + c.loser + ' a P' + c.oldPos + '.',
        (c) => 'Movimiento de ranking. P' + c.newPos + ' para ' + c.winner + '.',
        (c) => 'Movimiento de ranking. ' + c.winner + ' gana P' + c.newPos + ' y estabiliza.',
        (c) => 'Movimiento de ranking. Cambio en P' + c.newPos + '. ' + c.winner + ' sube.'
      ],
      battle: [
        (c) => 'Duelo P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'Duelo P' + c.pos + '. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'Duelo P' + c.pos + '. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'Duelo P' + c.pos + '. Rango cr√≠tico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' en rango. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en rango. Rango cr√≠tico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cerrado. Rango cr√≠tico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. Delta ' + c.sec + 's entre ' + c.attacker + ' y ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.defender + ' tiene a ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. ' + c.attacker + ' en rango de ataque. Gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' con gap corto. Rango cr√≠tico: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' bajo presi√≥n. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.'
      ],
      battlePodium: [
        (c) => 'Podio P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Podio P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Podio P' + c.pos + '. Delta ' + c.sec + 's por el podio.',
        (c) => 'Podio P' + c.pos + '. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'Podio P' + c.pos + '. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' por trofeo. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' por trofeo. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' por trofeo. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' por trofeo. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' por trofeo. Rango de pase: ' + c.sec + 's.',
        (c) => 'Zona de podio P' + c.pos + '. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'Zona de podio P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Zona de podio P' + c.pos + '. Delta ' + c.sec + 's por el podio.',
        (c) => 'Zona de podio P' + c.pos + '. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'Zona de podio P' + c.pos + '. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cr√≠tico para podio. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cr√≠tico para podio. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' cr√≠tico para podio. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' cr√≠tico para podio. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' cr√≠tico para podio. Rango de pase: ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' de podio en disputa. Gap ' + c.sec + 's. ' + c.attacker + ' presiona a ' + c.defender + '.',
        (c) => 'P' + c.pos + ' de podio en disputa. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'P' + c.pos + ' de podio en disputa. Delta ' + c.sec + 's por el podio.',
        (c) => 'P' + c.pos + ' de podio en disputa. ' + c.defender + ' defiende con gap ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' de podio en disputa. Rango de pase: ' + c.sec + 's.'
      ],
      closing: [
        (c) => 'Cierre en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Cierre en P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. ' + c.attacker + ' ya est√° a ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Cierre en P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Tendencia P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Tendencia P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. ' + c.attacker + ' ya est√° a ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Tendencia P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'Delta en P' + c.pos + '. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'Delta en P' + c.pos + '. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. ' + c.attacker + ' ya est√° a ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'Delta en P' + c.pos + '. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.',
        (c) => 'P' + c.pos + ' con recorte. ' + c.attacker + ' reduce a ' + c.toSec + 's sobre ' + c.defender + '.',
        (c) => 'P' + c.pos + ' con recorte. Gap cae de ' + c.fromSec + 's a ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. ' + c.attacker + ' ya est√° a ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. Cierre confirmado: ' + c.fromSec + 's -> ' + c.toSec + 's.',
        (c) => 'P' + c.pos + ' con recorte. Tendencia positiva: ' + c.toSec + 's.',
        (c) => 'Gap bajando en P' + c.pos + '. De ' + c.fromSec + 's a ' + c.toSec + 's. ' + c.attacker + ' recorta.'
      ],
      
      gap: [
        (c) => 'Gap P' + c.pos + '. ' + c.attacker + ' a ' + c.sec + 's de ' + c.defender + '.',
        (c) => 'Gap P' + c.pos + '. ' + c.defender + ' adelante, ' + c.attacker + ' a ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' gap ' + c.sec + 's. ' + c.attacker + ' viene detr√°s.',
        (c) => 'P' + c.pos + '. Separaci√≥n ' + c.sec + 's entre ' + c.defender + ' y ' + c.attacker + '.',
        (c) => 'P' + c.pos + '. ' + c.attacker + ' marca ' + c.sec + 's al de adelante.'
      ],
      pressure: [
        (c) => 'Presi√≥n en P' + c.pos + '. ' + c.attacker + ' pegado a ' + c.defender + '. ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' bajo presi√≥n. ' + c.attacker + ' a ' + c.sec + 's. Ojo defensa.',
        (c) => 'Defensa en P' + c.pos + '. ' + c.defender + ' se sostiene con ' + c.sec + 's.',
        (c) => 'P' + c.pos + ' en modo defensa. ' + c.attacker + ' est√° encima, ' + c.sec + 's.'
      ],
      top3: [
        (c) => 'Top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Top 3: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Top 3: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.',
        (c) => 'Tabla de punta: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Tabla de punta: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Tabla de punta: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.',
        (c) => 'Estado del podio: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Estado del podio: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Estado del podio: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.',
        (c) => 'Orden actual: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Orden actual: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Orden actual: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.',
        (c) => 'Lectura de top 3: P1 ' + c.p1 + '. P2 ' + c.p2 + '. P3 ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ', ' + c.p2 + ', ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ' lidera. ' + c.p2 + ' segundo. ' + c.p3 + ' tercero.',
        (c) => 'Lectura de top 3: Orden: ' + c.p1 + ' - ' + c.p2 + ' - ' + c.p3 + '.',
        (c) => 'Lectura de top 3: ' + c.p1 + ' al frente, ' + c.p2 + ' y ' + c.p3 + ' detr√°s.'
      ],
      train: [
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Delta m√≠nimo, decisi√≥n r√°pida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'Delta m√≠nimo, decisi√≥n r√°pida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Paquete P2-P4: ' + c.p2 + ' - ' + c.p3 + ' - ' + c.p4 + '. ') : 'Paquete compacto P2 a P4. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'Delta m√≠nimo, decisi√≥n r√°pida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Cluster: ' + c.p2 + ', ' + c.p3 + ' y ' + c.p4 + '. ') : 'Cluster por podio. ') + 'La siguiente curva es clave.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta m√≠nimo. ') + 'Alto riesgo de swap.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta m√≠nimo. ') + 'Ventana de pase abierta.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta m√≠nimo. ') + 'Cualquier error altera la tabla.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta m√≠nimo. ') + 'Delta m√≠nimo, decisi√≥n r√°pida.',
        (c) => 'Grupo compacto detectado. ' + (c.p2 ? ('Grupo: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Tres autos con delta m√≠nimo. ') + 'La siguiente curva es clave.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Alto riesgo de swap.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Ventana de pase abierta.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Cualquier error altera la tabla.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'Delta m√≠nimo, decisi√≥n r√°pida.',
        (c) => 'Paquete P2-P4. ' + (c.p2 ? ('P2-P4: ' + c.p2 + ', ' + c.p3 + ', ' + c.p4 + '. ') : 'Grupo P2-P4 en rango. ') + 'La siguiente curva es clave.'
      ]
    };

    const AUTO_PHRASES_NARRATIVO = Object.assign({}, AUTO_PHRASES_PRO, {
      // Menos "lista de frases", m√°s narraci√≥n con hilo
      leaderChange: [
        (c) => `Cambio de l√≠der. ${c.newLeader} toma P1. ${c.oldLeader} cae a P2. Esto se reescribe.`,
        (c) => `¬°Hay swap al frente! ${c.newLeader} se queda con la punta. ${c.oldLeader} ahora P2.`,
        (c) => `P1 cambia de due√±o. ${c.newLeader} adelante, y ${c.oldLeader} a recomponer.`
      ],
      pass: [
        (c) => `Pase confirmado en P${c.pos}. ${c.attacker} ya est√° por delante de ${c.defender}.`,
        (c) => `Movimiento limpio: ${c.attacker} gana la posici√≥n sobre ${c.defender} en P${c.pos}.`,
        (c) => `Se concreta el pase. ${c.attacker} se mete en P${c.pos}, ${c.defender} pierde la plaza.`
      ],
      battle: [
        (c) => `C√°mara en P${c.pos}. ${c.attacker} viene pegado a ${c.defender}. Gap ${c.deltaStr}.`,
        (c) => `P${c.pos} est√° al rojo: ${c.attacker} en espejo de ${c.defender}. Gap ${c.deltaStr}.`,
        (c) => `Tenemos pelea real por P${c.pos}. ${c.attacker} presiona a ${c.defender}. Gap ${c.deltaStr}.`
      ],
      battlePodium: [
        (c) => `Batalla por podio. ${c.attacker} sobre ${c.defender}. Gap ${c.deltaStr}.`,
        (c) => `Podio en juego: ${c.attacker} trae a tiro a ${c.defender}. Gap ${c.deltaStr}.`,
        (c) => `Esto huele a trofeo: ${c.attacker} quiere el podio y ${c.defender} aguanta. Gap ${c.deltaStr}.`
      ],
      closing: [
        (c) => `√öltimo tramo. P1 ${c.p1}, P2 ${c.p2}, P3 ${c.p3}. Aqu√≠ se define.`,
        (c) => `Entramos a cierre. ${c.p2} tiene a ${c.p1} en la mira. ${c.p3} no se baja del podio.`,
        (c) => `Cierre de carrera. ${c.p1} manda, pero ${c.p2} est√° inc√≥modo cerca.`
      ],
      record: [
        (c) => `${c.pilot} marca mejor vuelta: ${c.best}. Eso s√≠ es ritmo.`,
        (c) => `Nuevo mejor tiempo de ${c.pilot}: ${c.best}. Deja nota.`,
        (c) => `Best lap para ${c.pilot}: ${c.best}. Se escuch√≥ el motor.`
      ],
      qualiBest: [
        (c) => `Clasificaci√≥n al l√≠mite. ${c.pilot} suelta ${c.best} y se mete en la conversaci√≥n.`,
        (c) => `En quali, ${c.pilot} aprieta con ${c.best}. Eso mueve la tabla.`,
        (c) => `Queda registrada: ${c.pilot} con ${c.best}. Ojo con esa vuelta.`
      ]
    });

    
    // ===== Auto Locutor TV (bancos dedicados por tipo de sesi√≥n) =====
    // - FINAL: narrativa tipo TV, batallas reales, pases confirmados, l√≠der/podio, best lap
    // - MANGA: pelea por la pole contra reloj, ranking estable, best lap y cierres por d√©cimas (sin "rebases" falsos)
    const AUTO_PHRASES_TV_FINAL = Object.assign({}, AUTO_PHRASES_NARRATIVO, {
      leaderChange: [
        (c) => `Cambio de l√≠der. ${c.winner} se pone al frente. ${c.loser} cae a P2.`,
        (c) => `Nuevo l√≠der. ${c.winner} manda. ${c.loser} ahora persigue.`,
        (c) => `Se mueve la punta. P1 ${c.winner}. P2 ${c.loser}.`
      ],
      pass: [
        (c) => `Rebase confirmado. ${c.winner} pasa a ${c.loser} por P${c.pos}.`,
        (c) => `Movimiento claro. ${c.winner} se queda con P${c.pos}, ${c.loser} pierde la posici√≥n.`,
        (c) => `Cambio de orden. ${c.winner} adelante de ${c.loser} en P${c.pos}.`
      ],
      battle: [
        (c) => `Duelo directo. ${c.a} y ${c.b}, a ${c.gap}.`,
        (c) => `Batalla cerrada. ${c.a} contra ${c.b}, separados por ${c.gap}.`,
        (c) => `Ojo en pista. ${c.a} y ${c.b} est√°n pegados, ${c.gap}.`
      ],
      battlePodium: [
        (c) => `Podio en juego. ${c.a} defiende de ${c.b}, a ${c.gap}.`,
        (c) => `Se calienta el podio. ${c.b} aprieta a ${c.a}, ${c.gap}.`,
        (c) => `√öltimo escal√≥n. ${c.a} y ${c.b} por el podio, ${c.gap}.`
      ],
      closing: [
        (c) => `Atenci√≥n. ${c.chaser} ya est√° a ${c.gap} de ${c.target}.`,
        (c) => `Se viene el ataque. ${c.chaser} recorta, ${c.gap} a ${c.target}.`,
        (c) => `Presi√≥n real. ${c.chaser} se acerca a ${c.target}, ${c.gap}.`
      ],
      pressure: [
        (c) => `Presi√≥n. ${c.chaser} encima de ${c.target}, ${c.gap}.`,
        (c) => `Sin respiro. ${c.target} tiene a ${c.chaser} a ${c.gap}.`,
        (c) => `Casi lo tiene. ${c.chaser} a ${c.gap} de ${c.target}.`
      ],
      train: [
        (c) => `Trenecito. De P${c.from} a P${c.to}, todos en fila, sin margen.`,
        (c) => `Grupo compacto. P${c.from} a P${c.to}, nadie se despega.`,
        (c) => `Paquete apretado. Del P${c.from} al P${c.to}, cuidado con el error.`
      ],
      top3: [
        (c) => `Top 3. P1 ${c.p1}. P2 ${c.p2}. P3 ${c.p3}.`,
        (c) => `Arriba. ${c.p1} lidera, ${c.p2} segundo, ${c.p3} tercero.`,
        (c) => `Podio provisional. ${c.p1}, ${c.p2}, ${c.p3}.`
      ],
      story: [
        (c) => `Foco en ${c.a} contra ${c.b}. ${c.gap}.`,
        (c) => `C√°mara al duelo. ${c.a} y ${c.b}, ${c.gap}.`,
        (c) => `Seguimos esta pelea. ${c.a} vs ${c.b}, ${c.gap}.`
      ],
      qualiBest: [
        (c) => `Vuelta r√°pida. ${c.pilot} marca ${c.best}.`,
        (c) => `Best lap. ${c.pilot}, ${c.best}.`,
        (c) => `Ojo. ${c.pilot} baja el tiempo, ${c.best}.`
      ],
      qualiPole: [
        (c) => `Pelea por la punta. ${c.a} y ${c.b}, ${c.gap}.`,
        (c) => `P1 bajo presi√≥n. ${c.a} y ${c.b} a ${c.gap}.`,
        (c) => `Diferencia m√≠nima. ${c.a} contra ${c.b}, ${c.gap}.`
      ]
    });

    const AUTO_PHRASES_TV_MANGA = Object.assign({}, AUTO_PHRASES_TV_FINAL, {
      // En MANGA hablamos de tabla y pole provisional (contra reloj)
      pass: [
        (c) => `La tabla se mueve. ${c.winner} sube a P${c.pos}, ${c.loser} baja.`,
        (c) => `Ranking provisional. ${c.winner} gana P${c.pos}, ${c.loser} cede.`,
        (c) => `Cambio en la tabla. ${c.winner} por delante de ${c.loser} en P${c.pos}.`
      ],
      top3: [
        (c) => `Tabla provisional. P1 ${c.p1}. P2 ${c.p2}. P3 ${c.p3}.`,
        (c) => `Pole provisional. ${c.p1}. Segundo ${c.p2}. Tercero ${c.p3}.`,
        (c) => `Arriba en la tabla. ${c.p1}, ${c.p2}, ${c.p3}.`
      ],
      battle: [
        (c) => `Pelea por la pole. ${c.a} y ${c.b}, ${c.gap}.`,
        (c) => `Clasificaci√≥n apretada. ${c.a} contra ${c.b}, ${c.gap}.`,
        (c) => `Diferencias por d√©cimas. ${c.a} y ${c.b}, ${c.gap}.`
      ],
      closing: [
        (c) => `${c.chaser} viene recortando. ${c.gap} a la pole de ${c.target}.`,
        (c) => `Atenci√≥n en la tabla. ${c.chaser} a ${c.gap} de ${c.target}.`,
        (c) => `Pole fight. ${c.chaser} se acerca a ${c.target}, ${c.gap}.`
      ],
      pressure: [
        (c) => `Presi√≥n por la pole. ${c.chaser} a ${c.gap} de ${c.target}.`,
        (c) => `Clasificaci√≥n en fuego. ${c.target} con ${c.chaser} a ${c.gap}.`,
        (c) => `Nada decidido. ${c.chaser} a ${c.gap} de ${c.target}.`
      ],
      qualiPole: [
        (c) => `Pole fight. ${c.a} y ${c.b} separados por ${c.gap}.`,
        (c) => `Por la pole. ${c.a} contra ${c.b}, ${c.gap}.`,
        (c) => `Cierre por d√©cimas. ${c.a} y ${c.b}, ${c.gap}.`
      ],
      qualiBest: [
        (c) => `Mejor vuelta. ${c.pilot} marca ${c.best}.`,
        (c) => `Vuelta r√°pida en clasificaci√≥n. ${c.pilot}, ${c.best}.`,
        (c) => `Se baja el tiempo. ${c.pilot} con ${c.best}.`
      ]
    });

const AUTO_PHRASES_BY_STYLE = {
      pro: AUTO_PHRASES_PRO,
      picante: AUTO_PHRASES_PICANTE,
      engineer: AUTO_PHRASES_ENGINEER,
      narrativo: AUTO_PHRASES_NARRATIVO,
      // alias de UI (modo TV/Coach/Min)
      tv: AUTO_PHRASES_TV_FINAL,
      coach: AUTO_PHRASES_PRO,
      min: AUTO_PHRASES_PRO
    };

function autoDecorate(text, type, style) {
  const t = String(text || '').trim();
  if (!t) return '';
  // Micro-variaci√≥n (pocas veces, para que no suene payaso)
  const r = Math.random();
  const st = String(style || 'pro');
  const tp = String(type || 'x');

  const prefixes = (st === 'engineer')
    ? ['Dato.', 'Info.', 'Control.']
    : (st === 'picante')
      ? ['Ojo.', 'Atenci√≥n.', 'Se prende.']
      : (st === 'narrativo')
        ? ['Ahora.', 'Cambiamos c√°mara.', 'Seguimos.', 'Atenci√≥n.', 'Foco.']
        : ['Ojo.', 'Atenci√≥n.', 'Momento.'];

  const suffixes = (st === 'engineer')
    ? ['Sin margen.', 'Sigue as√≠.']
    : (st === 'picante')
      ? ['Se puso bueno.', 'Sin piedad.']
      : (st === 'narrativo')
        ? ['No se sueltan.', 'Se viene el pase.', 'Sin respiro.', 'Esto est√° vivo.']
        : ['Esto se pone bueno.', 'Ojo ah√≠.'];

  // Narrativo: un poquito m√°s de "hilo", pero sin spam
  const pRate = (st === 'narrativo') ? 0.22 : 0.18;
  const sRate = (st === 'narrativo') ? 0.40 : 0.30;

  if (r < pRate) {
    const p = autoRandPick(prefixes, 'decorP:' + st + ':' + tp);
    return p ? (p + ' ' + t) : t;
  }
  if (r < sRate) {
    const s = autoRandPick(suffixes, 'decorS:' + st + ':' + tp);
    return s ? (t + ' ' + s) : t;
  }
  return t;
}

    function autoBuildMessage(type, ctx) {
      const style = (autoCommentatorMode === 'tv' || autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || (autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo')) ? autoCommentatorMode : 'pro';
      const sessType = (typeof currentSessionInfo !== 'undefined' && currentSessionInfo && currentSessionInfo.type) ? String(currentSessionInfo.type) : '';
      const isManga = (sessType === 'MANGA');
      const isFinal = (sessType === 'FINAL');
      let dict = (AUTO_PHRASES_BY_STYLE && AUTO_PHRASES_BY_STYLE[style]) ? AUTO_PHRASES_BY_STYLE[style] : AUTO_PHRASES_PRO;
      if (style === 'tv' || style === 'narrativo') {
        dict = isManga ? AUTO_PHRASES_TV_MANGA : AUTO_PHRASES_TV_FINAL;
      }
      if (ctx && typeof ctx === 'object') { try { ctx.sessionType = sessType; ctx.isFinal = isFinal; ctx.isManga = isManga; } catch(e) {} }
      const bank = (dict && dict[type]) ? dict[type] : (AUTO_PHRASES_PRO[type] || []);
      const fn = autoRandPick(bank, style + ':' + type);
      if (typeof fn === 'function') {
        const out = String(fn(ctx) || '').trim();
        return autoDecorate(out, type, style);
      }
      
    function autoCatFromType(tp){
      const t = String(tp || '').toLowerCase();
      if (t.includes('blue')) return 'blueflag';
      if (t === 'qualibest' || t === 'qualipole' || t.includes('best')) return 'bestlap';
      if (t.includes('pole')) return 'bestlap';
      if (t === 'pass' || t.includes('leaderchange')) return 'pos';
      if (t.includes('podium') || t.includes('top3')) return 'podium';
      if (t === 'gap') return 'gaps';
      if (t.includes('leadergap') || t === 'leader') return 'leadergap';
      if (t === 'closing' || t === 'battle' || t === 'pressure' || t === 'train' || t === 'story' || t === 'closingstory') return 'pelea';
      return 'total';
    }

return '';
    }

    function handleAutoCommentator() {
      try {
        if (!raceData || !Array.isArray(raceData.classification)) return;
        // Auto Locutor nunca debe quedar mudo por estar en SUPER/BASE cuando NO hay piloto seleccionado.
        // Si no hay piloto, forzamos TV silenciosamente para que hable. Si hay piloto y est√°s en SUPER/BASE, respetamos SUPER (seguimiento light).
        try{
          if (typeof uiNarrationMode !== 'undefined' && (uiNarrationMode === 'SILENT' || uiNarrationMode === 'SUPER')) {
            if (!selectedPilotKey) {
              try { setNarrationMode('TV', { silent:true, temp:true }); } catch(e) {}
            } else {
              return;
            }
          }
        }catch(e){}
        // AUTO + SEGUIMIENTO:
// - Antes: si hab√≠a piloto seleccionado, el Auto Locutor quedaba mudo.
// - Ahora: puede convivir con seguimiento, pero sin hablar encima del piloto.
const allowAutoWithSelected = true; // default ON
if (selectedPilotKey && !allowAutoWithSelected) return;
if (selectedPilotKey && allowAutoWithSelected){
  // No te piso la voz del seguimiento (si acaba de hablar algo, espero).
  const sinceAny = Date.now() - (typeof lastAnySpeechAt !== 'undefined' ? (lastAnySpeechAt || 0) : 0);
  if (sinceAny < 5200) return;
}
        if (!voiceMasterEnabled) return;

        let vs = (typeof voiceSettings !== 'undefined' && voiceSettings) ? voiceSettings : {};
        const keepBlue = (vs && typeof vs.blueflag === 'boolean') ? vs.blueflag : true;
        // Auto Locutor: perfil por estilo (independiente de los toggles del piloto seleccionado)
        // - TV/Narrativo: siempre trae Top3, pole/bestlap y batallas (sin n√∫meros de GAP por defecto)
        try{
          const __style = (autoCommentatorMode === 'tv' || (autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo') || autoCommentatorMode === 'pro' || autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer')
            ? autoCommentatorMode : 'pro';

          if (__style === 'tv' || __style === 'narrativo'){
            vs = Object.assign({}, vs, {
              pos:true, podium:true, leadergap:true, total:true,
              pelea:true, bestlap:true, attack:true, defense:false,
              blueflag: keepBlue,
      courtesy: true,
              gaps:false, estlap:false, ritmo:false, streak:false, box:false
            });
          } else if (__style === 'pro' || __style === 'picante'){
            vs = Object.assign({}, vs, {
              pos:true, podium:true, leadergap:true, total:true,
              pelea:true, bestlap:true, attack:true, defense:false,
              blueflag: keepBlue,
      courtesy: true,
              gaps:false
            });
          } else if (__style === 'engineer'){
            vs = Object.assign({}, vs, {
              pos:true, leadergap:true, total:true, bestlap:true,
              gaps:true,
              pelea:false, attack:true, defense:false,
              blueflag: keepBlue
            });
          }
        }catch(e) {}
        // Si el usuario apaga TODO menos laps, no inventamos
        const autoOn = !!(vs.pos || vs.podium || vs.pelea || vs.gaps || vs.leadergap || vs.bestlap || vs.estlap || vs.attack || vs.defense || vs.ritmo || vs.total || vs.blueflag);
        if (!autoOn) return;

        const arr = raceData.classification.slice().filter(r => r && (r.pos != null));
        if (!arr.length) return;

        arr.sort((a,b) => (Number(a.pos)||999) - (Number(b.pos)||999));

        const leader = arr.find(r => Number(r.pos) === 1) || arr[0];
        const leaderLap = Number(leader && leader.lapcount) || 0;
        const progress = autoRaceProgress(leaderLap);

        const chapter = (progress < 0.33) ? 0 : (progress < 0.66) ? 1 : (progress < 0.85) ? 2 : 3;
        const __autoStyle = (autoCommentatorMode === 'tv' || autoCommentatorMode === 'picante' || autoCommentatorMode === 'engineer' || (autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo')) ? autoCommentatorMode : 'pro';
        try { commentatorAutoCfg.__dyn = autoDynCfgForStyle(__autoStyle); } catch(e) {}

        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

        // ====== candidatos (score decide)
        let candidates = [];
        const battles = [];
        const addCand = (c) => { if (c && c.text && isFinite(c.score)) candidates.push(c); };

        // Bandera azul (Auto Locutor): lapeo/trafico detectado por pasos de meta
        try {
          if (vs.blueflag) {
            const bc = autoBlueFlagCandidate(arr, leader);
            if (bc) addCand(bc);
          }
        } catch(e) {}

        // ====== confirmaci√≥n de movimientos (FINAL) para evitar anuncios "fantasma"
        // Idea: cuando detectamos un swap de posiciones, primero lo ponemos en espera y lo anunciamos
        // solo si se mantiene en el siguiente tick (o tras ~800ms). En MANGA seguimos siendo conservadores.
        const __pendingMoves = commentatorAutoState.pendingMoves || (commentatorAutoState.pendingMoves = new Map());

        const __queueMove = (k, payload) => {
          try{
            const prev = __pendingMoves.get(k);
            if (!prev) __pendingMoves.set(k, Object.assign({ seen: 1, ts: now }, payload));
            else {
              prev.seen = (prev.seen || 0) + 1;
              prev.ts = prev.ts || now;
              // refrescar datos por si cambian nombres
              Object.assign(prev, payload);
            }
          } catch(e) {}
        };

        const __flushMoves = () => {
          try{
            const isFinalSess = (currentSessionInfo && currentSessionInfo.type === 'FINAL');
            const maxAge = 4200; // ms
            for (const [k, mv] of Array.from(__pendingMoves.entries())) {
              if (!mv) { __pendingMoves.delete(k); continue; }
              if ((now - (mv.ts || 0)) > maxAge) { __pendingMoves.delete(k); continue; }

              // confirmaci√≥n: 2 ticks o 800ms, y la posici√≥n sigue igual
              const okByTime = (now - (mv.ts || 0)) >= 800;
              const okBySeen = (mv.seen || 0) >= 2;

              if (!(okByTime || okBySeen)) continue;

              const rowNow = arr.find(x => getPilotKey(x) === mv.winnerKey);
              const posNow = rowNow ? (Number(rowNow.pos) || null) : null;
              if (!posNow || posNow !== mv.currPos) { __pendingMoves.delete(k); continue; }

              // En FINAL, confirmamos y anunciamos. En MANGA solo si aporta (top3 o >=2 puestos)
              if (!isFinalSess) {
                const deltaPos = (mv.prevPos ? (mv.prevPos - mv.currPos) : 0);
                if (!(mv.currPos <= 3 || deltaPos >= 2)) { __pendingMoves.delete(k); continue; }
              }

              addCand(mv.cand);
              __pendingMoves.delete(k);
            }
          } catch(e) {}
        };


        // ====== cambios de l√≠der / posiciones
        const leaderKey = getPilotKey(leader);
        if (leaderKey && commentatorAutoState.lastLeaderKey && leaderKey !== commentatorAutoState.lastLeaderKey) {
          if (vs.pos || vs.leadergap || vs.podium) {
            const prevLeaderName = safeRacerName((commentatorAutoState.lastLeaderKeyName || ''));
            const winner = safeRacerName(leader.racerName) || 'el l√≠der nuevo';
            const loser = prevLeaderName || 'el l√≠der anterior';
            const text = autoBuildMessage('leaderChange', { winner, loser });
            addCand({
              type:'leaderChange',
              score: 10.0 + (progress > 0.75 ? 0.6 : 0),
              text,
              key: 'auto_leader_change',
              sig: 'auto:leaderChange',
              sigCooldownMs: 9000,
              priority: 9
            });
          }
        }
        // guardar nombre del l√≠der para el siguiente tick
        commentatorAutoState.lastLeaderKeyName = safeRacerName(leader && leader.racerName);

        // Overtakes por swap de posiciones
        if (commentatorAutoState.prevKeyByPos && commentatorAutoState.prevKeyByPos.length) {
          // detecta swaps simples: key actual en pos i y key previa diferente
          for (let i = 0; i < Math.min(arr.length, 10); i++) {
            const curr = arr[i];
            const currPos = Number(curr.pos) || (i+1);
            const currKey = getPilotKey(curr);
            if (!currKey) continue;
            const prevKeyAtThisPos = commentatorAutoState.prevKeyByPos[currPos-1];
            if (prevKeyAtThisPos && prevKeyAtThisPos !== currKey) {
              const prevPos = commentatorAutoState.prevPosByKey.get(currKey);
              // solo si realmente gan√≥ posiciones
              if (prevPos && currPos < prevPos) {
                const loserKey = prevKeyAtThisPos;
                const loserPrevPos = commentatorAutoState.prevPosByKey.get(loserKey) || (currPos + 1);
                const winner = safeRacerName(curr.racerName) || 'un piloto';
                const loser = safeRacerName((arr.find(x => getPilotKey(x)===loserKey)||{}).racerName) || 'otro piloto';
                const _isManga = (currentSessionInfo && currentSessionInfo.type === 'MANGA');
                const deltaPos = (prevPos ? (prevPos - currPos) : 0);

                // En MANGA (contra reloj), micro swaps suelen ser jitter - solo anunciamos si aporta
                if (_isManga && !(currPos <= 3 || deltaPos >= 2)) {
                  // skip
                } else {
                  let s = 8.8;
                  let type = 'pass';
                  let sig = 'auto:pass:' + currKey + ':' + currPos;
                  let sigCooldownMs = 20000;
                  let priority = 8;
                  let text = '';

                  if (_isManga) {
                    // Ranking provisional (no "rebase")
                    type = 'rankMove';
                    sig = 'auto:rankMove:' + currKey + ':' + currPos;
                    sigCooldownMs = 16000;
                    priority = 6;
                    s = 6.4;
                    if (currPos <= 3) s += 0.9;
                    if (deltaPos >= 3) s += 0.6;
                    text = (prevPos && prevPos > currPos)
                      ? `Tabla viva. ${winner} sube a P${currPos} desde P${prevPos}.`
                      : `Tabla viva. ${winner} se mete en P${currPos}.`;
                  } else {
                    text = autoBuildMessage('pass', { winner, loser, newPos: currPos, oldPos: loserPrevPos });
                    if (currPos <= 3) s += 0.9;
                    if (currPos === 1) s += 0.6;
                    if (progress > 0.75 && currPos <= 5) s += 0.6;
                  }

                  // En FINAL, confirmamos el movimiento antes de anunciar (anti jitter y anti atraso)
                  const __isFinal = (currentSessionInfo && currentSessionInfo.type === 'FINAL');
                  const __moveKey = (type === 'rankMove' ? ('rm:' + currKey + ':' + currPos) : ('ps:' + currKey + ':' + currPos));
                  const __cand = {
                    type,
                    score: s,
                    text,
                    key: (_isManga ? ('auto_rank_' + currKey + '_' + currPos) : ('auto_pass_' + currKey + '_' + currPos)),
                    sig,
                    sigCooldownMs,
                    priority
                  };

                  if (__isFinal) {
                    __queueMove(__moveKey, {
                      winnerKey: currKey,
                      currPos,
                      prevPos,
                      cand: __cand
                    });
                  } else {
                    addCand(__cand);
                  }
                }
}
            }
          }
        }

                // confirmar y soltar movimientos pendientes (FINAL)
        __flushMoves();

// ====== top 3 (resumen inteligente: solo cuando aporta)
        if (vs.pos || vs.podium || vs.leadergap) {
          if (arr.length >= 3) {
            const p1 = safeRacerName(arr[0].racerName) || 'P1';
            const p2 = safeRacerName(arr[1].racerName) || 'P2';
            const p3 = safeRacerName(arr[2].racerName) || 'P3';

            const sig = `${p1}|${p2}|${p3}`;
            const hadSig = !!(commentatorAutoState.lastTop3Sig);
            const orderChanged = hadSig && (sig !== commentatorAutoState.lastTop3Sig);

            const lastChap = (typeof commentatorAutoState.lastTop3Chapter === 'number') ? commentatorAutoState.lastTop3Chapter : -1;
            const chapterChanged = (chapter !== lastChap);

            const cfg = (commentatorAutoCfg && commentatorAutoCfg.__dyn) ? commentatorAutoCfg.__dyn : commentatorAutoCfg;
            const baseCd = Number(cfg.top3ChapterCooldownMs) || 65000;
            const cd = chapterChanged ? Math.min(22000, baseCd) : baseCd;

            const sinceTop3 = now - (commentatorAutoState.lastTop3Ms || 0);
            const shouldByTime = (sinceTop3 > cd);
            const shouldByChapter = chapterChanged && (sinceTop3 > 14000);

            if ((orderChanged || shouldByChapter || shouldByTime) && leaderLap > 0) {
              const lapNow = leaderLap || 0;
              const lapTotal = Number(raceData.lapCount) || 0;
              const text = autoBuildMessage('top3', { p1, p2, p3, lapNow, lapTotal });

              let s = 3.2;
              if (orderChanged) s += 1.5;
              if (chapterChanged) s += 0.6;
              if (progress > 0.80) s += 0.4;

              addCand({
                type:'top3',
                score: s,
                text,
                key:'auto_top3',
                sig:'auto:top3',
                sigCooldownMs: cfg.top3CooldownMs,
                priority: 3,
                onCommit: () => {
                  commentatorAutoState.lastTop3Ms = now;
                  commentatorAutoState.lastTop3Sig = sig;
                  commentatorAutoState.lastTop3Chapter = chapter;
                  commentatorTop3LastLeaderLap = leaderLap || commentatorTop3LastLeaderLap;
                }
              });
            }
          }
        }

// ====== batallas cerradas (<=0.5s) y trenecito
        if (vs.pelea) {
          // trenecito podio: P2-P4 muy juntos
          if (arr.length >= 4) {
            const a2 = arr[1], a3 = arr[2], a4 = arr[3];
            const k2 = getPilotKey(a2), k3 = getPilotKey(a3), k4 = getPilotKey(a4);
            const sameLap = (Number(a2.lapcount)||0)===(Number(a3.lapcount)||0) && (Number(a3.lapcount)||0)===(Number(a4.lapcount)||0);
            if (sameLap && a2.time!=null && a3.time!=null && a4.time!=null) {
              const d23 = (a3.time - a2.time)/1000;
              const d34 = (a4.time - a3.time)/1000;
              if (d23>0 && d34>0 && d23<=0.60 && d34<=0.60) {
                const p2n = safeRacerName(a2.racerName) || 'P2';
                const p3n = safeRacerName(a3.racerName) || 'P3';
                const p4n = safeRacerName(a4.racerName) || 'P4';
                const text = autoBuildMessage('train', { p2: p2n, p3: p3n, p4: p4n });
                addCand({
                  type:'train',
                  score: 7.2 + (progress>0.75?0.6:0),
                  text,
                  key:'auto_train_podium',
                  sig:'auto:train',
                  sigCooldownMs: 18000,
                  priority: 7
                });
              }
            }
          }

          for (let i = 0; i < arr.length - 1; i++) {
            const ahead = arr[i];
            const behind = arr[i + 1];
            if (!ahead || !behind) continue;

            const aKey = getPilotKey(ahead);
            const bKey = getPilotKey(behind);
            if (!aKey || !bKey) continue;

            const aLaps = Number(ahead.lapcount) || 0;
            const bLaps = Number(behind.lapcount) || 0;
            const pairKey = autoPairKey(aKey, bKey);

            // si no estan en la misma vuelta, rearmar latch
            if (aLaps !== bLaps) {
              if (commentatorBattleLatch && commentatorBattleLatch.has(pairKey)) commentatorBattleLatch.delete(pairKey);
              continue;
            }

            if (ahead.time == null || behind.time == null) continue;
            const diffMs = (behind.time - ahead.time);
            if (!diffMs || diffMs <= 0) continue;

const sec = diffMs / 1000;

const posFight = Number(ahead.pos) || (i + 1);

// Pool para narraci√≥n con hilo (seguimos la pelea aunque no est√© en 0.50 exacto)
const defenderName = safeRacerName(ahead.racerName) || 'el de adelante';
const attackerName = safeRacerName(behind.racerName) || 'el de atr√°s';
const secNum = sec;

// Tendencia (si el atacante viene m√°s r√°pido en la √∫ltima vuelta, pesa m√°s)
const aLast = Number(ahead.lastTime) || 0;
const bLast = Number(behind.lastTime) || 0;
const attackerFaster = (aLast > 0 && bLast > 0) ? ((aLast - bLast) / 1000) : 0; // >0 = el de atr√°s viene m√°s r√°pido

const rem = autoRememberPair(pairKey, secNum, leaderLap, now);
const trendBonus = (rem.deltaSec < -0.08) ? 0.8 : (rem.deltaSec < -0.04 ? 0.4 : 0);

// Score base para el pool
let poolScore = 4.0 + clamp01((1.25 - secNum) / 1.25) * 4.2;
if (posFight <= 3) poolScore += 1.3;
if (posFight === 1) poolScore += 0.7;
if (progress > 0.80 && posFight <= 5) poolScore += 0.5;
poolScore += trendBonus;
if (attackerFaster > 0.10) poolScore += 0.5;

if (secNum <= 1.25) {
  battles.push({
    pairKey,
    pos: posFight,
    defender: defenderName,
    attacker: attackerName,
    secNum,
    score: poolScore,
    lastMentionMs: rem.lastMentionMs || 0
  });
}

// histeresis: rearmar cuando se abre
            const prevLatch = commentatorBattleLatch ? commentatorBattleLatch.get(pairKey) : null;
            if (prevLatch && prevLatch.active) {
              if (sec >= 0.72) commentatorBattleLatch.delete(pairKey);
              else continue;
            }

            if (sec <= 0.65) {
              const defender = safeRacerName(ahead.racerName) || 'el de adelante';
              const attacker = safeRacerName(behind.racerName) || 'el de atr√°s';
              const secStr = autoFmtSec(sec);

              const closeness = clamp01((0.65 - sec) / 0.65);
              let score = 6.0 + closeness * 3.0;
              if (posFight <= 3) score += 1.6;
              if (posFight === 1) score += 0.8;
              if (progress > 0.80 && posFight <= 5) score += 0.7;

              const type = (posFight <= 3) ? 'battlePodium' : 'battle';
              const text = autoBuildMessage(type, { pos: posFight, attacker, defender, sec: secStr });

              addCand({
                type,
                score,
                text,
                key: 'auto_duel_' + pairKey,
                sig: 'auto:duel:' + pairKey,
                sigCooldownMs: 20000,
                priority: 6
              });

              if (commentatorBattleLatch) commentatorBattleLatch.set(pairKey, { active: true, lastLeadLap: leaderLap });
            }
          }
        }

        // ====== se cierra (0.5 a 1.6, baja gap fuerte)
        // Nota: POS ya no dispara cierres (para evitar duplicados). Cierres=ATAQUE/DEFENSA, gaps=n√∫meros.
        if (vs.attack || vs.defense || vs.gaps) {
          for (let i = 0; i < arr.length - 1; i++) {
            const ahead = arr[i];
            const behind = arr[i + 1];
            if (!ahead || !behind) continue;

            const aKey = getPilotKey(ahead);
            const bKey = getPilotKey(behind);
            if (!aKey || !bKey) continue;

            const aLaps = Number(ahead.lapcount) || 0;
            const bLaps = Number(behind.lapcount) || 0;
            const pairKey = autoPairKey(aKey, bKey);

            if (aLaps !== bLaps) {
              if (commentatorGapHistory && commentatorGapHistory.has(pairKey)) commentatorGapHistory.delete(pairKey);
              continue;
            }

            if (ahead.time == null || behind.time == null) continue;
            const diffMs = (behind.time - ahead.time);
            if (!diffMs || diffMs <= 0) continue;
            const sec = diffMs / 1000;

            const hist = commentatorGapHistory ? commentatorGapHistory.get(pairKey) : null;
            const lastTrailLap = hist ? (hist.lastTrailLap || 0) : 0;
            if (hist && lastTrailLap === bLaps) continue;

            const newHist = {
              lastGapMs: diffMs,
              lastTrailLap: bLaps,
              lastSpokenTrailLap: hist ? (hist.lastSpokenTrailLap || 0) : 0
            };
            if (commentatorGapHistory) commentatorGapHistory.set(pairKey, newHist);

            if (sec < 0.50 || sec > 1.60) continue;
            if (!hist || !hist.lastGapMs) continue;

            const deltaMs = (hist.lastGapMs - diffMs); // positivo: se acerca
            if (deltaMs < 170) continue;

            // no hablar cada vuelta
            if (newHist.lastSpokenTrailLap && bLaps <= (newHist.lastSpokenTrailLap + 1)) continue;


const posFight = Number(ahead.pos) || (i + 1);
const defender = safeRacerName(ahead.racerName) || 'el de adelante';
const attacker = safeRacerName(behind.racerName) || 'el de atr√°s';
const fromSec = autoFmtSec(hist.lastGapMs / 1000);
const toSec = autoFmtSec(sec);

// Pool de narraci√≥n: cuando se cierra fuerte, conviene seguirlo
try {
  const rem2 = autoRememberPair(pairKey, sec, leaderLap, now);
  let poolScore2 = 4.0 + clamp01((1.25 - sec) / 1.25) * 3.6;
  poolScore2 += clamp01(deltaMs / 700) * 1.2;
  if (posFight <= 3) poolScore2 += 1.1;
  if (progress > 0.80 && posFight <= 5) poolScore2 += 0.5;
  if (sec <= 1.25) {
    battles.push({
      pairKey,
      pos: posFight,
      defender,
      attacker,
      secNum: sec,
      score: poolScore2 + 0.6,
      lastMentionMs: rem2.lastMentionMs || 0
    });
  }
} catch(e) {}

            let score = 4.6 + clamp01(deltaMs / 600) * 2.5;
            if (posFight <= 3) score += 1.1;
            if (progress > 0.80 && posFight <= 5) score += 0.5;

            const deltaStr = autoFmtSec(Math.max(0, deltaMs)/1000);

            // ATAQUE: tendencia de recorte (m√°s narrativa)
            if (vs.attack) {
              const text = autoBuildMessage('closing', { pos: posFight, attacker, defender, fromSec, toSec, delta: deltaStr });
              addCand({
                type:'closing',
                score,
                text,
                key:'auto_close_' + pairKey,
                sig:'auto:close:' + pairKey,
                sigCooldownMs: 15000,
                priority: 4
              });
            }

            // GAPS: solo n√∫meros (sin hype), con cooldown largo para no spamear
            if (vs.gaps && posFight <= 6 && sec <= 2.0) {
              const text = autoBuildMessage('gap', { pos: posFight, attacker, defender, sec: autoFmtSec(sec) });
              addCand({
                type:'gap',
                score: Math.max(2.8, score - 1.9),
                text,
                key:'auto_gap_' + pairKey,
                sig:'auto:gap:' + pairKey,
                sigCooldownMs: 22000,
                priority: 2
              });
            }

            // DEFENSA: presi√≥n real (<=0.6) para el de adelante
            if (vs.defense && posFight <= 8 && sec <= 0.60) {
              const text = autoBuildMessage('pressure', { pos: posFight, attacker, defender, sec: autoFmtSec(sec) });
              addCand({
                type:'pressure',
                score: 6.2,
                text,
                key:'auto_pressure_' + pairKey,
                sig:'auto:press:' + pairKey,
                sigCooldownMs: 16000,
                priority: 5
              });
            }

            newHist.lastSpokenTrailLap = bLaps;
            if (commentatorGapHistory) commentatorGapHistory.set(pairKey, newHist);
          }
        }


// ====== modo de sesi√≥n
const sessionType = String((currentSessionInfo && currentSessionInfo.type) || '').toUpperCase();
const isMangaSess = (sessionType === 'MANGA');
const isFinalSess = (sessionType === 'FINAL');

// ====== narraci√≥n con hilo: elegimos una pelea y la seguimos con contexto
if ((autoCommentatorMode === 'tv' || (autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo') || vs.pelea || vs.attack || vs.defense) && battles && battles.length) {
  const sc = autoBuildStoryCandidate({ battles, now, leaderLap, progress, isMangaSess });
  if (sc) addCand(sc);
}

// ====== MANGA (clasificaci√≥n): pole/best lap (menos ruido, m√°s sustancia)
if (isMangaSess) {
  const wantBest = !!vs.bestlap;
  const wantPoleFight = !!(vs.bestlap || vs.pelea);

  try {
    // Mejor vuelta global
    if (wantBest) {
      let bestMs = null;
      let bestKey = '';
      let bestName = '';
      for (let i = 0; i < Math.min(arr.length, 12); i++) {
        const r = arr[i];
        const k = getPilotKey(r);
        const b = Number(r && r.best) || 0;
        if (!k || !b || !isFinite(b)) continue;
        if (bestMs == null || b < bestMs) {
          bestMs = b; bestKey = k; bestName = safeRacerName(r.racerName) || '';
        }
      }

      if (bestMs != null && isFinite(bestMs) && bestMs > 0) {
        const improved = (autoQualiState.bestOverallMs == null) ? true : (bestMs < (autoQualiState.bestOverallMs - 5));
        const since = now - (autoQualiState.lastBestSpeakMs || 0);

        if (improved && since > 8000) {
          const t = msToVoiceTime(bestMs); // ya aplica regla flat/precision
          const txt = autoBuildMessage('qualiBest', { pilot: bestName || 'alguien', best: t });
          addCand({
            type: 'qualiBest',
            score: 6.8,
            text: txt,
            key: 'auto_quali_best',
            sig: 'auto:qualiBest:' + String(bestKey || ''),
            sigCooldownMs: 15000,
            priority: 6,
            onCommit: () => {
              autoQualiState.bestOverallMs = bestMs;
              autoQualiState.bestOverallKey = bestKey;
              autoQualiState.lastBestSpeakMs = now;
            }
          });
        }
      }
    }

    // Pelea por la pole (Top2)
    if (wantPoleFight) {
      if (arr.length >= 2) {
        const r1 = arr[0], r2 = arr[1];
        const b1 = Number(r1 && r1.best) || 0;
        const b2 = Number(r2 && r2.best) || 0;
        const n1 = safeRacerName(r1 && r1.racerName) || 'P1';
        const n2 = safeRacerName(r2 && r2.racerName) || 'P2';
        if (b1 > 0 && b2 > 0 && isFinite(b1) && isFinite(b2)) {
          const gap = Math.abs(b2 - b1) / 1000;
          const sincePF = now - (autoQualiState.lastPoleFightSpeakMs || 0);
          if (((gap <= 0.08) && sincePF > 8000) || ((gap <= 0.16) && sincePF > 12000)) {
            const g = 'a ' + gapPhraseFromSec(gap);
            const txt = autoBuildMessage('qualiPole', { a: n1, b: n2, gap: g });
            addCand({
              type: 'qualiPole',
              score: 6.1,
              text: txt,
              key: 'auto_quali_pole',
              sig: 'auto:qualiPole',
              sigCooldownMs: 16000,
              priority: 5,
              onCommit: () => { autoQualiState.lastPoleFightSpeakMs = now; }
            });
          }
        }
      }
    }
  } catch(e) {}
}

// ====== si no hay accion real, resumen con calma (anti-loop / anti-perico)
        try {
          let maxScore = 0;
          for (const c of candidates) maxScore = Math.max(maxScore, Number(c && c.score) || 0);

          const quietCooldownMs = (autoCommentatorMode === 'tv') ? (isMangaSess ? 20000 : 28000) : ((autoCommentatorMode === 'narrativo') ? 20000 : 24000);
          const sinceQuiet = now - (commentatorAutoState.lastQuietMs || 0);

          const allowQuiet = !!(vs.total || vs.leadergap);

          if (allowQuiet && sinceQuiet > quietCooldownMs && maxScore < 4.6) {
            const leaderName = safeRacerName(leader && leader.racerName) || 'P1';
            const p2 = (arr.length >= 2) ? arr[1] : null;
            const p2Name = p2 ? (safeRacerName(p2.racerName) || 'P2') : 'P2';

            let gapTxt = '';
            try {
              if (p2 && leader && leader.time != null && p2.time != null) {
                const lap1 = Number(leader.lapcount) || 0;
                const lap2 = Number(p2.lapcount) || 0;
                if (lap1 === lap2) {
                  const g = Math.max(0, (Number(p2.time) - Number(leader.time)) / 1000);
                  if (g > 0) gapTxt = autoFmtSec(g);
                } else if (lap1 > lap2) {
                  gapTxt = autoGapTextFromLapDiff(lap1 - lap2);
                }
              }
            } catch(e) {}

            // tiempo restante (si hay duracion)
            let leftTxt = '';
            try {
              const dur = Number(currentSessionInfo && currentSessionInfo.durationMs) || 0;
              const elapsed = Number(leader && leader.time) || 0;
              if (dur > 0 && elapsed > 0) {
                const left = Math.max(0, dur - elapsed);
                leftTxt = formatClockMs(left);
              }
            } catch(e) {}

            let msg = '';
            if (isMangaSess) {
              msg = leftTxt
                ? `Clasificacion estable. Lider ${leaderName}. Quedan ${leftTxt}.`
                : `Clasificacion estable. Lider ${leaderName}.`;
            } else if (isFinalSess) {
              if (gapTxt) {
                msg = leftTxt
                  ? `Carrera estable. Lider ${leaderName}. ${p2Name} va a ${gapTxt}. Quedan ${leftTxt}.`
                  : `Carrera estable. Lider ${leaderName}. ${p2Name} va a ${gapTxt}.`;
              } else {
                msg = leftTxt
                  ? `Carrera estable. Lider ${leaderName}. Quedan ${leftTxt}.`
                  : `Carrera estable. Lider ${leaderName}.`;
              }
            } else {
              msg = leftTxt ? `Seguimos. Lider ${leaderName}. Quedan ${leftTxt}.` : `Seguimos. Lider ${leaderName}.`;
            }

            addCand({
              type:'quiet',
              score: 3.55 + (progress > 0.85 ? 0.2 : 0),
              text: msg,
              key: 'auto_quiet',
              sig: 'auto:quiet',
              sigCooldownMs: quietCooldownMs,
              priority: 1,
              onCommit: () => { commentatorAutoState.lastQuietMs = now; }
            });
          }
        } catch(e) {}

        // ====== elegir el mejor mensaje \(1 por tick\)
        if (!candidates.length) {
          // silencio es oro
          commentatorAutoState.lastLeaderKey = leaderKey || commentatorAutoState.lastLeaderKey;
          commentatorAutoState.lastLeaderLap = leaderLap || commentatorAutoState.lastLeaderLap;
        } else {
          
// MANGA: reduce ruido (menos swaps, m√°s info √∫til)
if (isMangaSess && candidates && candidates.length) {
  // Top3 + cierres + trenes. Lo dem√°s en manga suele ser "ruido" por salida escalonada.
  const allow = new Set(['top3','blueflag','closing','train','battle','battlePodium','story','qualiBest','qualiPole','quiet','leaderChange','rankMove']);
  const filtered = [];
  for (const c of candidates) {
    if (c && c.type && allow.has(c.type)) filtered.push(c);
  }
  if (filtered.length) {
    candidates.length = 0;
    for (const c of filtered) candidates.push(c);
  }
}


// NARRATIVO: si hay hilo (story), no dupliques con cierres/gaps cada vuelta
if ((autoCommentatorMode === 'tv' || autoCommentatorMode === 'narrativo') && candidates && candidates.length) {
  let hasStory = false;
  for (const c of candidates) { if (c && c.type === 'story') { hasStory = true; break; } }
  if (hasStory) {
    const filtered = [];
    for (const c of candidates) {
      if (!c || !c.type) continue;
      if ((c.type === 'gap') || ((c.type === 'closing' || c.type === 'pressure' || c.type === 'battle' || c.type === 'battlePodium') && (Number(c.score)||0) < 8.6)) continue;
      if (c.type === 'train' && (Number(c.score)||0) < 8.2) continue;
      filtered.push(c);
    }
    if (filtered.length) {
      candidates.length = 0;
      for (const c of filtered) candidates.push(c);
    }
  }
}


// TV: balance - menos "story", m√°s acci√≥n (battle/closing/train)
// - Si hay acci√≥n real, story solo entra si es MUCHO mejor y no acabamos de contar story.
try {
  if (candidates && candidates.length) {
    const cfg = (commentatorAutoCfg && commentatorAutoCfg.__dyn) ? commentatorAutoCfg.__dyn : commentatorAutoCfg;
    const actionSet = new Set(['battle','battlePodium','closing','pressure','train','leaderChange','pass','rankMove','qualiBest','qualiPole']);
    let bestAction = -1;
    let bestStory = null;
    for (const c of candidates) {
      if (!c || !c.type) continue;
      if (c.type === 'story') {
        if (!bestStory || (Number(c.score)||0) > (Number(bestStory.score)||0)) bestStory = c;
      } else if (actionSet.has(c.type)) {
        bestAction = Math.max(bestAction, Number(c.score)||0);
      }
    }
    const hasAction = bestAction >= 6.0;
    const storyRecent = (autoNarratorState && autoNarratorState.lastSpokenType === 'story' && ((now - (autoNarratorState.lastSpokenMs||0)) < (Number(cfg.windowMs)||32000)));

    if (hasAction) {
      const keepStory = (!storyRecent && bestStory && (Number(bestStory.score)||0) >= 9.2 && (Number(bestStory.score)||0) >= (bestAction + 1.6));
      const filtered = [];
      for (const c of candidates) {
        if (!c || !c.type) continue;
        if (c.type === 'story') continue;
        filtered.push(c);
      }
      if (keepStory) filtered.push(bestStory);
      if (filtered.length) {
        candidates.length = 0;
        for (const c of filtered) candidates.push(c);
      }
    }
  }
} catch(e) {}

candidates.sort((a,b) => (b.score - a.score) || (b.priority - a.priority));

for (const c of candidates) {
            const sigCd = Number(c.sigCooldownMs || 0) || commentatorAutoCfg.sigDefaultCooldownMs;
            if (!autoCanSpeak(c.score, c.sig, sigCd, now)) continue;

             // dedupe por texto (idea)
             if (!autoTextOk(c.text, now)) continue;

            // hablar
            const __autoCat = autoCatFromType(c.type);
            const __autoKey = 'sys_auto_' + String(c.key || c.sig || ('auto_' + c.type));
            speakWithLaps(leaderLap, c.text, { voiceURI: nextAutoVoiceURI(), cat: __autoCat, key: __autoKey, priority: c.priority || 0, cooldownMs: 2500, dedupe: true,
              mood: (c.type==='battle' || c.type==='closing' || c.type==='leaderChange' || c.type==='pass' || c.type==='pressure' || c.type==='train') ? 'hype' : (c.type==='qualiBest' || c.type==='qualiPole') ? 'serious' : 'calm' });

            commentatorAutoState.lastSpeakMs = now;
            commentatorAutoState.window.push(now);
            autoMarkSig(c.sig, now);
            try { if (typeof c.onCommit === 'function') c.onCommit(); } catch(e) {}
            break;
          }

          commentatorAutoState.lastLeaderKey = leaderKey || commentatorAutoState.lastLeaderKey;
          commentatorAutoState.lastLeaderLap = leaderLap || commentatorAutoState.lastLeaderLap;
        }

        // ====== actualizar snapshot de posiciones
        const prevPos = new Map();
        const prevByPos = [];
        for (let i = 0; i < arr.length; i++) {
          const r = arr[i];
          const k = getPilotKey(r);
          const p = Number(r.pos) || (i+1);
          if (k) {
            prevPos.set(k, p);
            prevByPos[p-1] = k;
          }
        }
        commentatorAutoState.prevPosByKey = prevPos;
        commentatorAutoState.prevKeyByPos = prevByPos;

      } catch (e) {
        console.error('handleAutoCommentator', e);
      }
    }



function handleVoiceAndBeeps() {
      if (!raceData || !Array.isArray(raceData.classification)) return;
      if (!selectedPilotKey) return;

      const p = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey);
      if (!p) return;

      // Beep tenue al primer detect del piloto seleccionado
      if (!selectedPilotFirstDetectBeeped) {
        selectedPilotFirstDetectBeeped = true;
        try { if (selectedPilotKey) firstDetectBeepedByPilot.set(selectedPilotKey, true); } catch(e) {}

        try { if (voiceMasterEnabled) playBeep('soft'); } catch(e) {}
      }

      const lapsNow = Number(p.lapcount) || 0;
      const idx = findPilotIndexByKey(selectedPilotKey);
      const hist = lapHistory.get(selectedPilotKey) || { lastLapcount: 0, times: [] };

      // √öltima vuelta: SIEMPRE primero en seguimiento.
// El feed puede traer lastTime como string ("08.239"), como ms, o no traerlo.
// 1) intentamos con el feed (varios nombres) usando parseTimeToMs
// 2) fallback al historial (updateLapHistoryAll ya corri√≥ antes de voz)
let __lapMsRaw = 0;
try {
  __lapMsRaw = normalizeIncomingLapValue(
    (typeof p.lastTime !== 'undefined' ? p.lastTime :
     (typeof p.lastLapTime !== 'undefined' ? p.lastLapTime :
      (typeof p.lastLap !== 'undefined' ? p.lastLap :
       (typeof p.lastLapMs !== 'undefined' ? p.lastLapMs :
        (typeof p.last !== 'undefined' ? p.last : 0)))))
  );
} catch(e) { __lapMsRaw = 0; }
let lapMsNow = normalizeLapMs(__lapMsRaw);
if (!lapMsNow) {
  try {
    const t = (hist && Array.isArray(hist.times)) ? hist.times : [];
    const last = t.length ? t[t.length - 1] : 0;
    if (isLapPlausible(last)) lapMsNow = last;
  } catch(e) {}
}
const now = Date.now();

      // Track de cambios de posici√≥n en este tick
      let posChangedTick = false;
      let posFrom = null;
      let posTo = null;
      let posDelta = 0;
// Helper
      const say = (m, opts) => speakWithLaps(lapsNow, m, opts);

      // Actualiza el modo desde raceName (ya viene de Firebase)
      if (raceData && raceData.raceName) {
        currentSessionInfo = parseSessionFromRaceName(raceData.raceName);
       try { maybeAutoApplySessionPreset(currentSessionInfo); } catch(e) {}
      }

      const isManga = currentSessionInfo && currentSessionInfo.type === 'MANGA';
      const isFinal = currentSessionInfo && currentSessionInfo.type === 'FINAL';

      // =========================
      // 1) Detecta eventos y genera pendientes (no habla aqui)
      // =========================

      // Posici√≥n (evento)
      if (p.pos && p.pos > 0) {
        if (lastKnownPos == null) lastKnownPos = p.pos;
        if (startPosForSelected == null) startPosForSelected = p.pos;

        // MANGA: estabilidad de posici√≥n (evita flip-flop en ranking por salida escalonada)
        if (isManga) {
          const curPos = Math.floor(p.pos);
          if (mangaPosStability.lastSeenPos == null) {
            mangaPosStability.lastSeenPos = curPos;
            mangaPosStability.stablePos = curPos;
            mangaPosStability.stableCount = 1;
            mangaPosStability.lastChangeAt = now;
          } else if (curPos === mangaPosStability.lastSeenPos) {
            mangaPosStability.stableCount = Math.min(10, (mangaPosStability.stableCount || 0) + 1);
            if (mangaPosStability.stableCount >= 2) mangaPosStability.stablePos = curPos;
          } else {
            mangaPosStability.lastSeenPos = curPos;
            mangaPosStability.stableCount = 1;
            mangaPosStability.lastChangeAt = now;
          }
        }

        if (p.pos !== lastKnownPos) {
          posChangedTick = true;
          posFrom = lastKnownPos;
          posTo = p.pos;
          posDelta = (Math.floor(posTo) - Math.floor(posFrom)); // + = cae, - = sube
        }

        // Mensaje corto de posici√≥n: solo se agenda en paso por meta.
        // Si la posici√≥n cambia por otros autos (sin meta), en FINAL puede avisar; en MANGA esperamos a tu cruce y a que se estabilice.
        if (voiceSettings.pos) {
          // Anuncio de posicion confirmado (anti-jitter) y SOLO en cruce por meta
          const curPos = Math.floor(p.pos);

          if (posStability.stablePos == null) posStability.stablePos = curPos;

          if (curPos !== posStability.stablePos) {
            if (posStability.pendingPos === curPos) {
              posStability.pendingCount = (posStability.pendingCount || 0) + 1;
            } else {
              posStability.pendingPos = curPos;
              posStability.pendingCount = 1;
              posStability.pendingSince = now;
            }

            const stableByCount = (posStability.pendingCount >= (isManga ? 5 : 3));
            const stableByTime  = (posStability.pendingSince && (now - posStability.pendingSince) >= (isManga ? 3500 : 1200));
if (stableByCount || stableByTime) {
              const fromPos = posStability.stablePos;
              const toPos   = curPos;

              const pendingCntBefore = (posStability.pendingCount || 0);
              const pendingSinceBefore = posStability.pendingSince;

              posStability.stablePos = toPos;
              posStability.pendingPos = null;
              posStability.pendingCount = 0;

              const lapWillSpeak = (lapsNow > lastAnnouncedLapcount); // tu cruce por meta pendiente
              const canQueue = ((now - (posStability.lastAnnounceAt || 0)) >= (isManga ? 16000 : 8000));

              // MANGA: ranking por reloj propio -> filtrar jitter fuerte. Solo hablamos si se ve estable o si hay cambio grande/top3.
              let mangaOk = true;
              let mangaDelta = (fromPos != null ? (fromPos - toPos) : 0);

              if (isManga) {
                const stablePosM = (mangaPosStability && mangaPosStability.stablePos != null) ? mangaPosStability.stablePos : toPos;
                const stableCountM = (mangaPosStability && mangaPosStability.stableCount != null) ? mangaPosStability.stableCount : 0;
                const stableOk = (stablePosM === toPos) && (stableCountM >= 6) && (!mangaPosStability.lastChangeAt || (now - mangaPosStability.lastChangeAt) >= 3000);

                const prevLapPos = (mangaLastLapCrossPos != null) ? mangaLastLapCrossPos : null;
                mangaDelta = (prevLapPos != null) ? (prevLapPos - toPos) : mangaDelta;

                const bigMove = Math.abs(mangaDelta) >= 2;
                const intoTop3 = (toPos <= 3) && (prevLapPos == null || prevLapPos > 3 || prevLapPos !== toPos);

                const cd = (intoTop3 || bigMove) ? 8000 : 18000;
                const cdOk = (now - (mangaPosStability.lastAnnounceAt || 0)) >= cd;

                const newPos = (mangaPosStability.lastAnnouncedStablePos == null) || (toPos !== mangaPosStability.lastAnnouncedStablePos);
                const smallMove = (!intoTop3 && !bigMove && Math.abs(mangaDelta) === 1);
                const strongEvidence = ((pendingCntBefore >= 8) || (pendingSinceBefore && (now - pendingSinceBefore) >= 6500));
                mangaOk = cdOk && newPos && stableOk && (intoTop3 || bigMove || (!smallMove || strongEvidence));
              }

              if (lapWillSpeak && canQueue && mangaOk) {
                pendingPosChange = {
                  pos: toPos,
                  delta: mangaDelta, // + = subes, - = bajas (en MANGA no decimos "ganaste/perdiste")
                  opts: { key: 'pos_' + toPos + '_' + lapsNow, priority: 85, cooldownMs: 2500, dedupe: true },
                  expLap: lapsNow + 2,
                  mangaStablePos: (isManga ? ((mangaPosStability && mangaPosStability.stablePos != null) ? mangaPosStability.stablePos : toPos) : null)
                };
              }
            }
          } else {
            posStability.pendingPos = null;
            posStability.pendingCount = 0;
          }
        }

        lastKnownPos = p.pos;
      }

      // NetGain (evento)
      if (!isManga && voiceSettings.pos && p.pos && Number(p.pos) > 0) {
        const posNow = Number(p.pos);
        if (startPosForSelected == null) startPosForSelected = posNow;
        const net = startPosForSelected - posNow;
        if (lastNetGainValue == null) lastNetGainValue = net;

        if (net !== lastNetGainValue) {
          let t = '';
          if (net > 0) t = `Vas +${Math.floor(net)}`;
          else if (net < 0) t = `Vas ${Math.floor(net)}`; // net ya es negativo
          else t = 'Regresas a tu posici√≥n de salida';

          pendingNetGain = {
            text: t,
            opts: { key: 'posNet_' + lapsNow, priority: 35, cooldownMs: 2500, dedupe: true },
            expLap: lapsNow + 3,
            value: net
          };
          lastNetGainValue = net;
        }
      }

      // MANGA: anunciar pole provisional (solo cuando cambia, anti spam)
      if (isManga && voiceSettings.pos && raceData && Array.isArray(raceData.classification) && raceData.classification.length) {
        try {
          const sorted = raceData.classification.slice().sort((a, b) => (Number(a.pos) || 999) - (Number(b.pos) || 999));
          const p1 = sorted[0];
          const p1Key = getPilotKey(p1);
          const p1Name = safeRacerName(p1 && p1.racerName) || '';
          if (p1Key && p1Name) {
            const sincePole = now - (lastPoleSpokenAt || 0);
            if (p1Key !== lastPoleSpokenKey && sincePole > 9000) {
              pendingPole = {
                text: `Pole provisional: ${p1Name}`,
                opts: { key: 'pole_' + p1Key, priority: 60, cooldownMs: 9000, dedupe: true, ttlMs: 7000 },
                expLap: lapsNow + 4,
                key: p1Key
              };
              lastPoleSpokenKey = p1Key;
              lastPoleSpokenAt = now;
            }
          }
        } catch (e) {}
      }

      // MANGA: cron√≥metro por piloto (salida escalonada)
      if (isManga) {
        updateMangaPilotStartsFromClassification((raceData && raceData.classification) ? raceData.classification : []);
      } else {
        if (mangaClockTimer) stopMangaClock();
      }
// Best lap (evento)
      if ((typeof uiNarrationMode === 'undefined' || uiNarrationMode !== 'SUPER') && voiceSettings.bestlap && lapMsNow && lapsNow > 0 && lapsNow !== lastBestAnnouncedLap) {
        const isNewBest = (lastBestAnnouncedMs == null) ? true : (lapMsNow < (lastBestAnnouncedMs - 30));
        if (isNewBest) {
          pendingBestLap = {
            text: 'Mejor vuelta',
            opts: { key: 'bestlap_' + lapsNow, priority: 75, cooldownMs: 1500, dedupe: true },
            expLap: lapsNow + 2,
            ms: lapMsNow
          };
          lastBestAnnouncedMs = lapMsNow;
        }
        lastBestAnnouncedLap = lapsNow;
      }

      
// Estimaci√≥n (evento, no spamea)
if (voiceSettings.estlap) {
  let est = Number(p.estLap) || 0;

  // Si el feed no trae estLap en MANGA, lo calculamos por tiempo propio (contra reloj)
  if (est <= 0 && isManga) {
    try {
      const elapsedMs = parseTimeToMs(p.time);
      const durMs = (currentSessionInfo && currentSessionInfo.durationMs) ? Number(currentSessionInfo.durationMs) : (3 * 60 * 1000);
      const laps = Number(p.lapcount) || 0;
      if (laps >= 3 && elapsedMs > 15000 && durMs > 10000 && elapsedMs < durMs) {
        const avgLap = elapsedMs / Math.max(1, laps);
        const remMs = Math.max(0, durMs - elapsedMs);
        const add = Math.floor(remMs / Math.max(1, avgLap));
        est = Math.max(0, laps + add);
      }
    } catch(e) {}
  }

  if (est > 0) {
    const estInt = Math.floor(est);
    const lastInt = (lastSpokenEstLap == null) ? null : Math.floor(lastSpokenEstLap);
    const changedEnough = (lastInt == null) ? true : (Math.abs(estInt - lastInt) >= 2);
    const spaced = (lapsNow - lastEstLapSpokenLap) >= 6;

    if ((changedEnough && spaced) || (spaced && (lapsNow - lastEstLapSpokenLap) >= 10)) {
      const palabra = (estInt === 1) ? 'vuelta' : 'vueltas';
      pendingEstLap = {
        text: `Estimaci√≥n ${estInt} ${palabra}`,
        opts: { key: 'est_' + estInt + '_' + lapsNow, dedupe: true },
        expLap: lapsNow + 5,
        est: estInt
      };
    }
  }
}

// Bandera azul (detector por cruces de meta) (pendiente que ya arma el detector por pasos de meta)
      if (voiceSettings.blueflag) {
        updateBlueFlagFromPassEvents();
      }

      
      if (voiceSettings.courtesy) {
        updateCourtesyFromPassEvents();
      }
// Expira pendientes viejas
      if (pendingPosChange && pendingPosChange.expLap != null && lapsNow > pendingPosChange.expLap) pendingPosChange = null;
      if (pendingNetGain && pendingNetGain.expLap != null && lapsNow > pendingNetGain.expLap) pendingNetGain = null;
      if (pendingBestLap && pendingBestLap.expLap != null && lapsNow > pendingBestLap.expLap) pendingBestLap = null;
      if (pendingEstLap && pendingEstLap.expLap != null && lapsNow > pendingEstLap.expLap) pendingEstLap = null;
      if (pendingPole && pendingPole.expLap != null && lapsNow > pendingPole.expLap) pendingPole = null;

      // =========================
      // 2) Laps siempre primero (bloqueado)
      // =========================
      const lapCrossed = (voiceSettings.laps && lapsNow > 0 && lapsNow !== lastAnnouncedLapcount);

      if (lapCrossed) {
        if (lapMsNow) {
          // Beep mejora/empeora
          if (lastSpokenLastTime && lastSpokenLastTime > 0) {
            if (lapMsNow < (lastSpokenLastTime - 20)) playBeep('up');
            else if (lapMsNow > (lastSpokenLastTime + 20)) playBeep('down');
          }
          say(tiempoATexto(lapMsNow), { key: 'lap_' + lapsNow, priority: 100, dedupe: true });
          flashLastLap();
          lastSpokenLastTime = lapMsNow;
        }
                lastAnnouncedLapcount = lapsNow;
        // MANGA: fija el "rank" por cruce para evitar delta mal calculado por jitter entre lecturas
        if (isManga) {
          try {
            const rpos = Math.floor(Number(p.pos) || 0);
            if (rpos > 0) { mangaLastLapCrossPos = rpos; mangaLastLapCrossLap = lapsNow; }
          } catch (e) {}
        }
} else {
        // Sin paso por meta: en MANGA nos quedamos callados (la tabla "brinca" por salida escalonada).
        // En FINAL podemos avisar breve si te mueven de posici√≥n sin tu cruce.
        if (!basicModeEnabled && !isManga && posChangedTick && voiceSettings.pos) {
          handlePositionChangeNoLap(posFrom, posTo, posDelta);
        }
        return;
      }

      // =========================
      // 3) AI Director: elige 1 o 2 mensajes extra post-Laps (seg√∫n situaci√≥n)
      // =========================
      let candidates = [];

      const pushCand = (id, score, text, opts, onCommit) => {
        if (!text) return;
        const o = Object.assign({}, (opts || {}));
        const cat = (id === 'leader') ? 'leadergap' : (id === 'fight') ? 'pelea' : (id === 'ritmo_up' || id === 'ritmo_down') ? 'ritmo' : id;
        if (!o.cat) o.cat = cat;
        candidates.push({ id, score, text, opts: o, onCommit });
      };

      // Contexto front/back
      const ctx = (idx >= 0) ? getFrontBackContext(idx) : null;


      // Marca de batalla en Lap Chart (ATK/DEF/DUEL) - se marca SOLO en cruce de meta
try {
  if (lapCrossed && ctx && selectedPilotKey) {
    const isManga = (currentSessionInfo && currentSessionInfo.type === 'MANGA');
    const thr = isManga ? 0.55 : 0.60;

    const f = (ctx.sameFrontLap && ctx.frontSec != null && isFinite(ctx.frontSec)) ? Number(ctx.frontSec) : null;
    const b = (ctx.sameBackLap  && ctx.backSec  != null && isFinite(ctx.backSec))  ? Number(ctx.backSec)  : null;

    const atk = (f != null && f <= thr);
    const def = (b != null && b <= thr);

    let tag = null;
    if (atk && def) tag = 'DUEL';
    else if (atk) tag = 'ATK';
    else if (def) tag = 'DEF';

    if (tag) setLastLapMark(selectedPilotKey, tag);
  }
} catch (e) {}

      // Azul (si hay pendiente para este piloto)
      if (voiceSettings.blueflag &&
          pendingBlueFlagForPilotKey &&
          pendingBlueFlagForPilotKey === selectedPilotKey &&
          pendingBlueFlagMessage) {
        pushCand('blueflag', isFinal ? 100 : 90, pendingBlueFlagMessage,
          { key: 'blueflag_' + lapsNow, priority: 80, cooldownMs: 4000, dedupe: true, interrupt: false },
          () => {
            pendingBlueFlagForPilotKey = '';
            pendingBlueFlagMessage = '';
            lastBlueFlagPilotLap = lapsNow;
          }
        );
      }

      // Pendientes (eventos)
      if ((typeof uiNarrationMode === 'undefined' || uiNarrationMode !== 'SUPER') && voiceSettings.bestlap && pendingBestLap) {
        pushCand('bestlap', isManga ? 98 : 75, pendingBestLap.text, pendingBestLap.opts, () => {
          pendingBestLap = null;
        });
      }

      if (pendingPosChange && voiceSettings.pos) {
        const ppos = (pendingPosChange.pos != null) ? pendingPosChange.pos : (p && p.pos ? Math.floor(p.pos) : 0);

        // MANGA: si el rank ya no coincide con el estable actual, no lo digas (evita "datos viejos").
        if (isManga) {
          try {
            const stableNow = (mangaPosStability && mangaPosStability.stablePos != null) ? mangaPosStability.stablePos : ppos;
            if (stableNow != null && ppos && stableNow !== ppos) { pendingPosChange = null; }
          } catch(e) {}
        }

        if (pendingPosChange) {
          let text = '';
          if (ppos) {
            if (basicModeEnabled) {
              if (isManga) {
                text = `Ranking P${ppos}`;
              } else {
                const d = Number(pendingPosChange.delta || 0);
                if (d > 0) text = `P${ppos}, ganaste ${d===1 ? 'una' : d}`;
                else if (d < 0) text = `P${ppos}, perdiste ${(-d)===1 ? 'una' : (-d)}`;
                else text = `P${ppos}`;
              }
            } else {
              let extra = '';
              if (ctx) {
                const fn = ctx.frontName ? safeRacerName(ctx.frontName) : '';
                const bn = ctx.backName ? safeRacerName(ctx.backName) : '';
                if (fn && bn) extra = `. Adelante ${fn}, atr√°s ${bn}`;
                else if (fn) extra = `. Adelante ${fn}`;
                else if (bn) extra = `. Atr√°s ${bn}`;
              }
              text = `${isManga ? "Rank " : ""}P${ppos}${extra}`;
            }
          } else {
            text = pendingPosChange.text || '';
          }

          const __posOpts = Object.assign({}, (pendingPosChange.opts || { key: 'pos_' + lapsNow, priority: 75, cooldownMs: 1500, dedupe: true }), { validatePos: { pilotKey: selectedPilotKey, pos: ppos } });

          pushCand('pos', isFinal ? 92 : 55, text,
            __posOpts,
            () => {
              try { posStability.lastAnnounceAt = Date.now(); } catch(e) {}
              try {
                if (isManga && ppos) {
                  mangaPosStability.lastAnnouncedStablePos = ppos;
                  mangaPosStability.lastAnnounceAt = Date.now();
                }
              } catch(e) {}
              pendingPosChange = null;
            }
          );
        }
      }

      if (!isManga && voiceSettings.pos && pendingNetGain) {
        pushCand('pos', isFinal ? 45 : 25, pendingNetGain.text, pendingNetGain.opts, () => {
          pendingNetGain = null;
          lastNetGainSpokenLap = lapsNow;
        });
      }

      
if (voiceSettings.pos && pendingPole) {
  pushCand('pole', isManga ? 48 : 10, pendingPole.text, pendingPole.opts, () => {
    pendingPole = null;
  });
}

if (voiceSettings.estlap && pendingEstLap) {
        pushCand('estlap', isManga ? 55 : 30, pendingEstLap.text, pendingEstLap.opts, () => {
          lastSpokenEstLap = pendingEstLap.est;
          lastEstLapSpokenLap = lapsNow;
          pendingEstLap = null;
        });
      }

      // (Eliminado) Adelante/Atras <0.6: redundante con GAP/PELEA/ATK/DEF

// Ataque / Defensa (con latch)
      if (ctx && voiceSettings.attack && ctx.sameFrontLap && ctx.frontSec != null) {
        const sec = ctx.frontSec;
        const otherKey = ctx.frontKey || 'front';
        if (attackLatch.active) {
          if (attackLatch.otherKey !== otherKey || sec >= 0.90 || !ctx.sameFrontLap) {
            attackLatch.active = false;
          }
        }
        if (!attackLatch.active && sec < 0.6) {
          const secStr = gapPhraseFromSec(sec);
          const nm = safeRacerName(ctx.frontName || '');
          const txt = nm ? ('Ataque. ' + nm + ' a ' + secStr) : ('Ataque. Adelante a ' + secStr);
          pushCand('attack', isFinal ? 88 : 20, txt,
            { key: 'attack_' + Math.floor(lapsNow/2), priority: 68, cooldownMs: 3500, dedupe: true },
            () => {
              attackLatch.active = true;
              attackLatch.otherKey = otherKey;
              attackLatch.lap = lapsNow;
            }
          );
        }
      } else {
        attackLatch.active = false;
      }

      if (ctx && voiceSettings.defense && ctx.sameBackLap && ctx.backSec != null) {
        const sec = ctx.backSec;
        const otherKey = ctx.backKey || 'back';
        if (defenseLatch.active) {
          if (defenseLatch.otherKey !== otherKey || sec >= 0.90 || !ctx.sameBackLap) {
            defenseLatch.active = false;
          }
        }
        if (!defenseLatch.active && sec < 0.6) {
          const secStr = gapPhraseFromSec(sec);
          const nm = safeRacerName(ctx.backName || '');
          const txt = nm ? ('Defensa. ' + nm + ' a ' + secStr) : ('Defensa. Atras a ' + secStr);
          pushCand('defense', isFinal ? 88 : 20, txt,
            { key: 'defense_' + Math.floor(lapsNow/2), priority: 68, cooldownMs: 3500, dedupe: true },
            () => {
              defenseLatch.active = true;
              defenseLatch.otherKey = otherKey;
              defenseLatch.lap = lapsNow;
            }
          );
        }
      } else {
        defenseLatch.active = false;
      }

      // Pelea cerrada (encajonado)
      if (ctx && voiceSettings.pelea && ctx.sameFrontLap && ctx.sameBackLap && ctx.frontSec != null && ctx.backSec != null) {
        const inFight = (ctx.frontSec < 0.80) && (ctx.backSec < 0.80);
        if (fightLatch.active) {
          if (!inFight || ctx.frontSec >= 1.20 || ctx.backSec >= 1.20) {
            fightLatch.active = false;
          }
        }
        if (!fightLatch.active && inFight) {
          pushCand('fight', isFinal ? 78 : 16, 'Pelea cerrada',
            { key: 'fight_' + Math.floor(lapsNow/2), priority: 65, cooldownMs: 4500, dedupe: true },
            () => {
              fightLatch.active = true;
              fightLatch.lap = lapsNow;
            }
          );
        }
      } else {
        fightLatch.active = false;
      }

      // Podio (solo si tiene sentido)
      if (voiceSettings.podium && isFinal && lapsNow > 0 && p.pos && p.pos > 3) {
        if (lapsNow % 3 === 0 && (!lastPodiumSpokenLap || (lapsNow - lastPodiumSpokenLap) >= 3)) {
          const third = raceData.classification.find(r => r.pos === 3);
          if (third && third.time != null && p.time != null) {
            const meLaps = (p.lapcount != null) ? p.lapcount : 0;
            const thirdLaps = (third.lapcount != null) ? third.lapcount : 0;
            const lapDiff = thirdLaps - meLaps;

            if (lapDiff !== 0) {
              const v = Math.abs(lapDiff);
              const palabra = (v === 1) ? 'una vuelta' : (v + ' vueltas');
              pushCand('podium', 55, 'Podio mas ' + palabra,
                { key: 'podio_laps_' + lapsNow, priority: 60, cooldownMs: 2500, dedupe: true, validateLap: { pilotKey: selectedPilotKey, lapcount: lapsNow } },
                () => { lastPodiumSpokenLap = lapsNow; }
              );
            } else {
              const diffMs = p.time - third.time;
              if (diffMs && diffMs > 0) {
                const sec = diffMs / 1000;
                if (sec <= 3.0) {
                  const secStr = gapPhraseFromSec(sec);
                  pushCand('podium', 65, 'Podio a ' + secStr + ' segundos',
                    { key: 'podio_' + Math.floor(lapsNow/3), priority: 60, cooldownMs: 2500, dedupe: true, validateLap: { pilotKey: selectedPilotKey, lapcount: lapsNow } },
                    () => { lastPodiumSpokenLap = lapsNow; }
                  );
                }
              }
            }
          }
        }
      }

      // Diferencia adelante/atr√°s (cada 3 vueltas)
      if (voiceSettings.gaps && idx >= 0 && lapsNow > 0 && ((isManga && (lapsNow % 4 === 0)) || (!isManga && (lapsNow % 3 === 0)))) {
        const msg = buildGapSummaryForPilotIndex(idx);
        if (msg) {
          pushCand('gaps', isFinal ? 40 : 15, msg,
            { key: 'gaps_' + Math.floor(lapsNow/3), priority: 40, cooldownMs: 1800, dedupe: true, validateLap: { pilotKey: selectedPilotKey, lapcount: lapsNow } },
            () => { lastGapInfoLap = lapsNow; }
          );
        }
      }

      // Referencia al l√≠der (cada 3 vueltas)
      if (voiceSettings.leadergap && lapsNow > 0 && ((isManga && (lapsNow % 5 === 0)) || (!isManga && (lapsNow % 3 === 0)))) {
        const leader = raceData.classification.find(r => r.pos === 1);
        if (leader && leader.time != null && p.time != null) {
          const meLaps = (p.lapcount != null) ? p.lapcount : 0;
          const lLaps  = (leader.lapcount != null) ? leader.lapcount : 0;
          const lapDiff = lLaps - meLaps;

          let msg = '';
          if (lapDiff !== 0) {
            const v = Math.abs(lapDiff);
            msg = (v === 1) ? 'Lider mas una vuelta' : ('Lider mas ' + v + ' vueltas');
          } else {
            const diffMs = p.time - leader.time;
            if (diffMs && diffMs > 0) {
              const sec = diffMs / 1000;
              const secStr = gapPhraseFromSec(sec);
              msg = 'Lider a ' + secStr;
            }
          }
          if (msg) {
            pushCand('leader', isFinal ? 38 : 12, msg,
              { dedupe: true, validateLap: { pilotKey: selectedPilotKey, lapcount: lapsNow } },
              () => { lastLeaderGapSpokenLap = lapsNow; }
            );
          }
        }
      }

      // Ritmo (cada 3 vueltas, sin palabreria)
      if (voiceSettings.ritmo && lapsNow > 0 && lapsNow % 3 === 0) {
        const t = (hist.times || []).filter(isLapPlausible);
        const last3 = t.slice(-3);
        const prev3 = t.slice(-6, -3);
        if (last3.length === 3 && prev3.length === 3) {
          const avgLast = last3.reduce((a,b)=>a+b,0) / 3;
          const avgPrev = prev3.reduce((a,b)=>a+b,0) / 3;
          const diff = avgPrev - avgLast; // positivo = mejoraste
          if (diff > 120) {
            pushCand('ritmo_up', isManga ? 72 : 28, 'Ritmo subiendo',
              { key: 'ritmo_up_' + Math.floor(lapsNow/3), priority: 30, cooldownMs: 2500, dedupe: true },
              () => { lastTrendSpokenLap = lapsNow; }
            );
          } else if (diff < -120) {
            pushCand('ritmo_down', isManga ? 72 : 28, 'Ritmo bajando',
              { key: 'ritmo_down_' + Math.floor(lapsNow/3), priority: 30, cooldownMs: 2500, dedupe: true },
              () => { lastTrendSpokenLap = lapsNow; }
            );
          }
        }
      }

      // Total (cada 1 minuto)
      if (voiceSettings.total && p.time && p.time > 0) {
        const totalSeconds = Math.floor(p.time / 1000);
        if (totalSeconds - lastTotalTimeAnnouncedSeconds >= 60) {
          const texto = tiempoATexto(p.time);
          pushCand('total', isManga ? 32 : 18, 'Total ' + texto,
            { key: 'total_' + Math.floor(totalSeconds/60), priority: 20, dedupe: true },
            () => { lastTotalTimeAnnouncedSeconds = totalSeconds; }
          );
        }
      }

      // PRO metrics: pace (ultimas 3) + racha (milestones)
      if (!basicModeEnabled) {
        const tAll = (hist.times || []).filter(isLapPlausible);
        const pace3 = rollingAvgLast(tAll, 3);

        // Caida de ritmo: empeoras fuerte 2 veces seguidas (comparado con tu pace3 anterior)
        if (voiceSettings.ritmo && pace3 && tAll.length >= 6) {
          const prev = Number(hist._pace3Prev) || 0;
          if (prev) {
            const delta = pace3 - prev; // positivo = peor
            if (delta > 150) hist._paceDropCount = (hist._paceDropCount || 0) + 1;
            else hist._paceDropCount = 0;

            if ((hist._paceDropCount || 0) >= 2 && (lapsNow - (hist._paceDropSpokenLap || 0)) >= 6) {
              const dsec = delta / 1000;
              const dStr = toFixedFloor(dsec, decimalPrecision);
              pushCand('ritmo_down', isFinal ? 58 : 22, `Ojo, caida de ritmo +${dStr}`,
                { key: 'ritmoDown_' + Math.floor(lapsNow/2), priority: 35, cooldownMs: 6000, dedupe: true },
                () => { hist._paceDropSpokenLap = lapsNow; hist._paceDropCount = 0; }
              );
            }
          }
          hist._pace3Prev = pace3;
        } else {
          if (pace3) hist._pace3Prev = pace3;
        }

        // Racha: anuncia milestones de vueltas dentro de +0.2s de tu best
        if (voiceSettings.streak && tAll.length >= 3) {
          const comp = ensureHistComputed(hist);
          const bestRef = (comp && comp.best) ? comp.best : 0;
          if (bestRef) {
            const s02 = countConsecutiveWithin(tAll, bestRef + 200);
            const mile = streakMilestone(s02);
            const lastM = Number(hist._streak02Milestone) || 0;
            if (mile && mile > lastM && (lapsNow - (hist._streakSpokenLap || 0)) >= 3) {
              pushCand('streak', isFinal ? 42 : 18, `Racha. ${mile} dentro de 0.2`,
                { key: 'streak_' + mile + '_' + Math.floor(lapsNow/2), priority: 30, cooldownMs: 7000, dedupe: true },
                () => { hist._streak02Milestone = mile; hist._streakSpokenLap = lapsNow; }
              );
            }
          }
        }
      }


      // Box (cada 10 vueltas o cada 1 min, lo que llegue primero)
      if (voiceSettings.box) {
        const totalSeconds = p.time ? Math.floor(p.time / 1000) : 0;
        const byTime = totalSeconds && (totalSeconds - lastAutoSummaryAnnouncedSeconds >= 60);
        const byLap  = lapsNow > 0 && (lapsNow % 10 === 0);

        if (byTime || byLap) {
          const posTxt = (p.pos && p.pos > 0) ? ('P ' + Math.floor(p.pos)) : '';
          const gapTxt = formatoGapVueltas(p.gap) ? ('Gap ' + formatoGapVueltas(p.gap)) : '';
          const bestTxt = p.best ? msToMinSec(p.best) : '';
          let msg = '';
          if (posTxt) msg += posTxt + '. ';
          if (gapTxt) msg += gapTxt + '. ';
          if (bestTxt) msg += 'Best lap ' + bestTxt + '. ';
          msg = msg.trim();
          if (msg) {
            pushCand('box', isFinal ? 22 : 40, msg,
              { key: 'box_' + Math.floor(totalSeconds/60) + '_' + Math.floor(lapsNow/10), priority: 18, cooldownMs: 2500, dedupe: true },
              () => { lastAutoSummaryAnnouncedSeconds = totalSeconds; }
            );
          }
        }
      }

      // Si no hay nada, listo
      if (!candidates.length) return;

      
      // RD anti-repeat penalty: baja score si acaba de decir lo mismo (sin bloquear cr√≠ticos)
      const rdModeLocal = (raceDirectorMode === 'minimal' || raceDirectorMode === 'stratega' || raceDirectorMode === 'coach') ? raceDirectorMode : 'stratega';
      const ttlId = (rdModeLocal === 'minimal') ? 4 : 2;
      const ttlTxt = (rdModeLocal === 'minimal') ? 4 : 3;
      const criticalIds = isManga
        ? new Set(['blueflag','podium'])
        : new Set(['blueflag','pos','fight','attack','defense','podium','leader']);
      for (const c of candidates) {
        if (!c) continue;
        if (!criticalIds.has(c.id)) {
          const lastId = rdLastIdLap.get(c.id) || 0;
          if (lapsNow > 0 && (lapsNow - lastId) > 0 && (lapsNow - lastId) < ttlId) c.score -= 12;
          const lastTx = rdLastTextLap.get(c.text) || 0;
          if (lapsNow > 0 && (lapsNow - lastTx) > 0 && (lapsNow - lastTx) < ttlTxt) c.score -= 10;
        }
      }

      // BASIC: solo permitir AZUL y POS (evita spam)
      if (basicModeEnabled) {
        candidates = candidates.filter(c => c && (c.id === 'blueflag' || c.id === 'pos'));
      }

// Orden: mayor score, luego mayor prioridad
      candidates.sort((a,b) => (b.score - a.score) || (((b.opts && b.opts.priority) ? b.opts.priority : 0) - ((a.opts && a.opts.priority) ? a.opts.priority : 0)));

      // =========================
      // Manual (RD OFF): habla lo encendido, con l√≠mite para no spamear
      // =========================
      const rdOn = !!raceDirectorEnabled;

      if (!rdOn) {
        // MANGA: no hablar entre metas (salida escalonada + 1 sensor)
        if (isManga && !lapCrossed) return;
        const maxSpoken = basicModeEnabled ? 1 : (isManga ? 1 : 4);
        let spoken = 0;
        for (const c of candidates) {
          if (!c || !c.text) continue;
          if (c.score < 18) continue;

          const tTry = rdTrimWords(c.text, 16);

          // MANGA: anti-repeat por TEXTO aunque el evento cambie
          if (isManga) {
            const lastTxtLap = rdLastTextLap.get(tTry) || 0;
            if (lastTxtLap && (lapsNow - lastTxtLap) > 0 && (lapsNow - lastTxtLap) < 4) continue;
          }

          say(tTry, c.opts || {});
          rdLastIdLap.set(c.id, lapsNow);
          rdLastTextLap.set(tTry, lapsNow);

          try { if (typeof c.onCommit === 'function') c.onCommit(); } catch (e) {}
          spoken++;
          if (spoken >= maxSpoken) break;
        }
        return;
      }

      // =========================
      
      // =========================
      // RD ON: elige 1 o 2 mensajes seg√∫n situaci√≥n (humano, no metralleta)
      // MANGA: solo hablar en tu cruce por meta
      if (isManga && !lapCrossed) return;

      // =========================
      const posNowRD = Number(p.position) || 0;
      const tierRD = (posNowRD > 0 && posNowRD <= 3) ? 'front' : ((posNowRD > 0 && posNowRD <= 10) ? 'mid' : 'back');

      // Anti-repetici√≥n dura (por id y por texto). No bloquea cr√≠ticos.
      const ttlById = (id) => (id === 'estlap' ? 10 : (id === 'pos' ? 2 : ttlId));
      const ttlByTxt = (id) => (id === 'estlap' ? 10 : ttlTxt);

      const tooSoonId = (id) => {
        const last = rdLastIdLap.get(id) || 0;
        const ttl = ttlById(id);
        return last && (lapsNow - last) > 0 && (lapsNow - last) < ttl;
      };
      const tooSoonTxt = (id, text) => {
        const last = rdLastTextLap.get(text) || 0;
        const ttl = ttlByTxt(id);
        return last && (lapsNow - last) > 0 && (lapsNow - last) < ttl;
      };

      // Pick 1
      let pick1 = null;
      let t1 = '';
      for (const c of candidates) {
        if (!c || !c.text) continue;
        const tTry = rdTrimWords(rdMakeText(c.id, c.text, rdBuildCtx({ tier: tierRD, isManga, ...ctx }, p)), 12);
        if (!criticalIds.has(c.id)) {
          if (tooSoonId(c.id)) continue;
          if (tooSoonTxt(c.id, tTry)) continue;
        }
        pick1 = c;
        t1 = tTry;
        break;
      }

      if (pick1) {
        say(t1, pick1.opts || {});
        rdLastIdLap.set(pick1.id, lapsNow);
        rdLastTextLap.set(t1, lapsNow);
        try { if (typeof pick1.onCommit === 'function') pick1.onCommit(); } catch (e) {}

        // MANGA: solo 1 mensaje extra por cruce (adem√°s del lap time). No metralleta.
        if (isManga) return;

        const g1 = groupOf(pick1.id);

        // Pick 2 (opcional)
        let pick2 = null;
        let t2 = '';
        for (let i = 0; i < candidates.length; i++) {
          const c = candidates[i];
          if (!c || !c.text) continue;
          if (c.id === pick1.id) continue;
          if (g1 && groupOf(c.id) === g1) { if (!(pick1 && (pick1.id === 'pos' || c.id === 'pos'))) continue; }
          if (c.score < 35) continue;

          const tTry = rdTrimWords(rdMakeText(c.id, c.text, rdBuildCtx({ tier: tierRD, isManga, ...ctx }, p)), 12);
          if (!criticalIds.has(c.id)) {
            if (tooSoonId(c.id)) continue;
            if (tooSoonTxt(c.id, tTry)) continue;
          }

          pick2 = c;
          t2 = tTry;
          break;
        }

        if (pick2) {
          say(t2, pick2.opts || {});
          rdLastIdLap.set(pick2.id, lapsNow);
          rdLastTextLap.set(t2, lapsNow);
          try { if (typeof pick2.onCommit === 'function') pick2.onCommit(); } catch (e) {}
        }
      }
      return;
    }

speakBtn.addEventListener('click', () => {
      if (!raceData || !Array.isArray(raceData.classification) || !selectedPilotKey) return;
      const p = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey);
      if (!p) return;

      // Beep tenue al primer detect del piloto seleccionado
      if (!selectedPilotFirstDetectBeeped) {
        selectedPilotFirstDetectBeeped = true;
        try { if (selectedPilotKey) firstDetectBeepedByPilot.set(selectedPilotKey, true); } catch(e) {}

        try { if (voiceMasterEnabled) playBeep('soft'); } catch(e) {}
      }
      const pos = p.pos || '-';
      const laps = p.lapcount != null ? p.lapcount : 0;
      const key = getPilotKey(p);
      let hist = lapHistory.get(key);
      if (!hist) {
        hist = { lastLapcount: Number(p.lapcount) || 0, lastTotalLapMs: 0, times: [], marks: [], bestMs: 0 };
        lapHistory.set(key, hist);
      }
      const computed = ensureHistComputed(hist);
      const consPct = getConsistencyFromFirebase(p);

      // Mostrar consistencia (feed) y œÉ (historial lap chart)
      try {
        if (consistencyValEl) consistencyValEl.textContent = consPct ? (consPct + '%') : '--%';
      } catch(e) {}
      try {
        const sig = (computed && computed.sigma && isFinite(computed.sigma)) ? (computed.sigma / 1000) : NaN;
        if (sigmaValEl) sigmaValEl.textContent = (isFinite(sig) && sig > 0) ? sig.toFixed(3) : '-.---';
      } catch(e) {}

      let bestMsFinal = isLapPlausible(p.best) ? p.best : (computed.best || 0);
      if (computed.best && (!bestMsFinal || computed.best < bestMsFinal)) bestMsFinal = computed.best;

      const meanMsFinal = isLapPlausible(p.mean) ? p.mean : (computed.mean || 0);

      const bestTxt = bestMsFinal ? tiempoATexto(bestMsFinal) : '';
      const meanTxt = meanMsFinal ? tiempoATexto(meanMsFinal) : '';
      const gapTxt = formatoGapVueltas(p.gap);
      let msg = `Posici√≥n ${pos}. `;
      if (bestTxt) msg += `Best lap ${bestTxt}. `;
      if (meanTxt) msg += `Promedio ${meanTxt}. `;
      if (gapTxt) msg += `Diferencia ${gapTxt}. `;
      if (consPct) msg += `Consistencia ${consPct} por ciento.`;
      speakText(msg);
    });

        // =========================
    // Modo de sesi√≥n (AUTO desde raceName)
    // =========================
    var currentSessionInfo = { type: 'UNKNOWN', main: '', durationMs: 0, label: 'MODO -' };

    function parseSessionFromRaceName(raceName) {
      const name = String(raceName || '').toUpperCase();
      const isManga = /MANGA/.test(name) || /Q\d/.test(name) || /QUALY|QUALI|CLASIF|CLASIFIC/.test(name) || /HEAT|ROUND/.test(name);
      const isFinal = /FINAL/.test(name) || /A\s*MAIN|B\s*MAIN|C\s*MAIN/.test(name) || /\bMAIN\b/.test(name);

      let main = '';
      // Busca "MANGA A" o "FINAL A" o "A MAIN"
      const m1 = name.match(/\bMANGA\s*([ABC])\b/);
      const m2 = name.match(/\bFINAL\s*([ABC])\b/);
      const m3 = name.match(/\b([ABC])\s*MAIN\b/);
      if (m1 && m1[1]) main = m1[1];
      else if (m2 && m2[1]) main = m2[1];
      else if (m3 && m3[1]) main = m3[1];

      let type = 'TRAIN';
      if (isManga && !isFinal) type = 'MANGA';
      else if (isFinal && !isManga) type = 'FINAL';
      else if (isFinal && isManga) type = 'FINAL'; // preferimos FINAL si viene mezclado
      else if (isManga) type = 'MANGA';

      let durationMs = 0;
      if (type === 'MANGA') durationMs = 3 * 60 * 1000;
      if (type === 'FINAL') {
        // Final A = 6:00, Finales B/C/D... = 4:00
        const m = String(main || '').toUpperCase();
        durationMs = (m === 'A') ? (6 * 60 * 1000) : (4 * 60 * 1000);
      }

let label = 'MODO TRAIN';
      if (type === 'MANGA') label = 'MODO MANGA 3:00';
      if (type === 'FINAL') {
        const m = String(main || '').toUpperCase();
        const d = (m === 'A') ? '6:00' : '4:00';
        label = m ? ('MODO FINAL ' + m + ' ' + d) : ('MODO FINAL ' + d);
      }

      const qid = (type === 'MANGA') ? (getQualiIdFromRaceName(String(raceName||'')) || '') : '';

      return { type, main, durationMs, label, qid };
    }

    // Alias: compatibilidad con m√≥dulos que usan este helper
    function detectSessionTypeAndDuration(raceName){
      return parseSessionFromRaceName(raceName);
    }


// =========================
// FIN DE SESI√ìN (por duraci√≥n)
// - MANGA: 3:00 -> "Termin√≥ la clasificaci√≥n"
// - FINAL: seg√∫n modo (A=6:00, otras=4:00) -> "Carrera terminada" + posici√≥n + resumen
// Dispara SOLO cuando tu tiempo total cruza el l√≠mite EN UNA NUEVA VUELTA.
// =========================
let sessionFinishSig = '';
let sessionFinishAnnounced = false;
let sessionFinishAt = 0;
let sessionFinishPrevByKey = new Map(); // key -> { laps, totalMs }

function getRowTotalMs(row) {
  try {
    return parseTimeToMs(
      (typeof row.time !== 'undefined' ? row.time :
       (typeof row.totalTime !== 'undefined' ? row.totalTime :
        (typeof row.totalMs !== 'undefined' ? row.totalMs :
         (typeof row.totalTimeMs !== 'undefined' ? row.totalTimeMs :
          (typeof row.estTime !== 'undefined' ? row.estTime : 0)))))
    ) || 0;
  } catch(e) { return 0; }
}

function getBestMsForRow(row) {
  let bestMs = 0;
  try {
    if (row && isLapPlausible(row.best)) bestMs = row.best;
  } catch(e) {}
  try {
    const k = getPilotKey(row);
    const hist = k ? lapHistory.get(k) : null;
    const hb = hist && hist.bestMs ? hist.bestMs : 0;
    if (isLapPlausible(hb) && (!bestMs || hb < bestMs)) bestMs = hb;
  } catch(e) {}
  return bestMs || 0;
}

function getQualiGlobalRankForPilot(raceName, pilotName){
  try{
    const rn = String(raceName || '');
    const store = loadQualiStoreFor(rn);
    const sessions = (store && store.sessions) ? store.sessions : {};
    const sessionKeys = Object.keys(sessions || {}).sort((a,b)=>{
      const na = parseInt(String(a).replace(/[^0-9]+/g,'')) || 0;
      const nb = parseInt(String(b).replace(/[^0-9]+/g,'')) || 0;
      return na - nb;
    });

    const pilots = {};
    for (const qid of sessionKeys){
      const sess = sessions[qid];
      const rows = (sess && Array.isArray(sess.rows)) ? sess.rows : [];
      for (const row of rows){
        if (!row) continue;
        const nm = (row.racerName ?? '');
        const nk = normalizeNameKey(nm);
        if (!nk) continue;
        if (!pilots[nk]) pilots[nk] = { name: nm, byQ: {} };
        if (String(nm).length > String(pilots[nk].name || '').length) pilots[nk].name = nm;
        pilots[nk].byQ[qid] = {
          laps: Number(row.laps || 0),
          timeMs: Number(row.timeMs || Number.MAX_SAFE_INTEGER)
        };
      }
    }

    const list = [];
    for (const nk of Object.keys(pilots)){
      const p = pilots[nk];
      let best = null;
      for (const qid of sessionKeys){
        const r = p.byQ[qid];
        if (!r) continue;
        if (!best || (r.laps > best.laps) || (r.laps === best.laps && r.timeMs < best.timeMs)) best = r;
      }
      if (!best) continue;
      list.push({ nameKey: nk, racerName: p.name, bestRow: best });
    }

    list.sort((a,b)=>{
      const al = Number(a.bestRow?.laps || 0);
      const bl = Number(b.bestRow?.laps || 0);
      if (bl !== al) return bl - al;
      return Number(a.bestRow?.timeMs || Number.MAX_SAFE_INTEGER) - Number(b.bestRow?.timeMs || Number.MAX_SAFE_INTEGER);
    });

    const nk = normalizeNameKey(pilotName || '');
    const idx = nk ? list.findIndex(x=>x && x.nameKey === nk) : -1;
    return { pos: (idx>=0 ? (idx+1) : 0), total: list.length };
  } catch(e) { return { pos:0, total:0 }; }

function getQualiGlobalRankForPilotKey(raceName, pilotKey){
  try{
    const rn = String(raceName || '');
    const store = loadQualiStoreFor(rn);
    const sessions = (store && store.sessions) ? store.sessions : {};
    const sessionKeys = Object.keys(sessions || {}).sort((a,b)=>{
      const na = parseInt(String(a).replace(/[^0-9]+/g,'')) || 0;
      const nb = parseInt(String(b).replace(/[^0-9]+/g,'')) || 0;
      return na - nb;
    });

    const pilots = {};
    for (const qid of sessionKeys){
      const sess = sessions[qid];
      const rows = (sess && Array.isArray(sess.rows)) ? sess.rows : [];
      for (const row of rows){
        if (!row) continue;
        const pk = String(row.pilotKey || '').toLowerCase().trim();
        if (!pk) continue;
        if (!pilots[pk]) pilots[pk] = { pilotKey: pk, racerName: row.racerName || '', byQ: {} };
        pilots[pk].byQ[qid] = {
          laps: Number(row.laps || 0),
          timeMs: Number(row.timeMs || Number.MAX_SAFE_INTEGER)
        };
      }
    }

    const list = [];
    for (const pk of Object.keys(pilots)){
      const p = pilots[pk];
      let best = null;
      for (const qid of sessionKeys){
        const r = p.byQ[qid];
        if (!r) continue;
        if (!best || (r.laps > best.laps) || (r.laps === best.laps && r.timeMs < best.timeMs)) best = r;
      }
      if (!best) continue;
      list.push({ pilotKey: pk, racerName: p.racerName, bestRow: best });
    }

    list.sort((a,b)=>{
      const al = Number(a.bestRow?.laps || 0);
      const bl = Number(b.bestRow?.laps || 0);
      if (bl !== al) return bl - al;
      return Number(a.bestRow?.timeMs || Number.MAX_SAFE_INTEGER) - Number(b.bestRow?.timeMs || Number.MAX_SAFE_INTEGER);
    });

    const pk = String(pilotKey || '').toLowerCase().trim();
    const idx = pk ? list.findIndex(x=>x && x.pilotKey === pk) : -1;
    return { pos: (idx>=0 ? (idx+1) : 0), total: list.length };
  } catch(e) { return { pos:0, total:0 }; }
}


}

function buildSessionFinishMessage(row, rData) {
  const info = currentSessionInfo || {};
  const isManga = String(info.type || '').toUpperCase() === 'MANGA';
  const isFinal = String(info.type || '').toUpperCase() === 'FINAL';

  const posNum = row && row.pos ? Number(row.pos) : 0;
  const totalPilots = (rData && Array.isArray(rData.classification)) ? rData.classification.length : 0;

  let msg = isManga ? 'Termin√≥ la clasificaci√≥n.' : 'Carrera terminada.';

  // Resultado del piloto seguido/actual
  if (posNum > 0) {
    msg += ' Terminaste P' + posNum + (totalPilots ? (' de ' + totalPilots) : '') + '.';
  }

  // Resumen r√°pido para finales
  if (isFinal && selectedPilotKey && posNum > 0) {
    if (posNum === 1) msg += ' Felicidades campe√≥n.';
    else if (posNum === 2) msg += ' Segundo lugar. Podio.';
    else if (posNum === 3) msg += ' Tercer lugar. Podio.';
    else if (posNum <= 10) msg += ' Top 10. Buen cierre.';
    else msg += ' Buen cierre.';
  }

  // En MANGA, agrega ranking en la general del d√≠a (Q-Tabla)
  if (isManga && selectedPilotKey) {
    try{
      const nm = safeRacerName(row && row.racerName) || '';
      const pk = (selectedPilotKey || (row ? getPilotKey(row) : ''));
      const rk = (pk ? getQualiGlobalRankForPilotKey((rData && rData.raceName) ? rData.raceName : (raceData && raceData.raceName), pk)
                 : getQualiGlobalRankForPilot((rData && rData.raceName) ? rData.raceName : (raceData && raceData.raceName), nm));
      if (rk && rk.pos && rk.total) {
        msg += ' En la Q tabla ' + (isManga ? 'quedas' : 'vas') + ' P' + rk.pos + ' de ' + rk.total + '.';
      }
    }catch(e){}
  }

  // Best lap (solo si NO est√°s en SUPER light)
  const bestMs = getBestMsForRow(row);
  if (bestMs && uiNarrationMode !== 'SUPER') {
    msg += ' Best lap ' + tiempoATexto(bestMs) + '.';
  }
  return msg;
}

function checkSessionFinishOnLap() {
  try {
    if (!raceData || !Array.isArray(raceData.classification) || !raceData.classification.length) return;

    const rn = String(raceData.raceName || '');
    if (rn !== sessionFinishSig) {
      sessionFinishSig = rn;
      sessionFinishAnnounced = false;
      sessionFinishPrevByKey = new Map();
    }

    const info = currentSessionInfo || {};
    const dur = Number(info.durationMs) || 0;
    if (!dur) return;

    // Elegimos piloto seleccionado; si no hay, usamos l√≠der
    let row = null;
    if (selectedPilotKey) {
      row = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey) || null;
    }
    if (!row) row = raceData.classification.find(r => r.pos === 1) || raceData.classification[0];
    if (!row) return;

    const key = getPilotKey(row) || '__';
    const laps = Number(row.lapcount) || 0;
    const totalMs = getRowTotalMs(row) || 0;

    const prev = sessionFinishPrevByKey.get(key) || { laps: 0, totalMs: 0 };
    sessionFinishPrevByKey.set(key, { laps, totalMs });

    if (sessionFinishAnnounced) return;
    if (!isFinite(totalMs) || totalMs <= 0) return;

    // Dispara cuando el tiempo total cruza el l√≠mite (no depende de 'vuelta nueva')
    // - Nadie cae exacto en 3:00/6:00: se cierra la √∫ltima vuelta.
    // - Si cargamos tarde y ya viene arriba del l√≠mite, anuncia una sola vez.
    const prevTotal = Number(prev.totalMs || 0);

    if (totalMs < dur) return;
    if (prevTotal && prevTotal >= dur) return;

    try { speechQueue.length = 0; } catch(e) {}
    try { if (window.speechSynthesis) window.speechSynthesis.cancel(); } catch(e) {}
    try { recordQualiSnapshotIfNeeded(raceData); } catch(e) {}
    const msg = buildSessionFinishMessage(row, raceData);
    enqueueSpeech(msg, {
      key: 'session_finish_' + sessionFinishSig,
      priority: 97,
      cooldownMs: 600000,
      dedupe: true
    });

    sessionFinishAnnounced = true;
    sessionFinishAt = Date.now();
    try { idleSilenceActive = true; } catch(e) {}
} catch(e) {
    console.error('checkSessionFinishOnLap', e);
  }
}

    // ===== B) Acumulador de Clasificaci√≥n (Q1+) - por vueltas / time =====
    const QUALI_STORE_KEY = 'trm_quali_store_v1';
    let __qualiPrevRaceName = '';
    let __qualiPrevRaceData = null;

    function getLocalDateKey(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function getRaceBaseFromRaceName(raceName){
      if (!raceName || typeof raceName !== 'string') return '';
      const idx = raceName.indexOf(' - ');
      if (idx === -1) return raceName.trim();
      return raceName.slice(0, idx+3).trim(); // incluye " - " (para que se vea igual que tu corte en 2 l√≠neas)
    }
    function getQualiIdFromRaceName(raceName){
      if (!raceName || typeof raceName !== 'string') return '';
      const m = raceName.match(/Q(\d+)(?=[\.\s-])/i);
      return m ? ('Q' + m[1]) : '';
    }
    function safeJsonParse(s){
      try { return JSON.parse(s); } catch(e) { return null; }
    }

    function escapeHtml(s){
      const str = (s === null || s === undefined) ? '' : String(s);
      return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;');
    }
    function loadQualiStoreFor(raceName){
      const today = getLocalDateKey();
      const raceBase = getRaceBaseFromRaceName(raceName);
      let store = safeJsonParse(lsGet(QUALI_STORE_KEY) || '');
      if (!store || typeof store !== 'object') store = null;

      if (!store || store.date !== today || store.raceBase !== raceBase) {
        store = { date: today, raceBase, sessions: {}, bestByPilot: {}, aliasByName: {} };
        try { lsSet(QUALI_STORE_KEY, JSON.stringify(store)); } catch(e) {}
      } else {
        // sanity
        if (!store.sessions || typeof store.sessions !== 'object') store.sessions = {};
        if (!store.bestByPilot || typeof store.bestByPilot !== 'object') store.bestByPilot = {};
        if (!store.aliasByName || typeof store.aliasByName !== 'object') store.aliasByName = {};
      }
      return store;
    }
    function saveQualiStore(store){
      try { lsSet(QUALI_STORE_KEY, JSON.stringify(store)); } catch(e) {}
    }

    function normalizeNameKey(v){
  if (v == null) return '';
  let s = String(v).trim().toLowerCase();
  s = s.replace(/\s+/g, ' ');
  try { s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch(e) {}
  s = s.replace(/[^a-z0-9 ]+/g, '');
  s = s.replace(/\s+/g, ' ').trim();
  return s;
}

function pickBetterQuali(a,b){
  if (!a) return b;
  if (!b) return a;
  const al = Number(a.laps || 0);
  const bl = Number(b.laps || 0);
  if (bl > al) return b;
  if (bl < al) return a;
  const at = Number(a.timeMs || Number.MAX_SAFE_INTEGER);
  const bt = Number(b.timeMs || Number.MAX_SAFE_INTEGER);
  return (bt < at) ? b : a;
}

function getQualiNameKey(r){
  const nm = normalizeNameKey(r && r.racerName);
  return nm || '';
}
function getQualiNumberKey(r){
  try{
    const num = (r && r.racerNumber != null) ? String(r.racerNumber).trim() : '';
    if (num && num !== '0' && num !== '-') return 'N' + num;
  }catch(e){}
  return '';
}

// Para la Q-Tabla: dedupe robusto.
// Regla: usa racerNumber si existe. Si no, usa nombre normalizado.
// Adem√°s: si primero llega sin n√∫mero (P+nombre) y despu√©s llega con n√∫mero (Nxx), migra y fusiona.
function getQualiPilotKey(r, store){
  const nameKey = getQualiNameKey(r);
  const numKey  = getQualiNumberKey(r);

  if (store){
    if (!store.aliasByName || typeof store.aliasByName !== 'object') store.aliasByName = {};
    if (!store.bestByPilot || typeof store.bestByPilot !== 'object') store.bestByPilot = {};
  }

  if (numKey){
    if (store && nameKey && !store.aliasByName[nameKey]) {
      store.aliasByName[nameKey] = numKey;
    }
    // Migra legacy P+nameKey -> numKey
    if (store && nameKey){
      const legacyKey = 'P' + nameKey;
      if (legacyKey !== numKey && store.bestByPilot[legacyKey]) {
        store.bestByPilot[numKey] = pickBetterQuali(store.bestByPilot[numKey], store.bestByPilot[legacyKey]);
        try { delete store.bestByPilot[legacyKey]; } catch(e) {}
      }
    }
    return numKey;
  }

  // Si ya conocemos el n√∫mero por nombre, √∫salo
  if (store && nameKey && store.aliasByName[nameKey]) return store.aliasByName[nameKey];

  return nameKey ? ('P' + nameKey) : '';
}

    function recordQualiSnapshotIfNeeded(rawRace, raceData) {
      // Compat: se puede llamar con 1 argumento (raceData)
      if (rawRace && !raceData) raceData = rawRace;
      if (!rawRace && raceData) rawRace = raceData;
      try {
        if (!rawRace || !raceData || !Array.isArray(raceData.classification)) return;

        const raceName = String(rawRace.raceName || '').trim();
        if (!raceName) return;

        const __si = detectSessionTypeAndDuration(raceName);
        if (!__si || __si.type !== 'MANGA') return;

        const qid = __si.qid || ('Q?_' + hashShort(raceName));
        const store = loadQualiStoreFor(raceName);
        if (!store.sessions) store.sessions = Object.create(null);

        let sess = store.sessions[qid];
        if (!sess) {
          sess = store.sessions[qid] = {
            qid,
            when: Date.now(),
            raceName,
            durationMs: Number(__si.durationMs || 0) || 0,
            bestByPilot: Object.create(null),
            rows: [],
            finalized: false,
            lastUpdateAt: 0
          };
        }

        // Tiempo del lider para detectar fin de manga (3:00 aprox, puede pasar un poco por el ultimo cruce)
        const leader = (raceData.classification && raceData.classification[0]) ? raceData.classification[0] : null;
        const leaderTimeMs = leader ? (Number(leader.time) || parseTimeToMs(leader.timeStr || leader.time || 0) || 0) : 0;
        const dur = Number(sess.durationMs || __si.durationMs || 0) || 180000;

        const now = Date.now();
        const canUpdate = !sess.finalized && (now - (sess.lastUpdateAt || 0) >= 2500);

        if (canUpdate) {
          for (const row of raceData.classification) {
            const pilotKey = getQualiPilotKey(row, store);
            if (!pilotKey) continue;

            const laps = Number(row.lapcount) || 0;
            if (laps <= 0) continue;

            const timeMs = (Number(row.time) || 0) || parseTimeToMs(row.timeStr || row.time || 0) || Number.MAX_SAFE_INTEGER;
            const bestMs = (Number(row.best) || 0) || parseTimeToMs(row.best || 0) || 0;

            const entry = {
              pilotKey,
              racerNumber: row.racerNumber,
              racerName: safeRacerName(row.racerName),
              laps,
              timeMs: Number(timeMs) || Number.MAX_SAFE_INTEGER,
              bestMs: Number(bestMs) || 0,
              raceName,
              qid,
              at: now
            };

            const prev = sess.bestByPilot[pilotKey];
            if (!prev || laps > prev.laps || (laps === prev.laps && entry.timeMs < prev.timeMs)) {
              sess.bestByPilot[pilotKey] = entry;
            }
          }

          sess.rows = Object.values(sess.bestByPilot);
          sess.lastUpdateAt = now;
        }

        if (!sess.finalized && leaderTimeMs && leaderTimeMs >= (dur - 1000)) {
          sess.finalized = true;
        }

        store.sessions[qid] = sess;
        store.lastRaceName = raceName;
        store.updatedAt = now;
        saveQualiStore(store);

      } catch(e) {
        // no revienta
      }
    }

    function computeQualiList(store){
  if (!store || !store.bestByPilot) return [];

  // Dedupe final: una sola fila por piloto (por nombre), aun si hubo mezcla P+nombre y Nxx.
  const raw = Object.values(store.bestByPilot).map(x => ({...x}));
  const grouped = {};
  for (const it of raw){
    if (!it) continue;
    const nk = normalizeNameKey(it.racerName || '');
    const gk = nk ? ('P' + nk) : (String(it.pilotKey || it.racerNumber || '').trim());
    if (!gk) continue;
    grouped[gk] = pickBetterQuali(grouped[gk], it);
  }

  const arr = Object.values(grouped).map(x => ({...x}));
  arr.sort((a,b)=>{
    const al = Number(a.laps || 0);
    const bl = Number(b.laps || 0);
    if (bl !== al) return bl - al;
    return Number(a.timeMs || Number.MAX_SAFE_INTEGER) - Number(b.timeMs || Number.MAX_SAFE_INTEGER);
  });
  return arr;
}

    function renderQualiTable(){
      if (!qualiMeta || !qualiTable) return;

      // Store basado en raceName actual (se resetea si cambi√≥ evento o d√≠a)
      const rn = (raceData && raceData.raceName) ? raceData.raceName : (lastRaceName || '');
      const store = loadQualiStoreFor(rn);

      const sessions = (store && store.sessions) ? store.sessions : {};
      const sessionKeys = Object.keys(sessions || {}).sort((a,b)=>{
        const na = parseInt(String(a).replace(/\D+/g,'')) || 0;
        const nb = parseInt(String(b).replace(/\D+/g,'')) || 0;
        return na - nb;
      });

      // Meta
      const raceBase = (store && store.raceBase) ? store.raceBase : '';
      const dateKey  = (store && store.dateKey) ? store.dateKey : getLocalDateKey();

      // Armar mapa piloto -> por Q
      const pilots = {};
      for (const qid of sessionKeys){
        const sess = sessions[qid];
        const rows = (sess && Array.isArray(sess.rows)) ? sess.rows : [];
        for (const row of rows){
          if (!row) continue;
          const nm = (row.racerName ?? '');
          const nk = normalizeNameKey(nm);
          if (!nk) continue;

          if (!pilots[nk]){
            pilots[nk] = {
              name: nm,
              byQ: {},
              bestQ: '',
              bestRow: null
            };
          } else {
            // si el nombre "bonito" cambi√≥ (acentos, etc), preferir el m√°s largo (suele venir completo)
            if (String(nm).length > String(pilots[nk].name || '').length) pilots[nk].name = nm;
          }
          pilots[nk].byQ[qid] = {
            racerName: nm,
            laps: Number(row.laps || 0),
            timeMs: Number(row.timeMs || Number.MAX_SAFE_INTEGER),
            timeRaw: String(row.timeRaw ?? ''),
            bestMs: Number(row.bestMs || 0),
            bestRaw: String(row.bestRaw ?? '')
          };
        }
      }

      // Calcular mejor global por piloto (m√°s vueltas, empate menor tiempo)
      const list = [];
      for (const nk of Object.keys(pilots)){
        const p = pilots[nk];
        let best = null;
        let bestQ = '';
        for (const qid of sessionKeys){
          const r = p.byQ[qid];
          if (!r) continue;
          if (!best ||
              (r.laps > best.laps) ||
              (r.laps === best.laps && r.timeMs < best.timeMs)) {
            best = r;
            bestQ = qid;
          }
        }
        if (!best) continue;
        p.bestRow = best;
        p.bestQ = bestQ;
        list.push({
          nameKey: nk,
          racerName: p.name,
          bestRow: best,
          bestQ: bestQ,
          byQ: p.byQ
        });
      }

      // Orden final de la "Clasificaci√≥n" del d√≠a
      list.sort((a,b)=>{
        const al = Number(a.bestRow?.laps || 0);
        const bl = Number(b.bestRow?.laps || 0);
        if (bl !== al) return bl - al;
        return Number(a.bestRow?.timeMs || Number.MAX_SAFE_INTEGER) - Number(b.bestRow?.timeMs || Number.MAX_SAFE_INTEGER);
      });

      // Subt√≠tulo
      if (qualiSub){
        qualiSub.textContent = sessionKeys.length
          ? ('Sesiones guardadas: ' + sessionKeys.join(', '))
          : 'A√∫n no hay sesiones guardadas.';
      }

      // Meta chips
      const count = list.length;
      qualiMeta.innerHTML = `
        <div class="qmeta">
          <div class="qchip">Evento: <b>${escapeHtml(raceBase || '‚Äî')}</b></div>
          <div class="qchip">D√≠a: <b>${escapeHtml(dateKey || '‚Äî')}</b></div>
          <div class="qchip">Pilotos: <b>${count}</b></div>
          <div class="qchip">Mejor por piloto</div>
        </div>
      `;

      // Header din√°mico
      const headRow = document.getElementById('qualiHeadRow');
      if (headRow){
        let h = '';
        h += `<th class="qcol-pos">Pos</th>`;
        h += `<th style="min-width:170px;">Nombre</th>`;
        h += `<th style="min-width:170px;">Clasificaci√≥n</th>`;
        for (const qid of sessionKeys){
          h += `<th style="min-width:120px;">${escapeHtml(qid)}</th>`;
        }
        headRow.innerHTML = h;
      }

      const tbody = qualiTable.querySelector('tbody');
      if (!tbody) return;

      function fmtTotal(timeRaw){
        return formatFeedTimeHMSms(timeRaw);
      }
      function fmtBest(bestMs){
        const ms = Number(bestMs || 0);
        if (!isFinite(ms) || ms <= 0) return '';
        // best lap no debe ser enorme
        if (ms > 600000) return '';
        return msToMinSec(ms);
      }
      function cellHtml(row){
        if (!row) return `<div class="qmain qcell-empty">-</div>`;
        const laps = Number(row.laps || 0);
        const t = fmtTotal(row.timeRaw);
        const b = fmtBest(row.bestMs);
        return `
          <div class="qmain"><b>${laps}L</b> / ${t}</div>
          ${b ? `<div class="qbest">${escapeHtml(b)}</div>` : ``}
        `;
      }

      // Highlight: piloto seleccionado y P1 en modo Auto Locutor (TV)
      let __selNk = '';
      try{
        if (selectedPilotKey){
          let nm = '';
          try{
            const sr = (raceData && Array.isArray(raceData.classification)) ? raceData.classification.find(r=> getPilotKey(r) === selectedPilotKey) : null;
            nm = sr ? (safeRacerName(sr.racerName) || '') : '';
          }catch(e){}
          if (!nm){
            const parts = String(selectedPilotKey).split('||');
            nm = (parts[1] ? parts[1] : parts[0]) || '';
          }
          __selNk = normalizeNameKey(nm || '');
        }
      }catch(e){}

      const __autoLocOn = (!selectedPilotKey) && !!voiceMasterEnabled && (typeof uiNarrationMode !== 'undefined') && (uiNarrationMode === 'TV');

      let htmlRows = '';
      for (let i=0; i<list.length; i++){
        const e = list[i];
        const pos = i + 1;

        const bestQ = e.bestQ || '';
        const bestRow = e.bestRow || {};
        const bestMain = cellHtml(bestRow);
        const bestTag = bestQ ? `<div class="qtag">${escapeHtml(bestQ)}</div>` : '';

        const __isSel = (__selNk && e.nameKey && e.nameKey === __selNk);
        const __isAutoP1 = (__autoLocOn && pos === 1);
        const trCls = `${__isSel ? 'qrow-selected' : ''} ${__isAutoP1 ? 'qrow-autoP1' : ''}`.trim();

        htmlRows += `<tr class="${trCls}">`;
        htmlRows += `<td><b>${pos}</b></td>`;
        htmlRows += `<td>${escapeHtml(e.racerName || '')}</td>`;
        htmlRows += `<td class="qcell-best">${bestTag}${bestMain}</td>`;

        for (const qid of sessionKeys){
          const r = e.byQ[qid];
          const cls = (qid === bestQ) ? 'qcell-best' : '';
          const empty = (!r) ? 'qcell-empty' : '';
          htmlRows += `<td class="${cls} ${empty}">${cellHtml(r)}</td>`;
        }

        htmlRows += `</tr>`;
      }

      tbody.innerHTML = htmlRows;
    }



    function updateSessionInfo(r) {
      const rn = (r && r.raceName) ? String(r.raceName) : '';
      currentSessionInfo = parseSessionFromRaceName(rn);
      // Auto Preset por sesi√≥n para TODAS las capas (seguimiento y auto locutor)
      // - Si cambia MANGA/FINAL/TRAIN, alineamos toggles seg√∫n el modo TV/BASE.
      try{
        if (autoSessionPresetsEnabled){
          const t = String((currentSessionInfo && currentSessionInfo.type) ? currentSessionInfo.type : 'TRAIN').toUpperCase();
          if (!window.__lastNarrPresetType || window.__lastNarrPresetType !== t){
            window.__lastNarrPresetType = t;
            try { applyNarrationModePreset(currentSessionInfo || {type:t}); } catch(e) {}
          }
        }
      }catch(e) {}
      // Reset de referencias (mejora/best) cuando cambia la sesi√≥n
      if (rn && rn !== lastSessionSigForBest) {
        prevBestByKey.clear();
        try { lapDiffSpeakGuard.clear(); } catch(e) {}
        lastSessionSigForBest = rn;
      }
    }



    function formatRaceTitleTwoLines(title) {
      const s = (title == null) ? '' : String(title);
      const t = s.trim();
      if (!t) return '';
      const sep = ' - ';
      const i = t.indexOf(sep);
      if (i < 0) return t;
      const left = t.slice(0, i).trimEnd();
      const right = t.slice(i + sep.length).trimStart();
      if (!right) return t;
      return left + ' -\n' + right;
    }
    function updateHeaderFromRace(r) {
      if (!r) return;

      updateSessionInfo(r);

      if (raceTitleText) {
        raceTitleText.textContent = formatRaceTitleTwoLines(r.raceName || 'Spotter_5.0.1');
      } else if (raceTitleMain) {
        // fallback: si no existe el span interno, usa el contenedor
        raceTitleMain.textContent = formatRaceTitleTwoLines(r.raceName || 'Spotter_5.0.1');
      }

      if (raceModeBadge) {
        const isLive = !!(r && (r.classification && r.classification.length));
        const dot = isLive ? 'üü¢' : '‚ö™';
        raceModeBadge.textContent = dot + ' ' + (currentSessionInfo.label || 'MODO -');
        // Colorea el badge por tipo de sesi√≥n
        raceModeBadge.classList.remove('mode-manga','mode-final','mode-finalA');
        if (currentSessionInfo && currentSessionInfo.type) {
          const t = String(currentSessionInfo.type).toUpperCase();
          if (t === 'MANGA' || t === 'QUALI') raceModeBadge.classList.add('mode-manga');
          else if (t === 'FINAL_A') raceModeBadge.classList.add('mode-finalA');
          else if (t.startsWith('FINAL')) raceModeBadge.classList.add('mode-final');
        }
      }

      if (raceInfo) {
        const laps = r.lapCount || 0;
        const best = r.bestLapTime ? msToMinSec(r.bestLapTime) : '-:--.---';
        raceInfo.textContent = `Vueltas objetivo: ${laps} ¬∑ Mejor global: ${best}`;
      }
    }

    function setLastUpdateNow() {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      if (lastUpdateInfo) {
        lastUpdateInfo.textContent = `Actualizado ${hh}:${mm}:${ss}`;
      }
    }

    // =========================
    // BLOQUE 2.3: UI batching con requestAnimationFrame (menos micro-lag / menos layout thrash)
    // =========================
    let __uiRafScheduled = false;
    let __uiPending = null;

    function scheduleUIUpdate(payload) {
      // Coalesce: si llegan varios ticks seguidos, solo pintamos el √∫ltimo
      __uiPending = payload || __uiPending;
      if (__uiRafScheduled) return;
      __uiRafScheduled = true;
      requestAnimationFrame(() => {
        __uiRafScheduled = false;
        const pl = __uiPending;
        __uiPending = null;
        if (!pl) return;
        try {
          applyUIUpdate(pl);
        } catch (e) {
          console.error('applyUIUpdate error', e);
        }
      });
    }

    function applyUIUpdate(pl) {
      // pl: { raceData, selectedPilotKey, isSelectingPilot }
      try { updateRecordCarreraUI(); } catch(e) {}
      try { updateHeaderFromRace(pl.raceData); } catch(e) {}
      try { setLastUpdateNow(); } catch(e) {}

      // Si la Q TABLA est√° abierta, mantenla viva (actualiza con cada tick)
      try { if (qualiBackdrop && qualiBackdrop.classList.contains('open')) renderQualiTable(); } catch(e) {}

      if (!pl.isSelectingPilot) {
        try { updatePilotOptions(); } catch(e) {}
      }

      if (pl.selectedPilotKey) {
        const p = (pl.raceData && pl.raceData.classification)
          ? pl.raceData.classification.find(r => getPilotKey(r) === pl.selectedPilotKey)
          : null;

        renderPilotCard(p || null);
        try { renderAutoTop3MiniGrid(); } catch(e) {}
      } else {
        renderPilotCard(null);
        try { renderAutoTop3MiniGrid(); } catch(e) {}
      }
      try { updateDiagPanel(); } catch(e) {}
    }


    
async function loadRaceFromFirebase() {
  // Background best-effort: seguimos intentando aunque est√© oculta (el navegador puede throttlear o congelar)
  if (!__firebaseOk || !db) { setLiveStatus(false); try { setDiagError('Firebase OFF'); } catch(e) {} return false; }

  const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  if (isLoading) {
    // Si una lectura se colg√≥ por red, no dejes el spotter muerto.
    if (now - loadingSince < 4500) return true;
    console.warn('Lectura anterior tard√≥ demasiado, reseteando isLoading');
    isLoading = false;
  }

  isLoading = true;
  loadingSince = now;

  try {
    const ref = doc(db, 'races', 'currentRace');

    // Timeout duro para que getDoc no congele el loop (iOS/red chueca)
    const snap = await Promise.race([
      getDoc(ref),
      new Promise((_, rej) => setTimeout(() => rej(new Error('timeout getDoc')), 3500))
    ]);
    try {
      const end = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      diagLastFetchMs = Math.max(0, Math.round(end - now));
      diagLastFetchAt = Date.now();
    } catch(e) {}
    if (!snap.exists()) {
      setLiveStatus(false);
      return true; // no es "error", solo no hay carrera
    }
    const data = snap.data() || {};
    setLiveStatus(true);

    let rawRace = null;
    if (data.parsed && Array.isArray(data.parsed.classification)) {
      rawRace = data.parsed;
    } else if (data.rawJson) {
      try {
        rawRace = JSON.parse(data.rawJson);
      } catch (e) {
        console.error('Error parseando rawJson', e);
      }
    }

    if (!rawRace || !Array.isArray(rawRace.classification)) {
      return true; // dato incompleto, pero lectura OK
    }

    const newRaceName = rawRace.raceName || '';
    if (newRaceName !== lastRaceName) {
      try { if (raceData) recordQualiSnapshotIfNeeded(raceData); } catch(e) {}
      try { markMovement('raceName'); } catch(e) {}
      try { lastPilotOptionsSignature = ''; } catch(e) {} // fuerza refresh de lista de pilotos
      previousClassification = null;
      lastSpokenLastTime = null;
      lastAnnouncedLapcount = 0;
      lastKnownPos = null;
      lastTotalTimeAnnouncedSeconds = 0;
      lastBestAnnouncedMs = null;
      lastBestAnnouncedLap = 0;
      lastTrendSpokenLap = 0;
      lastAheadAlertMs = 0;
      behind06Latch = { active:false, otherKey:'', lap:-1 };
      ahead06Latch  = { active:false, otherKey:'', lap:-1 };

      attackLatch  = { active:false, otherKey:'', lap:-1 };
      defenseLatch = { active:false, otherKey:'', lap:-1 };
      fightLatch   = { active:false, lap:-1 };
      startPosForSelected = null;
      lastNetGainValue = null;
      lastNetGainSpokenLap = 0;
      lastLeaderGapSpokenLap = 0;
      lastPodiumSpokenLap = 0;
      lastAutoSummaryAnnouncedSeconds = 0;
      resetAutoCommentatorState();
      // Reset fin de sesi√≥n
      sessionFinishSig = newRaceName;
      sessionFinishAnnounced = false;
      sessionFinishPrevByKey = new Map();
      lastRaceName = newRaceName;

      stopMangaClock();
      if (lastPassEvents && typeof lastPassEvents.clear === 'function') {
        lastPassEvents.clear();
      }
      try {
        if (autoBlueFlagLastLapByKey && typeof autoBlueFlagLastLapByKey.clear === 'function') autoBlueFlagLastLapByKey.clear();
        if (autoBlueWarnLastLapByKey && typeof autoBlueWarnLastLapByKey.clear === 'function') autoBlueWarnLastLapByKey.clear();
        autoBlueFlagLastAbsMs = 0;
      } catch(e) {}
      if (lapHistory && typeof lapHistory.clear === 'function') { lapHistory.clear(); }
      pendingBlueFlagForPilotKey = '';
      pendingBlueFlagMessage = '';
      lastBlueFlagPilotLap = 0;
    }

    raceData = normalizeRaceData(rawRace);

    // Q TABLA: snapshot continuo (solo MANGA/Q).
    try { recordQualiSnapshotIfNeeded(rawRace, raceData); } catch(e) {}


    // DIAG: expone el feed crudo y normalizado
    try { window.__lastRawRace = rawRace; window.__lastRaceData = raceData; window.__lastFireDoc = data; } catch(e) {}


    // Forzar refresh de dropdown al cargar/entrar a carrera
    try { updatePilotOptions(true, 'loadRace'); } catch(e) {}

    // Q TABLA: auto-guardado al cambiar de sesi√≥n (Q1+)
    try {
      const rnNow = String(raceData && raceData.raceName || '');
      if (__qualiPrevRaceData && rnNow && __qualiPrevRaceName && rnNow !== __qualiPrevRaceName) {
        recordQualiSnapshotIfNeeded(__qualiPrevRaceData);
      }
      __qualiPrevRaceName = rnNow;
      __qualiPrevRaceData = raceData;
    } catch(e) {}
    updateLapHistoryAll();
    refreshSessionBestCache();

    // Pre-c√°lculos que deben ocurrir antes de voz (netgain/finish)
    let __selRow = null;
    if (selectedPilotKey && raceData && Array.isArray(raceData.classification)) {
      __selRow = raceData.classification.find(r => getPilotKey(r) === selectedPilotKey) || null;
    }
    if (__selRow && __selRow.pos && __selRow.pos > 0 && (startPosForSelected == null)) {
      startPosForSelected = __selRow.pos;
      lastNetGainValue = 0;
    }
    try { checkSessionFinishOnLap(); } catch(e) {}

    // UI: batching en un solo frame para evitar layout thrash
    scheduleUIUpdate({ raceData, selectedPilotKey, isSelectingPilot });
    handleVoiceAndBeeps();
    handleAutoCommentator();
    return true;
  } catch (e) {
    console.error('Error leyendo Firebase', e);
    try { setDiagError((e && e.message) ? e.message : 'Error leyendo Firebase'); } catch(_) {}
    setLiveStatus(false);
    return false;
  } finally {
    isLoading = false;
  }
}

// =========================
// Polling adaptativo (costo/bater√≠a) + background best-effort - v7.51
// =========================
const POLL_FAST_MS = 250;        // carrera viva (movimiento reciente)
const POLL_IDLE_MIN_MS = 900;    // sin movimiento
const POLL_IDLE_MAX_MS = 1200;
const POLL_BG_MIN_MS = 1500;   // pesta√±a oculta (background best-effort)
const POLL_BG_MAX_MS = 2500;
const POLL_ERR_MIN_MS = 2000;    // Firebase error / sin init
const POLL_ERR_MAX_MS = 3200;
const POLL_ACTIVE_WINDOW_MS = 3500;
const POLL_MAX_BACKOFF_MS = 6000;
const RESCUE_ENTER_ERRORS = 3;
const RESCUE_RECOVER_SUCCESSES = 2;
const RESCUE_MIN_MS = 3000;
const RESCUE_MAX_MS = 6000;

let rescueMode = false;
let rescueSince = 0;
let rescueSuccessStreak = 0;
let rescueReason = '';

function setRescueBanner(on, text){
  const el = document.getElementById('rescueBanner');
  if (!el) return;
  if (on) {
    el.textContent = text || 'Red inestable - modo rescate';
    el.classList.add('on');
  } else {
    el.textContent = '';
    el.classList.remove('on');
  }
}

function enterRescue(reason){
  if (rescueMode) return;
  rescueMode = true;
  rescueSince = Date.now();
  rescueSuccessStreak = 0;
  rescueReason = reason || 'Red inestable';
  setRescueBanner(true, 'Red inestable - modo rescate');
  try { diagLogPush('ENTER RESCATE ' + rescueReason); } catch(e) {}
}

function exitRescue(){
  if (!rescueMode) return;
  rescueMode = false;
  rescueSince = 0;
  rescueSuccessStreak = 0;
  rescueReason = '';
  setRescueBanner(false, '');
  try { diagLogPush('EXIT RESCATE recuperado'); } catch(e) {}
}


let pollTimer = null;
let pollConsecutiveErrors = 0;
let pollLastIntervalMs = POLL_FAST_MS;

function randInt(min, max) {
  const lo = Math.floor(min);
  const hi = Math.floor(max);
  if (hi <= lo) return lo;
  return lo + Math.floor(Math.random() * (hi - lo + 1));
}

function computeNextPollMs() {
  const now = Date.now();

  if (rescueMode) return randInt(RESCUE_MIN_MS, RESCUE_MAX_MS);

  // En background/oculto: best-effort (los navegadores pueden throttlear o pausar)
  // pero nosotros seguimos intentando a un ritmo m√°s lento para cuidar bater√≠a/costo.
  if (document.hidden) {
    // si Firebase no est√° listo, no martilles
    if (!__firebaseOk || !db) return randInt(POLL_ERR_MIN_MS, POLL_ERR_MAX_MS);

    if (pollConsecutiveErrors >= 2) {
      const base = randInt(POLL_ERR_MIN_MS, POLL_ERR_MAX_MS);
      const mult = Math.min(4, Math.pow(2, pollConsecutiveErrors - 2)); // 1,2,4,4...
      return Math.min(POLL_MAX_BACKOFF_MS, base * mult);
    }
    return randInt(POLL_BG_MIN_MS, POLL_BG_MAX_MS);
  }

  const movementAgo = now - (lastMovementAt || now);
  const recentlyActive = movementAgo <= POLL_ACTIVE_WINDOW_MS;

  // si Firebase no est√° listo, no martilles
  if (!__firebaseOk || !db) return randInt(POLL_ERR_MIN_MS, POLL_ERR_MAX_MS);

  if (pollConsecutiveErrors >= 2) {
    const base = randInt(POLL_ERR_MIN_MS, POLL_ERR_MAX_MS);
    const mult = Math.min(4, Math.pow(2, pollConsecutiveErrors - 2)); // 1,2,4,4...
    return Math.min(POLL_MAX_BACKOFF_MS, base * mult);
  }

  if (recentlyActive) return POLL_FAST_MS;
  return randInt(POLL_IDLE_MIN_MS, POLL_IDLE_MAX_MS);
}

function stopAdaptivePolling() {
  if (pollTimer) { clearTimeout(pollTimer); pollTimer = null; }
}

async function adaptivePollTick() {
  // DIAG: ticks por minuto
  try {
    diagTickCount++;
    const _now = Date.now();
    const _dt = _now - (diagTickWindowStart || _now);
    if (_dt >= 60000) {
      diagTicksPerMin = Math.max(1, Math.round((diagTickCount * 60000) / _dt));
      diagTickCount = 0;
      diagTickWindowStart = _now;
    }
  } catch(e) {}


  stopAdaptivePolling();

  const ok = await loadRaceFromFirebase().catch((e) => {
    try { setDiagError((e && e.message) ? e.message : 'Error leyendo Firebase'); } catch(_) {}
    return false;
  });

  if (ok) {
    pollConsecutiveErrors = 0;
    if (rescueMode) {
      rescueSuccessStreak++;
      if (rescueSuccessStreak >= RESCUE_RECOVER_SUCCESSES) exitRescue();
    }
  } else {
    pollConsecutiveErrors++;
    rescueSuccessStreak = 0;
    if (pollConsecutiveErrors >= RESCUE_ENTER_ERRORS) enterRescue('errores seguidos');
  }

  const next = computeNextPollMs();
  pollLastIntervalMs = next;
  pollTimer = setTimeout(adaptivePollTick, next);
}

function startAdaptivePolling() {
  stopAdaptivePolling();
  pollConsecutiveErrors = 0;
  pollLastIntervalMs = POLL_FAST_MS;
  // al iniciar, limpia rescate visual
  try { exitRescue(); } catch(e) {}
  pollTimer = setTimeout(adaptivePollTick, 0);
}

    // =========================
    // Bootstrap (arranque)
    // =========================
    window.addEventListener('unhandledrejection', (ev) => {
      console.error('UnhandledRejection', ev.reason);
    });

    (async () => {
      const ok = await initFirebaseRuntime();
      if (!ok) {
        setLiveStatus(false);
        if (raceInfo) raceInfo.textContent = 'Firebase OFF - revisa conexi√≥n, CSP o bloqueadores.';
        return;
      }
      startAdaptivePolling();
    })();


// Best lap global: actualizado desde raceData.classification (ver refreshSessionBestCache)



    // DIAG toggle (panel flotante)
    function toggleDiagPanel(forceOn){
      try{
        const btn = document.getElementById('diagToggleBtn');
        const pnl = document.getElementById('diagPanel');
        if (!pnl) return;
        const isOn = (pnl.style.display !== 'none' && pnl.style.display !== '');
        const next = (forceOn != null) ? !!forceOn : !isOn;
        pnl.style.display = next ? 'block' : 'none';
        if (btn) btn.classList.toggle('active', next);
      }catch(e){ console.error('toggleDiagPanel', e); }
    }

    document.addEventListener('DOMContentLoaded', () => {
      try{
        const btn = document.getElementById('diagToggleBtn');
        if (btn) btn.addEventListener('click', () => toggleDiagPanel());
      }catch(e){}
    });
</script>

<style id="uxMinimalCss">
  body.ux-minimal .controls,
  body.ux-minimal .top-controls,
  body.ux-minimal .controls-row,
  body.ux-minimal .cbtn-row,
  body.ux-minimal .mode-row,
  body.ux-minimal .rd-mode-row,
  body.ux-minimal .session-presets,
  body.ux-minimal .spotter-master,
  body.ux-minimal .basic-toggles,
  body.ux-minimal .advanced-panel,
  body.ux-minimal #advancedPanel,
  body.ux-minimal .settings-panel,
  body.ux-minimal .hud-settings,
  body.ux-minimal .hud-segments,
  body.ux-minimal .msg-strip{
    display:none !important;
  }

  /* Mantenemos visible la tarjeta principal y el selector de piloto existente (lo hacemos adaptativo con JS) */
  #uxBar{
    position: fixed;
    left: 10px;
    right: 10px;
    bottom: 10px;
    z-index: 9999;
    display: flex;
    gap: 10px;
    align-items: center;
    justify-content: space-between;
    padding: 10px;
    border-radius: 16px;
    background: rgba(0,0,0,0.55);
    border: 1px solid rgba(255,255,255,0.14);
    backdrop-filter: blur(10px);
  }
  #uxStartBtn{
    flex: 1 1 auto;
    padding: 12px 14px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(15,18,26,0.92);
    color: #f2f5ff;
    font-weight: 800;
    letter-spacing: 0.3px;
  }
  #uxStartBtn:active{ transform: scale(0.99); }

  #uxPilotBtn, #uxMuteBtn, #uxSettingsBtn{
    flex: 0 0 auto;
    padding: 12px 12px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(10,12,18,0.92);
    color: #f2f5ff;
    font-weight: 700;
    min-width: 52px;
    text-align: center;
  }

  #uxPilotBtn{ max-width: 42vw; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  #uxHint{
    position: fixed;
    left: 10px;
    right: 10px;
    bottom: 72px;
    z-index: 9998;
    font-size: 12px;
    opacity: 0.75;
    padding: 8px 10px;
    border-radius: 12px;
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.10);
    display:none;
  }

  /* Modal ajustes mini */
  #uxSettingsModal{
    position: fixed;
    inset: 0;
    z-index: 10000;
    display: none;
    align-items: flex-end;
    justify-content: center;
    padding: 14px 10px;
    background: rgba(0,0,0,0.55);
  }
  #uxSettingsCard{
    width: min(720px, 100%);
    border-radius: 18px;
    padding: 12px;
    background: rgba(8,10,15,0.96);
    border: 1px solid rgba(255,255,255,0.14);
  }
  .uxRow{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    padding: 10px 6px;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  .uxRow:last-child{ border-bottom:none; }
  .uxRow label{ font-size: 13px; opacity: 0.9; }
  .uxRow select, .uxRow input[type="range"]{
    width: 55%;
  }
  #uxCloseSettings{
    width: 100%;
    margin-top: 10px;
    padding: 12px 14px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(15,18,26,0.92);
    color: #f2f5ff;
    font-weight: 800;
  }
</style>

<div id="uxHint">Tip: sin piloto seleccionado, INICIAR entra en Auto. Con piloto, entra en Seguimiento.</div>
<div id="uxBar" role="group" aria-label="Controles r√°pidos">
  <button id="uxStartBtn" type="button">INICIAR</button>
  <button id="uxPilotBtn" type="button" title="Seleccionar piloto">PILOTO</button>
  <button id="uxMuteBtn" type="button" title="Silencio r√°pido">MUTE</button>
  <button id="uxSettingsBtn" type="button" title="Ajustes">‚öôÔ∏è</button>
</div>

<div id="uxSettingsModal" aria-hidden="true">
  <div id="uxSettingsCard" role="dialog" aria-label="Ajustes">
    <div class="uxRow">
      <label for="uxVerbosity">Verboso</label>
      <select id="uxVerbosity">
        <option value="quiet">Silencioso</option>
        <option value="normal" selected>Normal</option>
        <option value="spicy">Picante</option>
      </select>
    </div>
    <div class="uxRow">
      <label for="uxRate">Velocidad</label>
      <input id="uxRate" type="range" min="1.0" max="2.5" step="0.1" value="1.7" />
    </div>
    <div class="uxRow">
      <label for="uxDiag">DIAG</label>
      <button id="uxDiag" type="button">Toggle</button>
    </div>
    <button id="uxCloseSettings" type="button">CERRAR</button>
  </div>
</div>

<script id="uxMinimalJs">
(function(){
  try{
    document.body.classList.add('ux-minimal');
  }catch(e){}

  const uxStartBtn = document.getElementById('uxStartBtn');
  const uxPilotBtn = document.getElementById('uxPilotBtn');
  const uxMuteBtn = document.getElementById('uxMuteBtn');
  const uxSettingsBtn = document.getElementById('uxSettingsBtn');
  const uxSettingsModal = document.getElementById('uxSettingsModal');
  const uxCloseSettings = document.getElementById('uxCloseSettings');
  const uxVerbosity = document.getElementById('uxVerbosity');
  const uxRate = document.getElementById('uxRate');
  const uxDiag = document.getElementById('uxDiag');

  const pilotSelect = document.getElementById('pilotSelect');
  const voiceBtn = document.getElementById('voiceToggleBtn') || document.getElementById('voiceToggleBtnMini');
  const diagBtn = document.getElementById('diagToggleBtn');

  const basicButtons = Array.from(document.querySelectorAll('.basic-toggle'));
  const btnBlue = basicButtons.find(b => (b.textContent||'').toLowerCase().includes('azul'));
  const btnCourtesy = basicButtons.find(b => (b.textContent||'').toLowerCase().includes('cortesia'));
  const btnPos = basicButtons.find(b => (b.textContent||'').toLowerCase().includes('pos'));

  const presetProBtn = document.getElementById('presetRdProBtn');
  const presetShowBtn = document.getElementById('presetRdShowBtn');

  const rateRange = document.getElementById('rateRange');
  const rateDisplay = document.getElementById('rateDisplay');

  function isVoiceOn(){
    if (!voiceBtn) return false;
    const t = (voiceBtn.textContent||'').toLowerCase();
    if (t.includes('off')) return false;
    return true;
  }

  function setVoiceOn(){
    try{
      // Preferimos el m√©todo interno porque hace unlock real en iOS/WebKit
      if (typeof setVoiceMaster === 'function'){
        setVoiceMaster(true);
        return;
      }
    }catch(e){}
    try{ voiceBtn && voiceBtn.click(); }catch(e){}
  }

  function toggleMute(){
    try{
      if (typeof setVoiceMaster === 'function'){
        setVoiceMaster(!isVoiceOn());
        return;
      }
    }catch(e){}
    try{ voiceBtn && voiceBtn.click(); }catch(e){}
  }

  function ensureFollowDefaults(){
    // Seguimiento: POS + AZUL + CORTESIA activos por default
    try{ if (btnPos && !btnPos.classList.contains('active')) btnPos.click(); }catch(e){}
    try{ if (btnBlue && !btnBlue.classList.contains('active')) btnBlue.click(); }catch(e){}
    try{ if (btnCourtesy && !btnCourtesy.classList.contains('active')) btnCourtesy.click(); }catch(e){}
  }

  function ensureAutoDefaults(){
    // Auto: dejamos que el motor decida, pero con blue/cortes√≠a ON siempre
    try{ if (btnBlue && !btnBlue.classList.contains('active')) btnBlue.click(); }catch(e){}
    try{ if (btnCourtesy && !btnCourtesy.classList.contains('active')) btnCourtesy.click(); }catch(e){}
  }

  function applyVerbosity(v){
    try{
      localStorage.setItem('spotter_verbosity', v);
    }catch(e){}
    // Mapeo simple a presets existentes
    try{
      if (v === 'spicy'){
        presetShowBtn && presetShowBtn.click();
      } else {
        presetProBtn && presetProBtn.click();
      }
    }catch(e){}

    // Ajuste fino para silencioso: apagar categor√≠as ruidosas
    try{
      if (typeof voiceSettings === 'object' && voiceSettings){
        if (v === 'quiet'){
          voiceSettings.gaps = false;
          voiceSettings.leadergap = false;
          voiceSettings.pelea = false;
          voiceSettings.ritmo = false;
          voiceSettings.bestlap = false;
          voiceSettings.front06 = false;
          voiceSettings.back06 = false;
        }
        if (v === 'normal'){
          // pro ya lo deja bien
        }
      }
    }catch(e){}
  }

  function syncPilotBtn(){
    if (!pilotSelect) return;
    const opt = pilotSelect.options[pilotSelect.selectedIndex];
    const label = opt ? opt.textContent.trim() : 'PILOTO';
    uxPilotBtn.textContent = label ? label.slice(0, 18) : 'PILOTO';
  }

  function openPilotPicker(){
    if (!pilotSelect) return;
    // En m√≥vil, hacemos focus; en desktop, lo dejamos visible y focus igual
    try{
      pilotSelect.scrollIntoView({behavior:'smooth', block:'center'});
    }catch(e){}
    try{ pilotSelect.focus(); }catch(e){}
    try{ pilotSelect.click(); }catch(e){}
  }

  function showSettings(on){
    uxSettingsModal.style.display = on ? 'flex' : 'none';
    uxSettingsModal.setAttribute('aria-hidden', on ? 'false' : 'true');
  }

  function setRate(v){
    const r = Number(v);
    if (!isFinite(r)) return;
    try{
      if (rateRange){ rateRange.value = String(r); rateRange.dispatchEvent(new Event('input')); }
      if (uxRate){ uxRate.value = String(r); }
    }catch(e){}
    try{
      if (rateDisplay) rateDisplay.textContent = r.toFixed(1) + 'x';
    }catch(e){}
  }

  // Restore prefs
  try{
    const vb = localStorage.getItem('spotter_verbosity');
    if (vb && uxVerbosity) uxVerbosity.value = vb;
  }catch(e){}
  try{
    if (rateRange && uxRate) uxRate.value = rateRange.value;
  }catch(e){}

  // Mobile adapt pilot select visibility
  function setPilotSelectVisibility(){
    if (!pilotSelect) return;
    const isMobile = window.matchMedia && window.matchMedia('(max-width: 640px)').matches;
    const wrap = pilotSelect.closest('.pilot-select');
    if (!wrap) return;
    wrap.style.display = isMobile ? 'none' : 'block';
  }
  setPilotSelectVisibility();
  window.addEventListener('resize', setPilotSelectVisibility);

  if (pilotSelect){
    pilotSelect.addEventListener('change', () => {
      syncPilotBtn();
      try{ localStorage.setItem('spotter_last_pilot', pilotSelect.value || ''); }catch(e){}
    });
    // initial
    syncPilotBtn();
  }

  uxPilotBtn && uxPilotBtn.addEventListener('click', () => {
    openPilotPicker();
    // En m√≥vil, mostramos el select moment√°neamente
    try{
      const wrap = pilotSelect && pilotSelect.closest('.pilot-select');
      if (wrap && wrap.style.display === 'none'){
        wrap.style.display = 'block';
        setTimeout(() => { try{ setPilotSelectVisibility(); }catch(e){} }, 5000);
      }
    }catch(e){}
  });

  uxMuteBtn && uxMuteBtn.addEventListener('click', () => toggleMute());

  uxSettingsBtn && uxSettingsBtn.addEventListener('click', () => showSettings(true));
  uxCloseSettings && uxCloseSettings.addEventListener('click', () => showSettings(false));
  uxSettingsModal && uxSettingsModal.addEventListener('click', (ev) => {
    if (ev.target === uxSettingsModal) showSettings(false);
  });

  uxVerbosity && uxVerbosity.addEventListener('change', () => applyVerbosity(uxVerbosity.value));
  uxRate && uxRate.addEventListener('input', () => setRate(uxRate.value));
  uxDiag && uxDiag.addEventListener('click', () => { try{ diagBtn && diagBtn.click(); }catch(e){} });

  // START: 1 bot√≥n para todo
  uxStartBtn && uxStartBtn.addEventListener('click', () => {
    // unlock + voice on
    setVoiceOn();

    const hasPilot = pilotSelect && pilotSelect.value;
    if (hasPilot){
      ensureFollowDefaults();
      try{ enqueueSpeech && enqueueSpeech('Seguimiento listo'); }catch(e){}
    } else {
      ensureAutoDefaults();
      try{ enqueueSpeech && enqueueSpeech('Auto listo'); }catch(e){}
    }

    // aplica verbosidad actual
    try{ applyVerbosity(uxVerbosity ? uxVerbosity.value : 'normal'); }catch(e){}
  });

})();
</script>

</body>
</html>